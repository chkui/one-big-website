webpackJsonp([18],{340:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h2 id="h2-1">Hazelcast是什么</h2>\n<p>“分布式”、“集群服务”、“网格式内存数据”、“分布式缓存“、“弹性可伸缩服务”——这些牛逼闪闪的名词拿到哪都是ITer装逼的不二之选。在Javaer的世界，有这样一个开源项目，只需要引入一个jar包、只需简单的配置和编码即可实现以上高端技能，他就是 <em>Hazelcast</em>。</p>\n<p><em>Hazelcast </em>是由Hazelcast公司（没错，这公司也叫Hazelcast！）开发和维护的开源产品，可以为基于jvm环境运行的各种应用提供分布式集群和分布式缓存服务。Hazelcast可以嵌入到任何使用Java、C++、.NET开发的产品中（C++、.NET只提供客户端接入）。Hazelcast目前已经更新到3.X版本，Java中绝大部分数据结构都被其以为分布式的方式实现。比如Javaer熟悉的Map接口，当通过Hazelcast创建一个Map实例后，在节点A调用&nbsp;<em>Map::put("A","A_DATA")&nbsp;</em>方法添加数据，节点B使用&nbsp;<em>Map::get("A")&nbsp;</em>可以获到值为<em>"A_DATA" </em>的数据<em>。Hazelcast </em>提供了 <em>Map、Queue、MultiMap、Set、List、Semaphore、Atomic&nbsp;</em>等接口的分布式实现；提供了基于<em>Topic&nbsp;</em>实现的消息队列或订阅\\发布模式；提供了分布式id生成器（<em>IdGenerator</em>）；提供了分布式事件驱动（<em>Distributed Events</em>）；提供了分布式计算（<em>Distributed Computing</em>）；提供了分布式查询（<em>Distributed Query</em>）。总的来说在独立jvm经常使用数据结果或模型&nbsp;<em>Hazelcast </em>都提供了分布式集群的实现。</p>\n<p><em>Hazelcast </em>有开源版本和商用版本。开源版本遵循 <em>Apache License 2.0&nbsp;</em>开源协议免费使用。商用版本需要获取特定的License，两者之间最大的区别在于：商用版本提供了数据高密度存储。我们都知道jvm有自己特定的GC机制，无论数据是在堆还是栈中，只要发现无效引用的数据块，就有可能被回收。而<em>Hazelcast</em>的分布式数据都存放在jvm的内存中，频繁的读写数据会导致大量的GC开销。使用商业版的<em>Hazelcast</em>会拥有高密度存储的特性，大大降低Jvm的内存开销，从而降低GC开销。</p>\n<p>很多开源产品都使用Hazelcast 来组建微服务集群，例如咱们的Vert.x，首选使用Hazelcast来组建分布式服务。有兴趣可以看我的这篇分享——<a title="Vert.x 如何创建集群" href="https://www.chkui.com/article/vertx/vertx_source_code_how_to_create_cluster" >Vert.x 如何创建集群</a> ，文中说明了Vert.x如何使用Hazelcast组建集群。</p>\n<p>附：</p>\n<ul>\n    <li>Hazelcast源码：<a title="Hazelcast开源项目源码" href="https://github.com/hazelcast/hazelcast" rel="nofollow">https://github.com/hazelcast/hazelcast</a></li>\n    <li>关于Hazelcast的问题可以到<a title="Hazelcast问题Github提交" href="https://github.com/hazelcast/hazelcast/issues" rel="nofollow">https://github.com/hazelcast/hazelcast/issues</a>或<a title="Hazelcast问题stackoverflow" href="http://stackoverflow.com" rel="nofollow">http://stackoverflow.com</a>。</li>\n</ul>\n<h2 id="h2-2">Hazelcast的特性</h2>\n<h3 id="h3-1">自治集群（无中心化）</h3>\n<p><em>Hazelcast </em>没有任何中心节点（文中的节点可以理解为运行在任意服务器的独立jvm，下同），或者说<em>Hazelcast </em>不需要特别指定一个中心节点。在运行的过程中，它自己选定集群中的某个节点作为中心点来管理所有的节点。</p>\n<h3 id="h3-2">数据按应用分布式存储</h3>\n<p><em>Hazelcast </em>的数据是分布式存储的。他会将数据尽量存储在需要使用该项数据的节点上，以实现数据去中心化的目的。在传统的数据存储模型中（<em>MySql、MongDB、Redis&nbsp;</em>等等）数据都是独立于应用单独存放，当需要提升数据库的性能时，需要不断加固单个数据库应用的性能。即使是现在大量的数据库支持集群模式或读写分离，但是基本思路都是某几个库支持写入数据，其他的库不断的拷贝更新数据副本。这样做的坏处一是会产生大量脏读的问题，二是消耗大量的资源来传递数据——从数据源频繁读写数据会耗费额外资源，当数据量增长或创建的主从服务越来越多时，这个消耗呈指数级增长。</p>\n<p>使用 <em>Hazelcast </em>可以有效的解决数据中心化问题。他将数据分散的存储在每个节点中，节点越多越分散。每个节点都有各自的应用服务，而Hazelcast集群会根据每个应用的数据使用情况分散存储这些数据，在应用过程中数据会尽量“靠近”应用存放。这些在集群中的数据共享整个集群的存储空间和计算资源。</p>\n<h3 id="h3-3">抗单点故障</h3>\n<p>集群中的节点是无中心化的，每个节点都有可能随时退出或随时进入。因此，在集群中存储的数据都会有一个备份（可以配置备份的个数，也可以关闭数据备份）。这样的方式有点类似于 <em>hadoop</em>，某项数据存放在一个节点时，在其他节点必定有至少一个备份存在。当某个节点退出时，节点上存放的数据会由备份数据替代，而集群会重新创建新的备份数据。</p>\n<h3 id="h3-4">简易性</h3>\n<p>所有的 <em>Hazelcast </em>功能只需引用一个jar包，除此之外，他不依赖任何第三方包。因此可以非常便捷高效的将其嵌入到各种应用服务器中，而不必担心带来额外的问题（jar包冲突、类型冲突等等）。他仅仅提供一系列分布式功能，而不需要绑定任何框架来使用，因此适用于任何场景。</p>\n<p>除了以上特性，<em>Hazelcast </em>还支持服务器/客户端模型，支持脚本管理、能够和 <em>Docker </em>快速整合等等。</p>\n<h2 id="h2-3">简单使用例子</h2>\n<p>前面说了那么多概念，必须要来一点干货了。下面是一个使用 <em>Hazelcast </em>的极简例子。文中的所有代码都在github上：<a title="随风溜达的向日葵github-Hazelcast" href="https://github.com/chkui/hazelcast-demo" rel="nofollow">https://github.com/chkui/hazelcast-demo</a>。</p>\n<p>首先引入<em>Hazelcast</em>的jar包。</p>\n<p><em>Maven（pom.xml）</em>：</p>\n<pre class="dust"><code class="language-xml"><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">dependency</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n    </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">groupId</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">com.hazelcast</span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">groupId</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n    </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">artifactId</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">hazelcast</span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">artifactId</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n\t</span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">version</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">$</span><span class="code-template-variable">{hazelcast.vertsion}</span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">version</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n</span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">dependency</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span></code></pre>\n<p><em>Gradle（build.gradle）</em>：</p>\n<pre class="nginx"><code class="language-xml"><span class="code-attribute">compile</span> com.hazelcast:hazelcast:<span class="code-variable">${hazelcast.vertsion}</span></code></pre>\n<p>先创一个建 <em>Hazelcast </em>节点：</p>\n<pre class="javascript"><code class="language-java"><span class="code-comment"><span class="code-comment">//org.palm.hazelcast.getstart.HazelcastGetStartServerMaster </span></span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">HazelcastGetStartServerMaster</span></span></span><span class="hljs-class"> </span></span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword"><span class="code-keyword">static</span></span> <span class="code-keyword"><span class="code-keyword">void</span></span> <span class="code-title">main</span><span class="hljs-params">(<span class="code-built_in">String</span>[] args)</span> </span>{\n\t\t<span class="code-comment"><span class="code-comment">// 创建一个 hazelcastInstance实例</span></span>\n\t\tHazelcastInstance instance = Hazelcast.newHazelcastInstance();\n\t\t<span class="code-comment"><span class="code-comment">// 创建集群Map</span></span>\n\t\t<span class="code-built_in">Map</span>&lt;Integer, <span class="code-built_in">String</span>&gt; clusterMap = instance.getMap(<span class="code-string"><span class="code-string">"MyMap"</span></span>);\n\t\tclusterMap.put(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="code-string"><span class="code-string">"Hello hazelcast map!"</span></span>);\n\n\t\t<span class="code-comment"><span class="code-comment">// 创建集群Queue</span></span>\n\t\tQueue&lt;<span class="code-built_in">String</span>&gt; clusterQueue = instance.getQueue(<span class="code-string"><span class="code-string">"MyQueue"</span></span>);\n\t\tclusterQueue.offer(<span class="code-string"><span class="code-string">"Hello hazelcast!"</span></span>);\n\t\tclusterQueue.offer(<span class="code-string"><span class="code-string">"Hello hazelcast queue!"</span></span>);\n\t}\n}</code></pre>\n<p>上面的代码使用&nbsp;<em>Hazelcast </em>实例创建了一个节点。然后通过这个实例创建了一个分布式的Map和分布式的Queue，并向这些数据结构中添加了数据。运行这个main方法，会在console看到以下内容：</p>\n<blockquote>\n    <p>Members [1] {<br> &nbsp;&nbsp; &nbsp;Member [192.168.1.103]:5701 this<br> }</p>\n</blockquote>\n<p>随后再创建另外一个节点：</p>\n<pre class="cs"><code class="language-java"><span class="code-comment"><span class="code-comment">// org.palm.hazelcast.getstart.HazelcastGetStartServerSlave</span></span>\n<span class="code-keyword"><span class="code-keyword">public</span></span> <span class="hljs-class"><span class="code-keyword"><span class="code-keyword">class</span></span> <span class="code-title"><span class="code-title">HazelcastGetStartServerSlave</span></span> </span>{\n\t<span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">public</span></span></span><span class="hljs-function"> </span><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">static</span></span></span><span class="hljs-function"> </span><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">void</span></span></span><span class="hljs-function"> </span><span class="code-title"><span class="hljs-function"><span class="code-title">main</span></span></span><span class="hljs-params"><span class="hljs-function">(<span class="hljs-params">String[] args</span>)</span></span><span class="hljs-function"> </span></span>{\n\t\t<span class="code-comment"><span class="code-comment">//创建一个 hazelcastInstance实例</span></span>\n\t\tHazelcastInstance instance = Hazelcast.newHazelcastInstance();\n\t\tMap&lt;Integer, String&gt; clusterMap = instance.getMap(<span class="code-string"><span class="code-string">"MyMap"</span></span>);\n\t\tQueue&lt;String&gt; clusterQueue = instance.getQueue(<span class="code-string"><span class="code-string">"MyQueue"</span></span>);\n\t\t\n\t\tSystem.<span class="code-keyword">out</span>.println(<span class="code-string"><span class="code-string">"Map Value:"</span></span> + clusterMap.<span class="code-keyword">get</span>(<span class="hljs-number"><span class="hljs-number">1</span></span>));\n\t\tSystem.<span class="code-keyword">out</span>.println(<span class="code-string"><span class="code-string">"Queue Size :"</span></span> + clusterQueue.size());\n\t\tSystem.<span class="code-keyword">out</span>.println(<span class="code-string"><span class="code-string">"Queue Value 1:"</span></span> + clusterQueue.poll());\n\t\tSystem.<span class="code-keyword">out</span>.println(<span class="code-string"><span class="code-string">"Queue Value 2:"</span></span> + clusterQueue.poll());\n\t\tSystem.<span class="code-keyword">out</span>.println(<span class="code-string"><span class="code-string">"Queue Size :"</span></span> + clusterQueue.size());\n\t}\n}</code></pre>\n<p>该节点的作用是从<em>Map、Queue</em>中读取数据并输出。运行会看到以下输出</p>\n<blockquote>\n    <p>Members [2] {<br> &nbsp;&nbsp; &nbsp;Member [192.168.1.103]:5701<br> &nbsp;&nbsp; &nbsp;Member [192.168.1.103]:5702 this<br> }</p>\n    <p>八月 06, 2016 11:33:29 下午 com.hazelcast.core.LifecycleService<br> 信息: [192.168.1.103]:5702 [dev] [3.6.2] Address[192.168.1.103]:5702 is STARTED<br> Map Value:Hello hazelcast map!<br> Queue Size :2<br> Queue Value 1:Hello hazelcast!<br> Queue Value 2:Hello hazelcast queue!<br> Queue Size :0</p>\n</blockquote>\n<p>至此，2个节点的集群创建完毕。第一个节点向map实例添加了{key:1,value:"Hello hazelcast map!"}，向queue实例添加[“Hello hazelcast!”,“Hello hazelcast queue!”]，第二个节点读取并打印这些数据。</p>\n<p>除了直接使用Hazelcast服务来组建集群，Hazelcast还提供了区别于服务端的客户端应用包。客户端与服务端最大的不同是：他不会存储数据也不能修改集群中的数据。目前客户端有C++、.Net、Java多种版本。</p>\n<p>使用客户端首先要引入客户端jar包。</p>\n<p><em>Maven（pom.xml）</em>：</p>\n<pre class="dust"><code class="language-xml"><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">dependency</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n    </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">groupId</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">com.hazelcast</span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">groupId</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n    </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">artifactId</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">hazelcast-client</span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">artifactId</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n    </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">version</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">$</span><span class="code-template-variable">{hazelcast.version}</span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">version</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n</span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">dependency</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span></code></pre>\n<p><em>Gradle（build.gradle）</em>：</p>\n<pre class="nginx"><code class="nginx"><span class="code-attribute"><span class="code-attribute">compile</span></span> com.hazelcast:hazelcast-client:<span class="code-variable"><span class="code-variable">${hazelcast.vertsion}</span></span></code></pre>\n<p>创建一个client节点。</p>\n<pre class="cs"><code class="language-java"><span class="code-keyword"><span class="code-keyword">public</span></span> <span class="hljs-class"><span class="code-keyword"><span class="code-keyword">class</span></span> <span class="code-title"><span class="code-title">HazelcastGetStartClient</span></span> </span>{\n\t<span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">public</span></span></span><span class="hljs-function"> </span><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">static</span></span></span><span class="hljs-function"> </span><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">void</span></span></span><span class="hljs-function"> </span><span class="code-title"><span class="hljs-function"><span class="code-title">main</span></span></span><span class="hljs-params"><span class="hljs-function">(<span class="hljs-params">String[] args</span>)</span></span><span class="hljs-function"> </span></span>{\n\t\tClientConfig clientConfig = <span class="code-keyword"><span class="code-keyword">new</span></span> ClientConfig();\n\t\tHazelcastInstance instance = HazelcastClient.newHazelcastClient(clientConfig);\n\t\tMap&lt;Integer, String&gt; clusterMap = instance.getMap(<span class="code-string"><span class="code-string">"MyMap"</span></span>);\n\t\tQueue&lt;String&gt; clusterQueue = instance.getQueue(<span class="code-string"><span class="code-string">"MyQueue"</span></span>);\n\t\t\n\t\tSystem.<span class="code-keyword">out</span>.println(<span class="code-string"><span class="code-string">"Map Value:"</span></span> + clusterMap.<span class="code-keyword">get</span>(<span class="hljs-number"><span class="hljs-number">1</span></span>));\n\t\tSystem.<span class="code-keyword">out</span>.println(<span class="code-string"><span class="code-string">"Queue Size :"</span></span> + clusterQueue.size());\n\t\tSystem.<span class="code-keyword">out</span>.println(<span class="code-string"><span class="code-string">"Queue Value 1:"</span></span> + clusterQueue.poll());\n\t\tSystem.<span class="code-keyword">out</span>.println(<span class="code-string"><span class="code-string">"Queue Value 2:"</span></span> + clusterQueue.poll());\n\t\tSystem.<span class="code-keyword">out</span>.println(<span class="code-string"><span class="code-string">"Queue Size :"</span></span> + clusterQueue.size());\n\t}\n}</code></pre>\n<p>然后先启动 <em>HazelcastGetStartServerMaster::main</em>，再启动 <em>HazelcastGetStartClient::main</em>。可以看到客户端输出：</p>\n<blockquote>\n    <p>Members [1] {<br> &nbsp;&nbsp; &nbsp;Member [192.168.197.54]:5701<br> }</p>\n    <p>八月 08, 2016 10:54:22 上午 com.hazelcast.core.LifecycleService<br> 信息: HazelcastClient[hz.client_0_dev][3.6.2] is CLIENT_CONNECTED<br> Map Value:Hello hazelcast map!<br> Queue Size :2<br> Queue Value 1:Hello hazelcast!<br> Queue Value 2:Hello hazelcast queue!<br> Queue Size :0</p>\n</blockquote>\n<p>至此，客户端功能也创建完毕&nbsp;。可以看到客户端的console输出内容比服务端少了很多，这是因为客户端不必承载服务端的数据处理功能，也不必维护各种节点信息。</p>\n\n<h2 id="h2-4">例子运行解析</h2>\n<p>下面我们根据console的输出来看看 <em>Hazelcast </em>启动时到底干了什么事。（下面的输出因环境或IDE不同，可能会有差异）</p>\n<blockquote>\n    <p><span style="color:#FF0000">class: com.hazelcast.config.XmlConfigLocator<br> info:&nbsp;Loading \'hazelcast-default.xml\' from classpath.&nbsp;</span></p>\n</blockquote>\n<p>这里输出的内容表示<em>Hazelcast</em>启动时加载的配置文件。如果用户没有提供有效的配置文件，<em>Hazelcast</em>会使用默认配置文件。后续的文章会详细说明 <em>Hazelcast </em>的配置。</p>\n<blockquote>\n    <p><span style="color:#FF0000">class: com.hazelcast.instance.DefaultAddressPicker<br> info: Prefer IPv4 stack is true.<br> class: com.hazelcast.instance.DefaultAddressPicker<br> info:&nbsp;Picked Address[192.168.197.54]:5701, using socket ServerSocket[addr=/0:0:0:0:0:0:0:0,localport=5701], bind any local is true</span></p>\n</blockquote>\n<p>这一段输出说明了当前 <em>Hazelcast </em>的网络环境。首先是检测IPv4可用且检查到当前的IPv4地址是192.168.197.54。然后使用IPv6启用socket。在某些无法使用IPv6的环境上，需要强制指定使用IPv4，增加jvm启动参数：<em>-Djava.net.preferIPv4Stack=true</em> 即可。</p>\n<blockquote>\n    <p><span style="color:#FF0000">class: com.hazelcast.system<br> info:&nbsp;Hazelcast 3.6.2 (20160405 - 0f88699) starting at Address[192.168.197.54]:5701<br> class: com.hazelcast.system<br> info: [192.168.197.54]:5701 [dev] [3.6.2] Copyright (c) 2008-2016, Hazelcast, Inc. All Rights Reserved.</span></p>\n</blockquote>\n<p>这一段输出说明了当前实例的初始化端口号是5701。<em>Hazelcast&nbsp;</em>默认使用5701端口。如果发现该端口被占用，会+1查看5702是否可用，如果还是不能用会继续向后探查直到5800。<em>Hazelcast&nbsp;</em>默认使用5700到5800的端口，如果都无法使用会抛出启动异常。</p>\n<blockquote>\n    <p><span style="color:#FF0000">class: com.hazelcast.system<br> info: [192.168.197.54]:5701 [dev] [3.6.2] Configured Hazelcast Serialization version : 1<br> class: com.hazelcast.spi.OperationService<br> info: [192.168.197.54]:5701 [dev] [3.6.2] Backpressure is disabled<br> class: com.hazelcast.spi.impl.operationexecutor.classic.ClassicOperationExecutor<br> info: [192.168.197.54]:5701 [dev] [3.6.2] Starting with 2 generic operation threads and 4 partition operation threads.</span></p>\n</blockquote>\n<p>这一段说明了数据的序列化方式和启用的线程。<em>Hazelcast </em>在节点间传递数据有2种序列化方式，在后续的文章中国会详细介绍。<em>Hazelcast&nbsp;</em>会控制多个线程执行不同的工作，有负责维持节点连接的、有负责数据分区管理的。</p>\n<blockquote>\n    <p><span style="color:#FF0000">class: com.hazelcast.instance.Node<br> info: [192.168.197.54]:5701 [dev] [3.6.2] Creating MulticastJoiner<br> class: com.hazelcast.core.LifecycleService<br> info: [192.168.197.54]:5701 [dev] [3.6.2] Address[192.168.197.54]:5701 is STARTING<br> class: com.hazelcast.nio.tcp.nonblocking.NonBlockingIOThreadingModel<br> info: [192.168.197.54]:5701 [dev] [3.6.2] TcpIpConnectionManager configured with Non Blocking IO-threading model: 3 input threads and 3 output threads<br> class: com.hazelcast.cluster.impl.MulticastJoiner<br> info: [192.168.197.54]:5701 [dev] [3.6.2]&nbsp;</span></p>\n</blockquote>\n<p>上面这一段输出中，<span style="color:#000000">Creating MulticastJoiner表示使用组播协议来组建集群。还创建了6个用于维护非拥塞信息输出\\输出。</span></p>\n<blockquote>\n    <p><span style="color:#FF0000">Members [1] {</span><br> <span style="color:#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;Member [192.168.197.54]:5701<br> &nbsp;&nbsp;&nbsp;&nbsp;Member [192.168.197.54]:5702&nbsp;this<br> }</span></p>\n    <p><span style="color:#FF0000">class: com.hazelcast.core.LifecycleService<br> info: [192.168.197.54]:5701 [dev] [3.6.2] Address[192.168.197.54]:5701 is STARTED</span><br> <span style="color:#FF0000">class: com.hazelcast.partition.InternalPartitionService<br> info: [192.168.197.54]:5701 [dev] [3.6.2] Initializing cluster partition table arrangement...</span></p>\n</blockquote>\n<p><span style="color:#000000">&nbsp;&nbsp;&nbsp;&nbsp;Members[2]表示当前集群只有2个节点。2个节点都在ip为</span>192.168.197.54<span style="color:#000000">的这台设备上，2个节点分别占据了5701端口和5702端口。端口后面的this说明这是当前节点，而未标记this的是其他接入集群的节点。最后InternalPartitionService输出的信息表示集群初始化了“数据分片”，后面会介绍“数据分片”的概念和原理。</span></p>\n<p><span style="color:#000000">&nbsp; &nbsp; 上面就是Hazelcast在默认情况下执行的启动过程，可以看出在初始化的过程中我们可以有针对性的修改一些Hazelcast的行为：</span></p>\n<ol>\n    <li>使用默认配置文档 <em>hazelcast-default.xml </em>来启动集群。<span style="color:#FF0000">因此我们可以自定义这个配置文件来影响<em>Hazelcast&nbsp;</em>的行为</span>。</li>\n    <li>启用IPv4或IPv6来建立集群，因此可以知道Hazelcast集群的通信是基于TCP、UDP，需要打开socket支持集群交互。<span style="color:#FF0000">因此我们可以指定使用的通讯方案</span>。</li>\n    <li><em>Hazelcast</em>会启动多个线程来执行不同的工作，有些负责维护数据、有些负责集群通信、有些负责一些基础操作。<span style="color:#FF0000">因此我们可以配置和管理这些线程</span>。</li>\n    <li><em>Hazelcast</em>默认使用<em>MulitCast</em>（组播协议）来组建集群，因此在局域网环境他可以无需配置自己完成集群组建。<span style="color:#FF0000">因此我们可以指定使用TCP/IP或其他通讯协议</span>。</li>\n    <li><em>Hazelcast</em>会自己探寻可以使用的端口，默认情况下会使用5700到5800间没有被占用的端口。<span style="color:#FF0000">因此我们可以配置这些端口如何使用</span>。</li>\n    <li><em>Hazelcast</em>初始化一个名为“数据分片”的方案来管理和存储数据。<span style="color:#FF0000">因此我们可以调整和控制这些数据分片</span>。</li>\n</ol>\n<p>以上所有红色字体的部分都可以通过配置文件来影响。在后续的文章中会详细介绍相关的 配置说明（待续）。</p>\n<p>-----------------------------------亮瞎人的分割线-----------------------------------</p>\n<p>如果对Hazelcast的基本原理没什么兴趣，就不用向下看“运行结构“和“数据分片原理”了，直接去 <a title="Hazelcast基本配置" href="https://www.chkui.com/article/hazelcast/hazelcast_configuration_management">Hazelcast基本配置</a>了解如何使用Hazelcast吧。</p>\n<h2 id="h2-5">Hazelcast运行结构</h2>\n<p>Hazelcast的官网上列举了2种运行模式，一种是p2p（点对点）模式、一种是在点对点模式上扩展的C/S模式。下图是p2p模式的拓补结构。</p>\n<p style="text-align:center"><img alt="" height="249" src="https://file.mahoooo.com/res/file/hazelcast_get_started_and_code_sample_1.png" width="334"></p>\n<p>在p2p模式中，所有的节点（Node）都是集群中的服务节点，提供相同的功能和计算能力。每个节点都分担集群的总体性能，每增加一个节点都可以线性增加集群能力。</p>\n<p>在p2p服务集群的基础上，我们可以增加许多客户端接入到集群中，这样就形成了集群的C/S模式，提供服务集群视作S端，接入的客户端视作C端。这些客户端不会分担集群的性能，但是会使用集群的各种资源。下图的结构就是客户端接入集群的情况。</p>\n<p style="text-align:center"><img alt="" height="257" src="https://file.mahoooo.com/res/file/hazelcast_get_started_and_code_sample_2.png" width="507"></p>\n<p>可以为客户端提供特别的缓存功能，告知集群让那些它经常要使用的数存放在“离它最近”的节点。</p>\n<h2 id="h2-6">Hazelcast分片概念与原理</h2>\n<p><em>Hazelcast</em>通过分片来存储和管理所有进入集群的数据，采用分片的方案目标是保证数据可以快速被读写、通过冗余保证数据不会因节点退出而丢失、节点可线性扩展存储能力。下面将从理论上说明<em>Hazelcast</em>是如何进行分片管理的。</p>\n<h3 id="h3-5">分片</h3>\n<p><em>Hazelcast</em>的每个数据分片（shards）被称为一个分区（Partitions）。分区是一些内存段，根据系统内存容量的不同，每个这样的内存段都包含了几百到几千项数据条目，默认情况下，<em>Hazelcast</em>会把数据划分为271个分区，并且每个分区都有一个备份副本。当启动一个集群成员时，这271个分区将会一起被启动。</p>\n<p>下图展示了集群只有一个节点时的分区情况。</p>\n<p><img alt="" height="234" src="https://file.mahoooo.com/res/file/hazelcast_get_started_and_code_sample_3.png" width="99"></p>\n<p>从一个节点的分区情况可以看出，当只启动一个节点时，所有的271个分区都存放在一个节点中。然后我们启动第二个节点。会出现下面这样的分区方式。</p>\n<p><img alt="" height="259" src="https://file.mahoooo.com/res/file/hazelcast_get_started_and_code_sample_4.png" width="214"></p>\n<p>二个节点的图中，用黑色文字标记的表示主分区，用蓝色文字标记的表示复制分区（备份分区）。第一个成员有135个主分区（黑色部分），所有的这些分区都会在第二个成员中有一个副本（蓝色部分），同样的，第一个成员也会有第二个成员的数据副本。</p>\n<p>当增加更多的成员时，<em>Hazelcast</em>会将主数据和备份数据一个接一个的迁移到新成员上，最终达成成员之间数据均衡且相互备份。当<em>Hazelcast</em>发生扩展的时候，只有最小数量的分区被移动。下图呈现了4个成员节点的分区分布情况。</p>\n<p><img alt="" height="258" src="https://file.mahoooo.com/res/file/hazelcast_get_started_and_code_sample_5.png" width="445"></p>\n<p>上面的几个图说明了的Hazelcast是如何执行分区的。通常情况下，分区的分布情况是无序的，他们会随机分布在集群中的各个节点中。最重要的是，Hazelcast会平均分配成员之前的分区，并均匀在的成员之间创建备份。</p>\n<p>在Hazelcast 3.6版本中，新增了一种集群成员：“精简成员”（lite members），他的特点是不拥有任何分区。“精简成员”的目标是用于“高密度运算”任务（computationally-heavy task executions。估计是指CPU密集型运算）或者注册监听（listener） 。虽然“精简成员”没有自己的分区，但是他们同样可以访问集群中其他成员的分区。</p>\n<p>总的来说，当集群中的节点发送变动时（进入或退出），都会导致分区在节点中移动并再平衡，以确保数据均匀存储。但若是“精简节点”的进入或退出，并不会出现重新划分分区情况，因为精简节点并不会保存任何分区。</p>\n\n<h3 id="h3-6">数据分区管理</h3>\n<p>创建了分区以后，Hazelcast会将所有的数据存放到每个分区中。它通过哈希运算将数据分布到每个分区中。获取存储数据Key值（例如map）或value值（例如topic、list），然后进行以下处理：</p>\n<ol>\n    <li>将设定的key或value转换成byte[]；</li>\n    <li>对转换后的byte[]进行哈希计算；</li>\n    <li>将哈希计算的结果和分区的数量（271）进行模运算（同余运算、mod运算、%运算）。</li>\n</ol>\n<p>因为byte[]是和271进行同模运算，因此计算结果一定会在0~270之间，根据这个值可以指定到用于存放数据的分区。</p>\n<h3 id="h3-7">分区表</h3>\n<p>当创建分区以后，集群中的所有成员必须知道每个分区被存储到了什么节点。因此集群还需要维护一个分区表来追踪这些信息。</p>\n<p>当启动第一个节点时，一个分区表将随之创建。表中包含分区的ID和标记了他所属的集群节点。分区表的目标就是让集群中所有节点（包括“精简节点”）都能获取到数据存储信息，确保每个节点都知道数据在哪。集群中最老的节点（通常情况下是第一个启动的成员）定期发送分区表给所有的节点。以这种方式，当分区的所有权发生变动时，集群中的所有节点都会被通知到。分区的所有权发生变动有很多种情况，比如，新加入一个节点、或节点离开集群等。如果集群中最早启动的节点被关闭，那么随后启动的节点将会继承发送分区表的任务，继续将分区表发送给所有成员。</p>'},348:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h2 id="h2-1">从一个类开始</h2>\n<p>我们从一个简单类开始说起：</p>\n<pre><code class="java"><span class="code-keyword">package</span> example.classLifecicle;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">SimpleClass</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tSimpleClass ins = <span class="code-keyword">new</span> SimpleClass();\n\t}\n}</code></pre>\n<p>这是一段平凡得不能再平凡的Java代码，稍微有点编程语言入门知识的人都能理解它表达的意思：</p>\n<ol>\n    <li>创建一个名为SimpleClass的类；</li>\n    <li>定义一个入口main方法；</li>\n    <li>在main方法中创建一个SimpleClass类实例；</li>\n    <li>退出。</li>\n</ol>\n\n<h2 id="h2-2">什么是Java bytecode</h2>\n<p>那么这一段代码是怎么在机器（JVM）里运行的呢？在向下介绍之前先说清几个概念。</p>\n<p>首先，Java语言和JVM完全可以看成2个完全不相干的体系。虽然JVM全称叫Java Virtual\n    Machine，最开始也是为了能够实现Java的设计思想而制定开发的。但是时至今日他完全独立于Java语言成为一套生命力更为强悍的体系工具。他有整套规范，根据这个规范它有上百个应用实现，其中包括我们最熟悉的hotspot、jrockit等。还有一些知名的变种版本——harmony和android\n    dalvik，严格意义上变种版本并不能叫java虚拟机，因为其并未按照jvm规范开发，但是从设计思想、API上看又有大量的相似之处。</p>\n<p>其次，JVM并不能理解Java语言，他所理解的是称之为Java bytecode的"语言"。Java\n    bytecode从形式上来说是面向过程的，目前包含130多个指令，他更像可以直接用于CPU计算的一组指令集。所以无论什么语言，最后只要按照规范编译成java\n    bytecode（以下简称为"字节码"）都可以在JVM上运行。这也是scala、groovy、kotlin等各具特色的语言虽然在语法规则上不一致，但是最终都可以在JVM上平稳运行的原因。</p>\n\n<h2 id="h2-3">Java bytecode的规范和存储形式</h2>\n<p>前面代码保存成 <em>.java</em> 文件然后用下面的命令编译过后就可以生成.class字节码了：</p>\n<pre><code class="bash">$ javac SimpleClass.java <span class="code-comment">#SimpleClass.class</span></code></pre>\n<p>字节码是直接使用2进制的方式存储的，每一段数据都定义了具体的作用。下面是<em>SimpleClass.class</em> 的16进制数据（使用<em>vim + xxd</em>打开）：</p>\n<p><img alt="Jvm与字节码——类的方法区模型" height="315"\n        src="https://file.mahoooo.com/res/file/java_jvm_class_compile_in_the_method_area_2.png" width="500"></p>\n<p>一个 <em>.class</em> 文件的字节码分为10个部分：</p>\n<p>0~4字节：文件头，用于表示这是一个<em>Java bytecode</em>文件，值固定为0xCAFEBABE。</p>\n<p>2+2字节：编译器的版本信息。</p>\n<p>2+n字节：常量池信息。</p>\n<p>2字节：入口权限标记。</p>\n<p>2字节：类符号名称。</p>\n<p>2字节：父类符号名称。</p>\n<p>2+n字节：接口。</p>\n<p>2+n字节：域（成员变量）。</p>\n<p>2+n字节：方法。</p>\n<p>2+n字节：属性。</p>\n<p>每个部分的前2个字节都是该部分的标识位。</p>\n<p>本篇的目的是说明字节码的作用以及JVM如何使用字节码运转的，想要详细了解2进制意义的请看这里：http://www.jianshu.com/p/252f381a6bc4。</p>\n\n<h2 id="h2-4">反汇编及字节码解析</h2>\n<p>我们可以使用 <strong><em>javap</em></strong> 命令将字节码反汇编成我们容易阅读的格式化了的指令集编码:</p>\n<pre><code class="bash">$ javap -p SimpleClass.class <span class="code-comment">#查看类和成员</span>\n$ javap -s SimpleClass.class <span class="code-comment">#查看方法签名</span>\n$ javap -c SimpleClass.class <span class="code-comment">#反汇编字节码</span>\n$ javap -v SimpleClass.class <span class="code-comment">#返汇编查看所有信息</span></code></pre>\n<p><strong><em>javap</em></strong> 还有很多的参数，可以使用 <strong><em>javap --help</em></strong> 来了解。下面是使用<strong><em>javap\n    -v</em></strong> 命令输出的内容，输出了常量池信息、方法签名、方法描述、堆栈数量、本地内存等信息：</p>\n<pre><code class="apache"><span class="code-attribute">public</span> class example.classLifecicle.SimpleClass\n  <span class="code-attribute">flags</span>: ACC_PUBLIC, ACC_SUPER\n<span class="code-attribute">Constant</span> pool:\n   <span class="code-comment">#1 = Methodref          #4.#13         // java/lang/Object."&lt;init&gt;":()V</span>\n   <span class="code-comment">#2 = Class              #14            // example/classLifecicle/SimpleClass</span>\n   <span class="code-comment">#3 = Methodref          #2.#13         // example/classLifecicle/SimpleClass."&lt;init&gt;":()V</span>\n   <span class="code-comment">#4 = Class              #15            // java/lang/Object</span>\n   <span class="code-comment">#5 = Utf8               &lt;init&gt;</span>\n   <span class="code-comment">#6 = Utf8               ()V</span>\n   <span class="code-comment">#7 = Utf8               Code</span>\n   <span class="code-comment">#8 = Utf8               LineNumberTable</span>\n   <span class="code-comment">#9 = Utf8               main</span>\n  <span class="code-comment">#10 = Utf8               ([Ljava/lang/String;)V</span>\n  <span class="code-comment">#11 = Utf8               SourceFile</span>\n  <span class="code-comment">#12 = Utf8               SimpleClass.java</span>\n  <span class="code-comment">#13 = NameAndType        #5:#6          // "&lt;init&gt;":()V</span>\n  <span class="code-comment">#14 = Utf8               example/classLifecicle/SimpleClass</span>\n  <span class="code-comment">#15 = Utf8               java/lang/Object</span>\n{\n  <span class="code-attribute">public</span> example.classLifecicle.SimpleClass();\n    <span class="code-attribute">descriptor</span>: ()V\n    <span class="code-attribute">flags</span>: ACC_PUBLIC\n    <span class="code-attribute">Code</span>:\n      <span class="code-attribute">stack</span>=1, locals=1, args_size=1\n         <span class="code-attribute">0</span>: aload_0\n         <span class="code-attribute">1</span>: invokespecial #1                  // Method java/lang/Object.<span\n            class="code-string">"&lt;init&gt;"</span>:()V\n         <span class="code-attribute">4</span>: return\n      <span class="code-attribute">LineNumberTable</span>:\n        <span class="code-attribute">line</span> 3: 0\n\n  <span class="code-attribute">public</span> static void main(java.lang.String[]);\n    <span class="code-attribute">descriptor</span>: ([Ljava/lang/String;)V\n    <span class="code-attribute">flags</span>: ACC_PUBLIC, ACC_STATIC\n    <span class="code-attribute">Code</span>:\n      <span class="code-attribute">stack</span>=2, locals=2, args_size=1\n         <span class="code-attribute">0</span>: new           #2                  // class example/classLifecicle/SimpleClass\n         <span class="code-attribute">3</span>: dup\n         <span class="code-attribute">4</span>: invokespecial #3                  // Method <span class="code-string">"&lt;init&gt;"</span>:()V\n         <span class="code-attribute">7</span>: astore_1\n         <span class="code-attribute">8</span>: return\n      <span class="code-attribute">LineNumberTable</span>:\n        <span class="code-attribute">line</span> 5: 0\n        <span class="code-attribute">line</span> 6: 8\n}\n</code></pre>\n<p>下面是关于字节码格式的描述：</p>\n<p><strong><em>public class example.classLifecicle.SimpleClass</em></strong></p>\n<p>这一段表示这个类的符号。</p>\n<p><em><strong>flags: ACC_PUBLIC, ACC_SUPER</strong></em></p>\n<p>该类的标记。例如是否是public类等等，实际上就是将一些Java关键字转译成对应的Java bytecode。</p>\n<p><em><strong>Constant pool:</strong></em></p>\n<p><em>constant pool:</em> 之后的内容一直到<em> { </em>符号，都是我们所说的"常量池"。在对java类进行编译之后就会产生这个常量池。通常我们所说的类加载，就是加载器将字节码描述的常量信息转换成实际存储在运行时常量池中的一些内存数据（当然每个方法中的指令集也会随之加载到方法指向的某个内存空间中）。\n</p>\n<p>"#1"可以理解为常量的ID。可以把常量池看作一个Table，每一个ID都指向一个常量，而在使用时都直接用"#1"这样的ID来引用常量。</p>\n<p>常量池中的包含了运行这个类中方法所有需要用到的所有常量信息，Methodref、Class、Utf8、NameAndType等表示常量的类型，后面跟随的参数表示这个常量的引用位置或者数值。</p>\n<p><em><strong>{}:</strong></em></p>\n<p>常量池之后的{}之间是方法。每一个方法分为符号（名称）、标记、描述以及指令集。descriptor：描述。flags：入口权限标记。Code：指令集。</p>\n<p>Code中，stack表示这一段指令集堆栈的最大深度, locals表示本地存储的最大个数, args_size表述传入参数的个数。</p>\n\n<h2 id="h2-5">字节码如何驱动机器运行</h2>\n<p>\n    在往下说之前，先说下JVM方法区的内容。方法区顾名思义就是存储各种方法的地方。但是从实际应用来看，以Hotspot为例——方法区在实现时通常分为class常量池、运行常量池。在大部分书籍中，运行时常量池被描述为包括类、方法的所有描述信息以及常量数据,（<a\n        href="https://www.chkui.com/article/java/java_jvm_method_area_and_constant_pool" rel="nofollow">详情请看这篇文章</a>。</p>\n<p>对于机器来说并不存在什么类的感念的。到了硬件层面，他所能了解的内容就是：1）我要计算什么（cpu），2）我要存储什么（缓存、主存、磁盘等，我们统称内存）？</p>\n<p>\n    按照分层模型来说JVM只是一个应用进程，是不可能直接和机器打交道的（这话也不是绝对的，有些虚拟机还真直接当作操作系统在特有硬件设备上用）。在JVM到硬件之间还隔着一层操作系统，在本地运行时是直接调用操作系统接口的（windows和linux都是C/C++）。不过为了JVM虚拟机更高效，字节码设计为更接近机器逻辑行为的方式来运行。不然也没必要弄一个字节码来转译Java语言，像nodejs用的V8引擎那样实时编译Javascript不是更直接？这也是过去C/C++唾弃Java效率低下，到了如今Java反而去吐槽其他解释型编译环境跑得慢的原因（不过这也不见得100%正确。比如某些情况下Java在JVM上处理JSON不见得比JavaScript在nodejs上快，而且写起代码来也挺费劲的）。</p>\n<p>\n    我们回到硬件计算和存储的问题。CPU的计算过程实质上就是操作系统的线程不断给CPU传递指令集。线程就像传送带一样，把一系列指令排好队然后一个一个交给CPU去处理。每一个指令告诉CPU干一件事，而干事的前后总得有个依据（输入）和结果（输出），这就是各种缓存、内存、磁盘的作用——提供依据、保存结果。JVM线程和操作系统线程是映射关系（mapping），而JVM的堆（heap）和非堆（Non-heap）就是一个内存管理的模型。所以我们跳出分层的概念，将字节码理解为直接在驱动cpu和内存运行的汇编码更容易理解。</p>\n<p>最后，我们回到方法区（Method\n    Area）这个规范概念。CPU只关心一堆指令，而JVM中所有的指令都是放置在方法区中的。JVM的首要任务是把这些指令有序的组织起来，按照编程好的逻辑将指令一个一个交给CPU去运行。而CPU都是靠线程来组织指令运算的，所以JVM中每个线程都有一个线程栈，通过他将指令组织起来一个一个的交给CPU去运算——这就是计数器（Counter\n    Register，用以指示当前应该执行什么字节码指令）、线程栈（Stacks，线程的运算模型——先进后出） 和 栈帧（Stacks\n    Frame，方法执行的本地变量）&nbsp;的概念。所以无论多复杂的设计，方法区可以简单的理解为：<strong>有序的将指令集组织起来，并在使用的时候可以通过某些方法找到对应的指令集合</strong>。</p>\n<p><strong>解析常量池</strong></p>\n<p><img alt="Jvm与字节码——类的方法区模型" height="339"\n        src="https://file.mahoooo.com/res/file/java_jvm_class_compile_in_the_method_area_1.png" width="563"></p>\n<p>先看 <em><strong>SimpleClass</strong></em>&nbsp;字节码中常量池中的一些数据，上图中每一个方框表示一个常量。方框中第一行的 <em><strong>#1</strong></em>\n    表示当前常量的ID，第二行 <strong><em>Methodref</em></strong> 表示这个这个常量的类型，第三行 <em><strong>#4,#13</strong></em> 表示常量的值。</p>\n<p>我们从 <em><strong>#1</strong></em> 开始跟着每个常量的值向下延伸可以展开一根以 <strong><em>Utf8</em></strong>&nbsp;类型作为叶节点的树，每一个叶节点都是一个值。所有的方法我们都可以通过树的方式展开得到下面的查询字段：\n</p>\n<pre><code class="apache"><span class="code-attribute">class</span> = java/lang/Object //属于哪个类\n<span class="code-attribute">method</span> = <span class="code-string">"&lt;init&gt;"</span> //方法名称\n<span class="code-attribute">params</span> = NaN //参数\n<span class="code-attribute">return</span> = V //返回类型</code></pre>\n<p>所有的方法都会以 <em><strong>package.class.name:(params)return&nbsp;</strong></em>的形式存储在方法区中，通过上面的参数很快可以定位到方法，例如&nbsp; <em>java.lang.Object."&lt;init&gt;":()V</em>，这里"&lt;init&gt;"是构造方法专用的名称。\n</p>\n<p><strong>解析方法中的指令集</strong></p>\n<p>方法除了用于定位的标识符外就是指令集，下面解析main方法的指令集：</p>\n<pre><code class="http"><span class="code-attribute">0</span>: new &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// class example/classLifecicle/SimpleClass\n<span class="code-attribute">3</span>: dup\n<span class="code-attribute">4</span>: invokespecial #3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Method "&lt;init&gt;":()V\n<span class="code-attribute">7</span>: astore_1\n<span class="code-attribute">8</span>: return</code></pre>\n<p>1)）new 表示新建一个ID为#2的对象即SimpleClass(#2-&gt;#15="<em><strong>example/classLifecicle/SimpleClass"</strong></em>)。此时JVM会在堆上创建一个能放置<strong><em>SimpleClass</em></strong>类的空间并将引用地址返回写到栈顶。这里仅仅完成在堆中分配空间，没执行初始化。\n</p>\n<p>2）dup表示复制栈顶数据。此时栈中有2个指向同一内存区域的<em><strong>SimpleClass</strong></em>引用。</p>\n<p>3）invokespecial\n    #3表示执行#3的方法。通过解析常量池#3就是<em><strong>SimpleClass</strong></em>的构造方法。此后会将<em><strong>SimpleClass</strong></em>构造方法中的指令压入栈中执行。\n</p>\n<p>4）接下来来是<em><strong>SimpleClass</strong></em>的构造方法部分： a）aload_0 表示将本地内存的第一个数据压入栈顶，本地内存的第一个数据就是this。b）invokespecial #1\n    表示执行 <em><strong>Object</strong></em> 的构造方法。c）退出方法。这样就完成了实例的构造过程。</p>\n<p>5）完成上述步骤后，线程栈上还剩下一个指向<em><strong>SimpleClass</strong></em>实例的引用，astore_1 表示将引用存入本地缓存第二个位置。</p>\n<p>6）return -&gt; 退出 <em>main</em> 方法。</p>\n\n<h2 id="h2-6">方法区结构</h2>\n<p><strong>那么在方法区中所有的类是如何组织存放的呢？</strong></p>\n<p>我们用一个关系型数据库常的结构就可以解释他。在数据库中我们常用的对象有3个——表、字段、数据。每一个类对应的字节码我们都可以看成会生成2张数据库表——常量池表、方法表。通过字节码的解析，在内存中产生了如下结构的表：</p>\n<p>常量池表:example.classLifecicle.SimpleClass_Constant</p>\n<table border="1" cellpadding="1" cellspacing="1" style="width:500px">\n    <tbody>\n    <tr>\n        <td><strong><em>id</em></strong></td>\n        <td><strong><em>type</em></strong></td>\n        <td><strong><em>value</em></strong></td>\n    </tr>\n    <tr>\n        <td>#1</td>\n        <td>Methodref</td>\n        <td>#4,#13</td>\n    </tr>\n    <tr>\n        <td>…</td>\n        <td>……</td>\n        <td>……</td>\n    </tr>\n    <tr>\n        <td>#4</td>\n        <td>Class</td>\n        <td>#15</td>\n    </tr>\n    <tr>\n        <td>#15</td>\n        <td>Utf8</td>\n        <td>java/lang/Object</td>\n    </tr>\n    </tbody>\n</table>\n<p>方法表:example.classLifecicle.SimpleClass_Method</p>\n<table border="1" cellpadding="1" cellspacing="1" style="width:500px">\n    <tbody>\n    <tr>\n        <td>name</td>\n        <td>params</td>\n        <td>return</td>\n        <td>flag</td>\n        <td>code</td>\n    </tr>\n    <tr>\n        <td>&lt;init&gt;</td>\n        <td>&nbsp; &nbsp; NaN</td>\n        <td>V</td>\n        <td>static,public</td>\n        <td>……</td>\n    </tr>\n    <tr>\n        <td>…&nbsp;</td>\n        <td>……</td>\n        <td>……</td>\n        <td>……</td>\n        <td>……</td>\n    </tr>\n    </tbody>\n</table>\n<p>然后在运行过程中当计数器遇到&nbsp;<strong><em>invokespecial #3</em></strong>&nbsp;这样的指令时就会根据指令后面的ID去本类的常量表中查询并组装数据。当组装出&nbsp;class\n    = java/lang/Object、method = "&lt;init&gt;"、params = NaN、return = V这样的数据后，就会去名为java.lang.Object的表中根据&nbsp;<em>method、params、return&nbsp;</em>字段的数据查询对应的code，找到后为该code创建一个本地内存，随后线程计数器逐个执行code中的指令。\n</p>\n<p>这里仅仅用关系型数据库表的概念来解释方法区中如何将指令执行和字节码对应起来，真正的JVM运行方式比这复杂得多。不过这样很容易理解方法区到底是怎么一回事。</p>'},380:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<p><a href="https://www.chkui.com/article/spring/spring_core_bean_post_processors" title="Spring核心——IOC处理器扩展">上一篇文章</a>介绍了非侵入式的框架的概念以及IOC的功能扩展点之一——BeanPostProcessor，我们接下来的内容继续说明IoC更多的扩展方法。\n</p>\n\n<h2 id="h2-1">BeanFactoryPostProcessor</h2>\n<p>BeanFactoryPostProcessor是针对整个容器的后置处理器。他的使用也非常简单，只要向容器中添加一个继承BeanFactoryPostProcessor的Bean即可。</p>\n\n<h3 id="h3-1">如何使用</h3>\n<p>继承了BeanFactoryPostProcessor接口的类PostProcessors：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.xml.beanfactorypostprocessor;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">PostProcessors</span> <span class="code-keyword">implements</span> <span\n            class="code-title">BeanFactoryPostProcessor</span></span>{\n<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span\n            class="code-keyword">throws</span> BeansException </span>{\n         <span class="code-comment">//DO</span>\n    }\n}</code></pre>\n<p>然后再向容器中添加这个Bean就增加了一个BeanFactoryPostProcessor。</p>\n<pre><code class="xml"><span class="php"><span class="code-meta">&lt;?</span>xml version=<span\n        class="code-string">"1.0"</span> encoding=<span class="code-string">"UTF-8"</span><span\n        class="code-meta">?&gt;</span></span>\n<span class="code-comment">&lt;!-- xml.beanfactorypostprocessor --&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">beans</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"chkui.springcore.example.xml.beanfactorypostprocessor.PostProcessors"</span> /&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>BeanFactoryPostProcessor主要用于处理容器相关的内容，他被触发时机是在IoC容器加载完各种配置后，还没执行Bean的初始化之前。这个时候除了PostProcessors这个Bean，其他任何Bean都没有被创建。&nbsp;所以在BeanFactoryPostProcessor处理Bean是不合适的，Bean应该要到BeanPostProcessor中去处理，2者的区别就是前者面向容器，后者面向Bean。接下来将通过一个详细例子来说明BeanFactoryPostProcessor和BeanPostProcessor的区别以及使用方式。期间还会介绍BeanDefinitio相关的内容。</p>\n\n<h3 id="h3-2">BeanFactoryPostProcessor与BeanPostProcessor使用</h3>\n<p><span style="color:#e74c3c">（文中仅仅是示例代码，无法运行，源码在</span><a href="https://gitee.com/chkui-com/spring-core-sample"\n                                                            rel="nofollow"><span style="color:#e74c3c">https://gitee.com/chkui-com/spring-core-sample</span></a><span\n        style="color:#e74c3c">，如需下载请自行clone）</span></p>\n\n<h4 id="h4-1"><span style="color:null">建造者模式</span></h4>\n<p>下面将会通过一个例子介绍2者的使用方式和使用场景。例子使用建造者模式模拟组装一台个人电脑，分为一下3步：</p>\n<ol>\n    <li>&nbsp;容器启动之后，会将电脑的所有“配件”（Cpu、Graphics、Ram）都添加到容器中。</li>\n    <li>&nbsp;在PostProcessorS实现BeanFactoryPostProcessor接口，它的功能是向容器添加一个Pc对象。</li>\n    <li>&nbsp;在PostProcessor实现BeanPostProcessor接口。他的工作是组装电脑——每一个Bean都会检查域上的@Autowired注解，并注入对应的部件，部件也会标记自己所属的电脑。</li>\n</ol>\n<p>下面是XML配置文件，它负责将Cpu、显卡、内存等电脑常用品牌的部件放置到容器中等待组装。此外它还添加了PostProcessorS和PostProcessor两个后置处理器用于装载电脑。</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"chkui.springcore.example.xml.beanfactorypostprocessor.bean.Cpu"</span>&gt;</span>\n     \t<span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"brand"</span> <span class="hljs-attr">value</span>=<span\n                class="code-string">"Amd"</span>/&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n    \n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"chkui.springcore.example.xml.beanfactorypostprocessor.bean.Graphics"</span>&gt;</span>\n     \t<span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"brand"</span> <span class="hljs-attr">value</span>=<span class="code-string">"Nvdia"</span>/&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n    \n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"chkui.springcore.example.xml.beanfactorypostprocessor.bean.Ram"</span>&gt;</span>\n     \t<span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"brand"</span> <span class="hljs-attr">value</span>=<span class="code-string">"Kingston"</span>/&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n    \n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"chkui.springcore.example.xml.beanfactorypostprocessor.PostProcessor"</span> /&gt;</span>\n    \n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"chkui.springcore.example.xml.beanfactorypostprocessor.PostProcessors"</span> /&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>下面是一个Cpu对象的结构，他标记了品牌和所属电脑。Graphics和Ram的结构和它一模一样。</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.xml.beanfactorypostprocessor.bean;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Cpu</span> </span>{\n\t<span class="code-keyword">private</span> String brand;\n\t\n\t<span class="code-meta">@Autowired</span>\n\t<span class="code-keyword">private</span> Pc belong;\n}</code></pre>\n<p>注意这里的@Autowired注解，我们的配置文件并没有开启Spring的自动装配功能，我们将在PostProcessor实现自动装配。</p>\n<p>PostProcessorS的作用是向容器动态添加一个之前未定义的Bean——Pc。</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.xml.beanfactorypostprocessor;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">PostProcessors</span> <span class="code-keyword">implements</span> <span\n            class="code-title">BeanFactoryPostProcessor</span></span>{\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span\n            class="code-keyword">throws</span> BeansException </span>{\n\t\t<span class="code-comment">//获取容器的注册接口</span>\n\t\tBeanDefinitionRegistry registry = (BeanDefinitionRegistry)beanFactory;\n\t\t<span class="code-comment">//新建一个BeanDefinition用于动态装配Bean</span>\n\t\tGenericBeanDefinition defininition = <span class="code-keyword">new</span> GenericBeanDefinition();\n\t\t<span class="code-comment">//设置要添加的类</span>\n\t\tdefininition.setBeanClass(Pc.class);\n\t\t<span class="code-comment">//注册BeanDefinition</span>\n\t\tregistry.registerBeanDefinition(<span class="code-string">"postBean"</span>, defininition);\n\t}\n}</code></pre>\n<p>如果看过 <a href="https://www.chkui.com/article/spring/spring_core_context_and_ioc" title="Spring核心——上下文与IoC">Ioc结构介绍的这篇文章</a>，你就会知道BeanFactory经过层层派生，实际上大部分接口都在一个类实现——DefaultListableBeanFactory，它除了实现ConfigurableListableBeanFactory接口，还实现了BeanDefinitionRegistry接口。BeanDefinitionRegistry提供了BeanDefinition的管理功能。\n</p>\n\n<h4 id="h4-2">BeanDefinition与适配器模式</h4>\n<p>\n    在上面的代码中出现了BeanDefinition接口，这里就顺道说一说这个有趣的小玩意。关于他如何使用Spring的官网并没有太详细的介绍（至少我没找到），网上倒是有各路大神的博客在解读他的源码，不过代码只是表象，要理解他的整套设计思路才能提升。</p>\n<p>关于BeanDefinition的使用模式，官网将其称呼为<em>configuration metadata</em>，直译过来叫“配置元数据”。&nbsp;他的作用有点类似于<a\n        href="https://www.chkui.com/article/spring/spring_core_context_and_ioc" title="Spring核心——上下文与IoC">Context分层应用的效果（见Spring核心——上下文与IoC&nbsp;关于\n    ApplicationContext的说明）</a>，目的就是将Bean的配置和初始化工作分成2个互不干扰的部分。</p>\n<p>我们知道 Spring现在支持各种各样的方式来添加Bean，比如在XML配置文件中使用&lt;bean&gt;标签、使用@Component以及他的派生类注解、可以在@Configuration类中生成、甚至还可以通过RMI实现远程配置等等。如果所有的这些配置来源直接和IoC容器产生关系生成Bean，那么耦合度、代码复杂度会越来越高，而且以后指不定什么时候又会加入什么新的配置方式。</p>\n<p>\n    为了解决这个问题Spring的大神们引入了适配器模式——IoC容器只接受BeanDefinition接口，IoC如何初始化一个Bean是仅仅是看BeanDefinition里的信息。而各种配置方式都有自己的适配器，所有的适配器都会根据他所需要处理的内容来生成一个BeanDefinition的实现类。这样，如果新增一个新的配置方式，增加一个适配器就可以搞定。</p>\n<p><img align="left" alt="Spring核心——IOC功能扩展点" height="381"\n        src="https://file.mahoooo.com/res/file/spring_core_ioc_extension_points.png" width="600"></p>\n<p>所以，我们也可以利用BeanDefinitionRegistry接口向容器添加一个BeanDefinition，进而在随后的执行过程中IoC容器会根据 这个BeanDefinition创建一个对应的Bean。</p>\n<h4 id="h4-3">BeanPostProcessor</h4>\n<p>\n    前面已经提到，BeanFactoryPostProcessor用于处理容器级别的问题，而BeanPostProcessor用来处理每一个Bean。我们前面已经用BeanFactoryPostProcessor向容器添加了一个Pc对象的Bean，接下来我们在BeanPostProcessor中处理每一个Bean的自动注入注解。</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.xml.beanfactorypostprocessor;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">PostProcessor</span> <span class="code-keyword">implements</span> <span\n            class="code-title">BeanPostProcessor</span>, <span class="code-title">BeanFactoryAware</span> </span>{\n\t<span class="code-keyword">private</span> ConfigurableListableBeanFactory beanFactory;\n\t<span class="hljs-function"><span class="code-keyword">public</span> Object <span class="code-title">postProcessBeforeInitialization</span><span\n            class="hljs-params">(Object bean, String beanName)</span> </span>{\n        <span class="code-keyword">return</span> autowiredImplement(bean);\n    }\n\t<span class="hljs-function"><span class="code-keyword">public</span> Object <span class="code-title">postProcessAfterInitialization</span><span\n            class="hljs-params">(Object bean, String beanName)</span> </span>{\n        <span class="code-keyword">return</span> bean;\n    }\n\t\n\t<span class="code-comment">//自定义实现autowired功能</span>\n\t<span class="hljs-function"><span class="code-keyword">private</span> Object <span class="code-title">autowiredImplement</span><span\n            class="hljs-params">(<span class="code-keyword">final</span> Object bean)</span> </span>{\n\t\t<span class="code-keyword">for</span>(Field field : bean.getClass().getDeclaredFields()) {\n\t\t\tAutowired value = field.getAnnotation(Autowired.class);\n\t\t\t<span class="code-keyword">if</span>(<span class="code-keyword">null</span> != value) {\n\t\t\t\tObject obj = beanFactory.getBean(field.getType());\n\t\t\t\tfield.setAccessible(<span class="code-keyword">true</span>);\n\t\t\t\tfield.set(bean, obj);\n\t\t\t}\n\t\t}\n\t\t<span class="code-keyword">return</span> bean;\n\t}\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setBeanFactory</span><span class="hljs-params">(BeanFactory beanFactory)</span> <span\n            class="code-keyword">throws</span> BeansException </span>{\n\t\t<span class="code-keyword">this</span>.beanFactory = (ConfigurableListableBeanFactory)beanFactory;\n\t}\n}</code></pre>\n<p>这里的PostProcessor实现BeanFactoryAware接口来获取&nbsp;BeanFactory。自动注入的处理逻辑都在autowiredImplement方法中，它会扫描Bean的每一个域检查是否有@Autowired注解，如果有则根据这个域的Class类型到BeanFactory去获取对应的Bean，然后反射注入。</p>\n<p>最后我们创建一个ApplicationContext来运行他们：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">SampleApp</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n    \tApplicationContext context = <span class="code-keyword">new</span> ClassPathXmlApplicationContext(<span\n            class="code-string">"xml/beanfactorypostprocessor/config.xml"</span>);\n    \tPc pc = context.getBean(Pc.class);\n        <span class="code-comment">/**\n        Pc Info: Graphics=Nvdia, Cpu=Amd, Ram=Kingston]\n        */</span>\n        System.out.println(pc);\n    }\n}</code></pre>\n<p>本文介绍了BeanFactoryPostProcessor和BeanPostProcessor的使用方式，以及IoC容易是如何通过BeanDefinition装载各种配置的。后续还会持续介绍Spring\n    IoC容器的各种功能扩展点。</p>'}});