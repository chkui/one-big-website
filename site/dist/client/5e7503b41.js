webpackJsonp([5],{378:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<h2 id="h2-1">JSR-175与元编程</h2>\n<p>要说明JSR-250先要解释清楚JSR-175，要解释清楚JSR就的先了解JCP是什么。网上资料很多，就不细说了，简单的说JCP（Java Community\n    Process）是管理Java生态（包括J2SE、J2EE等等）发展的合作组织。JSR（Java Specification\n    Request）就是组织内的成员针对Java的发展提出的一些需求，通过审核之后即会融入到新版本的Java功能中成为Java的一项特性或功能，不同的发行版本和虚拟机都会遵守这些约定。</p>\n<p>JSR-175的全文标题是<strong><span style="color:null">&nbsp;A Metadata Facility for the Java&nbsp;Programming Language （为Java语言提供元数据设施）</span></strong>。它明确提出了在Java平台引入“元编程”（Meta\n    Programming）的思想，要求提供对“元数据”（Meta Data）的支持。这就是我们现在大量使用的“@”注解（Annotation）功能的最早来源。JSR-175之后的JSR-181（Web服务支持）、JSR-250、<a\n            href="https://www.chkui.com/article/java/java_jsr330" title="JSR-330">JSR-330</a>都是基于“元数据”功能提出的一些更细节的实现。</p>\n<p>至于“元编程”、“元数据”是什么这里就不详细展开说明了，它的理论很早就提出了，据说最早是在Lisp这一类函数式编程语言上开始使用的。网上有很多相关的资料，简单的说它就是“对源码进行编码”，比如下面这样：</p>\n<pre><code class="java"><span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MyClass</span> </span>{\n\t<span class="code-meta">@Autowired</span>\n\t<span class="code-keyword">private</span> Interface support;\n}</code></pre>\n<p>通过@Autowired这个注解来对support这个域进行编码就可以很轻松的扩展原先类的功能。</p>\n\n<h2 id="h2-2">JSR-250的Spring实现</h2>\n<p>JSR-250主要是围绕着“资源”的使用预定义了一些注解（Annotation）,这里的“资源”可以理解为一个Class类的实例、一个JavaBean、或者一个Spring中的Bean。</p>\n<p>JSR-250相关的注解全部在 <em>javax.annotation</em> 和 <em>javax.annotation.security </em>包中，分成2个部分——资源定义和权限控制。它并没有提供具体的实现方式，仅仅是提供了指导性的文档和几个注解，由具体的框架去实现。\n</p>\n<p><em>javax.annotation</em> 中包含一下几个注解：</p>\n<ul>\n    <li>@Generated：生成资源的注解，通过该项标记产生的实例是一个资源。类似于Spring中的@Bean注解，用于生成一向资源。</li>\n    <li>@PostConstruct&nbsp;创造资源之后的回调处理，Spring已经实现了这个注解，见<a\n            href="https://www.chkui.com/article/spring/spring_core_bean_lifecycle_callback"\n            title="Bean的定义与控制">Bean的定义与控制</a> 一文的介绍。\n    </li>\n    <li>@PreDestroy&nbsp;销毁资源之前的回调处理，Spring同样实现了这个注解，见<a\n            href="https://www.chkui.com/article/spring/spring_core_bean_lifecycle_callback"\n            title="Bean的定义与控制">Bean的定义与控制</a>。\n    </li>\n    <li>@Resource&nbsp;标记使用资源的位置，Spring同样实现了这个注解的功能（后文会详细介绍）。功能上有些类似于@Autowired、@Inject，但是两者有不少的差别。</li>\n    <li>@Resources&nbsp;标记使用多项资源的位置，类似于使用@Autowired向一个列表装载数据。</li>\n</ul>\n<p>仔细看JSR-250定义的这些注解就会发现，他们都是关于“资源”的构建、销毁、使用的。Spring实现了@PostConstruct、@PreDestroy和@Resource。</p>\n<p>javax.annotation.security&nbsp;包中有以下内容：</p>\n<ul>\n    <li>@DeclareRoles&nbsp;声明角色</li>\n    <li>@DenyAll&nbsp; 拒绝所有角色</li>\n    <li>@PermitAll&nbsp; 授权所有惧色</li>\n    <li>@RolesAllowed&nbsp; 角色授权</li>\n    <li>@RunAs 运行模式</li>\n</ul>\n<p>security中的内容是在资源创建之后对<strong><em>资源的使用进行管理</em></strong>。和常规的权限控制模型一样——定义角色（@DeclareRoles&nbsp;）、确定角色对资源的控制权限（@DenyAll、@PermitAll\n    、@RolesAllowed&nbsp;）。Spring并没有实现这里的任何一个注解，在这里就不深入介绍了。这一块内容在J2EE的构建中有不少的应用。</p>\n\n<h2 id="h2-3">Spring中的@Resource</h2>\n<p>\n    在没有仔细看Spring的官方文档和JSR-250之前，我一直以为@Resource这个注解和@Autowired是2个不同的功能，更早的时候还以为是管理什么Properties资源的，很多网上的内容也写得比较模糊。虽然@Resource的实现是在\n    <em>CommonAnnotationBeanPostProcessor</em>&nbsp;而@Autowired 是在\n    AutowiredAnnotationBeanPostProcessor，但是实际上两者的功能是重叠的，或者说@Resource的提供的功能是@Autowired的子集。</p>\n<p>在Spring中使用@Resource注解时，把Bean理解为一项资源就很好理解了。下面通过一些简单的例子来介绍@Resource的使用。</p>\n<p>@Resource的功能是告诉IoC容器标记的位置需要什么样的“资源”，如下：</p>\n<pre><code class="java"><span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">Abc</span> </span>{}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">Xyz</span> </span>{}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">Implement</span> </span>{\n\t<span class="code-meta">@Resource</span>\n\t<span class="code-keyword">private</span> Abc abc;\n\t\n\t<span class="code-keyword">private</span> Xyz xyz;\n\n    <span class="code-meta">@Resource</span>\n    <span class="code-keyword">private</span> ApplicationContext context;\n\n\t<span class="code-meta">@Resource</span>(name=<span class="code-string">"b_instance"</span>)\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setInject</span><span class="hljs-params">(Xyz xyz)</span> </span>{\n\t\t<span class="code-keyword">this</span>.xyz = xyz;\n\t}\n}</code></pre>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">context:annotation-config</span>/&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n            class="code-string">"abc"</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"x.y.Abc"</span> /&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n            class="code-string">"xyz_instance"</span> <span class="hljs-attr">name</span>=<span class="code-string">"inject"</span> <span\n            class="hljs-attr">class</span>=<span class="code-string">"x.y.Xyz"</span> /&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"x.y.Implement"</span> /&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>\n    运行后，IoC会向标记了@Resource的位置注入Bean——是不是感觉和@Autowired一模一样？但是需要注意的是虽然两者最后都是注入一个Bean，但是@Resource和@Autowired的处理过程是不一样的。@Autowired如果没有提供任何参数，那么他优先按照类型注入，如果要对细节进行控制可以配合Primary和Qualifiers功能，详见<a\n        href="https://www.chkui.com/article/spring/spring_core_auto_inject_of_annotation" title="注解自动装载">注解自动装载</a>的介绍。@Resource是按照命名来注入资源的，以上面的代码为例子：\n</p>\n<ol>\n    <li>例如在setter方法上定义了name="xyz_instance"参数，那么会去IoC容器中寻找id、name等于"xyz_instance"的Bean来注入。</li>\n    <li>例如在abc这个域（成员变量）上没有定义name参数，那么会使用域的名称（这里是"abc"）去IoC中按id、name寻找Bean来注入。</li>\n    <li>如果@Resource定义在方法上，并且没有指定name参数，那么他会使用setter的名称（例子中方法名为setInject，名称就是"inject"）来寻找并注入数据。</li>\n    <li>最后，如果名称匹配不上，容器会根据标记位置的类型来注入数据，例如例如中的ApplicationContext。</li>\n</ol>\n<p>所以@Resource的装载资源过程是：1)匹配name参数；2)没有name参数时会根据setter或域的名称来匹配Bean的名称；3)还是匹配不上就根据标记位置的类型来注入数据。</p>\n<p>与@Autowired相比主要有以下几点区别：</p>\n<ol>\n    <li>控制粒度没有@Autowired细，某些参数Spring并没有实现功能。但是使用他更符合整个Java生态的规范。</li>\n    <li>如果是使用类型依赖注入数据，应优先使用@Autowired，效率会好一些。</li>\n    <li>@Resource通过名称注入与@Autowired相比省去了@Qualifiers等内容。</li>\n    <li>@Resource只能用在域和Setter方法上。</li>\n</ol>\n<p>总的来说如果是按照类型注入依赖对象，那么最终得到的结果并没有任何差异，只是执行过程上有差别。如果按Bean的名称使用，@Resource比@Autowired便捷一些，但是功能少很多。</p>\n<p>个人建议如果开发的是一个面向终端用户的应用，比如Web应用、网站什么的，直接用@Autowired就好了。如果制作的是一个给别的开发人员使用的工具，可以考虑@Resourec，他能得到更多框架的支持。</p>\n\n<h2 id="h2-4">@PostConstruct 与@PreDestroy</h2>\n<p>@PostConstruct 与@PreDestroy也是JSR-250中定义的注解，Spring都实现了他们的功能，使用方法可以查看<a\n        href="https://www.chkui.com/article/spring/spring_core_bean_lifecycle_callback" title="Bean的定义与控制">Bean的定义与控制</a>&nbsp;相关的说明和介绍。\n</p>'},392:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<h2 id="h2-1">一切从配置开始</h2>\n<p>在<a href="https://www.chkui.com/article/vertx/micro_service_index">微服务架构概念索引</a>一文中介绍了整个云源生应用的搭建体系，后续的内容将会从Spring\n    Cloud从技术架构，到基础设置再到团队协作方式一点一滴的记录搭建整个云服务的过程。现在从最基本的中心化配置开始介绍。</p>\n<p>Spring基金会项目繁多、种类各异，但是他们都脱离不了一个基本的要求——基于<a\n        href="https://www.chkui.com/article/spring/spring_annotation_of_xml_configuration">Spring Ioc的配置</a>。Spring的基础在于IoC容器，各种各样的项目都在IoC容器的基础之上扩展而来。在<a\n        href="https://www.chkui.com/article/spring/spring_core_design_pattern_and_ioc">设计模式与IoC</a>中已经介绍了IoCs的目的就是解决数据与Bean的关系、以及Bean与Bean之间的关系。\n</p>\n<h2 id="h2-2">Spring Cloud 中心化配置</h2>\n<p>在单Jvm的Spring应用中各种配置文件都是通过<a\n        href="https://www.chkui.com/article/spring/spring_core_environment_management_of_profile">Profile</a>结合<a\n        href="https://www.chkui.com/article/spring/spring_core_properties_management">PropertySource</a>进行管理，而到了<a\n        href="https://www.chkui.com/article/spring/spring_features_configuration">Spring Boot</a>则提供了大量的默认配置简化了这个过程。而在Spring\n    Cloud中需要管理大量的节点，中心化配置的需求随之而产生。</p>\n<p>Spring\n    Cloud的中心化配置并没有什么特别神奇的地方，实际上就是把本该放到本地的配置文件（例如application.yml）统一放置到一个仓库中。然后用一个Web服务来管理仓库，其他微服务节点从这个Web服务获取配置文件。所以就算没有Spring\n    Cloud Config提供这个功能，我们也可以自己编码在ApplicationContext的启动装载IoC之前先处理好配置。</p>\n<p>在假设有别的Spring Cloud知识之前，本文介绍不使用Netflix和Eureka注册服务的来管理中心化配置的方法。</p>\n<p><img src="http://file.mahoooo.com/res/file/2019-04-10-spring-cloud-config-struts.png" alt="Spring云源生应用-中心化配置"\n        title="配置服务结构" class="zoom-in-cursor"></p>\n<p>上图是Spring Cloud Config的基本结构。左侧是一系列的微服务节点，右侧是他们对应的配置文件。例如Node-1服务对应的是<em>node-1-config.yml</em>文件，在单一的应用中本来<em>node-1-config.yml</em>文件应该是放置在Node-1工程的classpath下的，现在的区别是将他们分开，将配置文件统一放置到一个仓库中，然后用Config-Service来管理。\n</p>\n<p>中心化配置就是这么简单，除了把配置文件拆走其他的使用方式完全一样，可以通过<a\n        href="https://www.chkui.com/article/spring/spring_core_properties_management">PropertySources或@Value注解</a>来获取配置的参数。\n</p>\n<p>至于中心化配置有什么好处就不用一一细说了，除了在负载均衡中减少配置之外，也便于环境管理等等。</p>\n<h2 id="h2-3">启用中心化配置</h2>\n<p>清楚原理之后做事就简单了，案例代码一共包含三个工程（<a\n        href="https://github.com/chkui/spring-cloud-samples/tree/master/configuration">github源码</a>），分别是<em>configuration-server</em>、<em>configuration-node-1</em>和<em>configuration-node-2</em>。configuration-server就是图中的Config-Service，他为所有的微服务节点提供中心化配置服务，所有的配置都在独立的<a\n        href="https://github.com/chkui/spring-cloud-repo">git仓库中</a>，在某个微服务节点请求配置数据的时候，<em>configuration-server</em>会去仓库中获取对应的配置并传输给微服务节点。\n</p>\n<h3 id="h3-1">Config Service</h3>\n<p>Spring Cloud的中心化配置服务通过Http请求提供配置管理服务，所以他自身也是一个Web。要启用的配置服务就2步：1.写一个配置文件指定服务端口和配置文件仓库，2.启动Spring Web服务。</p>\n<p>下面<code>application.yml</code>指定了中心化服务的端口（8888），然后指定了配置文件的Git仓库。配置文件的仓库可以是本地文件夹、可以是git仓库或者其他任何形式，这里以Git作为例子。</p>\n<pre><code class="yaml makefile"><span class="code-comment"># application.yml</span>\n<span class="code-section">server:</span>\n  port: 8888\n\n<span class="code-section">spring:</span>\n  cloud:\n    config:\n      server:\n        git:\n          uri:  https://github.com/chkui/spring-cloud-repo\n</code></pre>\n<p>配置好之后启动Web服务：</p>\n<pre><code class="java"><span class="code-comment">// chkui.spring.cloud.config.ConfigServiceApplication</span>\n\n<span class="code-meta">@EnableConfigServer</span> <span class="code-comment">//表示这是一个Configuration 服务</span>\n<span class="code-meta">@SpringBootApplication</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">ConfigServiceApplication</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tSpringApplication.run(ConfigServiceApplication.class, args);\n\t}\n}\n</code></pre>\n<p>启动web并没有任何特别之处，像个普通的Spring Boot工程启动即可。</p>\n<h3 id="h3-2">Client Node</h3>\n<p>有了中心化服务之后自然是要使用它。也仅仅需要2步：1.配置微服务，2.启动微服务。配置内容如下：</p>\n<pre><code class="yaml shell"><span class="code-meta">#</span><span class="bash"> bootstrap.yml</span>\nspring:\n  application:\n    name: node-config-1\n  cloud:\n    config:\n      uri: http://localhost:8888\n</code></pre>\n<p>访问中心化配置的参数主要就2个：1.指定配置文件名称、2.指定中心化服务器的地址与端口。</p>\n<p>\n    <strong>切记使用中心化配置时，像上面这个与服务器相关的配置要写到<code>bootstrap.yml</code>中，这样才能在访问远程配置之前先获取远程服务器的参数。写到<code>application.yml</code>里会导致永远都使用默认参数</strong>。\n</p>\n<p>配置文件的名称要与<a href="https://github.com/chkui/spring-cloud-repo">配置仓库</a>中的文件名对应。下面是<em>configuration-node-1</em>对应的配置文件的内容：\n</p>\n<pre><code class="yaml makefile"><span class="code-comment"># https://github.com/chkui/spring-cloud-repo/blob/master/node-config-1.yml</span>\n<span class="code-section">server:</span>\n  port: 9081 <span class="code-comment">#配置node-1端口</span>\n<span class="code-section">message: Response Node Client1 With WebFlux(Netty)! #配置message参数。</span>\n</code></pre>\n<p>下面是<em>configuration-node-1</em>中的主要代码：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.spring.cloud.config;\n<span class="code-comment">//import 省略</span>\n\n<span class="code-meta">@SpringBootApplication</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">ConfigClientApplication1</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n        SpringApplication.run(ConfigClientApplication1.class, args);\n    }\n}\n\n<span class="code-meta">@RestController</span>\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MessageRestController</span> </span>{\n\n    <span class="code-comment">//通过@Value注解获取中心化配置的参数</span>\n    <span class="code-meta">@Value</span>(<span\n            class="code-string">"${message:Configuration Server Error(Node-1)}"</span>)\n    <span class="code-keyword">private</span> String message;\n\n    <span class="code-meta">@RequestMapping</span>(<span class="code-string">"/message"</span>)\n    <span class="hljs-function">Mono&lt;String&gt; <span class="code-title">getMessage</span><span class="hljs-params">()</span> </span>{\n        <span class="code-keyword">return</span> Mono.just(<span class="code-keyword">this</span>.message);\n    }\n}\n</code></pre>\n<p><em>configuration-node-1</em>用spring-boot启动了一个WebFlux，这个时候访问 <a href="http://localhost:9081/message">http://localhost:9081/message</a>\n    会返回配置文件中的信息：<em>Response Node Client1 With WebFlux(Netty)!</em>。</p>\n<h2 id="h2-4">动态刷新</h2>\n<p>可以在不重启微服务节点的情况下更新配置参数，这在某些场景下非常意义。刷新配置参数主要是使用了<code>ConfigurableApplicationContext</code>的<code>refresh</code>接口，不过Spring\n    Cloud整合了Actuator功能直接外部调用接口即可。</p>\n<p><em>configuration-node-2</em>中的代码演示了这个过程：</p>\n<p>首先需要引入<code>spring-boot-starter-actuator</code>:</p>\n<pre><code class="groovy javascript">dependencies {\n\tcompile(<span class="code-string">\'org.springframework.cloud:spring-cloud-starter-config\'</span>)\n\tcompile(<span class="code-string">\'org.springframework.boot:spring-boot-starter-actuator\'</span>) <span\n            class="code-comment">//引入actuator</span>\n\tcompile(<span class="code-string">\'org.springframework.boot:spring-boot-starter-web\'</span>)\n}\n</code></pre>\n<p>然后在Controller层增加*@RefreshScope*注解：</p>\n<pre><code class="java"><span class="code-meta">@SpringBootApplication</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">ConfigClientApplication2</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tSpringApplication.run(ConfigClientApplication2.class, args);\n    }\n}\n\n<span class="code-meta">@RefreshScope</span>\n<span class="code-meta">@RestController</span>\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MessageRestController</span> </span>{\n    <span class="code-meta">@Value</span>(<span\n            class="code-string">"${message:Configuration Server Error(Node-2)}"</span>)\n    <span class="code-keyword">private</span> String message;\n\n    <span class="code-meta">@RequestMapping</span>(<span class="code-string">"/message"</span>)\n    <span class="hljs-function">String <span class="code-title">getMessage</span><span\n            class="hljs-params">()</span> </span>{\n        <span class="code-keyword">return</span> <span class="code-keyword">this</span>.message;\n    }\n}\n</code></pre>\n<p>最后在本地配置参数中暴露Actuator的接口：</p>\n<pre><code class="yaml php"><span class="code-comment">#</span>\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        <span class="code-keyword">include</span>: <span class="code-string">\'*\'</span>\n</code></pre>\n<p>现在就可以通过Actuator暴露的接口来更新配置参数——Post访问 <code>localhost:9082/actuator/refresh</code>：</p>\n<pre><code class="bash">curl localhost:9082/actuator/refresh -d {} -H <span class="code-string">"Content-Type: application/json"</span>\n</code></pre>\n<p>到了Spring Boot 2.×之后Actuator默认关闭所有Web服务接口。这里仅仅是说明有这个功能，通常不会使用Web暴露接口的方式来操作。如下图，Spring Boot和Spring\n    Cloud已经暴露了大量的MBean，通常会使用JMX来管理和监控服务状态。\n    <img src="http://file.mahoooo.com/res/file/2019-04-11-spring-cloud-config-mbeans.png" alt="Spring云源生应用-中心化配置"\n         title="Spring Cloud MBeans" class="zoom-in-cursor"></p>\n<p>所以如果要使用 配置刷新 等功能建议使用<code>Spirng Boot Admin</code>或者其他基于JMX的管理工具来操作。</p>\n<h2 id="h2-5">配置说明</h2>\n<h3 id="h3-3">服务端</h3>\n<p>启用必要配置：</p>\n<ol>\n    <li>引入<code>spring-cloud-config-server</code>。</li>\n    <li>设置服务端口：<code>server.port</code></li>\n    <li>设置仓库地址：<code>spring.cloud.config.server.git.uri</code>，仓库类型可以有很多种。</li>\n</ol>\n<p>更多配置：</p>\n<ol>\n    <li><code>spring.cloud.config.server.git.timeout</code><a\n            href="https://cloud.spring.io/spring-cloud-config/spring-cloud-config.html#_setting_http_connection_timeout"\n            title="可以设置访问仓库的超时时间（秒）">可以设置访问仓库的超时时间（秒）</a>。\n    </li>\n    <li><code>spring.cloud.config.server.git.uri</code><a\n            href="https://cloud.spring.io/spring-cloud-config/spring-cloud-config.html#_placeholders_in_git_uri"\n            title="可以使用`{application}`、`{profile}`等占位符">可以使用<code>{application}</code>、<code>{profile}</code>等占位符</a>。用于复杂的仓库管理。\n    </li>\n    <li>占位符可以配合使用通配符和正则表达式来解决更复杂的配置问题：<a\n            href="https://cloud.spring.io/spring-cloud-config/spring-cloud-config.html#_pattern_matching_and_multiple_repositories"\n            title="参考资料">详细</a>。\n    </li>\n    <li>通常git仓库都涉及到权限认证，可以用<a\n            href="https://cloud.spring.io/spring-cloud-config/spring-cloud-config.html#_authentication" title="HTTPS">HTTPS</a>或者<a\n            href="https://cloud.spring.io/spring-cloud-config/spring-cloud-config.html#_git_ssh_configuration_using_properties"\n            title="ssh-key">SSH-KEY</a>的方式解决。\n    </li>\n    <li><a href="https://cloud.spring.io/spring-cloud-config/spring-cloud-config.html#_force_pull_in_git_repositories"\n           title="`force-pull`参数可以强制更新本地仓库中的配置文件"><code>force-pull</code>参数可以强制更新本地仓库中的配置文件</a>。\n    </li>\n    <li><code>spring.cloud.config.server.git.repos</code>参数可以用于多项配置，用子目录来区分配置。</li>\n    <li><code>spring.cloud.config.server.git.refreshRate</code>可以控制服务器到仓库的更新频率。默认为0，表示只要有微服务请求了数据就会去远程仓库获取文件。</li>\n    <li><code>spring.cloud.config.server.git.basedir</code>用于配置远程文件下载本地的临时文件夹，默认使用操作系统的<code>/tmp</code>。</li>\n    <li>除了使用本文介绍的使用git作为配置文件仓库，还支持<a\n            href="https://cloud.spring.io/spring-cloud-config/spring-cloud-config.html#_file_system_backend"\n            title="本地文件系统">本地文件系统</a>、<a\n            href="https://cloud.spring.io/spring-cloud-config/spring-cloud-config.html#vault-backend" title="Vault">Vault</a>、<a\n            href="https://cloud.spring.io/spring-cloud-config/spring-cloud-config.html#_jdbc_backend"\n            title="数据库">数据库</a>、<a\n            href="https://cloud.spring.io/spring-cloud-config/spring-cloud-config.html#_redis_backend" title="Redis">Redis</a>、<a\n            href="https://cloud.spring.io/spring-cloud-config/spring-cloud-config.html#_credhub_backend"\n            title="CredHub">CredHub</a>等方式管理配置仓库。\n    </li>\n    <li>[可以同时使用git、svn等仓库](Composite Environment Repositories "可以同时使用git、svn等仓库")。</li>\n    <li><a href="https://cloud.spring.io/spring-cloud-config/spring-cloud-config.html#_property_overrides"\n           title="`spring.cloud.config.server.overrides`"><code>spring.cloud.config.server.overrides</code></a>用于配置通用属性，通过这个配置可以让所有的节点都获取这个属性。\n    </li>\n    <li><a href="https://cloud.spring.io/spring-cloud-config/spring-cloud-config.html#_security" title="安全管理">安全管理</a>用于在一些非独立的环境做中心化配置，比如配置服务器直接放置在外网。\n    </li>\n    <li>通常情况下会将Config Server作为一个独立的Web服务，但是也可以使用<code>spring.cloud.config.server.bootstrap</code>和``<a\n            href="https://cloud.spring.io/spring-cloud-config/spring-cloud-config.html#_embedding_the_config_server"\n            title="但是也可以把他嵌入别的系统中去">嵌入别的系统中去</a>。\n    </li>\n</ol>\n<h3 id="h3-4">客户端</h3>\n<ol>\n    <li>引入<code>spring-cloud-starter-config</code>。</li>\n    <li>在<code>bootstrap.yml</code>设置中心化配置服务地址：<code>spring.cloud.config.uri</code>。</li>\n    <li>在<code>bootstrap.yml</code>设置文件名：<code>spring.application.name</code>。</li>\n    <li>可以在<code>bootstrap.yml</code>设置profiles：<code>spring.profiles.active</code>。非必要</li>\n</ol>\n<h3 id="h3-5">配置仓库</h3>\n<ol>\n    <li>中心化配置文件同样支持<code>profile</code>特性，所以在仓库中具备以下命名规则：</li>\n</ol>\n<pre><code class="coffeescript"><span class="hljs-regexp">/{application}/</span>{profile}[/{label}]\n/{application}-{profile}.yml\n<span class="hljs-regexp">/{label}/</span>{application}-{profile}.yml\n/{application}-{profile}.properties\n<span class="hljs-regexp">/{label}/</span>{application}-{profile}.properties\n</code></pre>'},401:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<p>本文将解释如何在Windows下安装TensorFlow。</p>\n\n<h2 id="h2-1">确定安装哪类TensorFlow</h2>\n<p>需要先确定哪种类型的TensorFlow：</p>\n<ul>\n    <li><strong>仅支持CUP运算版本：</strong>如果电脑的系统没有&nbsp;NVIDIA®的GPU，那么必须安装这个版本。这个版本的TensorFlow安装非常简单（安装仅需一个命令，5到10分钟），所以即使系统中有满足要求的NVIDIA®\n        GPU官方还是建议在学习阶段安装这个版本。\n    </li>\n    <li><strong>支持GPU运算的版本：</strong>TensorFlow程序在GPU下运行比在CPU下运行明显快很多。如果系统中包含&nbsp;NVIDIA®的GPU满足下一个小节所示的条件并且程序对性能要求很高，建议安装此版本。\n    </li>\n</ul>\n\n<h2 id="h2-2">运行TensorFlow所需要的GPU配置</h2>\n<p>如果在系统中安装使用GPU运行的TensorFlow，需要确保下面介绍的NVIDIA软件已经安装到系统中。</p>\n<ul>\n    <li>CUDA® Toolkit 8.0。请看 <a\n            href="http://docs.nvidia.com/cuda/cuda-installation-guide-microsoft-windows/#axzz4eDEVDKkM" rel="nofollow">NVIDIA安装cuda</a>\n        的文档，根据文档中的描述确保已经将CUDA相关的路径增加到&nbsp;<code>%PATH%</code>&nbsp;环境变量中。\n    </li>\n    <li>NVIDIA的驱动关联&nbsp;CUDA Toolkit 8.0。</li>\n    <li>cuDNN v5.1。请查看 <a href="https://developer.nvidia.com/cudnn" rel="nofollow">NVIDIA&nbsp;cudnn</a>\n        文档。需要注意的是cuDNN通常安装在与其他CUDA动态链接库（dll）不同的位置。确保已经将cuDNN的 动态链接库（dll）的地址添加到系统的&nbsp;&nbsp;<code>%PATH%</code>&nbsp;环境变量中。\n    </li>\n    <li>GPU显卡必须拥有3.0以上版本的CUDA计算能力，查看 <a href="https://developer.nvidia.com/cuda-gpus" rel="nofollow">NVIDIA显卡支持列表</a>\n        了解支持情况。\n    </li>\n</ul>\n<p>如果系统中已经安装了以前的相关包，请更新到所指定的版本。</p>\n\n<h2 id="h2-3">如何安装TensorFlow</h2>\n<p>在安装TensorFlow之前必须选定一个安装机制。目前提供2种机制：</p>\n<ul>\n    <li>"native"app</li>\n    <li>Anaconda</li>\n</ul>\n<p>\n    Native的安装（以下简称本地安装）方式会将TensorFlow直接安装在当前的系统中，不会在系统和TensorFlow之间搭建任何的虚拟环境，所以本地安装不会额外安装一个独立的容器。需要注意的是本地安装可能会干扰系统中其他基于python安装的程序。如果事先已经安装配置了满足需要的python环境，本地安装通常只需要一个命令就可以完成。使用本地安装，用户可以在系统中任何位置运行TensorFlow。</p>\n<p>在Anaconda模式下，需要使用conda创建一个虚拟环境。官方优先推荐使用&nbsp;<code>pip install</code>&nbsp;命令来安装TensorFlow，其次再考虑anaconda的&nbsp;<code>conda\n    install</code>&nbsp;命令。conda包是第三方社区提供的（非TensorFlow官方），TensorFlow团队从始至终都不会去测试在conda中运行的情况，在使用时需考虑这个风险。</p>\n\n<h3 id="h3-1">本地安装</h3>\n<p>首先，需要安装以下版本的python：</p>\n<ul>\n    <li><a href="https://www.python.org/downloads/release/python-352/" rel="nofollow">Python 3.5.x from python.org</a>\n    </li>\n</ul>\n<p>TensorFlow在windows操作系统中仅仅支持3.5.x版本的python。Python 3.5.x附带pip3软件包管理器，这是用于安装TensorFlow的程序。</p>\n<p>安装TensorFlow需要启动一个终端（terminal），然后在该终端中输入对应的pip3 install命令。安装仅支持CPU版本的TensorFlow，输入以下命令：</p>\n<pre class="lua"><code class="language-bash">C:\\&gt; pip3 install <span class="code-comment">--upgrade tensorflow</span></code></pre>\n<p>安装GPU版本的TensorFlow，使用以下命令：</p>\n<pre class="lua"><code class="language-bash">C:\\&gt; pip3 install <span\n        class="code-comment">--upgrade tensorflow-gpu</span></code></pre>\n<p>Anaconda模式安装</p>\n<p><span style="color:#FF0000">再次强调，Anaconda安装是有第三方社区提供的，非官方。</span></p>\n<p>在Anaconda环境中安装TensorFlow分为以下几个步骤：</p>\n<ol>\n    <li>按照&nbsp;<a href="https://www.continuum.io/downloads" rel="nofollow">Anaconda download site</a>&nbsp;的说明进行下载和安装操作。\n    </li>\n    <li>调用以下命令来创建一个名为tensorflow的conda环境：\n        <pre class="groovy"><code class="language-bash"><span class="code-string">C:</span>&gt; conda create -n tensorflow </code></pre>\n        <p></p></li>\n    <li><p>键入以下命令来启用conda环境：</p>\n        <pre class="yaml"><code class="language-bash"><span class="hljs-attr">C:</span>&gt; activate tensorflow\n (tensorflow)C:&gt;  <span class="code-comment"><span\n                    class="code-comment"># Your prompt should change </span></span></code></pre>\n        <p></p></li>\n    <li><p>键入以下命令在conda环境中安装TensorFlow。这里 安装CPU版本的命令：</p>\n        <pre class="groovy"><code class="language-bash">(tensorflow)<span class="code-string">C:</span>&gt; pip install --ignore-installed --upgrade <span\n                class="code-string">https:</span><span class="code-comment">//storage.googleapis.com/tensorflow/windows/cpu/tensorflow-1.0.1-cp35-cp35m-win_amd64.whl </span>\n</code></pre>\n        <p>这是GPU版本的命令：</p>\n        <pre class="groovy"><code class="language-bash">(tensorflow)<span class="code-string">C:</span>&gt; pip install --ignore-installed --upgrade <span\n                class="code-string">https:</span><span class="code-comment">//storage.googleapis.com/tensorflow/windows/gpu/tensorflow_gpu-1.0.1-cp35-cp35m-win_amd64.whl </span></code></pre>\n        <p></p></li>\n</ol>\n\n<h3 id="h3-2">验证安装&nbsp;</h3>\n<ol>\n    <li>通过以下步骤来验证TensorFlow是否安装成功：</li>\n    <li>启动一个终端（比如CMD）</li>\n    <li>如果通过Anaconda安装，先启动Anaconda环境。</li>\n    <li>在终端运行python</li>\n    <li>\n        <pre class="groovy"><code class="language-bash"><span class="code-string">C:</span>&gt; python </code></pre>\n    </li>\n    <li>在python的交互环境中输入以下脚本代码：</li>\n    <li> <pre class="python"><code class="python"><span class="code-meta"><span\n            class="code-meta">&gt;&gt;&gt; </span></span><span class="code-keyword"><span\n            class="code-keyword">import</span></span> tensorflow <span class="code-keyword"><span class="code-keyword">as</span></span> tf\n\n\n\n\nhello = tf.constant(<span class="code-string"><span class="code-string">\'Hello, TensorFlow!\'</span></span>)\nsess = tf.Session()\nprint(sess.run(hello))\n </code></pre>\n        <p>如果python输出以下内容，则表明TensorFlow已经安装成功然后就可以写TensorFlow的程序了：</p></li>\n    <li>\n        <pre class=""><code class="language-bash">Hello, TensorFlow!</code></pre>\n        <p>如果收到了一些异常信息，请继续向下看。</p></li>\n</ol>\n\n<h3 id="h3-3">常见的安装问题</h3>\n<p>TensorFlow通过Stack Overflow网站来记录错误信息以及处理方法。下面的列表包含一些跳转的到&nbsp;Stack Overflow的连接。如果在安装过程中遇到的问题没有在下面中，请到Stack\n    Overflow去搜索相关的关键字。若还是搜索不到，请直接提出新问题并标记&nbsp;<code>tensorflow</code>&nbsp;的标签。</p>\n<table>\n    <tbody>\n    <tr>\n        <th>Stack Overflow Link</th>\n        <th>Error Message</th>\n    </tr>\n    <tr>\n        <td><a href="https://stackoverflow.com/q/41007279" rel="nofollow">41007279</a></td>\n        <td>\n            [...\\stream_executor\\dso_loader.cc] Couldn\'t open CUDA library nvcuda.dll\n        </td>\n    </tr>\n    <tr>\n        <td><a href="https://stackoverflow.com/q/41007279" rel="nofollow">41007279</a></td>\n        <td>\n            [...\\stream_executor\\cuda\\cuda_dnn.cc] Unable to load cuDNN DSO\n        </td>\n    </tr>\n    <tr>\n        <td><a href="http://stackoverflow.com/q/42006320" rel="nofollow">42006320</a></td>\n        <td>\n            ImportError: Traceback (most recent call last): File "...\\tensorflow\\core\\framework\\graph_pb2.py", line 6,\n            in from google.protobuf import descriptor as _descriptor ImportError: cannot import name \'descriptor\'\n        </td>\n    </tr>\n    <tr>\n        <td><a href="https://stackoverflow.com/q/42011070" rel="nofollow">42011070</a></td>\n        <td>\n            No module named "pywrap_tensorflow"\n        </td>\n    </tr>\n    </tbody>\n</table>'},402:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<h2 id="h2-1">TensorFlow入门</h2>\n<p>本文将初步向码农和程序媛们介绍如何使用TensorFlow进行编程。在阅读之前请先 <a href="https://www.chkui.com/article/tensorflow/tensorflow_windows_install" rel="nofollow">安装TensorFlow</a>，此外为了能够更好的理解本文的内容，阅读之前需要了解一点以下知识：\n</p>\n<ol>\n    <li>python基本编程。能看得懂python代码，最好能使用脚本工具或pycharm之类的IDC编写代码。</li>\n    <li>至少有一点数组的概念。</li>\n    <li>最理想的状态是具备机器学习的基础知识。不过如果在阅读之前没有了解过任何机器学习相关的知也无大碍，可以把本文作为了解机器学习的开端。后面会另开一篇用MNIST了解机器学习的基础知识。</li>\n</ol>\n<p>TensorFlow提供种类繁多的API接口，其中TensorFlow Core是最低层级的接口，为开发TensorFlow提供基础支持。官方推荐把TensorFlow\n    Core用作机器学习研究以及相关的数据建模。除了TensorFlow Core之外还有更高抽象的API接口，这些API接口比TensorFlow Core更易于使用、更易于快速实现业务需求。例如&nbsp;tf.contrib.learn\n    接口，它提供管理数据集合、进行数据评估、训练、推演等功能。在使用TensorFlow开发的过程中需要特别注意，以&nbsp;<code>contrib</code>&nbsp;开头的API接口依然还在不断完善中，很有可能在未来某个发行版本中进行调整或者直接取消。\n</p>\n<p>本文首先介绍TensorFlow Core，然后会演示如何使用&nbsp;tf.contrib.learn 实现简单的建模。了解TensorFlow\n    Core是为了让开发者理解在使用抽象接口时底层是如何工作的，以便于在训练数据时创建更合适的模型。</p>\n\n<h2 id="h2-2">TensorFlow</h2>\n<p>\n    TensorFlow的基础数据单元是张量（tensor）。一个张量认为是一组向量的集合，从数据结构的角度来理解这个集合等价于一组数值存储在1到多个队列中（张量没办法几句话说得清楚，想要了解去谷哥或者度妞搜索“张量分析”，可以简单想象成一个多维度的数组）。一个张量的阶表示了张量的维度，下面是一些张量的例子：</p>\n<blockquote> \n <pre class="lua"><code class="lua"><span class="hljs-number"><span class="hljs-number">3</span></span> # <span\n         class="hljs-number"><span class="hljs-number">0</span></span>阶张量，可以用图形[]来表示\n[<span class="hljs-number"><span class="hljs-number">1.</span></span> ,<span class="hljs-number"><span\n             class="hljs-number">2.</span></span>, <span class="hljs-number"><span class="hljs-number">3.</span></span>] # <span\n             class="hljs-number"><span class="hljs-number">1</span></span>阶张量，是一个图形为[<span class="hljs-number"><span\n             class="hljs-number">3</span></span>]的向量\n<span class="code-string"><span class="code-string">[[1., 2., 3.], [4., 5., 6.]]</span></span> # <span\n             class="hljs-number"><span class="hljs-number">2</span></span>阶张量，是一个图形为[<span class="hljs-number"><span\n             class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>]的矩阵\n<span class="code-string"><span class="code-string">[[[1., 2., 3.]]</span></span>, <span class="code-string"><span\n             class="code-string">[[7., 8., 9.]]</span></span>] # 图形为[<span class="hljs-number"><span\n             class="hljs-number">2</span></span>,<span class="hljs-number"><span\n             class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>]的三阶张量</code></pre>\n</blockquote>\n\n<h2 id="h2-3">TensorFlow Core教程</h2>\n\n<h3 id="h3-1">导入TensorFlow</h3>\n<p>下面是导入TensorFlow包的标准方式：</p>\n<pre class="haskell"><code class="language-python"><span class="code-keyword"><span\n        class="code-keyword">import</span></span> tensorflow <span class="code-keyword"><span\n        class="code-keyword">as</span></span> tf</code></pre>\n<p>通过python的方式导入之后，&nbsp;tf 提供了访问所有TensorFlow类、方法和符号的入口。</p>\n\n<h3 id="h3-2">图计算（Computational Graph）</h3>\n<p>TensorFlow Core的编程开发可以看就做2个事：</p>\n<ol>\n    <li>构建计算图。（建模）</li>\n    <li>运行计算图。（执行）</li>\n</ol>\n<blockquote>\n    <p>图（graph，也可以叫连接图）表示由多个点链接而成的图。本文中的图指的是TensorFlow建模后运算的路径，可以使用TensorBoard看到图的整个形态。</p>\n    <p>节点（node）表示图中每一个点，这些点都代表了一项计算任务。</p>\n</blockquote>\n<p><strong>所以简而言之</strong>：编程 <em>TensorFlow Core</em> 就是事先安排好一系列节点的计算任务，然后运行这些任务。</p>\n<p>\n    下面我们先构建一个简单的图，图中的节点（node）有0或多个张量作为输入，并产生一个张量作为输出。一个典型的节点是“常量”（constant）。TensorFlow的常量在构建计算模型时就已经存在，在运行计算时并不需要任何输入。下面的代码创建了2个浮点常量值常量&nbsp;<code>node1</code>&nbsp;和&nbsp;<code>node2</code>：\n</p>\n<pre class="go"><code class="language-python">node1 = tf.constant(<span class="hljs-number"><span class="hljs-number">3.0</span></span>, tf.<span\n        class="code-keyword">float32</span>)\nnode2 = tf.constant(<span class="hljs-number"><span class="hljs-number">4.0</span></span>) <span class="code-comment"># also tf.<span\n            class="code-keyword">float32</span> implicitly</span>\n<span class="code-built_in">print</span>(node1, node2)</code></pre>\n<p>运行后会打印输出：</p>\n<pre class="lisp"><code class="language-python">Tensor(<span class="code-string"><span\n        class="code-string">"Const:0"</span></span>, shape=(), dtype=float32) Tensor(<span class="code-string"><span\n        class="code-string">"Const_1:0"</span></span>, shape=(), dtype=float32)</code></pre>\n<p>观察这个打印的结果会发现，它并不是按照预想的那样输出 <em>3.0</em> 或<em> 4.0 </em>的值。这里输出的是一个节点的对象信息。因为到这里还没有执行第二项工作——运行计算模型图。只有在运行时，才会使用到节点真实的值\n    <em>3.0</em> 和<em>4.0</em>。为了进行图运算需要创建一个会话（session），一个会话封装了TensorFlow运行库的各种控制方法和状态量（context）。</p>\n<p>下面的代码会创建一个会话（session）对象实例，然后执行&nbsp;<code>run</code>&nbsp;方法来进行模型计算：</p>\n<pre class="lua"><code class="language-python">sess = tf.Session()\n<span class="code-built_in">print</span>(sess.run([node1, node2]))</code></pre>\n<p>运行后我们会发现，打印的结果是3.0和4.0：</p>\n<pre class="json"><code class="language-python">[<span class="hljs-number"><span class="hljs-number">3.0</span></span>, <span\n        class="hljs-number"><span class="hljs-number">4.0</span></span>]</code></pre>\n<p>\n    然后，对&nbsp;<code>node1</code>&nbsp;和&nbsp;<code>node2</code>&nbsp;进行和运算，这个和运算就是图中的运算模型。下面的代码是构建一个&nbsp;<code>node1</code>&nbsp;、&nbsp;<code>node2</code>&nbsp;进行和运算，&nbsp;<code>node3</code>&nbsp;代表和运算的模型，构建完毕后使用\n    <code>sess.run</code>&nbsp;运行：</p>\n<pre class="lua"><code class="language-python">node3 = tf.add(node1, node2)\n<span class="code-built_in">print</span>(<span class="code-string"><span class="code-string">"node3: "</span></span>, node3)\n<span class="code-built_in">print</span>(<span class="code-string"><span class="code-string">"sess.run(node3): "</span></span>,sess.run(node3))</code></pre>\n<p>运行后会输出了以下内容：</p>\n<pre class="bash"><code class="language-python">node3:  Tensor(<span class="code-string"><span class="code-string">"Add_2:0"</span></span>, shape=(), dtype=<span\n        class="code-built_in">float</span>32)\nsess.run(node3):  <span class="hljs-number">7.0</span></code></pre>\n<p>到此，完成了TensorFlow创建图和执行图的过程。</p>\n<p>前面提到TensorFlow提供了一个名为TensorBoard的工具，这个工具能够显示图运算的节点。下面是一个TensorBoard可视化看到计算图的例子：</p>\n<p><img alt="TensorFlow 使用入门教程" height="130"\n        src="https://file.mahoooo.com/res/file/tensorflow_get_started_0.png" width="269"></p>\n<p>这样的常量运算结果并没有什么价值，因为他总是恒定的产生固定的结果。图中的节点能够以参数的方式接受外部输入——比如使用占位符。占位符可以等到模型运行时再使用动态计算的数值：</p>\n<pre class="ini"><code class="language-python"><span class="hljs-attr">a</span> = tf.placeholder(tf.float32)\n<span class="hljs-attr">b</span> = tf.placeholder(tf.float32)\n<span class="hljs-attr">adder_node</span> = a + b  <span\n            class="code-comment"># + 可以代替tf.add(a, b)构建模型</span></code></pre>\n<p>上面这3行代码有点像用一个function或者一个lambda表达式来获取参数输入。我们可以在运行时输入各种各样的参数到图中进行计算：</p>\n<pre class="css"><code class="language-python"><span class="code-selector-tag">print</span>(<span\n        class="code-selector-tag">sess</span><span class="code-selector-class">.run</span>(<span\n        class="code-selector-tag">adder_node</span>, {<span class="code-attribute">a</span>: <span\n        class="hljs-number"><span class="hljs-number">3</span></span>, b:<span class="hljs-number"><span\n        class="hljs-number">4.5</span></span>}))\n<span class="code-selector-tag">print</span>(<span class="code-selector-tag">sess</span><span\n            class="code-selector-class">.run</span>(<span class="code-selector-tag">adder_node</span>, {<span\n            class="code-attribute">a</span>: [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span\n            class="hljs-number"><span class="hljs-number">3</span></span>], b: [<span class="hljs-number"><span\n            class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>]}))</code></pre>\n<p>输出结果为：</p>\n<pre class="css"><code class="css">7<span class="code-selector-class"><span class="code-selector-class">.5</span></span>\n<span class="hljs-selector-attr"><span class="hljs-selector-attr">[ 3. &nbsp;7.]</span></span></code></pre>\n<p>在TensorBoard中，显示的计算图为：</p>\n<p><img alt="TensorFlow 使用入门教程" height="207"\n        src="https://file.mahoooo.com/res/file/tensorflow_get_started_1.png" width="243"></p>\n<p>我们可以使用更复杂的表达式来增加计算的内容：</p>\n<pre class="groovy"><code class="language-python">add_and_triple = adder_node * <span class="hljs-number"><span\n        class="hljs-number">3.</span></span>\nprint(sess.run(add_and_triple, {<span class="code-string">a:</span> <span class="hljs-number"><span class="hljs-number">3</span></span>, <span\n            class="code-string">b:</span><span class="hljs-number"><span class="hljs-number">4.5</span></span>}))</code></pre>\n<p>计算输出：</p>\n<pre class="css"><code class="css">22<span class="code-selector-class"><span\n        class="code-selector-class">.5</span></span></code></pre>\n<p>TensorBoard中的显示：</p>\n<p><img alt="TensorFlow 使用入门教程" height="337"\n        src="https://file.mahoooo.com/res/file/tensorflow_get_started_2.png" width="280"></p>\n<p>在机器学习中一个模型通常需要接收各种类型的数据作为输入。为了使得模型可以不断的训练通常需要能够针对相同的输入修改图的模型以获取新的输出。<strong>变量（Variables）</strong>可以增加可训练的参数到图中，他们由指定一个初始类型和初始值来创建：\n</p>\n<pre class="ini"><code class="language-python"><span class="hljs-attr">W</span> = tf.Variable([<span\n        class="hljs-number">.<span class="hljs-number">3</span></span>], tf.float32)\n<span class="hljs-attr">b</span> = tf.Variable([<span class="hljs-number">-.<span class="hljs-number">3</span></span>], tf.float32)\n<span class="hljs-attr">x</span> = tf.placeholder(tf.float32)\n<span class="hljs-attr">linear_model</span> = W * x + b</code></pre>\n<p>前面已经提到在调用&nbsp;<code>tf.constant</code>&nbsp;时会初始化不可变更的常量。 而这里通过调用&nbsp;<code>tf.Variable</code>&nbsp;创建的变量不会被初始化，为了在TensorFlow运行之前（<code>sess.run</code>执行模型运算之前）初始化所有的变量，需要增加一步&nbsp;<code>init</code>&nbsp;操作：\n</p>\n<pre class="swift"><code class="swift"><span class="code-keyword"><span class="code-keyword">init</span></span> = tf.global_variables_initializer()\nsess.run(<span class="code-keyword"><span class="code-keyword">init</span></span>)</code></pre>\n<p>可以通过重载&nbsp;<code>init</code>&nbsp;方式来全局初始化所有TensorFlow图中的变量。在上面的代码中，在我们调用&nbsp;<code>sess.run</code>&nbsp;之前，所有的变量都没有初始化。\n</p>\n<p>下面的&nbsp;<code>x</code>&nbsp;是一个占位符，<code>{x:[1,2,3,4]}</code>&nbsp;&nbsp;表示在运算中把x的值替换为[1,2,3,4]：</p>\n<pre class="css"><code class="language-python"><span class="code-selector-tag">print</span>(<span\n        class="code-selector-tag">sess</span><span class="code-selector-class">.run</span>(<span\n        class="code-selector-tag">linear_model</span>, {<span class="code-attribute">x</span>:[<span\n        class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span\n        class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span\n        class="hljs-number"><span class="hljs-number">4</span></span>]}))</code></pre>\n<p>输出：</p>\n<pre class="json"><code class="language-python">[ <span class="hljs-number"><span class="hljs-number">0.</span></span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span\n        class="hljs-number"><span class="hljs-number">0.30000001</span></span> &nbsp;<span class="hljs-number"><span\n        class="hljs-number">0.60000002</span></span> &nbsp;<span class="hljs-number"><span class="hljs-number">0.90000004</span></span>]</code></pre>\n<p>现在已经创建了一个计算模型，但是并不清晰是否足够有效，为了让他越来越有效，需要对这个模型进行数据训练。下面的代码定义名为&nbsp;<code>y</code>&nbsp;的占位符来提供所需的值，然后编写一个“损益功能”（loss\n    function）。</p>\n<p>一个“损益功能”是用来衡量当前的模型对于想达到的输出目标还有多少距离的工具。下面的例子使用线性回归作为损益模型。回归的过程是：计算模型的输出和损益变量（<code>y</code>）的差值，然后再对这个差值进行平方运算（方差），然后再把方差的结果向量进行和运算。下面的代码中，&nbsp;<code>linear_model\n    - y</code>&nbsp;创建了一个向量，向量中的每一个值表示对应的错误增量。然后调用&nbsp;<code>tf.square</code>&nbsp;对错误增量进行平方运算。最后将所有的方差结果相加创建一个数值的标量来抽象的表示错误差异，使用&nbsp;<code>tf.reduce_sum</code>来完成这一步工作。如下列代码：\n</p>\n<pre class="makefile"><code class="language-python"><span class="code-comment"><span class="code-comment"># 定义占位符</span></span>\ny = tf.placeholder(tf.float32)\n<span class="code-comment"><span class="code-comment"># 方差运算</span></span>\nsquared_deltas = tf.square(linear_model - y)\n<span class="code-comment"><span class="code-comment"># 定义损益模型</span></span>\nloss = tf.reduce_sum(squared_deltas)\n<span class="code-comment"><span class="code-comment"># 输出损益计算结果</span></span>\nprint(sess.run(loss, {x:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span\n            class="hljs-number">3</span>,<span class="hljs-number">4</span>], y:[<span\n            class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-2</span>,<span\n            class="hljs-number">-3</span>]}))</code></pre>\n<p>运算之后的差异值是：</p>\n<pre class="css"><code class="css">23<span class="code-selector-class"><span\n        class="code-selector-class">.66</span></span></code></pre>\n<p>\n    可以通过手动将&nbsp;<code>W</code>&nbsp;和&nbsp;<code>b</code>&nbsp;的值修改为-1和1降低差异结果。TensorFlow中使用&nbsp;<code>tf.Variable</code>&nbsp;创建变量，使用&nbsp;<code>tf.assign</code>&nbsp;修改变量。例如&nbsp;<code>W=-1</code>&nbsp;、<code>b=1</code>&nbsp;才是当前模型最佳的值，可以像下面这样修改他们的值：\n</p>\n<pre class="groovy"><code class="language-python">fixW = tf.assign(W, [<span class="hljs-number"><span\n        class="hljs-number">-1.</span></span>])\nfixb = tf.assign(b, [<span class="hljs-number"><span class="hljs-number">1.</span></span>])\nsess.run([fixW, fixb])\nprint(sess.run(loss, {<span class="code-string">x:</span>[<span class="hljs-number"><span\n            class="hljs-number">1</span></span>,<span class="hljs-number"><span\n            class="hljs-number">2</span></span>,<span class="hljs-number"><span\n            class="hljs-number">3</span></span>,<span class="hljs-number"><span\n            class="hljs-number">4</span></span>], <span class="code-string">y:</span>[<span class="hljs-number"><span\n            class="hljs-number">0</span></span>,<span class="hljs-number"><span\n            class="hljs-number">-1</span></span>,<span class="hljs-number"><span\n            class="hljs-number">-2</span></span>,<span class="hljs-number"><span class="hljs-number">-3</span></span>]}))</code></pre>\n<p>修改之后的最终输出结果为：</p>\n<pre class="css"><code class="css">0<span class="code-selector-class"><span class="code-selector-class">.0</span></span></code></pre>\n\n<h3 id="h3-3">tf.train 接口</h3>\n<p>机器学习的完整过程超出了本文的范围，这里仅说明训练的过程。TensorFlow提供了很多优化器来逐渐（迭代或循环）调整每一个参数，最终实现损益值尽可能的小。最简单的优化器之一是“梯度递减”（<strong>gradient\n    descent</strong>），它会对损益计算模型求导，然后根据求导的结果调整输入变量的值（<code>W</code>和<code>b</code>），最终目的让求导的结果逐渐趋向于0。手工进行编写求导运算非常冗长且容易出错，TensorFlow还提供了函数&nbsp;<code>tf.gradients</code>&nbsp;实现自动求导过程。下面的例子展示了使用梯度递减训练样本的过程：\n</p>\n<pre class="bash"><code class="language-python"><span class="code-comment"><span class="code-comment"># 设定优化器，这里的0.01表示训练时的步进值</span></span>\noptimizer = tf.train.GradientDescentOptimizer(<span class="hljs-number">0.01</span>)\ntrain = optimizer.minimize(loss)\nsess.run(init) <span class="code-comment"><span class="code-comment"># 初始化变量值.</span></span>\n<span class="code-keyword"><span class="code-keyword">for</span></span> i <span class="code-keyword"><span\n            class="code-keyword">in</span></span> range(<span class="hljs-number">1000</span>): <span\n            class="code-comment"><span class="code-comment"># 遍历1000次训练数据，每次都重新设置新的W和b值</span></span>\n  sess.run(train, {x:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span\n            class="hljs-number">3</span>,<span class="hljs-number">4</span>], y:[<span\n            class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-2</span>,<span\n            class="hljs-number">-3</span>]})\n\n<span class="code-built_in">print</span>(sess.run([W, b]))</code></pre>\n<p>这个模式的运算结果是：</p>\n<pre class="json"><code class="json">[array([<span class="hljs-number"><span\n        class="hljs-number">-0.9999969</span></span>], dtype=float32), array([ <span class="hljs-number"><span\n        class="hljs-number">0.99999082</span></span>], dtype=float32)]</code></pre>\n<p>\n    现在我们已经完成机器学习的整个过程。虽然进行简单的线性回归计算并不需要用到太多的TensorFlow代码，但是这仅仅是一个用于实例的案例，在实际应用中往往需要编写更多的代码实现复杂的模型匹配运算。TensorFlow为常见的模式、结构和功能提供了更高级别的抽象接口。</p>\n\n<h3 id="h3-4">一个完整的训练过程</h3>\n<p>下面是根据前文的描述，编写的完整线性回归模型：</p>\n<pre class="makefile"><code class="language-python"><span class="code-keyword">import</span> numpy <span\n        class="code-keyword">as</span> np\n<span class="code-keyword">import</span> tensorflow <span class="code-keyword">as</span> tf\n\n<span class="code-comment"><span class="code-comment"># 模型参数</span></span>\nW = tf.Variable([<span class="hljs-number">.3</span>], tf.float32)\nb = tf.Variable([<span class="hljs-number">-.3</span>], tf.float32)\n<span class="code-comment"><span class="code-comment"># 模型输入</span></span>\nx = tf.placeholder(tf.float32)\n<span class="code-comment"><span class="code-comment"># 模型输出</span></span>\nlinear_model = W * x + b\n<span class="code-comment"><span class="code-comment"># 损益评估参数</span></span>\ny = tf.placeholder(tf.float32)\n<span class="code-comment"><span class="code-comment"># 损益模式</span></span>\nloss = tf.reduce_sum(tf.square(linear_model - y)) <span class="code-comment"># 方差和</span>\n<span class="code-comment"><span class="code-comment"># 优化器</span></span>\noptimizer = tf.train.GradientDescentOptimizer(<span class="hljs-number">0.01</span>)\ntrain = optimizer.minimize(loss)\n<span class="code-comment"><span class="code-comment"># 训练数据</span></span>\nx_train = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span\n            class="hljs-number">3</span>,<span class="hljs-number">4</span>]\ny_train = [<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span\n            class="hljs-number">-2</span>,<span class="hljs-number">-3</span>]\n<span class="code-comment"><span class="code-comment"># 定义训练的循环</span></span>\ninit = tf.global_variables_initializer()\nsess = tf.Session()\nsess.run(init) <span class="code-comment"><span class="code-comment"># reset values to wrong</span></span>\n<span class="code-keyword">for</span> i <span class="code-keyword">in</span> range(<span class="hljs-number">1000</span>):\n  sess.run(train, {x:x_train, y:y_train})\n\n<span class="code-comment"><span class="code-comment"># 评估训练结果的精确性</span></span>\ncurr_W, curr_b, curr_loss  = sess.run([W, b, loss], {x:x_train, y:y_train})\nprint(<span class="code-string">"W: %s b: %s loss: %s"</span>%(curr_W, curr_b, curr_loss))</code></pre>\n<p>运行后会输出：</p>\n<pre class="css"><code class="language-python"><span class="code-selector-tag">W</span>: <span\n        class="hljs-selector-attr">[</span><span class="hljs-number"><span class="hljs-selector-attr">-0.9999969</span></span><span\n        class="hljs-selector-attr">]</span> <span class="code-selector-tag">b</span>: <span\n        class="hljs-selector-attr">[ </span><span class="hljs-number"><span class="hljs-selector-attr">0.99999082</span></span><span\n        class="hljs-selector-attr">]</span> <span class="code-selector-tag">loss</span>: <span\n        class="hljs-number">5<span class="code-selector-class">.69997e-11</span></span></code></pre>\n<p>这个复杂的程序仍然可以在TensorBoard中可视化呈现：</p>\n<p><img alt="TensorFlow 使用入门教程" height="721"\n        src="https://file.mahoooo.com/res/file/tensorflow_get_started_3.png" width="832"></p>\n\n<h2 id="h2-4">tf.contrib.learn</h2>\n<p>前面已经提到，TensorFlow除了TensorFlow Core之外，为了便于业务开发还提供了很多更抽象的接口。<code>tf.contrib.learn</code>&nbsp;是TensorFlow的一个高级库，他提供了更加简化的机器学习机制，包括：\n</p>\n<ol>\n    <li>运行训练循环</li>\n    <li>运行评估循环</li>\n    <li>管理数据集合</li>\n    <li>管理训练数据</li>\n</ol>\n<p>tf.contrib.learn&nbsp;定义了一些通用模块。</p>\n\n<h4 id="h4-1">基本用法</h4>\n<p>先看看使用&nbsp;<code>tf.contrib.learn</code>&nbsp;来实现线性回归的方式。</p>\n<pre class="haskell"><code class="language-python"><span class="code-keyword"><span\n        class="code-keyword">import</span></span> tensorflow <span class="code-keyword"><span\n        class="code-keyword">as</span></span> tf\n<span class="code-comment"><span class="code-meta"># NumPy常用语加载、操作、预处理数据.</span></span>\n<span class="code-keyword"><span class="code-keyword">import</span></span> numpy <span class="code-keyword"><span\n            class="code-keyword">as</span></span> np\n\n<span class="code-comment"><span class="code-meta"># 定义一个特性列表features。</span></span>\n<span class="code-comment"><span class="code-meta"># 这里仅仅使用了real-valued特性。还有其他丰富的特性功能</span></span>\n<span class="code-title">features</span> = [tf.contrib.layers.real_valued_column(<span class="code-string"><span\n            class="code-string">"x"</span></span>, dimension=<span class="hljs-number"><span\n            class="hljs-number">1</span></span>)]\n\n<span class="code-comment"><span class="code-meta"># 一个评估者（estimator）是训练（fitting）与评估（inference）的开端。</span></span>\n<span class="code-comment"><span class="code-meta"># 这里预定于了许多类型的训练评估方式，比如线性回归（linear regression）、</span></span>\n<span class="code-comment"><span class="code-meta"># 逻辑回归（logistic regression）、线性分类（linear classification）和回归（regressors）</span></span>\n<span class="code-comment"><span class="code-meta"># 这里的estimator提供了线性回归的功能</span></span>\n<span class="code-title">estimator</span> = tf.contrib.learn.<span class="code-type">LinearRegressor</span>(feature_columns=features)\n\n<span class="code-comment"><span class="code-meta"># TensorFlow提供了许多帮助类来读取和设置数据集合</span></span>\n<span class="code-comment"><span class="code-meta"># 这里使用了‘numpy_input_fn’。</span></span>\n<span class="code-comment"><span class="code-meta"># 我们必须告诉方法我们许多多少批次的数据，以及每次批次的规模有多大。</span></span>\n<span class="code-title">x</span> = np.array([<span class="hljs-number"><span\n            class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span>, <span\n            class="hljs-number"><span class="hljs-number">3.</span></span>, <span class="hljs-number"><span\n            class="hljs-number">4.</span></span>])\n<span class="code-title">y</span> = np.array([<span class="hljs-number"><span\n            class="hljs-number">0.</span></span>, <span class="hljs-number"><span class="hljs-number">-1.</span></span>, <span\n            class="hljs-number"><span class="hljs-number">-2.</span></span>, <span class="hljs-number"><span\n            class="hljs-number">-3.</span></span>])\n<span class="code-title">input_fn</span> = tf.contrib.learn.io.numpy_input_fn({<span class="code-string"><span\n            class="code-string">"x"</span></span>:x}, y, batch_size=<span class="hljs-number"><span class="hljs-number">4</span></span>,\n                                              num_epochs=<span class="hljs-number"><span class="hljs-number">1000</span></span>)\n\n<span class="code-comment"><span class="code-meta"># ‘fit’方法通过指定steps的值来告知方法要训练多少次数据</span></span>\n<span class="code-title">estimator</span>.fit(input_fn=input_fn, steps=<span class="hljs-number"><span\n            class="hljs-number">1000</span></span>)\n\n<span class="code-comment"><span class="code-meta"># 最后我们评估我们的模型价值。在一个实例中，我们希望使用单独的验证和测试数据集来避免过度拟合。</span></span>\n<span class="code-title">estimator</span>.evaluate(input_fn=input_fn)</code></pre>\n<p>运行后输出：</p>\n<pre class="lua"><code class="language-python">&nbsp; &nbsp; {<span class="code-string"><span class="code-string">\'global_step\'</span></span>: <span\n        class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="code-string"><span\n        class="code-string">\'loss\'</span></span>: <span class="hljs-number"><span\n        class="hljs-number">1.9650059e-11</span></span>}</code></pre>\n\n<h4 id="h4-2">自定义模型</h4>\n<p><code>tf.contrib.learn</code>&nbsp;并不限定只能使用它预设的模型。假设现在需要创建一个未预设到TensorFlow中的模型。我们依然可以使用<code>tf.contrib.learn</code>保留数据集合、训练数据、训练过程的高度抽象。我们将使用我们对较低级别TensorFlow\n    API的了解，展示如何使用LinearRegressor实现自己的等效模型。</p>\n<p>使用&nbsp;<code>tf.contrib.learn</code>&nbsp;创建一个自定义模型需要用到它的子类&nbsp;<code>tf.contrib.learn.Estimator</code>&nbsp;。而&nbsp;<code>tf.contrib.learn.LinearRegressor</code>&nbsp;是&nbsp;&nbsp;<code>tf.contrib.learn.Estimator</code>&nbsp;的子类。下面的代码中为&nbsp;<code>Estimator</code>&nbsp;新增了一个&nbsp;<code>model_fn</code>&nbsp;功能，这个功能将告诉&nbsp;<code>tf.contrib.learn</code>&nbsp;如何进行评估、训练以及损益计算：\n</p>\n<pre class="python"><code class="language-python"><span class="code-keyword"><span\n        class="code-keyword">import</span></span> numpy <span class="code-keyword"><span class="code-keyword">as</span></span> np\n<span class="code-keyword"><span class="code-keyword">import</span></span> tensorflow <span class="code-keyword"><span\n            class="code-keyword">as</span></span> tf\n<span class="code-comment"><span class="code-comment"># 定义一个特征数组，这里仅提供实数特征</span></span>\n<span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">def</span></span></span><span\n        class="hljs-function"> </span><span class="code-title"><span class="hljs-function"><span class="code-title">model</span></span></span><span\n        class="hljs-params"><span class="hljs-function"><span class="hljs-params">(features, labels, mode)</span></span></span><span\n        class="hljs-function">:</span></span>\n  <span class="code-comment"><span class="code-comment"># 构建线性模型和预设值</span></span>\n  W = tf.get_variable(<span class="code-string"><span class="code-string">"W"</span></span>, [<span class="hljs-number"><span\n            class="hljs-number">1</span></span>], dtype=tf.float64)\n  b = tf.get_variable(<span class="code-string"><span class="code-string">"b"</span></span>, [<span class="hljs-number"><span\n            class="hljs-number">1</span></span>], dtype=tf.float64)\n  y = W*features[<span class="code-string"><span class="code-string">\'x\'</span></span>] + b\n  <span class="code-comment"><span class="code-comment"># 损益子图</span></span>\n  loss = tf.reduce_sum(tf.square(y - labels))\n  <span class="code-comment"><span class="code-comment"># 训练子图</span></span>\n  global_step = tf.train.get_global_step()\n  optimizer = tf.train.GradientDescentOptimizer(<span class="hljs-number"><span class="hljs-number">0.01</span></span>)\n  train = tf.group(optimizer.minimize(loss),\n                   tf.assign_add(global_step, <span class="hljs-number"><span class="hljs-number">1</span></span>))\n  <span class="code-comment"><span class="code-comment"># ModelFnOps方法将创建我们自定义的一个抽象模型。</span></span>\n  <span class="code-keyword"><span class="code-keyword">return</span></span> tf.contrib.learn.ModelFnOps(\n      mode=mode, predictions=y,\n      loss=loss,\n      train_op=train)\n\nestimator = tf.contrib.learn.Estimator(model_fn=model)\n<span class="code-comment"><span class="code-comment"># 定义数据集</span></span>\nx = np.array([<span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span\n            class="hljs-number">2.</span></span>, <span class="hljs-number"><span class="hljs-number">3.</span></span>, <span\n            class="hljs-number"><span class="hljs-number">4.</span></span>])\ny = np.array([<span class="hljs-number"><span class="hljs-number">0.</span></span>, <span class="hljs-number"><span\n            class="hljs-number">-1.</span></span>, <span class="hljs-number"><span class="hljs-number">-2.</span></span>, <span\n            class="hljs-number"><span class="hljs-number">-3.</span></span>])\ninput_fn = tf.contrib.learn.io.numpy_input_fn({<span class="code-string"><span class="code-string">"x"</span></span>: x}, y, <span\n            class="hljs-number"><span class="hljs-number">4</span></span>, num_epochs=<span class="hljs-number"><span\n            class="hljs-number">1000</span></span>)\n\n<span class="code-comment"><span class="code-comment"># 训练数据</span></span>\nestimator.fit(input_fn=input_fn, steps=<span class="hljs-number"><span class="hljs-number">1000</span></span>)\n<span class="code-comment"><span class="code-comment"># 评估模型</span></span>\nprint(estimator.evaluate(input_fn=input_fn, steps=<span class="hljs-number"><span class="hljs-number">10</span></span>))</code></pre>\n<p>运行后输出：</p>\n<pre class="lua"><code class="language-python">{<span class="code-string"><span class="code-string">\'loss\'</span></span>: <span\n        class="hljs-number"><span class="hljs-number">5.9819476e-11</span></span>, <span class="code-string"><span\n        class="code-string">\'global_step\'</span></span>: <span class="hljs-number"><span class="hljs-number">1000</span></span>}</code></pre>\n\n<h2 id="h2-5">接下来做什么</h2>\n<p>阅读了到这里，你应该初步了解如何在TensorFlow中进行开发和编码。但是如果你刚踏入机器学习的领域，就算很仔细的看了本文，对于如何使用TensorFlow进行机器学习基本上还是懵逼的。<span\n        style="color:#FF0000">请继续阅读</span><a href="https://my.oschina.net/chkui/blog/888346" rel="nofollow">《MNIST\n    机器学习入门</a>》<span style="color:#FF0000">，文章给出了一个完整的机器学习建模案例，适合零知识入门机器学习。</span></p>'}});