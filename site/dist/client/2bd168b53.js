webpackJsonp([2],{335:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<p>JSR330是Jcp给出的官方标准反向依赖注入规范。Java大部分反向依赖注入的工具或者框架目前基本上都满足JSR330规范、例如spring、guice以及Dagger。</p>\n<p>以我们最常用的spring为例。</p>\n<p>JSR中<span style="color:#cc0000">@Inject</span>可以当做<span style="color:#cc0000">@AutoWired</span>来使用。而<span\n        style="color:#cc0000">@Named</span>可以当做<span style="color:#cc0000">@Component</span>来使用。</p>\n<p>使用JSR330首先要引入javax.inject包：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">dependency</span>&gt;</span>  \n    <span class="code-tag">&lt;<span class="code-name">groupId</span>&gt;</span>javax.inject<span class="code-tag">&lt;/<span\n            class="code-name">groupId</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">artifactId</span>&gt;</span>javax.inject<span class="code-tag">&lt;/<span\n            class="code-name">artifactId</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">version</span>&gt;</span>1<span class="code-tag">&lt;/<span\n            class="code-name">version</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">dependency</span>&gt;</span> </code></pre>\n<p>目前Maven中央仓库中就一个inject的jar。</p>\n<p>首先使用xml配置通过注解扫描添加bean。</p>\n<pre><code class="xml"><span class="php"><span class="code-meta">&lt;?</span>xml version=<span\n        class="code-string">"1.0"</span> encoding=<span class="code-string">"UTF-8"</span><span\n        class="code-meta">?&gt;</span></span>\n<span class="code-tag">&lt;<span class="code-name">beans</span> <span class="hljs-attr">xmlns</span>=<span\n        class="code-string">"http://www.springframework.org/schema/beans"</span>\n    <span class="hljs-attr">xmlns:xsi</span>=<span\n            class="code-string">"http://www.w3.org/2001/XMLSchema-instance"</span>\n    <span class="hljs-attr">xmlns:context</span>=<span class="code-string">"http://www.springframework.org/schema/context"</span>  \n    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="code-string">"http://www.springframework.org/schema/beans  \n    http://www.springframework.org/schema/beans/spring-beans-3.1.xsd  \n    http://www.springframework.org/schema/context  \n    http://www.springframework.org/schema/context/spring-context-3.1.xsd"</span>&gt;</span>  \n    <span class="code-tag">&lt;<span class="code-name">context:component-scan</span>  <span class="hljs-attr">base-package</span>=<span\n            class="code-string">"com.demo.jsr330"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span>  </code></pre>\n<p>然后像下面这个添加一个bean</p>\n<pre><code class="java"><span class="code-meta">@Named</span>  \n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">service</span> </span>{\n  <span class="hljs-function"><span class="code-keyword">public</span>  <span class="code-keyword">void</span>   <span\n          class="code-title">print</span><span class="hljs-params">()</span></span>{\n     System.out.println(<span class="code-string">"Service  print  method is invoked"</span>);  \n  }  \n}  </code></pre>\n<p>然后将这个bean注入到其他bean中去使用</p>\n<pre><code class="java"><span class="code-meta">@Named</span>  \n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Faction</span> </span>{\n  <span class="code-meta">@Inject</span>\n  Service service;\n\n  <span class="hljs-function"><span class="code-keyword">public</span>  <span class="code-keyword">void</span>  <span\n          class="code-title">show</span><span class="hljs-params">()</span></span>{\n     service.print()； \n  }  \n}  </code></pre>\n<p>JSR330还定义了<span style="color:#FF0000">@Qualifier</span>和<span style="color:#FF0000">@Provider</span>，对应到spring都给出了标准的实现。\n</p>\n<p>使用JSR330代替原注解的好处是无论使用任何反向依赖注入工具或框架，只要他是支持JSR330的，都可以平滑的切换。</p>'},344:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<h2 id="h2-1">Niubility的Nodejs &nbsp;&nbsp;</h2>\n<p>关于大名鼎鼎的Nodejs是什么就不用再介绍了，他的牛逼之处数都数不完——让javascript称霸全宇宙、将一个只用于前端的编程语言同时可以制霸前后端、让致力于前端开发的小哥又多了一项事业新增了一门手艺、亮瞎人的全异步事件驱动型架构（event-driven、non-blocking、scalability）。总的来说就是，学好Nodejs必须能够赚大钱迎娶白富美。</p>\n<p>本人一直垂涎与Nodejs的鼎鼎大名，但是由于工作繁忙，一直没时间深入亵玩。最近因为一些机缘，又要着手一些前端开发的工作才觅得一次全面接触的良机。</p>\n<p>看到这里你肯定要说，又是一个要把Nodejs吹上天的文章！NoNo，本文会一步一步的说明我是怎么学会和用上nodejs的，然后结合其我所了解的语言告诉各位我所了解的Nodejs坑和优势。</p>\n\n<h2 id="h2-2">学习基础</h2>\n<p>先说说本人开始学习使用的基础。早期在某外企开发室内3D设计软件，那段时间用已经成为古董的MFC做各种windows事件驱动开发。</p>\n<p>之后就一直在做Java生态的东西、反正就是SSH啦、MVC啦、Dao啦、Entity啦、JNDI啦、JDBC啦等等，相信每个Javaer都懂的。早些年做Java时，前端部分基本就是玩转Jsp，页面清一色的用Jsp动态生成，然后丢给浏览器。现在所属团队几乎已经放弃这种方式，都是用spring-boot等弄前后端分离了。</p>\n<p>随后有幸接到一个自己可以全权负责的全新的项目，于是带着2个人开始尝试抛弃JSP，引入了大量的ajax异步请求的客户端组装数据。那时候这样做其实蛮痛苦的，新项目根本没有真正意义的前端开发人员（都玩JSP呢），所以自己不得不去研究前端的各种前端技术。在随后的许多时光中，深入且大量的学习了前端开发的所有东西，从一穷二白只会用div画画静态页面，到后面自己封装列表、消息通知等组件，通杀jquery、angularjs，了解各种脚手架。所以学习Nodejs开发，我基本上是没有语言障碍的，只是需要跟上它的思路。</p>\n\n<h2 id="h2-3">安装Nodejs</h2>\n<p>要用一样东西之前，当然是要先安装环境。Nodejs的安装网上一搜一大把，这里就简单记录一下流程，方面以后查阅。因为本人用一台windows（windows10）办公、用一台linux（ubuntu16.04）开发，所以2个操作系统都安装了Nodejs，像OSX这样高大上的玩意，暂时没机器去弄（穷）。</p>\n\n<h3 id="h3-1">windows</h3>\n<ol>\n    <li>先去官网（https://nodejs.org或https://nodejs.org/en/download/）下载一个安装包，我下的是长期稳定版。建议下载.msi。</li>\n    <li>然后就是安装了，这没什么好说的。无非就是设定一下安装目录，然后一通Next。</li>\n    <li>安装好之后检查下环境变量，看看path下添加入了Nodejs的运行路径。cmd中输入path可以看到添加了nodejs的安装目录。然后输入node --version可以看到当前的Nodejs版本号。如下图：&nbsp;&nbsp;&nbsp;&nbsp;<img alt="安装NodeJs运行环境" height="175" src="https://file.mahoooo.com/res/file/install_nodejs_runtime_environment_1.png" width="527"></li>\n    <li>Nodejs自带npm，npm和其他未来要使用的组件都存放在“X:\\yourpath\\nodejs\\node_modules”里。所以需要在windows环境变量重增加一个NODE_PATH=X:\\yourpath\\nodejs\\node_modules的参数，保证未来新增的一些模块工具可以正常使用。右键“我的电脑”-&gt;高级系统设置-&gt;环境变量-&gt;然后新建以上参数。</li>\n    <li>再然后就是最后一步了，设置node_cache（用于npm存放一些临时文件）和node_global（全局工具文件夹），当然这里也可以不设置，他会自动放在当前用户的文件夹下，但是有强迫症的我必须要设置。在cmd中输入一下命令：</li>\n</ol>\n<pre class="sql"><code class="language-bash">npm config <span class="code-built_in"><span class="code-keyword">set</span></span> prefix <span class="code-string"><span class="code-string">\'X:\\yourpath\\nodejs\\node-global\'</span></span>\n\nnpm config <span class="code-built_in"><span class="code-keyword">set</span></span> <span class="code-keyword">cache</span> <span class="code-string"><span class="code-string">\'X:\\yourpath\\nodejs\\node_cache\'</span></span></code></pre>\n\n<h3 id="h3-2">linux</h3>\n<p>linux安装和windows安装Nodejs差不多，都是下载包、解压、开用。</p>\n<ol>\n    <li>先去官网下载一个linux版本的安装包（下首页的那个就行）。下载以后发现是 xz后缀，先得用xz命令解压成tar，再用tar完成解压。</li>\n    <li>添加Nodejs运行环境：直接把node的运行目录添加到&amp;PATH里。在profile中添加Node的运行环境： <pre class="bash"><code class="language-bash"><span class="code-comment"><span class="code-comment">#node</span></span>\n<span class="code-built_in"><span class="code-built_in">export</span></span> NODE_HOME=/yourpath/node-v4.5.0-linux-x64\n<span class="code-built_in"><span class="code-built_in">export</span></span> PATH=<span class="code-variable"><span class="code-variable">$NODE_HOME</span></span>/bin:<span class="code-variable"><span class="code-variable">$PATH</span></span></code></pre> <p>然后再任意位置测试了一下运行node命令都可以正常使用。</p> </li>\n    <li> <p>然后我们需要添加node_modules到PATH中，保证npm可以使用：</p> <pre class="bash"><code class="language-apache"><span class="code-comment">#npm</span>\n<span class="code-built_in">export</span> NODE_PATH=<span class="code-variable">$NODE_HOME</span>/node_modules\n</code></pre> <p>配置完之后，就可以使用npm命令了。（修改之后切记注销用户）</p> </li>\n</ol>\n<p>完成以上步奏之后，就可以用node和npm命令干你相干的事了。安装之前按看到很多教程说是要安装python2.2到2.7的版本。但是我解压完nodejs包后在bin下运行了node -v命令居然可以跑，我就没去管python的事，应该是我用的是打包版的原因。</p>\n\n<h3 id="h3-3">Apt安装Nodejs</h3>\n<p>1.设定Nodejs安装源：</p>\n<pre class="nginx"><code class="language-bash"><span class="code-attribute">curl</span> <span class="hljs-_">-s</span>L https://deb.nodesource.com/setup_8.x | sudo -E bash -</code></pre>\n<p>2.安装Nodejs</p>\n<pre class="actionscript"><code class="language-bash">sudo apt-<span class="code-keyword">get</span> install -y nodejs</code></pre>\n\n<h3 id="h3-4">验证安装结果</h3>\n<p>安装完成之后，我在windows和linux都测试了一下。</p>\n<p>测试nodejs：输入node打开REPL，然后使用log打印数据：</p>\n<pre class="javascript"><code class="language-bash">$ node\n&gt; <span class="code-built_in">console</span>.log(<span class="code-string"><span class="code-string">"hello nodejs!"</span></span>);\nhello nodejs!\n<span class="hljs-literal">undefined</span></code></pre>\n<p>然后用npm测试安装grunt-cli：</p>\n<pre class="groovy"><code class="language-bash">$ npm install -g grunt-cli\n<span class="hljs-regexp">/yourpath/</span>node-v4<span class="hljs-number">.5</span><span class="hljs-number">.0</span>-linux-x64<span class="hljs-regexp">/node_global/</span>bin<span class="hljs-regexp">/grunt -&gt; /</span>yourpath<span class="hljs-regexp">/node-v4.5.0-linux-x64/</span>node_global<span class="hljs-regexp">/lib/</span>node_modules<span class="hljs-regexp">/grunt-cli/</span>bin/grunt\ngrunt-cli@<span class="hljs-number">1.2</span><span class="hljs-number">.0</span> <span class="hljs-regexp">/me/</span>soft<span class="hljs-regexp">/node/</span>node-v4<span class="hljs-number">.5</span><span class="hljs-number">.0</span>-linux-x64<span class="hljs-regexp">/node_global/</span>lib<span class="hljs-regexp">/node_modules/</span>grunt-cli\n├── grunt-known-options@<span class="hljs-number">1.1</span><span class="hljs-number">.0</span>\n├── resolve@<span class="hljs-number">1.1</span><span class="hljs-number">.7</span>\n├── nopt@<span class="hljs-number">3.0</span><span class="hljs-number">.6</span> (abbrev@<span class="hljs-number">1.0</span><span class="hljs-number">.9</span>)\n└── findup-sync@<span class="hljs-number">0.3</span><span class="hljs-number">.0</span> (glob@<span class="hljs-number">5.0</span><span class="hljs-number">.15</span>)</code></pre>\n\n<h3 id="h3-5">运行一个Nodejs程序</h3>\n<p>安装好之后，node的命令行和npm的命令行就都可以使用了，随后当然就是要跑跑Nodejs了。像下面这样创建一个创建一个example.js文件，随便放在某个文件：</p>\n<pre class="javascript"><code class="language-javascript"><span class="code-keyword"><span class="code-keyword">const</span></span> http = <span class="code-built_in"><span class="code-built_in">require</span></span>(<span class="code-string"><span class="code-string">\'http\'</span></span>);\n\n<span class="code-keyword"><span class="code-keyword">const</span></span> hostname = <span class="code-string"><span class="code-string">\'127.0.0.1\'</span></span>;\n<span class="code-keyword"><span class="code-keyword">const</span></span> port = <span class="hljs-number"><span class="hljs-number">3000</span></span>;\n\n<span class="code-keyword"><span class="code-keyword">const</span></span> server = http.createServer((req, res) -&gt; {\n  res.statusCode = <span class="hljs-number"><span class="hljs-number">200</span></span>;\n  res.setHeader(<span class="code-string"><span class="code-string">\'Content-Type\'</span></span>, <span class="code-string"><span class="code-string">\'text/plain\'</span></span>);\n  res.end(<span class="code-string"><span class="code-string">\'Hello World Nodejs\\n\'</span></span>);\n});\n\nserver.listen(port, hostname, () =&gt; {\n  <span class="code-built_in"><span class="code-built_in">console</span></span>.log(<span class="code-string"><span class="code-string">`Server running at http://</span><span class="hljs-subst"><span class="code-string"><span class="hljs-subst">${hostname}</span></span></span><span class="code-string">:</span><span class="hljs-subst"><span class="code-string"><span class="hljs-subst">${port}</span></span></span><span class="code-string">/`</span></span>);\n});</code></pre>\n<p>然后在当前文件下打开一个cmd运行以下命令：</p>\n<pre class="css"><code class="language-bash"><span class="code-selector-tag">node</span> <span class="code-selector-tag">example</span><span class="code-selector-class">.js</span></code></pre>\n<p>可以看到输出：</p>\n<pre class="php"><code class="language-bash"><span class="code-variable">$node</span> example.js\n\nServer running at http:<span class="code-comment">//127.0.0.1:3000</span></code></pre>\n'},353:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<h2 id="h2-1">什么叫前后端同构？</h2>\n<p>为了解决某些问题（比如SEO、提升渲染速度等）<strong><em>react</em></strong>\n    提供了2个方法在服务端生成一个HTML文本格式的字符串。在得到了这个HTML格式的字符串之后，通常会将其组装成一个页面直接返回给用户的浏览器。</p>\n<p>到这里，服务端的活已经干完了，然后就是浏览器这边干活。</p>\n<p>浏览器拿到HTML文本后，立刻进行渲染将内容呈现给用户。然后加载页面所需的 .js 文件，然后执行\n    <em><strong>JavaScript&nbsp;</strong></em>脚本，然后开始初始化&nbsp;<em><strong>react</strong></em> 组件…………</p>\n<p>到这里问题就来了。<strong><em>react</em></strong> 初始化组件后会执行组件内所有\n    <em>render&nbsp;() </em>方法，然后生成虚拟DOM的树形结构，然后在适当的时候将虚拟dom<em>写</em>到浏览器的真实dom中。因为 <strong><em>react</em></strong>\n    总是根据虚拟dom来生成真实dom，所以最后会把服务器端渲染好的HTML全部替换掉。</p>\n<p>\n    上面这个事情说不是问题确实也不是问题，无非就是用户看到页面然后“闪现”一下。说是问题还真是个问题，产品会拿着这毛病从用户体验的角度在各种场合和你死磕半个月。磕累了你索性把服务端渲染关了，然后运营又拿着SEO的问题准备和你开始撕逼了。</p>\n<p>聪明如 Facebook 的工程师当然想到了这些问题，所以他们在<em>ReactDOMServer.renderToString(element) 方法</em>中提供了一个\n    <strong><em>checksum</em></strong> 机制。</p>\n<p>关于&nbsp;<strong><em>checksum </em></strong> <a href="https://facebook.github.io/react/docs/react-dom-server.html"\n                                                  rel="nofollow">官网</a> 并没有太多介绍，但是国内外的各路博客介绍了不少。我一直想找&nbsp;<em><strong>react</strong></em>\n    开发者关于这个机制的介绍一直没找到……。</p>\n<p><strong>前后端同构</strong>就是保证前端和后端的dom结构一致，不会发生重复渲染。<em><strong>react</strong></em>\n    使用&nbsp;<strong><em>checksum </em></strong>机制进行保障。</p>\n\n<h2 id="h2-2">什么叫React首屏渲染？</h2>\n<p>简单的说就是 <em><strong>react</strong></em> 在浏览器内存中第一次生成的虚拟 dom 树。<strong>切记是虚拟 dom ，而不是浏览器的dom</strong>。</p>\n<p>了解 <strong><em>react</em></strong> 的应该知道，所有 <em><strong>react</strong></em> 组件都有一个 <em>render()</em>\n    方法（如果使用function方式编写的组件会把function里的所有代码都塞到 <em>render()</em> 方法中去）。当<em>ReactDOM.render( element, container,\n        [callback] )</em>方法执行时，会执行以下步骤：</p>\n<ol>\n    <li>所有组件的会先进行初始化（es6执行构造函数）。</li>\n    <li>所有组件的&nbsp;<em>render</em>&nbsp;<em>()</em> 方法会被调用一次，完成这个过程后会得到一颗虚拟的 dom 树。</li>\n    <li>&nbsp;<em><strong>react</strong></em> 会将虚拟dom转换成浏览器dom，完成后调用组件的&nbsp;<em>componentDidMount()</em>&nbsp;方法告诉你已经装载到浏览器上了。\n    </li>\n</ol>\n<p>在上面这个过程成中，步骤2完成后即为完成 <em><strong>react</strong></em> 的首屏渲染。结合 <strong><em>checksum</em></strong>&nbsp;机制步骤3有可能不会执行。\n</p>\n<p>当组件状态发生变更时（ <em>setState() </em>生命周期函数被调用）或者 父组件渲染时（父组件的 <em>render()</em> 方法被调用），当前组件的 <em>render()</em>\n    方法都会被执行，都有可能会导致虚拟dom变更，但是这些变更和首屏渲染没任何关系了。</p>\n\n<h2 id="h2-3">React前后端同构首屏渲染</h2>\n<p>了解了同构和首屏渲染，就好理解如何解决首屏不重复渲染的问题了。</p>\n<p>首先服务端渲染完之后会有一个 <em><strong>checksum</strong></em> 值写在根元素的属性上：</p>\n<p><img alt="React 前后端同构防止重复渲染" height="70"\n        src="https://file.mahoooo.com/res/file/react_server_render_with_checksum_1.png" width="601"></p>\n<p>这个 <em><strong>checksum</strong></em>&nbsp;是根据服务端生成的HTML内容哈希计算得到的。</p>\n<p>然后在浏览器加载完所有的js文件之后，开始执行前面介绍的&nbsp;<em>ReactDOM.render( element, container, [callback] )</em> &nbsp;初始化渲染的三个步骤。当执行完第二步生成虚拟dom后，<strong><em>react</em></strong>\n    会根虚拟dom用相同的算法计算一个哈希值，如果和 <em><strong>checksum</strong></em> 一致则认为服务器已经完成渲染，不会再执行第三步。</p>\n<p>如果 <strong><em>checksum</em></strong> 比对不一致，在 <strong>开发环境</strong>&nbsp;和 <strong>测试环境</strong>\n    会在浏览器console中输出以下警告内容：</p>\n<p><img alt="React 前后端同构防止重复渲染" height="85"\n        src="https://file.mahoooo.com/res/file/react_server_render_with_checksum_2.png" width="790"></p>\n<p><strong>生产环境不会输出任何警告。</strong></p>\n<p>同构渲染的内容就这么多，原理其实蛮简单的，无非就是保证DOM一致。但是结合代码分片、异步加载、服务端调接口异步组装数据等等功能后，如何保证服务端和浏览器端第一次渲染的dom一致还得花不少功夫。不过原理清楚了，事情总能办成。</p>'},359:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<p><a href="https://www.chkui.com/" title="@随风溜达的向日葵">@随风溜达的向日葵</a></p>\n<h2 id="h2-1">Nextjs</h2>\n<p><a href="https://nextjs.org/"><em>Nextjs</em></a>是<a href="https://reactjs.org/"><em>React</em></a>生态中非常受欢迎的SSR（server\n    side render——服务端渲染）框架，只需要几个步骤就可以搭建一个支持SSR的工程（_Nextjs_的快速搭建见<a\n            href="https://www.chkui.com/article/react/nextjs_getting_starting"><em>Next.js入门</em></a>）。 本文的案例代码来自于<a\n            href="https://github.com/palmg/website-standard-with-next">前端标准模板项目</a>。</p>\n<h2 id="h2-2">服务端组织数据</h2>\n<p><em>Nextjs</em>提供了便捷强大的服务端渲染功能——<strong>getInitialProps()</strong>，通过这个方法可以简单为服务端和前端同时处理异步请求数据：</p>\n<pre><code class="javascript"><span class="code-keyword">const</span> load = <span class="code-keyword">async</span> () =&gt;{\n    <span class="code-keyword">return</span> <span class="code-keyword">new</span> <span\n            class="code-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res, rej</span>)=&gt;</span>{\n        res(<span class="code-string">\'Success\'</span>)\n    })\n}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">Simple</span> <span\n        class="code-keyword">extends</span> <span class="code-title">React</span>.<span\n        class="code-title">Component</span></span>{\n    <span class="code-keyword">static</span> <span class="code-keyword">async</span> getInitialProps({req, query}) {\n        <span class="code-keyword">const</span> data = <span class="code-keyword">await</span> load();\n        <span class="code-keyword">return</span> {data}\n    }\n    render() {\n        <span class="code-keyword">return</span>(<span class="xml"><span class="code-tag">&lt;<span\n            class="code-name">p</span>&gt;</span>{this.props.data}<span class="code-tag">&lt;/<span\n            class="code-name">p</span>&gt;</span></span>)\n    }\n}\n</code></pre>\n<p>Next的强大之一体现在就这么几行代码就解决了SSR中最麻烦的前后端异步数据组装功能。再复杂的异步数据组装过程都可以放置到代码中的Promise对象中。</p>\n<h2 id="h2-3">页面与内页</h2>\n<p>在继续述说本文内容之前还需要强化两个概念——<strong>内页</strong>与<strong>页面</strong>。</p>\n<p>通过浏览器输入一个地址获取到的内容称之为<strong>页面</strong>。</p>\n<p>而在单页面应用中也会有通过导航栏或菜单控制的内容切换效果，我们将这些切换的内容称之为<strong>内页</strong>。单页面应用中一般会先打开一个页面，然后通过Dom的增删改模拟页面切换的效果。</p>\n<h2 id="h2-4">Nextjs中SSR渲染的局限性</h2>\n<p>\n    <code>getInitialProps()</code>方法虽然强大好用，但是现在还存在一个问题——<strong>只能在“内页”中使用</strong>。<em>Nextjs_规定了所有放置到<code>./pages</code>中的文件（通常是*.js_文件，也可以引入</em>.ts*文件）都视为一个内页，这些文件中被导出的React组件可以直接输入地址上访问。例如现在有<a\n        href="https://github.com/palmg/website-standard-with-next/blob/master/pages/about.js"><em>./pages/about.js</em></a>文件，运行\n    <em>Nextjs</em> 后在浏览输入<code>http://localhost:3000/about</code>就可以看到这个组件，而<a\n        href="https://github.com/palmg/website-standard-with-next/blob/master/pages/async/simple.js"><em>./pages/async/simple.js</em></a>对用的路径是<code>http://localhost:3000/async/simple</code>。\n</p>\n<p>但是在其他路径（比如<code>./component</code>）的组件是无法使用<code>getInitialProps()</code>方法的。乍一看这样似乎没多大问题，但是某些应用又需要这些组件不能放置到<code>./pages</code>中暴露到_url_中，又需要异步加载数据。看下面的例子。\n</p>\n<h3 id="h3-1">按需加载菜单的例子</h3>\n<p><img src="https://oscimg.oschina.net/oscnet/fd51a66e0f097658f7db8e37fb621c76857.jpg" alt="Nextjs+React非页面组件SSR渲染"\n        title="应用菜单" class="zoom-in-cursor"></p>\n<p>如上图。在企业级应用中（例如OA系统）通常不太需要实现SSR，这个时候可以根据角色权限在组件的<code>componentDidMount()</code>方法中异步加载菜单，但是在某些时候（例如一个可配置菜单的内容网站，或者对企业级应用进行服务端缓存）也会有菜单异步加载并且实现SSR的需要，这个时候需要在_Nextjs_框架的基础上扩展。\n</p>\n<p>看到这里可能你会想可以把菜单的组装像下面放到每个内页的<code>getInitialProps()</code>方法中去：</p>\n<pre><code class="javascript"><span class="code-keyword">const</span> Comp = <span class="hljs-function"><span\n        class="hljs-params">props</span> =&gt;</span>(<span class="xml"><span class="code-tag">&lt;<span\n        class="code-name">div</span>&gt;</span><span class="code-tag">&lt;<span class="code-name">Menus</span> <span\n        class="hljs-attr">menus</span>=<span class="code-string">{props.menus}/</span>&gt;</span><span class="code-tag">&lt;<span\n        class="code-name">div</span>&gt;</span>{props.pageData}<span class="code-tag">&lt;/<span\n        class="code-name">div</span>&gt;</span><span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span>);\nComp.getInitialProps = async ({req})=&gt;{\n    //load Menu Promise\n    const menus = await getMenus();\n    //load Page Data Promise\n    const pageData = await getPageData();\n    return {menus, pageData}\n}\n</span></code></pre>\n<p>这样做在实现上没问题，但是在架构设计上是颇为糟糕的。以下三个原因：</p>\n<ol>\n    <li>\n        对于React有各种各样的描述，比如单向数据流、组件化等等。但是他的核心思想其实是<strong>分而治之</strong>。在Jquery“统治”的年代可以使用_selector_(比如<code>$(\'#id\')</code>)轻易获取到页面上的任何元素。一个项目如果没有很好的规范化管理（长久的人工规范化管理是需要投入不少成本的），久而久之会发现各个板块之间耦合性越来越强、坑越来越多(代码腐烂)。而React的单向数据流让组件与组件之间没有直接的沟通方式，规范化从技术层面就被强化，进而才会产生了_Redux_、_Flux_这一类按照“分-总-分”的模式（实际上就是一个消息总线模式）去控制模块间沟通的。所以将业务逻辑相关性并不强的页面和菜单放置在一个地方处理并不合理。\n    </li>\n    <li>绝大多数项目都不是一个人开发的，一个架构设计者要考虑到未来参与项目的开发者水平参差不齐。如果让框架级的结构直接暴露到业务开发者的面前，保不准某个负责业务开发的小伙伴忽略或修改了什么代码导致框架级的坑出现。</li>\n    <li>按照上面的代码，实际上要求每个内页都保留<code>const menus = await getMenus();</code>、<code>&lt;Menus menus={props.menus}/&gt;</code>这一类的代码（每个内页都复制粘贴）。在架构上这叫“样板式代码”，架构设计者应当尽量将这些代码通过“分层”的方式放到一个地方去处理。\n    </li>\n</ol>\n<p>所以有理由为_Nextjs_的<code>./pages</code>之外的组件实现ssr数据异步加载。</p>\n<h2 id="h2-5">组件ssr异步数据实现</h2>\n<p>为了实现本文的需求——让所有组件实现类似于<code>getInitialProps()</code>的方法，我们先要理清_Nextjs_前后端渲染的过程。</p>\n<h3 id="h3-2">渲染过程</h3>\n<p>_Nextjs_为使用者提供了<a href="https://github.com/palmg/website-standard-with-next/blob/master/pages/_app.js"><code>./pages/_app.js</code></a>和<a\n        href="https://github.com/palmg/website-standard-with-next/blob/master/pages/_document.js"><code>./pages/_document.js</code></a>在内页处理之前执行某些任务,后者用于构建整个HTML的结构。并且<a\n        href="https://github.com/palmg/website-standard-with-next/blob/master/pages/_document.js"><code>./pages/_document.js</code></a>只会在服务端执行。本文将开发者自行实现的内页称为_page,现在对于_Nextjs_就有三个类型的构建——_<em>document</em>、_<em>app_和_component</em>,每个构建都可以包含<code>static\n    getInitialProps()</code>、<code>constructor()</code>和<code>render()</code>方法，他们的执行过程如下。</p>\n<h4 id="h4-1">服务端执行过程</h4>\n<ol>\n    <li>_document getInitialProps()</li>\n    <li>_app getInitialProps()</li>\n    <li>_page getInitialProps()</li>\n    <li>_app constructor()</li>\n    <li>_app render()</li>\n    <li>_page constructor()</li>\n    <li>_page render()</li>\n    <li>_document constructor()</li>\n    <li>_document render()</li>\n</ol>\n<p>以上的过程分解如下：</p>\n<ol>\n    <li>\n        <p><strong>组装异步数据（1~3）</strong>：服务端会先开始执行<code>_document.getInitialProps()</code>这个静态方法，方法中会执行<code>_app.getInitialProps()</code>再遍历所有的<code>_page.getInitialProps()</code>执行到这里所有的异步数据完成组装。\n        </p>\n    </li>\n    <li>\n        <p><strong>渲染React组件（4~7）</strong>：有了数据之后开始渲染页面，会使用<a\n                href="https://reactjs.org/docs/react-dom-server.html"><code>ReactDOMServer</code></a>执行产生一个HTML格式的字符串。\n        </p>\n    </li>\n    <li>\n        <p><strong>构建静态HTML（8~9）</strong>：有了<a href="https://reactjs.org/docs/react-dom-server.html"><code>ReactDOMServer</code></a>产生的字符串剩下的工作就是将其组装为一个标准的HTML文档返回给客户端。\n        </p>\n    </li>\n</ol>\n<h4 id="h4-2">客户端执行过程</h4>\n<p><strong>初始化页面时（首次打开页面）：</strong></p>\n<ol>\n    <li>_app constructor()</li>\n    <li>_app render()</li>\n    <li>_page constructor()</li>\n    <li>_page render()</li>\n</ol>\n<p>\n    客户端在首次打开页面时（或刷新页面）服务端已经提供了完整的HTML文档可以立即显示。此时React的组件依然执行一次虚拟Dom渲染，所以所有的组件都会执行。然后_Nextjs_利用类似于_React_服务端渲染的_checksum_的机制防止虚拟Dom对真实Dom进行渲染，关于_React_服务端渲染的_checksum_机制可以到<a\n        href="https://www.chkui.com/article/react/react_server_render_with_checksum">React 前后端同构防止重复渲染</a>一文了解。</p>\n<p><strong>内页跳转时（通过<code>next/link</code>跳转）：</strong></p>\n<ol>\n    <li>_app getInitialProps()</li>\n    <li>_page getInitialProps()</li>\n    <li>_app render()</li>\n    <li>_page constructor()</li>\n    <li>_page render()</li>\n</ol>\n<p>客户端跳转到一个新的内页和服务端渲染就没有什么关系了。__app和_page_的<code>getInitialProps()</code>先组装数据，然后通过<code>props</code>将组装好的数据传递给组件去渲染。需要注意的是_app的构造方法在内页跳转的时候并不会执行，因为它只在整个页面渲染的时候实例化一次。\n</p>\n<h3 id="h3-3">实现</h3>\n<p>在了解_Nextjs_解执行过程之后实现需求就很简单了——先通过_document或_app的<code>getInitialProps()</code>方法完成数据组装，然后将数据传递给对应的组件即可。当然按照分而治之的思想不能直接在框架去完成业务的事，需要为组件提供一个注册接口然后由_document或_app使用注册的方法去构建业务数据。\n</p>\n<p><strong>数据加载方法注册</strong></p>\n<p>首先需要为我们组件提供一个注册异步加载数据的接口，组件可以利用这个接口注册异步加载数据的方法让框架统一去<code>getInitialProps()</code>执行。 <a\n        href="https://github.com/palmg/website-standard-with-next/blob/master/util/serverInitProps.js"><code>./util/serverInitProps.js</code></a>提供了这个功能:\n</p>\n<pre><code class="javascript"><span class="code-keyword">const</span> FooDict = {};\n<span class="code-comment">//注册方法</span>\n<span class="code-keyword">export</span> <span class="code-keyword">const</span> registerAsyncFoo = <span\n            class="hljs-function">(<span class="hljs-params">key, foo, params = {}</span>) =&gt;</span> {\n    FooDict[key] = {foo, params};\n};\n\n<span class="code-comment">//获取方法</span>\n<span class="code-keyword">export</span> <span class="code-keyword">const</span> executeAsyncFoo = <span\n            class="code-keyword">async</span> () =&gt; {\n    <span class="code-keyword">const</span> valueDict = {};\n    <span class="code-keyword">const</span> keys = <span class="code-built_in">Object</span>.keys(FooDict);\n    <span class="code-keyword">for</span> (<span class="code-keyword">let</span> key <span\n            class="code-keyword">of</span> keys) {\n        <span class="code-keyword">const</span> dict = FooDict[key];\n        valueDict[key] = <span class="code-keyword">await</span> dict.foo(dict.params);\n    }\n    <span class="code-keyword">return</span> valueDict;\n};\n\n\n</code></pre>\n<p>然后我们在<a\n        href="https://github.com/palmg/website-standard-with-next/blob/master/components/app/application/menu.js"><code>menu</code></a>组件中注册异步获取数据的方法：\n</p>\n<pre><code class="javascript">registerAsyncFoo(<span class="code-string">\'menus\'</span>, getMenus);\n</code></pre>\n<p><code>getMenus</code>模拟异步获取数据的过程:</p>\n<pre><code class="javascript"><span class="code-keyword">import</span> {Menus} <span\n        class="code-keyword">from</span> <span class="code-string">"../../../../data/menuData"</span>;\n<span class="code-keyword">export</span> <span class="code-keyword">const</span> getMenus = <span class="hljs-function"><span\n            class="hljs-params">()</span> =&gt;</span> {\n    <span class="code-comment">//可以将这个promise修改为一个net方法实现异步动态装菜菜单</span>\n    <span class="code-keyword">return</span> <span class="code-keyword">new</span> <span\n            class="code-built_in">Promise</span>(<span class="hljs-function">(<span\n            class="hljs-params">resolve, reject</span>) =&gt;</span> {\n        resolve(Menus)\n    })\n};\n</code></pre>\n<p>注册完成后再<code>_app</code>中执行异步加载：</p>\n<pre><code class="javascript"><span class="code-keyword">import</span> {executeAsyncFoo} <span\n        class="code-keyword">from</span> <span class="code-string">"../util/serverInitProps"</span>;\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">ExpressApp</span> <span\n        class="code-keyword">extends</span> <span class="code-title">App</span> </span>{\n    <span class="code-keyword">static</span> <span class="code-keyword">async</span> getInitialProps({Component, router, ctx}) {\n        info(<span class="code-string">\'Execute _App getInitialProps()!\'</span>, <span class="code-string">\'executeReport\'</span>);\n        <span class="code-comment">/**\n         * app的getInitialProps会在服务端被调用一次，在前端每次切换页面时被调用。\n         */</span>\n        <span class="code-keyword">let</span> pageProps = {}, appProps = {};\n        <span class="code-keyword">if</span> (Component.getInitialProps) {\n            pageProps = <span class="code-keyword">await</span> Component.getInitialProps(ctx);\n        }\n        <span class="code-keyword">if</span> (ctx &amp;&amp; !ctx.req) {<span class="code-comment">//客户端执行</span>\n            appProps = <span class="code-built_in">window</span>.__NEXT_DATA__.props.appProps;\n        } <span class="code-keyword">else</span> {<span class="code-comment">//服务端执行</span>\n            appProps = <span class="code-keyword">await</span> executeAsyncFoo();\n        }\n        <span class="code-keyword">return</span> {pageProps, appProps}\n    }\n    <span class="code-comment">//other function</span>\n}\n</code></pre>\n<p>在服务端获取到数据之后会返回给<code>_ducoment</code>，_Nextjs_会将这些数据写到HTML的<code>window.__NEXT_DATA__</code>对象上而后在客户端可以从这个对象获取到已经在服务端加载的数据。\n    最后用React的Context特性传递数据，有需要用到这些数据的组件可以从<a\n            href="https://github.com/palmg/website-standard-with-next/blob/master/components/app/applicationContext.js"><code>ApplicationContext</code></a>中获取这些数据:\n</p>\n<pre><code class="javascript"><span class="code-comment">//_app</span>\n<span class="code-keyword">import</span> ApplicationContext <span class="code-keyword">from</span> <span\n            class="code-string">\'../components/app/applicationContext\'</span>\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">ExpressApp</span> <span\n        class="code-keyword">extends</span> <span class="code-title">App</span> </span>{\n     <span class="code-comment">//other function</span>\n     render() {\n        info(<span class="code-string">\'Execute _App render()!\'</span>, <span class="code-string">\'executeReport\'</span>);\n        <span class="code-keyword">const</span> {Component, pageProps, appProps} = <span\n            class="code-keyword">this</span>.props;\n        <span class="code-keyword">return</span> (\n            &lt;ApplicationContext.Provider value={appProps}&gt;\n                &lt;Application&gt;\n                    &lt;Component {...pageProps} /&gt;\n                &lt;/Application&gt;\n            &lt;/ApplicationContext.Provider&gt;\n        )\n    }\n    //other function\n}\n</code></pre>\n<pre><code class="javascript"><span class="code-comment">//menu</span>\n<span class="code-keyword">import</span> ApplicationContext <span class="code-keyword">from</span> <span\n            class="code-string">\'../applicationContext\'</span>\n<span class="code-keyword">const</span> Menu = <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> {\n    <span class="code-keyword">return</span> (\n        <span class="xml"><span class="code-tag">&lt;<span\n                class="code-name">ApplicationContext.Consumer</span>&gt;</span>\n            {appProps =&gt; {\n                const {menus} = appProps;\n                return menus.map(menu =&gt; (\n                    <span class="code-tag">&lt;<span class="code-name">Link</span> <span\n                            class="hljs-attr">href</span>=<span class="code-string">{menu.href}</span>&gt;</span>\n                        <span class="code-tag">&lt;<span class="code-name">a</span>&gt;</span>{menu.name}<span\n                    class="code-tag">&lt;/<span class="code-name">a</span>&gt;</span>\n                    <span class="code-tag">&lt;/<span class="code-name">Link</span>&gt;</span>\n                ))\n            }}\n        <span class="code-tag">&lt;/<span class="code-name">ApplicationContext.Consumer</span>&gt;</span>\n    );\n};\n</span></code></pre>\n<p><a href="https://github.com/palmg/website-standard-with-next/blob/master/util/serverInitProps.js"><code>./util/serverInitProps.js</code></a>可以在任何组件中使用，<code>_app</code>会逐一执行方法获取数据按照kev-value的方式设置到<code>ApplicationContext</code>中，而任意组件要做的仅仅是从<code>ApplicationContext</code>拿到目标数据。\n</p>\n<p>当然传递数据的方式不仅仅局限于React的Context特性，换成Redux或全局管理数据的方法都是可行的。</p>\n<p><a href="https://www.chkui.com/" title="@随风溜达的向日葵">@随风溜达的向日葵</a></p>'},395:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<h2 id="h2-1">TensorFlow入门</h2>\n<p>本文将初步向码农和程序媛们介绍如何使用TensorFlow进行编程。在阅读之前请先 <a href="https://www.chkui.com/article/tensorflow/tensorflow_windows_install" rel="nofollow">安装TensorFlow</a>，此外为了能够更好的理解本文的内容，阅读之前需要了解一点以下知识：\n</p>\n<ol>\n    <li>python基本编程。能看得懂python代码，最好能使用脚本工具或pycharm之类的IDC编写代码。</li>\n    <li>至少有一点数组的概念。</li>\n    <li>最理想的状态是具备机器学习的基础知识。不过如果在阅读之前没有了解过任何机器学习相关的知也无大碍，可以把本文作为了解机器学习的开端。后面会另开一篇用MNIST了解机器学习的基础知识。</li>\n</ol>\n<p>TensorFlow提供种类繁多的API接口，其中TensorFlow Core是最低层级的接口，为开发TensorFlow提供基础支持。官方推荐把TensorFlow\n    Core用作机器学习研究以及相关的数据建模。除了TensorFlow Core之外还有更高抽象的API接口，这些API接口比TensorFlow Core更易于使用、更易于快速实现业务需求。例如&nbsp;tf.contrib.learn\n    接口，它提供管理数据集合、进行数据评估、训练、推演等功能。在使用TensorFlow开发的过程中需要特别注意，以&nbsp;<code>contrib</code>&nbsp;开头的API接口依然还在不断完善中，很有可能在未来某个发行版本中进行调整或者直接取消。\n</p>\n<p>本文首先介绍TensorFlow Core，然后会演示如何使用&nbsp;tf.contrib.learn 实现简单的建模。了解TensorFlow\n    Core是为了让开发者理解在使用抽象接口时底层是如何工作的，以便于在训练数据时创建更合适的模型。</p>\n\n<h2 id="h2-2">TensorFlow</h2>\n<p>\n    TensorFlow的基础数据单元是张量（tensor）。一个张量认为是一组向量的集合，从数据结构的角度来理解这个集合等价于一组数值存储在1到多个队列中（张量没办法几句话说得清楚，想要了解去谷哥或者度妞搜索“张量分析”，可以简单想象成一个多维度的数组）。一个张量的阶表示了张量的维度，下面是一些张量的例子：</p>\n<blockquote> \n <pre class="lua"><code class="lua"><span class="hljs-number"><span class="hljs-number">3</span></span> # <span\n         class="hljs-number"><span class="hljs-number">0</span></span>阶张量，可以用图形[]来表示\n[<span class="hljs-number"><span class="hljs-number">1.</span></span> ,<span class="hljs-number"><span\n             class="hljs-number">2.</span></span>, <span class="hljs-number"><span class="hljs-number">3.</span></span>] # <span\n             class="hljs-number"><span class="hljs-number">1</span></span>阶张量，是一个图形为[<span class="hljs-number"><span\n             class="hljs-number">3</span></span>]的向量\n<span class="code-string"><span class="code-string">[[1., 2., 3.], [4., 5., 6.]]</span></span> # <span\n             class="hljs-number"><span class="hljs-number">2</span></span>阶张量，是一个图形为[<span class="hljs-number"><span\n             class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>]的矩阵\n<span class="code-string"><span class="code-string">[[[1., 2., 3.]]</span></span>, <span class="code-string"><span\n             class="code-string">[[7., 8., 9.]]</span></span>] # 图形为[<span class="hljs-number"><span\n             class="hljs-number">2</span></span>,<span class="hljs-number"><span\n             class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>]的三阶张量</code></pre>\n</blockquote>\n\n<h2 id="h2-3">TensorFlow Core教程</h2>\n\n<h3 id="h3-1">导入TensorFlow</h3>\n<p>下面是导入TensorFlow包的标准方式：</p>\n<pre class="haskell"><code class="language-python"><span class="code-keyword"><span\n        class="code-keyword">import</span></span> tensorflow <span class="code-keyword"><span\n        class="code-keyword">as</span></span> tf</code></pre>\n<p>通过python的方式导入之后，&nbsp;tf 提供了访问所有TensorFlow类、方法和符号的入口。</p>\n\n<h3 id="h3-2">图计算（Computational Graph）</h3>\n<p>TensorFlow Core的编程开发可以看就做2个事：</p>\n<ol>\n    <li>构建计算图。（建模）</li>\n    <li>运行计算图。（执行）</li>\n</ol>\n<blockquote>\n    <p>图（graph，也可以叫连接图）表示由多个点链接而成的图。本文中的图指的是TensorFlow建模后运算的路径，可以使用TensorBoard看到图的整个形态。</p>\n    <p>节点（node）表示图中每一个点，这些点都代表了一项计算任务。</p>\n</blockquote>\n<p><strong>所以简而言之</strong>：编程 <em>TensorFlow Core</em> 就是事先安排好一系列节点的计算任务，然后运行这些任务。</p>\n<p>\n    下面我们先构建一个简单的图，图中的节点（node）有0或多个张量作为输入，并产生一个张量作为输出。一个典型的节点是“常量”（constant）。TensorFlow的常量在构建计算模型时就已经存在，在运行计算时并不需要任何输入。下面的代码创建了2个浮点常量值常量&nbsp;<code>node1</code>&nbsp;和&nbsp;<code>node2</code>：\n</p>\n<pre class="go"><code class="language-python">node1 = tf.constant(<span class="hljs-number"><span class="hljs-number">3.0</span></span>, tf.<span\n        class="code-keyword">float32</span>)\nnode2 = tf.constant(<span class="hljs-number"><span class="hljs-number">4.0</span></span>) <span class="code-comment"># also tf.<span\n            class="code-keyword">float32</span> implicitly</span>\n<span class="code-built_in">print</span>(node1, node2)</code></pre>\n<p>运行后会打印输出：</p>\n<pre class="lisp"><code class="language-python">Tensor(<span class="code-string"><span\n        class="code-string">"Const:0"</span></span>, shape=(), dtype=float32) Tensor(<span class="code-string"><span\n        class="code-string">"Const_1:0"</span></span>, shape=(), dtype=float32)</code></pre>\n<p>观察这个打印的结果会发现，它并不是按照预想的那样输出 <em>3.0</em> 或<em> 4.0 </em>的值。这里输出的是一个节点的对象信息。因为到这里还没有执行第二项工作——运行计算模型图。只有在运行时，才会使用到节点真实的值\n    <em>3.0</em> 和<em>4.0</em>。为了进行图运算需要创建一个会话（session），一个会话封装了TensorFlow运行库的各种控制方法和状态量（context）。</p>\n<p>下面的代码会创建一个会话（session）对象实例，然后执行&nbsp;<code>run</code>&nbsp;方法来进行模型计算：</p>\n<pre class="lua"><code class="language-python">sess = tf.Session()\n<span class="code-built_in">print</span>(sess.run([node1, node2]))</code></pre>\n<p>运行后我们会发现，打印的结果是3.0和4.0：</p>\n<pre class="json"><code class="language-python">[<span class="hljs-number"><span class="hljs-number">3.0</span></span>, <span\n        class="hljs-number"><span class="hljs-number">4.0</span></span>]</code></pre>\n<p>\n    然后，对&nbsp;<code>node1</code>&nbsp;和&nbsp;<code>node2</code>&nbsp;进行和运算，这个和运算就是图中的运算模型。下面的代码是构建一个&nbsp;<code>node1</code>&nbsp;、&nbsp;<code>node2</code>&nbsp;进行和运算，&nbsp;<code>node3</code>&nbsp;代表和运算的模型，构建完毕后使用\n    <code>sess.run</code>&nbsp;运行：</p>\n<pre class="lua"><code class="language-python">node3 = tf.add(node1, node2)\n<span class="code-built_in">print</span>(<span class="code-string"><span class="code-string">"node3: "</span></span>, node3)\n<span class="code-built_in">print</span>(<span class="code-string"><span class="code-string">"sess.run(node3): "</span></span>,sess.run(node3))</code></pre>\n<p>运行后会输出了以下内容：</p>\n<pre class="bash"><code class="language-python">node3:  Tensor(<span class="code-string"><span class="code-string">"Add_2:0"</span></span>, shape=(), dtype=<span\n        class="code-built_in">float</span>32)\nsess.run(node3):  <span class="hljs-number">7.0</span></code></pre>\n<p>到此，完成了TensorFlow创建图和执行图的过程。</p>\n<p>前面提到TensorFlow提供了一个名为TensorBoard的工具，这个工具能够显示图运算的节点。下面是一个TensorBoard可视化看到计算图的例子：</p>\n<p><img alt="TensorFlow 使用入门教程" height="130"\n        src="https://file.mahoooo.com/res/file/tensorflow_get_started_0.png" width="269"></p>\n<p>这样的常量运算结果并没有什么价值，因为他总是恒定的产生固定的结果。图中的节点能够以参数的方式接受外部输入——比如使用占位符。占位符可以等到模型运行时再使用动态计算的数值：</p>\n<pre class="ini"><code class="language-python"><span class="hljs-attr">a</span> = tf.placeholder(tf.float32)\n<span class="hljs-attr">b</span> = tf.placeholder(tf.float32)\n<span class="hljs-attr">adder_node</span> = a + b  <span\n            class="code-comment"># + 可以代替tf.add(a, b)构建模型</span></code></pre>\n<p>上面这3行代码有点像用一个function或者一个lambda表达式来获取参数输入。我们可以在运行时输入各种各样的参数到图中进行计算：</p>\n<pre class="css"><code class="language-python"><span class="code-selector-tag">print</span>(<span\n        class="code-selector-tag">sess</span><span class="code-selector-class">.run</span>(<span\n        class="code-selector-tag">adder_node</span>, {<span class="code-attribute">a</span>: <span\n        class="hljs-number"><span class="hljs-number">3</span></span>, b:<span class="hljs-number"><span\n        class="hljs-number">4.5</span></span>}))\n<span class="code-selector-tag">print</span>(<span class="code-selector-tag">sess</span><span\n            class="code-selector-class">.run</span>(<span class="code-selector-tag">adder_node</span>, {<span\n            class="code-attribute">a</span>: [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span\n            class="hljs-number"><span class="hljs-number">3</span></span>], b: [<span class="hljs-number"><span\n            class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>]}))</code></pre>\n<p>输出结果为：</p>\n<pre class="css"><code class="css">7<span class="code-selector-class"><span class="code-selector-class">.5</span></span>\n<span class="hljs-selector-attr"><span class="hljs-selector-attr">[ 3. &nbsp;7.]</span></span></code></pre>\n<p>在TensorBoard中，显示的计算图为：</p>\n<p><img alt="TensorFlow 使用入门教程" height="207"\n        src="https://file.mahoooo.com/res/file/tensorflow_get_started_1.png" width="243"></p>\n<p>我们可以使用更复杂的表达式来增加计算的内容：</p>\n<pre class="groovy"><code class="language-python">add_and_triple = adder_node * <span class="hljs-number"><span\n        class="hljs-number">3.</span></span>\nprint(sess.run(add_and_triple, {<span class="code-string">a:</span> <span class="hljs-number"><span class="hljs-number">3</span></span>, <span\n            class="code-string">b:</span><span class="hljs-number"><span class="hljs-number">4.5</span></span>}))</code></pre>\n<p>计算输出：</p>\n<pre class="css"><code class="css">22<span class="code-selector-class"><span\n        class="code-selector-class">.5</span></span></code></pre>\n<p>TensorBoard中的显示：</p>\n<p><img alt="TensorFlow 使用入门教程" height="337"\n        src="https://file.mahoooo.com/res/file/tensorflow_get_started_2.png" width="280"></p>\n<p>在机器学习中一个模型通常需要接收各种类型的数据作为输入。为了使得模型可以不断的训练通常需要能够针对相同的输入修改图的模型以获取新的输出。<strong>变量（Variables）</strong>可以增加可训练的参数到图中，他们由指定一个初始类型和初始值来创建：\n</p>\n<pre class="ini"><code class="language-python"><span class="hljs-attr">W</span> = tf.Variable([<span\n        class="hljs-number">.<span class="hljs-number">3</span></span>], tf.float32)\n<span class="hljs-attr">b</span> = tf.Variable([<span class="hljs-number">-.<span class="hljs-number">3</span></span>], tf.float32)\n<span class="hljs-attr">x</span> = tf.placeholder(tf.float32)\n<span class="hljs-attr">linear_model</span> = W * x + b</code></pre>\n<p>前面已经提到在调用&nbsp;<code>tf.constant</code>&nbsp;时会初始化不可变更的常量。 而这里通过调用&nbsp;<code>tf.Variable</code>&nbsp;创建的变量不会被初始化，为了在TensorFlow运行之前（<code>sess.run</code>执行模型运算之前）初始化所有的变量，需要增加一步&nbsp;<code>init</code>&nbsp;操作：\n</p>\n<pre class="swift"><code class="swift"><span class="code-keyword"><span class="code-keyword">init</span></span> = tf.global_variables_initializer()\nsess.run(<span class="code-keyword"><span class="code-keyword">init</span></span>)</code></pre>\n<p>可以通过重载&nbsp;<code>init</code>&nbsp;方式来全局初始化所有TensorFlow图中的变量。在上面的代码中，在我们调用&nbsp;<code>sess.run</code>&nbsp;之前，所有的变量都没有初始化。\n</p>\n<p>下面的&nbsp;<code>x</code>&nbsp;是一个占位符，<code>{x:[1,2,3,4]}</code>&nbsp;&nbsp;表示在运算中把x的值替换为[1,2,3,4]：</p>\n<pre class="css"><code class="language-python"><span class="code-selector-tag">print</span>(<span\n        class="code-selector-tag">sess</span><span class="code-selector-class">.run</span>(<span\n        class="code-selector-tag">linear_model</span>, {<span class="code-attribute">x</span>:[<span\n        class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span\n        class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span\n        class="hljs-number"><span class="hljs-number">4</span></span>]}))</code></pre>\n<p>输出：</p>\n<pre class="json"><code class="language-python">[ <span class="hljs-number"><span class="hljs-number">0.</span></span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span\n        class="hljs-number"><span class="hljs-number">0.30000001</span></span> &nbsp;<span class="hljs-number"><span\n        class="hljs-number">0.60000002</span></span> &nbsp;<span class="hljs-number"><span class="hljs-number">0.90000004</span></span>]</code></pre>\n<p>现在已经创建了一个计算模型，但是并不清晰是否足够有效，为了让他越来越有效，需要对这个模型进行数据训练。下面的代码定义名为&nbsp;<code>y</code>&nbsp;的占位符来提供所需的值，然后编写一个“损益功能”（loss\n    function）。</p>\n<p>一个“损益功能”是用来衡量当前的模型对于想达到的输出目标还有多少距离的工具。下面的例子使用线性回归作为损益模型。回归的过程是：计算模型的输出和损益变量（<code>y</code>）的差值，然后再对这个差值进行平方运算（方差），然后再把方差的结果向量进行和运算。下面的代码中，&nbsp;<code>linear_model\n    - y</code>&nbsp;创建了一个向量，向量中的每一个值表示对应的错误增量。然后调用&nbsp;<code>tf.square</code>&nbsp;对错误增量进行平方运算。最后将所有的方差结果相加创建一个数值的标量来抽象的表示错误差异，使用&nbsp;<code>tf.reduce_sum</code>来完成这一步工作。如下列代码：\n</p>\n<pre class="makefile"><code class="language-python"><span class="code-comment"><span class="code-comment"># 定义占位符</span></span>\ny = tf.placeholder(tf.float32)\n<span class="code-comment"><span class="code-comment"># 方差运算</span></span>\nsquared_deltas = tf.square(linear_model - y)\n<span class="code-comment"><span class="code-comment"># 定义损益模型</span></span>\nloss = tf.reduce_sum(squared_deltas)\n<span class="code-comment"><span class="code-comment"># 输出损益计算结果</span></span>\nprint(sess.run(loss, {x:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span\n            class="hljs-number">3</span>,<span class="hljs-number">4</span>], y:[<span\n            class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-2</span>,<span\n            class="hljs-number">-3</span>]}))</code></pre>\n<p>运算之后的差异值是：</p>\n<pre class="css"><code class="css">23<span class="code-selector-class"><span\n        class="code-selector-class">.66</span></span></code></pre>\n<p>\n    可以通过手动将&nbsp;<code>W</code>&nbsp;和&nbsp;<code>b</code>&nbsp;的值修改为-1和1降低差异结果。TensorFlow中使用&nbsp;<code>tf.Variable</code>&nbsp;创建变量，使用&nbsp;<code>tf.assign</code>&nbsp;修改变量。例如&nbsp;<code>W=-1</code>&nbsp;、<code>b=1</code>&nbsp;才是当前模型最佳的值，可以像下面这样修改他们的值：\n</p>\n<pre class="groovy"><code class="language-python">fixW = tf.assign(W, [<span class="hljs-number"><span\n        class="hljs-number">-1.</span></span>])\nfixb = tf.assign(b, [<span class="hljs-number"><span class="hljs-number">1.</span></span>])\nsess.run([fixW, fixb])\nprint(sess.run(loss, {<span class="code-string">x:</span>[<span class="hljs-number"><span\n            class="hljs-number">1</span></span>,<span class="hljs-number"><span\n            class="hljs-number">2</span></span>,<span class="hljs-number"><span\n            class="hljs-number">3</span></span>,<span class="hljs-number"><span\n            class="hljs-number">4</span></span>], <span class="code-string">y:</span>[<span class="hljs-number"><span\n            class="hljs-number">0</span></span>,<span class="hljs-number"><span\n            class="hljs-number">-1</span></span>,<span class="hljs-number"><span\n            class="hljs-number">-2</span></span>,<span class="hljs-number"><span class="hljs-number">-3</span></span>]}))</code></pre>\n<p>修改之后的最终输出结果为：</p>\n<pre class="css"><code class="css">0<span class="code-selector-class"><span class="code-selector-class">.0</span></span></code></pre>\n\n<h3 id="h3-3">tf.train 接口</h3>\n<p>机器学习的完整过程超出了本文的范围，这里仅说明训练的过程。TensorFlow提供了很多优化器来逐渐（迭代或循环）调整每一个参数，最终实现损益值尽可能的小。最简单的优化器之一是“梯度递减”（<strong>gradient\n    descent</strong>），它会对损益计算模型求导，然后根据求导的结果调整输入变量的值（<code>W</code>和<code>b</code>），最终目的让求导的结果逐渐趋向于0。手工进行编写求导运算非常冗长且容易出错，TensorFlow还提供了函数&nbsp;<code>tf.gradients</code>&nbsp;实现自动求导过程。下面的例子展示了使用梯度递减训练样本的过程：\n</p>\n<pre class="bash"><code class="language-python"><span class="code-comment"><span class="code-comment"># 设定优化器，这里的0.01表示训练时的步进值</span></span>\noptimizer = tf.train.GradientDescentOptimizer(<span class="hljs-number">0.01</span>)\ntrain = optimizer.minimize(loss)\nsess.run(init) <span class="code-comment"><span class="code-comment"># 初始化变量值.</span></span>\n<span class="code-keyword"><span class="code-keyword">for</span></span> i <span class="code-keyword"><span\n            class="code-keyword">in</span></span> range(<span class="hljs-number">1000</span>): <span\n            class="code-comment"><span class="code-comment"># 遍历1000次训练数据，每次都重新设置新的W和b值</span></span>\n  sess.run(train, {x:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span\n            class="hljs-number">3</span>,<span class="hljs-number">4</span>], y:[<span\n            class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-2</span>,<span\n            class="hljs-number">-3</span>]})\n\n<span class="code-built_in">print</span>(sess.run([W, b]))</code></pre>\n<p>这个模式的运算结果是：</p>\n<pre class="json"><code class="json">[array([<span class="hljs-number"><span\n        class="hljs-number">-0.9999969</span></span>], dtype=float32), array([ <span class="hljs-number"><span\n        class="hljs-number">0.99999082</span></span>], dtype=float32)]</code></pre>\n<p>\n    现在我们已经完成机器学习的整个过程。虽然进行简单的线性回归计算并不需要用到太多的TensorFlow代码，但是这仅仅是一个用于实例的案例，在实际应用中往往需要编写更多的代码实现复杂的模型匹配运算。TensorFlow为常见的模式、结构和功能提供了更高级别的抽象接口。</p>\n\n<h3 id="h3-4">一个完整的训练过程</h3>\n<p>下面是根据前文的描述，编写的完整线性回归模型：</p>\n<pre class="makefile"><code class="language-python"><span class="code-keyword">import</span> numpy <span\n        class="code-keyword">as</span> np\n<span class="code-keyword">import</span> tensorflow <span class="code-keyword">as</span> tf\n\n<span class="code-comment"><span class="code-comment"># 模型参数</span></span>\nW = tf.Variable([<span class="hljs-number">.3</span>], tf.float32)\nb = tf.Variable([<span class="hljs-number">-.3</span>], tf.float32)\n<span class="code-comment"><span class="code-comment"># 模型输入</span></span>\nx = tf.placeholder(tf.float32)\n<span class="code-comment"><span class="code-comment"># 模型输出</span></span>\nlinear_model = W * x + b\n<span class="code-comment"><span class="code-comment"># 损益评估参数</span></span>\ny = tf.placeholder(tf.float32)\n<span class="code-comment"><span class="code-comment"># 损益模式</span></span>\nloss = tf.reduce_sum(tf.square(linear_model - y)) <span class="code-comment"># 方差和</span>\n<span class="code-comment"><span class="code-comment"># 优化器</span></span>\noptimizer = tf.train.GradientDescentOptimizer(<span class="hljs-number">0.01</span>)\ntrain = optimizer.minimize(loss)\n<span class="code-comment"><span class="code-comment"># 训练数据</span></span>\nx_train = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span\n            class="hljs-number">3</span>,<span class="hljs-number">4</span>]\ny_train = [<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span\n            class="hljs-number">-2</span>,<span class="hljs-number">-3</span>]\n<span class="code-comment"><span class="code-comment"># 定义训练的循环</span></span>\ninit = tf.global_variables_initializer()\nsess = tf.Session()\nsess.run(init) <span class="code-comment"><span class="code-comment"># reset values to wrong</span></span>\n<span class="code-keyword">for</span> i <span class="code-keyword">in</span> range(<span class="hljs-number">1000</span>):\n  sess.run(train, {x:x_train, y:y_train})\n\n<span class="code-comment"><span class="code-comment"># 评估训练结果的精确性</span></span>\ncurr_W, curr_b, curr_loss  = sess.run([W, b, loss], {x:x_train, y:y_train})\nprint(<span class="code-string">"W: %s b: %s loss: %s"</span>%(curr_W, curr_b, curr_loss))</code></pre>\n<p>运行后会输出：</p>\n<pre class="css"><code class="language-python"><span class="code-selector-tag">W</span>: <span\n        class="hljs-selector-attr">[</span><span class="hljs-number"><span class="hljs-selector-attr">-0.9999969</span></span><span\n        class="hljs-selector-attr">]</span> <span class="code-selector-tag">b</span>: <span\n        class="hljs-selector-attr">[ </span><span class="hljs-number"><span class="hljs-selector-attr">0.99999082</span></span><span\n        class="hljs-selector-attr">]</span> <span class="code-selector-tag">loss</span>: <span\n        class="hljs-number">5<span class="code-selector-class">.69997e-11</span></span></code></pre>\n<p>这个复杂的程序仍然可以在TensorBoard中可视化呈现：</p>\n<p><img alt="TensorFlow 使用入门教程" height="721"\n        src="https://file.mahoooo.com/res/file/tensorflow_get_started_3.png" width="832"></p>\n\n<h2 id="h2-4">tf.contrib.learn</h2>\n<p>前面已经提到，TensorFlow除了TensorFlow Core之外，为了便于业务开发还提供了很多更抽象的接口。<code>tf.contrib.learn</code>&nbsp;是TensorFlow的一个高级库，他提供了更加简化的机器学习机制，包括：\n</p>\n<ol>\n    <li>运行训练循环</li>\n    <li>运行评估循环</li>\n    <li>管理数据集合</li>\n    <li>管理训练数据</li>\n</ol>\n<p>tf.contrib.learn&nbsp;定义了一些通用模块。</p>\n\n<h4 id="h4-1">基本用法</h4>\n<p>先看看使用&nbsp;<code>tf.contrib.learn</code>&nbsp;来实现线性回归的方式。</p>\n<pre class="haskell"><code class="language-python"><span class="code-keyword"><span\n        class="code-keyword">import</span></span> tensorflow <span class="code-keyword"><span\n        class="code-keyword">as</span></span> tf\n<span class="code-comment"><span class="code-meta"># NumPy常用语加载、操作、预处理数据.</span></span>\n<span class="code-keyword"><span class="code-keyword">import</span></span> numpy <span class="code-keyword"><span\n            class="code-keyword">as</span></span> np\n\n<span class="code-comment"><span class="code-meta"># 定义一个特性列表features。</span></span>\n<span class="code-comment"><span class="code-meta"># 这里仅仅使用了real-valued特性。还有其他丰富的特性功能</span></span>\n<span class="code-title">features</span> = [tf.contrib.layers.real_valued_column(<span class="code-string"><span\n            class="code-string">"x"</span></span>, dimension=<span class="hljs-number"><span\n            class="hljs-number">1</span></span>)]\n\n<span class="code-comment"><span class="code-meta"># 一个评估者（estimator）是训练（fitting）与评估（inference）的开端。</span></span>\n<span class="code-comment"><span class="code-meta"># 这里预定于了许多类型的训练评估方式，比如线性回归（linear regression）、</span></span>\n<span class="code-comment"><span class="code-meta"># 逻辑回归（logistic regression）、线性分类（linear classification）和回归（regressors）</span></span>\n<span class="code-comment"><span class="code-meta"># 这里的estimator提供了线性回归的功能</span></span>\n<span class="code-title">estimator</span> = tf.contrib.learn.<span class="code-type">LinearRegressor</span>(feature_columns=features)\n\n<span class="code-comment"><span class="code-meta"># TensorFlow提供了许多帮助类来读取和设置数据集合</span></span>\n<span class="code-comment"><span class="code-meta"># 这里使用了‘numpy_input_fn’。</span></span>\n<span class="code-comment"><span class="code-meta"># 我们必须告诉方法我们许多多少批次的数据，以及每次批次的规模有多大。</span></span>\n<span class="code-title">x</span> = np.array([<span class="hljs-number"><span\n            class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span>, <span\n            class="hljs-number"><span class="hljs-number">3.</span></span>, <span class="hljs-number"><span\n            class="hljs-number">4.</span></span>])\n<span class="code-title">y</span> = np.array([<span class="hljs-number"><span\n            class="hljs-number">0.</span></span>, <span class="hljs-number"><span class="hljs-number">-1.</span></span>, <span\n            class="hljs-number"><span class="hljs-number">-2.</span></span>, <span class="hljs-number"><span\n            class="hljs-number">-3.</span></span>])\n<span class="code-title">input_fn</span> = tf.contrib.learn.io.numpy_input_fn({<span class="code-string"><span\n            class="code-string">"x"</span></span>:x}, y, batch_size=<span class="hljs-number"><span class="hljs-number">4</span></span>,\n                                              num_epochs=<span class="hljs-number"><span class="hljs-number">1000</span></span>)\n\n<span class="code-comment"><span class="code-meta"># ‘fit’方法通过指定steps的值来告知方法要训练多少次数据</span></span>\n<span class="code-title">estimator</span>.fit(input_fn=input_fn, steps=<span class="hljs-number"><span\n            class="hljs-number">1000</span></span>)\n\n<span class="code-comment"><span class="code-meta"># 最后我们评估我们的模型价值。在一个实例中，我们希望使用单独的验证和测试数据集来避免过度拟合。</span></span>\n<span class="code-title">estimator</span>.evaluate(input_fn=input_fn)</code></pre>\n<p>运行后输出：</p>\n<pre class="lua"><code class="language-python">&nbsp; &nbsp; {<span class="code-string"><span class="code-string">\'global_step\'</span></span>: <span\n        class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="code-string"><span\n        class="code-string">\'loss\'</span></span>: <span class="hljs-number"><span\n        class="hljs-number">1.9650059e-11</span></span>}</code></pre>\n\n<h4 id="h4-2">自定义模型</h4>\n<p><code>tf.contrib.learn</code>&nbsp;并不限定只能使用它预设的模型。假设现在需要创建一个未预设到TensorFlow中的模型。我们依然可以使用<code>tf.contrib.learn</code>保留数据集合、训练数据、训练过程的高度抽象。我们将使用我们对较低级别TensorFlow\n    API的了解，展示如何使用LinearRegressor实现自己的等效模型。</p>\n<p>使用&nbsp;<code>tf.contrib.learn</code>&nbsp;创建一个自定义模型需要用到它的子类&nbsp;<code>tf.contrib.learn.Estimator</code>&nbsp;。而&nbsp;<code>tf.contrib.learn.LinearRegressor</code>&nbsp;是&nbsp;&nbsp;<code>tf.contrib.learn.Estimator</code>&nbsp;的子类。下面的代码中为&nbsp;<code>Estimator</code>&nbsp;新增了一个&nbsp;<code>model_fn</code>&nbsp;功能，这个功能将告诉&nbsp;<code>tf.contrib.learn</code>&nbsp;如何进行评估、训练以及损益计算：\n</p>\n<pre class="python"><code class="language-python"><span class="code-keyword"><span\n        class="code-keyword">import</span></span> numpy <span class="code-keyword"><span class="code-keyword">as</span></span> np\n<span class="code-keyword"><span class="code-keyword">import</span></span> tensorflow <span class="code-keyword"><span\n            class="code-keyword">as</span></span> tf\n<span class="code-comment"><span class="code-comment"># 定义一个特征数组，这里仅提供实数特征</span></span>\n<span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">def</span></span></span><span\n        class="hljs-function"> </span><span class="code-title"><span class="hljs-function"><span class="code-title">model</span></span></span><span\n        class="hljs-params"><span class="hljs-function"><span class="hljs-params">(features, labels, mode)</span></span></span><span\n        class="hljs-function">:</span></span>\n  <span class="code-comment"><span class="code-comment"># 构建线性模型和预设值</span></span>\n  W = tf.get_variable(<span class="code-string"><span class="code-string">"W"</span></span>, [<span class="hljs-number"><span\n            class="hljs-number">1</span></span>], dtype=tf.float64)\n  b = tf.get_variable(<span class="code-string"><span class="code-string">"b"</span></span>, [<span class="hljs-number"><span\n            class="hljs-number">1</span></span>], dtype=tf.float64)\n  y = W*features[<span class="code-string"><span class="code-string">\'x\'</span></span>] + b\n  <span class="code-comment"><span class="code-comment"># 损益子图</span></span>\n  loss = tf.reduce_sum(tf.square(y - labels))\n  <span class="code-comment"><span class="code-comment"># 训练子图</span></span>\n  global_step = tf.train.get_global_step()\n  optimizer = tf.train.GradientDescentOptimizer(<span class="hljs-number"><span class="hljs-number">0.01</span></span>)\n  train = tf.group(optimizer.minimize(loss),\n                   tf.assign_add(global_step, <span class="hljs-number"><span class="hljs-number">1</span></span>))\n  <span class="code-comment"><span class="code-comment"># ModelFnOps方法将创建我们自定义的一个抽象模型。</span></span>\n  <span class="code-keyword"><span class="code-keyword">return</span></span> tf.contrib.learn.ModelFnOps(\n      mode=mode, predictions=y,\n      loss=loss,\n      train_op=train)\n\nestimator = tf.contrib.learn.Estimator(model_fn=model)\n<span class="code-comment"><span class="code-comment"># 定义数据集</span></span>\nx = np.array([<span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span\n            class="hljs-number">2.</span></span>, <span class="hljs-number"><span class="hljs-number">3.</span></span>, <span\n            class="hljs-number"><span class="hljs-number">4.</span></span>])\ny = np.array([<span class="hljs-number"><span class="hljs-number">0.</span></span>, <span class="hljs-number"><span\n            class="hljs-number">-1.</span></span>, <span class="hljs-number"><span class="hljs-number">-2.</span></span>, <span\n            class="hljs-number"><span class="hljs-number">-3.</span></span>])\ninput_fn = tf.contrib.learn.io.numpy_input_fn({<span class="code-string"><span class="code-string">"x"</span></span>: x}, y, <span\n            class="hljs-number"><span class="hljs-number">4</span></span>, num_epochs=<span class="hljs-number"><span\n            class="hljs-number">1000</span></span>)\n\n<span class="code-comment"><span class="code-comment"># 训练数据</span></span>\nestimator.fit(input_fn=input_fn, steps=<span class="hljs-number"><span class="hljs-number">1000</span></span>)\n<span class="code-comment"><span class="code-comment"># 评估模型</span></span>\nprint(estimator.evaluate(input_fn=input_fn, steps=<span class="hljs-number"><span class="hljs-number">10</span></span>))</code></pre>\n<p>运行后输出：</p>\n<pre class="lua"><code class="language-python">{<span class="code-string"><span class="code-string">\'loss\'</span></span>: <span\n        class="hljs-number"><span class="hljs-number">5.9819476e-11</span></span>, <span class="code-string"><span\n        class="code-string">\'global_step\'</span></span>: <span class="hljs-number"><span class="hljs-number">1000</span></span>}</code></pre>\n\n<h2 id="h2-5">接下来做什么</h2>\n<p>阅读了到这里，你应该初步了解如何在TensorFlow中进行开发和编码。但是如果你刚踏入机器学习的领域，就算很仔细的看了本文，对于如何使用TensorFlow进行机器学习基本上还是懵逼的。<span\n        style="color:#FF0000">请继续阅读</span><a href="https://my.oschina.net/chkui/blog/888346" rel="nofollow">《MNIST\n    机器学习入门</a>》<span style="color:#FF0000">，文章给出了一个完整的机器学习建模案例，适合零知识入门机器学习。</span></p>'}});