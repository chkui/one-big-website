webpackJsonp([14],{356:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<p>\n    React提供了一系列声明性的API接口，因此在使用时不必担心每次库的更新会修改API接口。这样可以降低编写应用的复杂度，但是带来的问题是无法很好的理解React是如何实现这些功能的。这篇文章会介绍React的差异比对算法——“融合算法”是如何执行的。</p>\n\n<h2 id="h2-1">差异匹配算法实现的前提</h2>\n<p>我们先来看看第一个值得关注的我问题：&nbsp;<code>render()</code>&nbsp;方法的作用是创建React元素的树形结构，当state或props发生更新后，&nbsp;<code>render()</code>&nbsp;会返回一个与之前有差异的结构树。在这个机制下，React需要弄清楚如何匹配最近的树并有效的更新UI。\n</p>\n<p>针对以上问题，有一些通用的算法可供参考，比如比对2颗树的差异，在前一个颗树的基础上生成最小操作树，但是这个算法的时间复杂度为n的三次方=O(n*n*n)，当树的节点较多时，这个算法的时间代价会导致算法几乎无法工作。</p>\n<p>\n    假设在我们使用React时，一共使用了1000个Dom标签元素，那么使用上面的算法，我们要比对数亿次才能得到比对的结果，根本不可能在一个浏览器中短时间完成。React实现了一个计算复杂度是O(n)的算法来解决这个问题，这个算法基于2个假设：</p>\n<ol>\n    <li>不同类型的2个标签元素产生不同的树。</li>\n    <li>开发人员可以为不同的子节点在渲染之前设定一个“key”属性值。</li>\n</ol>\n\n<h2 id="h2-2">差异算法</h2>\n<p>对于2颗有差异的树，React首先比对2颗树的根节点。根据跟节点的类型是否相同，算法接下来会执行不同的操作。</p>\n\n<h2 id="h2-3">Types不一样</h2>\n<p>\n    一旦2棵树之间的根元素类型不一样，React会直接移除旧的树并构建出新的树。例如从&nbsp;<code>&lt;a&gt;</code>&nbsp;变更为&nbsp;<code>&lt;img&gt;</code>、&nbsp;<code>&lt;Article&gt;</code>&nbsp;变更为&nbsp;<code>&lt;Comment&gt;</code>、&nbsp;<code>&lt;Button&gt;</code>&nbsp;变更为&nbsp;<code>&lt;div&gt;</code>&nbsp;，所有的这些变化都会导致整颗树重构。\n</p>\n<p>重构一棵新的树时，所有的旧节点都会移除。组件的<code>componentWillUnmount()</code>方法会被调用。&nbsp;然后到构建完成之后新的Dom会替换原来的Dom。此时组件的<code>componentWillMount()</code>和<code>componentDidMount()</code>会依次被调用。旧树Dom上的所有状态都会丢失。\n</p>\n<p>根据这个特性，根节点之后的所有组件都会卸载并重建，状态也会随之改变。例如下面2个组件对比：</p>\n<pre class="xml"><code class="language-html xml"><span class="code-tag"><span class="code-tag">&lt;</span><span\n        class="code-name"><span class="code-tag"><span class="code-name">div</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">Counter</span></span></span><span class="code-tag"> /&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n        class="code-name">div</span></span></span><span class="code-tag">&gt;</span></span>\n\n<span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n        class="code-name">span</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">Counter</span></span></span><span class="code-tag"> /&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n        class="code-name">span</span></span></span><span class="code-tag">&gt;</span></span></code></pre>\n<p><code>Counter</code>&nbsp;组件会被销毁并重新安装一个新的组件。</p>\n\n<h2 id="h2-4">Dom元素拥有相同的类型</h2>\n<p>当比较React元素为相同类型时，React会查看元素上的属性来比对。比对之后，React会保持的Dom节点不改变然后仅仅更新不同的属性值，例如：</p>\n<pre class="xml"><code class="language-html xml"><span class="code-tag"><span class="code-tag">&lt;</span><span\n        class="code-name"><span class="code-tag"><span class="code-name">div</span></span></span><span\n        class="code-tag"> </span><span class="hljs-attr"><span class="code-tag"><span class="hljs-attr">className</span></span></span><span\n        class="code-tag">=</span><span class="code-string"><span class="code-tag"><span\n        class="code-string">"before"</span></span></span><span class="code-tag"> </span><span class="hljs-attr"><span\n        class="code-tag"><span class="hljs-attr">title</span></span></span><span class="code-tag">=</span><span\n        class="code-string"><span class="code-tag"><span class="code-string">"stuff"</span></span></span><span\n        class="code-tag"> /&gt;</span></span>\n\n<span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n        class="code-name">div</span></span></span><span class="code-tag"> </span><span class="hljs-attr"><span\n        class="code-tag"><span class="hljs-attr">className</span></span></span><span class="code-tag">=</span><span\n        class="code-string"><span class="code-tag"><span class="code-string">"after"</span></span></span><span\n        class="code-tag"> </span><span class="hljs-attr"><span class="code-tag"><span\n        class="hljs-attr">title</span></span></span><span class="code-tag">=</span><span class="code-string"><span\n        class="code-tag"><span class="code-string">"stuff"</span></span></span><span\n        class="code-tag"> /&gt;</span></span></code></pre>\n<p>在比对这2个元素之后，React知道仅仅需要修改当前Dom的<code>className</code>。在更新<code>style</code>时，React同样知道仅仅需要更新修改部分即可。例如：</p>\n<pre class="groovy"><code class="language-html xml"><span class="code-tag">&lt;<span class="code-name">div</span> <span\n        class="hljs-attr">style</span>=<span class="code-string">{{<span class="code-string">color:</span></span> <span\n        class="code-string">\'</span><span class="hljs-attr"><span class="code-string">red</span></span><span\n        class="code-string">\'</span>, <span class="hljs-attr"><span class="code-string">fontWeight:</span></span> <span\n        class="code-string">\'</span><span class="hljs-attr"><span class="code-string">bold</span></span><span\n        class="code-string">\'</span>}} /&gt;</span>\n\n<span class="code-tag">&lt;<span class="code-name">div</span> <span class="hljs-attr">style</span>=<span\n        class="code-string">{{<span class="code-string">color:</span></span> <span class="code-string">\'</span><span\n        class="hljs-attr"><span class="code-string">green</span></span><span class="code-string">\'</span>, <span\n        class="hljs-attr"><span class="code-string">fontWeight:</span></span> <span class="code-string">\'</span><span\n        class="hljs-attr"><span class="code-string">bold</span></span><span class="code-string">\'</span>}} /&gt;</span></code></pre>\n<p>在转换这2个组件时，React知道仅仅需要修改color的样式，而fontWeight不必发生变动。</p>\n<p>在处理完当前Dom节点后，React依次对子节点进行递归。</p>\n\n<h2 id="h2-5">组件元素拥有相同的类型</h2>\n<p>当一个组件发生更新后，实例依然是原来的实例，所以状态还是以前的状态。React通过属性值（props）的更新来影响需要更新组件，此时组件实例的&nbsp;<code>componentWillReceiveProps()</code>&nbsp;和&nbsp;<code>componentWillUpdate()</code>&nbsp;方法会被调用。\n</p>\n<p>然后，&nbsp;<code>render()</code>&nbsp;方法会被调用并返回一个Dom，差异算法会递归比对之前返回Dom的差异。</p>\n\n<h2 id="h2-6">递归子元素</h2>\n<p>默认情况下，在递归子元素的Dom节点时，React同时对2个子元素列表进行迭代比对，如果发现差异都会产生一个突变（<a title="React性能优化"\n                                                               href="https://www.chkui.com/article/react/react_optimizing_performance"\n                                                               rel="nofollow">关于突变的概念请见React学习第六篇性能优化介绍不可变数据结构部分</a>）。\n</p>\n<p>例如，当增加一个元素在子元素的队尾，这2颗树的转换效率很高：</p>\n<pre class="xml"><code class="language-html xml"><span class="code-tag"><span class="code-tag">&lt;</span><span\n        class="code-name"><span class="code-tag"><span class="code-name">ul</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>first<span class="code-tag"><span\n            class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>second<span\n            class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n        class="code-name">ul</span></span></span><span class="code-tag">&gt;</span></span>\n\n<span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n        class="code-name">ul</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>first<span class="code-tag"><span\n            class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>second<span\n            class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>third<span class="code-tag"><span\n            class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n        class="code-name">ul</span></span></span><span class="code-tag">&gt;</span></span></code></pre>\n<p>React先匹配&nbsp;<code>&lt;li&gt;first&lt;/li&gt;</code>&nbsp;2棵树，然后再匹配&nbsp;<code>&lt;li&gt;second&lt;/li&gt;</code>&nbsp;。最后直接就添加&nbsp;<code>&lt;li&gt;third&lt;/li&gt;</code>&nbsp;节点。\n</p>\n<p>如果代码按下面的方式修改2颗树，执行的效率相对较差：</p>\n<pre class="xml"><code class="language-html xml"><span class="code-tag"><span class="code-tag">&lt;</span><span\n        class="code-name"><span class="code-tag"><span class="code-name">ul</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>Duke<span\n            class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>Villanova<span\n            class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n        class="code-name">ul</span></span></span><span class="code-tag">&gt;</span></span>\n\n<span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n        class="code-name">ul</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>Connecticut<span\n            class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>Duke<span\n            class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>Villanova<span\n            class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n        class="code-name">ul</span></span></span><span class="code-tag">&gt;</span></span></code></pre>\n<p>\n    React会突变修改所有的子节点，最终&nbsp;<code>&lt;li&gt;Duke&lt;/li&gt;</code>&nbsp;and&nbsp;<code>&lt;li&gt;Villanova&lt;/li&gt;</code>&nbsp;会被重新渲染。所以这种方式会带来很大的效率问题。\n</p>\n\n<h2 id="h2-7">Keys</h2>\n<p>为了解决上面的问题，React提供了一个“key”属性。当所有的子元素都有一个key值，React直接使用key值来比对树形结构中的所有子节点列表。例如为上面的的例子增加一个key会大大的提升转换效率：</p>\n<pre class="xml"><code class="language-html xml"><span class="code-tag"><span class="code-tag">&lt;</span><span\n        class="code-name"><span class="code-tag"><span class="code-name">ul</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">li</span></span></span><span class="code-tag"> </span><span class="hljs-attr"><span\n          class="code-tag"><span class="hljs-attr">key</span></span></span><span class="code-tag">=</span><span\n          class="code-string"><span class="code-tag"><span class="code-string">"2015"</span></span></span><span\n          class="code-tag">&gt;</span></span>Duke<span class="code-tag"><span class="code-tag">&lt;/</span><span\n            class="code-name"><span class="code-tag"><span class="code-name">li</span></span></span><span\n            class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">li</span></span></span><span class="code-tag"> </span><span class="hljs-attr"><span\n          class="code-tag"><span class="hljs-attr">key</span></span></span><span class="code-tag">=</span><span\n          class="code-string"><span class="code-tag"><span class="code-string">"2016"</span></span></span><span\n          class="code-tag">&gt;</span></span>Villanova<span class="code-tag"><span class="code-tag">&lt;/</span><span\n            class="code-name"><span class="code-tag"><span class="code-name">li</span></span></span><span\n            class="code-tag">&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n        class="code-name">ul</span></span></span><span class="code-tag">&gt;</span></span>\n\n<span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n        class="code-name">ul</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">li</span></span></span><span class="code-tag"> </span><span class="hljs-attr"><span\n          class="code-tag"><span class="hljs-attr">key</span></span></span><span class="code-tag">=</span><span\n          class="code-string"><span class="code-tag"><span class="code-string">"2014"</span></span></span><span\n          class="code-tag">&gt;</span></span>Connecticut<span class="code-tag"><span class="code-tag">&lt;/</span><span\n            class="code-name"><span class="code-tag"><span class="code-name">li</span></span></span><span\n            class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">li</span></span></span><span class="code-tag"> </span><span class="hljs-attr"><span\n          class="code-tag"><span class="hljs-attr">key</span></span></span><span class="code-tag">=</span><span\n          class="code-string"><span class="code-tag"><span class="code-string">"2015"</span></span></span><span\n          class="code-tag">&gt;</span></span>Duke<span class="code-tag"><span class="code-tag">&lt;/</span><span\n            class="code-name"><span class="code-tag"><span class="code-name">li</span></span></span><span\n            class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">li</span></span></span><span class="code-tag"> </span><span class="hljs-attr"><span\n          class="code-tag"><span class="hljs-attr">key</span></span></span><span class="code-tag">=</span><span\n          class="code-string"><span class="code-tag"><span class="code-string">"2016"</span></span></span><span\n          class="code-tag">&gt;</span></span>Villanova<span class="code-tag"><span class="code-tag">&lt;/</span><span\n            class="code-name"><span class="code-tag"><span class="code-name">li</span></span></span><span\n            class="code-tag">&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n        class="code-name">ul</span></span></span><span class="code-tag">&gt;</span></span></code></pre>\n<p>现在React可以知道key=\'2014\'的节点是一个新值另外2个节点仅仅需要移动一下位置。</p>\n<p>在实际使用中，key值并不难找。在常规业务中，很多列表都自然包含业务相关的ID了：</p>\n<pre class="dust"><code class="language-html xml"><span class="code-tag"><span class="xml"><span\n        class="code-tag">&lt;</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span\n        class="code-name">li</span></span></span></span><span class="xml"><span class="code-tag"> </span></span><span\n        class="hljs-attr"><span class="xml"><span class="code-tag"><span\n        class="hljs-attr">key</span></span></span></span><span class="xml"><span class="code-tag">=</span></span><span\n        class="code-string"><span class="code-template-variable">{item.id}</span></span><span class="xml"><span\n        class="code-tag">&gt;</span></span></span><span class="code-template-variable">{item.name}</span><span\n        class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span\n        class="xml"><span class="code-tag"><span class="code-name">li</span></span></span></span><span class="xml"><span\n        class="code-tag">&gt;</span></span></span></code></pre>\n<p>当无法使用业务ID时，也可以额外增加一个ID值来标记列表差异，比如根据要使用的数据生成一个hash值，React不需要key值全局唯一，只需要在兄弟节点之间保持唯一即可。</p>\n<p>最差情况下，你可以使用索引数据（0、1、2、....n）。使用索引需要注意的是，如果列表发生重新排序效率会很糟糕。</p>\n\n<h2 id="h2-8">一些常见的问题</h2>\n<p>在使用React时需要谨记每次调用 <strong><em>render()</em></strong>\n    方法，它总会尝试比对调用前后2棵树是否一致。在某些极端情况下，虽然最终呈现效果并没有发生多大的变化，但是有可能每一个简单的操作都导致React全局重新渲染(例如列表没有Key)。</p>\n<p>\n    React在当前版本的实现中还存在一个问题，可以快捷的告知React子树中某个节点的位置已经发生改变，但是无法告知React他移动到了什么位置。因此在遇到这种情况时，算法会重构整个子树。这个问题告诉我们，如果遇到弹窗之类需要偶尔出现的组件，最好是通过隐藏属性控制他，而非直接移除Dom。</p>\n<p>React依赖启发式算法，如果本文开篇提到的2个基本假设不成立，那么会导致算法效率极差。</p>\n<ol>\n    <li>算法不会尝试匹配不同2个组件之间的子树。如果编码中发现2个组件之间有非常相似的输出，应该尝试将2个组件合并为一个类型的组件。在实际应用中，我们还没发现这样导致问题。</li>\n    <li>用作列表的key值最好是稳定、可预见、唯一的。易变的key值（比如由<code>Math.random()</code>方法生成的值）将会导致许多组件实例和Dom节点被非必要的重新创建，这会导致性能低下且子组件丢失已有的状态。&nbsp;\n    </li>\n</ol>'},390:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h2 id="h2-1">Resource——资源</h2>\n<p>对于一个联机事务型系统（业务系统）来说，所依赖的外部运行信息主要有2个来源：<strong>数据项</strong>和<strong>资源项</strong>。数据项的存放位置通常是使用各种关系性或NoSql数据库，而资源项通常是使用文件、网络信息的方式来存储。\n</p>\n<p>早在JDK1.0的时代Java就已经提供了本地资源和网络资源的读取功能——<strong>java.net.URL</strong>。他可以同时管理本地资源（操作系统资源）以及网络资源，如下面这个例子：</p>\n<p>（文中的代码仅仅用于说明问题，源码请到<a href="https://gitee.com/chkui-com/spring-core-sample" rel="nofollow">案例gitee库下载</a>，对应的代码在包<em>chkui.springcore.example.hybrid.resource</em>中。）\n</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n\t\tclass="code-title">ResourceApp</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n\t\t\tclass="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> <span\n\t\t\tclass="code-keyword">throws</span> MalformedURLException </span>{\n\t\t<span class="code-comment">//读取本地资源</span>\n\t\tURL url = ResourceApp.class.getResource(<span class="code-string">"/extend.properties"</span>);\n\t\tprint(url);\n\t\t<span class="code-comment">//读取互联网资源</span>\n\t\turl = <span class="code-keyword">new</span> URL(<span class="code-string">"http"</span>, <span\n\t\t\tclass="code-string">"www.baidu.com"</span>, <span class="hljs-number">80</span>, <span class="code-string">""</span>);\n\t\tprint(url);\n\t\turl = <span class="code-keyword">new</span> URL(<span class="code-string">"https"</span>, <span\n\t\t\tclass="code-string">"www.chkui.com"</span>, <span class="hljs-number">443</span>, <span class="code-string">"/174870bb04.js"</span>);\n\t\tprint(url);\n\t}\n}\n<span class="code-comment">// 输出</span>\n<span class="code-comment">// file:/work/chkui/spring-core-sample/bin/main/extend.properties</span>\n<span class="code-comment">// http://www.baidu.com:80</span>\n<span class="code-comment">// https://www.chkui.com:443/174870bb04.js</span></code></pre>\n<p>\n\t对于每一个类来说getResource方法可以获取当前类所在的系统路径（getResource("")），以及classpath的路径（getResource("/")），利用这个功能我们可以获取操作系统上所知的任何资源。除了本地文件，URL也可以通过域名规则来获取网络上的资源。</p>\n<p>注意输出内容中的开头<strong><em>file:</em></strong> 、<strong><em>http:</em></strong>以及<strong><em>https:</em></strong>，他们表示资源的协议，除了以上这三者，还有<strong><em>ftp:、mailto:</em></strong>等协议。关于URL的详细解释可以看<a\n\t\thref="http://www.ietf.org/rfc/rfc2396.txt" rel="nofollow">ITEF标准</a>。</p>\n<p>URL指向某一个资源之后，可以使用URL::openStream或URL::getFile等方法进一步获取文件中的内容：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n\t\tclass="code-title">ResourceApp</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n\t\t\tclass="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> <span\n\t\t\tclass="code-keyword">throws</span> MalformedURLException </span>{\n\t\tUrl url = <span class="code-keyword">new</span> URL(<span class="code-string">"https"</span>, <span\n\t\t\tclass="code-string">"www.chkui.com"</span>, <span class="hljs-number">443</span>, <span class="code-string">"/174870bb04.js"</span>);\n\t\t<span class="code-keyword">try</span>(InputStream is = url.openStream()){\n\t\t\t<span class="code-keyword">byte</span>[] buffer = <span class="code-keyword">new</span> <span\n\t\t\tclass="code-keyword">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>];\n\t\t\tis.read(buffer);\n\t\t\tString content = <span class="code-keyword">new</span> String(buffer, Charset.forName(<span\n\t\t\tclass="code-string">"UTF-8"</span>));\n\t\t\tprint(<span class="code-string">"Content :"</span>, content);\n\t\t} <span class="code-keyword">catch</span> (IOException e) {\n\t\t}\n\t}\n}</code></pre>\n\n<h2 id="h2-2">Spring中的资源管理</h2>\n<p>Spring的资源管理在JDK的基础功能上进行了强大的扩展，即使你不用Spring的整个生态或者容器，你也可以将其资源管理作为一个工具整合到自己的系统中而提高效率。它扩展了以下内容：</p>\n<ol>\n\t<li>\n\t\t隐藏底层实现。对于各种各样的资源Spring都使用了不同的实现类来管理，但是他利用适配器模式让使用者仅仅需要了解<strong><em>org.springframework.core.io.Resource</em></strong>接口即可。\n\t</li>\n\t<li>新增资源存在判断、资源操作权限相关的功能，相对于<em>java.net.URL</em>资源不存在则设置为null更友好。</li>\n\t<li>支持通配符来获取资源，例如 ：<em>classpath:a/b/**/applicationContext-*.xml。</em></li>\n</ol>\n\n<h2 id="h2-3">协议与路径</h2>\n<p>在前面的内容中就提到了多个协议，spring的资源管理功能除了标准的协议，还增加了一个——<strong><em>classpath:</em></strong>协议，他表示从当前的classpath根路径开始获取资源。对于Spring的资源管理功能而言，主要有以下几种协议：\n</p>\n<table border="1" cellpadding="1" cellspacing="1" style="width:500px">\n\t<tbody>\n\t<tr>\n\t\t<th>协议&nbsp;</th>\n\t\t<th>例子</th>\n\t\t<th>说明</th>\n\t</tr>\n\t</tbody>\n\t<tbody>\n\t<tr>\n\t\t<td>classpath:</td>\n\t\t<td>classpath:res/extend.properties</td>\n\t\t<td>从当前jvm的classpath根路径开始获取资源。</td>\n\t</tr>\n\t<tr>\n\t\t<td>file:</td>\n\t\t<td>file:///tmp/myfile.data</td>\n\t\t<td>从操作系统(文件路径)的路径获取资源。</td>\n\t</tr>\n\t<tr>\n\t\t<td>http(s):</td>\n\t\t<td>http(s)://www.chkui.com/</td>\n\t\t<td>从互联网获取资源。</td>\n\t</tr>\n\t<tr>\n\t\t<td>(无标记)</td>\n\t\t<td>/data/extend.data</td>\n\t\t<td>根据应用上下文获取资源。</td>\n\t</tr>\n\t</tbody>\n</table>\n<p><strong><em>classpath:</em></strong>、<strong><em>file:</em></strong>、<strong><em>http(s):</em></strong>这三个协议都很明确的指明了获取资源的路径，但是没有声明协议的情况就比较特殊，他需要根据上下文来判定适用的路径。\n</p>\n<p>在<a href="https://www.chkui.com/article/spring/spring_core_context_and_ioc" title="上下文与IoC">上下文与IoC</a>这篇文章中已经介绍过，经过层层继承和实现，Spring提供容器实现功能的主要是<strong><em>ClassPathXmlApplicationContext</em></strong>和<strong><em>FileSystemXmlApplicationContext</em></strong>两个类，这两个Context本质上都是实现了相同的Context功能，最明显的区别之一就是加载文件的路径不同。比如下面的情况：\n</p>\n<pre><code class="java">ApplicationContext ctx = <span\n\t\tclass="code-keyword">new</span> ClassPathXmlApplicationContext(<span class="code-string">"config/ctx.xml"</span>);</code></pre>\n<p>ClassPathXmlApplicationContext默认启用的是<em>ClassPathResource</em>来管理资源，所以上面的路径配置相当于"classpath:config/ctx.xml"。但是如果修改为以下形式：\n</p>\n<pre><code class="java">ApplicationContext ctx = <span\n\t\tclass="code-keyword">new</span> ClassPathXmlApplicationContext(<span class="code-string">"file:///config/ctx.xml"</span>);</code></pre>\n<p>通过协议明确告知路径规则，那么在<em>ApplicationContext</em>会使用对应的<em>FileSystemResource</em>来加载管理资源。</p>\n<p>而<strong><em>FileSystemXmlApplicationContext</em></strong>与<strong><em>ClassPathXmlApplicationContext</em></strong>相互对应——默认使用的<em>FileSystemResource</em>，可以通过声明协议来指定对应的资源加载类。\n</p>\n<p>上面的内容提到了<em>ClassPathResource和FileSystemResource。</em>Spring为不同类型、协议的资源指定了各种各种的<strong><em>org.springframework.core.io.Resource</em></strong>实现类，主要有&nbsp;<em>UrlResource、ClassPathResource、FileSystemResource、ServletContextResource、InputStreamResource、ByteArrayResource</em>。从字面上看大概能了解对应的功能。在使用的时候我们并不需要了解他们的具体实现，只要知道不同的协议对应的资源路径即可。\n</p>\n\n<h2 id="h2-4">获取资源的方法</h2>\n\n<h3 id="h3-1">直接使用ApplicationContext</h3>\n<p>\n\t在明确所支持的协议之后，我们就可以用ResourcePatternResolver::getResources方法来获取资源。ApplicationContext继承了ResourcePatternResolver接口，所以我们通常使用以下方法获取资源：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.resource;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n\t\t\tclass="code-title">ResourceApp</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n\t\t\tclass="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span></span>{\n\t\tApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(ResourceApp.class);\n\t\tResource res = ctx.getResource(<span class="code-string">"classpath:extend.properties"</span>);\n\t\tprint(<span class="code-string">"Resource :"</span>, res);\n\t\tres = ctx.getResource(<span class="code-string">"https://www.chkui.com"</span>);\n\t\tprint(<span class="code-string">"Resource :"</span>, res);\n\t}\n}</code></pre>\n\n<h3 id="h3-2">ResourceLoaderAware注入</h3>\n<p>除了直接使用ApplicationContext，还可以通过继承ResourceLoaderAware的方式来获取资源加载接口：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.resource;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n\t\t\tclass="code-title">LoadResourceBean</span> <span class="code-keyword">implements</span> <span\n\t\t\tclass="code-title">ResourceLoaderAware</span></span>{\n\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n\t\t\tclass="code-title">setResourceLoader</span><span class="hljs-params">(ResourceLoader resourceLoader)</span> </span>{\n\t\tResource res = resourceLoader.getResource(<span class="code-string">"classpath:extend.properties"</span>);\n\t\tSystem.out.println(<span class="code-string">"Bean load Resource :"</span> + res);\n\t}\n}\n</code></pre>\n<p>\n\t实际上这里传入进来的ResourceLoader就是ApplicationContext，所以用ApplicationContextAware也可以实现对应的功能。但是为了明确功能的用途，这里最好还是实现ResourceLoaderAware比较合理。</p>\n\n<h3 id="h3-3">Autowired注入</h3>\n<p>在2.5.x之后，spring可以使用<a href="https://www.chkui.com/article/spring/spring_core_auto_inject_of_annotation"\n\t\t\t\t\t\t title="注解自动装载">@Autowired注解</a>引入ResourceLoader（ApplicationContext）：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.resource;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n\t\t\tclass="code-title">LoadResourceBean</span> <span class="code-keyword">implements</span> <span\n\t\t\tclass="code-title">ResourceLoaderAware</span></span>{\n\t<span class="code-meta">@Autowired</span>\n\tResourceLoader resourceLoader;\n\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n\t\t\tclass="code-title">setResourceLoader</span><span class="hljs-params">(ResourceLoader resourceLoader)</span> </span>{\n\t\tSystem.out.println(<span class="code-string">"Is ApplicationContext? "</span> + (<span\n\t\t\tclass="code-keyword">this</span>.resourceLoader == resourceLoader));\n\t\tResource res = <span class="code-keyword">this</span>.resourceLoader.getResource(<span class="code-string">"classpath:extend.properties"</span>);\n\t\tSystem.out.println(<span class="code-string">"Bean load Resource :"</span> + res);\n\t}\n}</code></pre>\n<p>和普通的Bean一样，还可以通过构造方法和setter方法注入ResourceLoader。</p>\n\n<h3 id="h3-4">XML配置获取资源</h3>\n<p>我们可以直接在XML中指定资源路径，然后在setter或构造方法中获取到对应的资源，看下面的例子。</p>\n<p>XMLConfigBean的Set方法直接获取一个<em>Resource</em>：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.resource;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n\t\t\tclass="code-title">XMLConfigBean</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n\t\t\tclass="code-title">setResource</span><span class="hljs-params">(Resource res)</span> <span\n\t\t\tclass="code-keyword">throws</span> IOException </span>{\n\t\tSystem.out.println(<span class="code-string">"XML load Resource :"</span> + res);\n\t\tProperties p = <span class="code-keyword">new</span> Properties();\n\t\tp.load(res.getInputStream());\n\t\tSystem.out.println(<span class="code-string">"Properties Info: "</span> + p.getProperty(<span\n\t\t\tclass="code-string">"info"</span>));\n\t}\n}</code></pre>\n<p>我们只需要在XML配置文件中指定资源路径位置，Spring会自动帮我们完成转换：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span>&gt;</span>\n\t<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n\t\t\tclass="code-string">"chkui.springcore.example.hybrid.resource.XMLConfigBean"</span>&gt;</span>\n\t\t<span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n\t\t\t\tclass="code-string">"resource"</span> <span class="hljs-attr">value</span>=<span class="code-string">"classpath:extend.properties"</span>/&gt;</span>\n\t<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>在XMLConfigBean::setResource方法中我们拿到的是"classpath:extend.properties"这一项资源。</p>\n\n<h2 id="h2-5">通配符指定资源</h2>\n<p>除了使用指定固定路径的方式获取一项资源，我们还可以使用"?"、"*"等通配符使用匹配规则来获取资源，例如：</p>\n<pre><code class="java">Resource[] resList = ctx.getResources(<span\n\t\tclass="code-string">"classpath:hybrid/**/*.xml"</span>);</code></pre>\n<p>Spring官网将这种资源匹配规则称为“Ant-style匹配”，虽然并不知道源自什么地方（应该是源自<em>Apache Ant</em>项目，但是我在Ant项目文档中还没看到对应的说明，心细致的码友可以再找找），但是Spring官方文档对其有详细的说明，详见<a\n\t\thref="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/util/AntPathMatcher.html"\n\t\trel="nofollow">AntPathMatcher的说明</a>。Ant-style的匹配规则大致如下：</p>\n<ol>\n\t<li>"?"：匹配一个字符。例如<em>"classpath:conf?g.xml"</em>匹配<em>"classpath:config.xml"</em>也匹配<em>"classpath:conf1g.xml"</em>但是不匹配<em>"classpath:conf12g.xml"</em>。\n\t</li>\n\t<li>"*"：匹配0到多个字符。例如<em>"classpath:*.xml"匹配classpath根目录下所有.xml文件。而"classpath:config/*.xml"匹配config文件夹中所有.xml文件。</em>\n\t</li>\n\t<li><em>"**"：匹配0到多个目录。例如"classpath:**/*.xml"匹配整个classpath下所有*.xml文件。"</em><em>classpath:config/**/*.xml"匹配config文件夹以及所有子文件夹的.xml文件。</em>\n\t</li>\n\t<li>{arg1:{a-z}+}：匹配任意多个a-z的字符，并将匹配到的内容赋值到变了arg1中。该条规则实用于<a\n\t\t\thref="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/util/AntPathMatcher.html"\n\t\t\trel="nofollow">AntPathMatcher</a>，当无法在ApplicationContext的资源匹配规则中使用。\n\t</li>\n</ol>\n\n<h3 id="h3-5">classpath*:扩展</h3>\n<p>在通配符的基础上，spring扩展了一个<strong><em>classpath*:</em></strong>协议。</p>\n<p>\n\t对于一个运行的Jvm来说，classpath的“根目录”一般有多个。比如在当前开发的工程有一个包含main方法的类文件——chkui/example/spinrg/app.class，此时引入一个jar包也包含一个一样的类文件chkui/example/spring/app.class（有空的码友可以自己试试Jvm到底运行哪个）。这种情况对于Jvm来说就引出"多个classpath"和"首选classpath"的概念，而classpath:和classpath*的差异就是，前者从首选classpath中优先获取资源，而后者会从所有classpath中寻找资源。而首先classpath一般是我们当前工程的编译文件（案例代码在<em>[project-root]/bin/main</em>）。\n</p>\n<p>其实在Jvm的资源加载方式上已经对<em><strong>classpath:</strong></em>和<strong><em>classpath*:</em></strong>提供了不同的实现，但是理解起来比较“绕”。一般情况下我们使用Class::getResource都是获取首选classpath路径下的资源，而使用ClassLoader::getResources(classPath)可以获取所有classpath下的资源。\n</p>\n<p>下面的代码展示了这个过程，案例代码在<a\n\t\thref="https://gitee.com/chkui-com/spring-core-sample/blob/master/src/main/java/chkui/springcore/example/hybrid/resource/ResourceApp.java"\n\t\trel="nofollow">chkui.springcore.example.hybrid.resource.ResourceApp::multiResourceLoad</a>方法中。</p>\n<p>为了演示这个过程我们引入了Google的Guava包（因为整个工程都没用到guava的内容，所以修改他的类不会产生影响），然后对应的在自己的工程中增加一个Guava包中相同的package和类：</p>\n<pre><code class="java"><span class="code-keyword">package</span> com.google.common.base;\n<span class="code-keyword">public</span> <span class="code-keyword">final</span> <span class="hljs-class"><span\n\t\t\tclass="code-keyword">class</span> <span class="code-title">Preconditions</span> </span>{}</code></pre>\n<p>在编译之后，会在bin文件夹（如果是maven就是/target）中产生一个main/com/google/common/base/Preconditions.class文件。然后通过下面的代码测试资源加载：</p>\n<pre><code class="java"><span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n\t\tclass="code-keyword">void</span> <span class="code-title">multiResourceLoad</span><span\n\t\tclass="hljs-params">()</span> <span class="code-keyword">throws</span> IOException </span>{\n\t\t<span class="code-keyword">final</span> String classPath = <span class="code-string">"com/google/common/base/Preconditions.class"</span>;\n\n\t\t<span class="code-comment">//class.getResource需要使用"/"表示root路径</span>\n        <span class="code-comment">//首选路径的资源</span>\n\t\tprint(<span class="code-string">"classpath: "</span>, ResourceApp.class.getResource(<span class="code-string">"/"</span> + classPath));\n\t\t<span class="code-comment">//Verify没有被覆盖，输出Jar包中的内容,注意jar:file: 协议的格式</span>\n\t\tprint(<span class="code-string">"In Jar classpath: "</span>, ResourceApp.class.getResource(<span\n\t\t\tclass="code-string">"/"</span> + unMultiClassPath));\n\n\t\t<span class="code-comment">//ClassLoader::getResource获取首选路径资源</span>\n\t\tprint(<span class="code-string">"First classpath: "</span>, Verify.class.getClassLoader().getResource(classPath));\n\t\t<span class="code-comment">//ClassLoader::getResources获取所有资源</span>\n\t\tEnumeration&lt;URL&gt; e = ResourceApp.class.getClassLoader().getResources(classPath);\n\t\t<span class="code-keyword">int</span> count = <span class="hljs-number">1</span>;\n\t\t<span class="code-keyword">while</span> (e.hasMoreElements()) {\n\t\t\tURL url = e.nextElement();\n\t\t\tprint(<span class="code-string">"classpath*["</span>, count++ ,<span class="code-string">"]:"</span>, url);\n\t\t}\n\t}</code></pre>\n<p>\n\t运行之后，只有在最后的迭代器中输出了Guava包中的Preconditions.class的路径，而其余位置都输出的是我自行创建的Preconditions.class，也就是首选classpath下的Preconditions.class，首选的资源也就是ClassLoader::getResources获取的迭代器的第一个值。</p>\n<p>Spring的<strong><em>classpath*:</em></strong>协议实际上底层也是用<em>ClassLoader::getResources</em>的方式实现的，不过扩展了支持通配符并将资源转换为org.springframework.core.io.Resource。上面用JDK演示的代码用spring的资源管理实现为下面的形式：\n</p>\n<pre><code class="java"><span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n\t\tclass="code-keyword">void</span> <span class="code-title">multiResourceLoad</span><span class="hljs-params">(ApplicationContext ctx)</span></span>{\n    ApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext();\n    <span class="code-keyword">final</span> String classPath = <span class="code-string">"com/google/common/base/Preconditions.class"</span>;\n    <span class="code-keyword">final</span> String unMultiClassPath = <span class="code-string">"com/google/common/base/Verify.class"</span>;\n    print(<span class="code-string">"classpath: "</span>, Arrays.asList(ctx.getResources(<span class="code-string">"classpath:"</span> + classPath)));\n    print(<span class="code-string">"classpath*: "</span>, Arrays.asList(ctx.getResources(<span class="code-string">"classpath*:"</span> + classPath)));\n    print(<span class="code-string">"unmulti-classpath*: "</span>, Arrays.asList(ctx.getResources(<span\n\t\t\tclass="code-string">"classpath*:"</span> + unMultiClassPath)));\n}</code></pre>\n\n<h2 id="h2-6">Spring中的各项资源</h2>\n<p>\n\t不仅仅是ApplicationContext::getResources方法，实际上Spring中绝大部分外部资源加载都是通过前面介绍的规则使用同一个工具类完成的，所以我们可以在许多地方使用对应的"协议"来管理我们的资源，比如下面的例子：</p>\n<pre><code class="java"><span class="code-meta">@ImportResource</span>(<span class="code-string">"classpath:hybrid/resource/config-*.xml"</span>)\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n\t\t\tclass="code-title">ResourceApp</span> </span>{}</code></pre>'},399:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<p>批处理任务的主要业务逻辑都是在<code>Step</code>中去完成的。可以将<code>Job</code>理解为运行<code>Step</code>的框架，而<code>Step</code>理解为业务功能。</p>\n<h2 id="h2-1">Step配置</h2>\n<p><code>Step</code>是<code>Job</code>中的工作单元，每一个<code>Step</code>涵盖了单行记录的处理闭环。下图是一个<code>Step</code>的简要结构：</p>\n<p><img src="https://docs.spring.io/spring-batch/4.2.x/reference/html/images/step.png" alt="Spring Batch(3)——Step控制"\n        class="zoom-in-cursor"></p>\n<p>一个<code>Step</code>通常涵盖三个部分：读数据（Reader）、处理数据（Processor）和写数据（Writer）。但是并不是所有的<code>Step</code>都需要自身来完成数据的处理，比如存储过程等方式是通过外部功能来完成，因此Spring\n    Batch提供了2种Step的处理方式：1）面向分片的<code>ChunkStep</code>，2）面向过程的<code>TaskletStep</code>。但是基本上大部分情况下都是使用面向分片的方式来解决问题。</p>\n<h2 id="h2-2">面向分片的处理过程</h2>\n<p>在<code>Step</code>中数据是按记录（按行）处理的，但是每条记录处理完毕之后马上提交事物反而会导致IO的巨大压力。因此Spring\n    Batch提供了数据处理的分片功能。设置了分片之后，一次工作会从Read开始，然后交由给Processor处理。处理完毕后会进行聚合，待聚合到一定的数量的数据之后一次性调用Write将数据提交到物理数据库。其过程大致为：</p>\n<p><img src="https://docs.spring.io/spring-batch/4.2.x/reference/html/images/chunk-oriented-processing.png"\n        alt="Spring Batch(3)——Step控制" class="zoom-in-cursor"></p>\n<p>在Spring Batch中所谓的事物和数据事物的概念一样，就是一次性提交多少数据。如果在聚合数据期间出现任何错误，所有的这些数据都将不执行写入。</p>\n<h2 id="h2-3">面向对象配置Step</h2>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Job <span class="code-title">sampleJob</span><span\n        class="hljs-params">(JobRepository jobRepository, Step sampleStep)</span> </span>{\n    <span class="code-keyword">return</span> <span class="code-keyword">this</span>.jobBuilderFactory.get(<span\n            class="code-string">"sampleJob"</span>)\n    \t\t\t.repository(jobRepository)\n                .start(sampleStep)\n                .build();\n}\n\n<span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Step <span\n        class="code-title">sampleStep</span><span\n        class="hljs-params">(PlatformTransactionManager transactionManager)</span> </span>{\n\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>.stepBuilderFactory.get(<span\n            class="code-string">"sampleStep"</span>)\n\t\t\t\t.transactionManager(transactionManager)\n\t\t\t\t.&lt;String, String&gt;chunk(<span class="hljs-number">10</span>) <span\n            class="code-comment">//分片配置</span>\n\t\t\t\t.reader(itemReader()) <span class="code-comment">//reader配置</span>\n\t\t\t\t.writer(itemWriter()) <span class="code-comment">//write配置</span>\n\t\t\t\t.build();\n}\n</code></pre>\n<p>观察sampleStep方法：</p>\n<ol>\n    <li>reader: 使用ItemReader提供读数据的方法。</li>\n    <li>write：ItemWrite提供写数据的方法。</li>\n    <li>transactionManager：使用默认的 <code>PlatformTransactionManager</code> 对事物进行管理。<strong>当配置好事物之后Spring\n        Batch会自动对事物进行管理，无需开发人员显示操作</strong>。\n    </li>\n    <li>chunk：指定一次性数据提交的记录数，因为任务是基于Step分次处理的，当累计到chunk配置的次数则进行一次提交。提交的内容除了业务数据，还有批处理任务运行相关的元数据。</li>\n</ol>\n<p>是否使用<code>ItemProcessor</code>是一个可选项。如果没有Processor可以将数据视为读取并直接写入。</p>\n<h2 id="h2-4">提交间隔</h2>\n<p><code>Step</code>使用<code>PlatformTransactionManager</code>管理事物。每次事物提交的间隔根据<code>chunk</code>方法中配置的数据执行。如果设置为1，那么在每一条数据处理完之后都会调用<code>ItemWrite</code>进行提交。提交间隔设置太小，那么会浪费需要多不必要的资源，提交间隔设置的太长，会导致事物链太长占用空间，并且出现失败会导致大量数据回滚。因此设定一个合理的间隔是非常必要的，这需要根据实际业务情况、性能要求、以及数据安全程度来设定。如果没有明确的评估目标，设置为10~20较为合适。\n</p>\n<h2 id="h2-5">配置Step重启</h2>\n<p>前文介绍了<code>Job</code>的重启，但是每次重启对<code>Step</code>也是有很大的影响的，因此需要特定的配置。</p>\n<h3 id="h3-1">限定重启次数</h3>\n<p>某些<code>Step</code>可能用于处理一些先决的任务，所以当Job再次重启时这<code>Step</code>就没必要再执行，可以通过设置startLimit来限定某个<code>Step</code>重启的次数。当设置为1时候表示仅仅运行一次，而出现重启时将不再执行：\n</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Step <span class="code-title">step1</span><span\n        class="hljs-params">()</span> </span>{\n\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>.stepBuilderFactory.get(<span\n            class="code-string">"step1"</span>)\n\t\t\t\t.&lt;String, String&gt;chunk(<span class="hljs-number">10</span>)\n\t\t\t\t.reader(itemReader())\n\t\t\t\t.writer(itemWriter())\n\t\t\t\t.startLimit(<span class="hljs-number">1</span>)\n\t\t\t\t.build();\n}\n</code></pre>\n<h3 id="h3-2">重启已经完成任务的Step</h3>\n<p>\n    在单个<code>JobInstance</code>的上下文中，如果某个<code>Step</code>已经处理完毕（COMPLETED）那么在默认情况下重启之后这个<code>Step</code>并不会再执行。可以通过设置<code>allow-start-if-complete</code>为true告知框架每次重启该<code>Step</code>都要执行：\n</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Step <span class="code-title">step1</span><span\n        class="hljs-params">()</span> </span>{\n\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>.stepBuilderFactory.get(<span\n            class="code-string">"step1"</span>)\n\t\t\t\t.&lt;String, String&gt;chunk(<span class="hljs-number">10</span>)\n\t\t\t\t.reader(itemReader())\n\t\t\t\t.writer(itemWriter())\n\t\t\t\t.allowStartIfComplete(<span class="code-keyword">true</span>)\n\t\t\t\t.build();\n}\n</code></pre>\n<h2 id="h2-6">配置略过逻辑</h2>\n<p>某些时候在任务处理单个记录时中出现失败并不应该停止任务，而应该跳过继续处理下一条数据。是否跳过需要根据业务来判定，因此框架提供了跳过机制交给开发人员使用。如何配置跳过机制：</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Step <span class="code-title">step1</span><span\n        class="hljs-params">()</span> </span>{\n\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>.stepBuilderFactory.get(<span\n            class="code-string">"step1"</span>)\n\t\t\t\t.&lt;String, String&gt;chunk(<span class="hljs-number">10</span>)\n\t\t\t\t.reader(flatFileItemReader())\n\t\t\t\t.writer(itemWriter())\n\t\t\t\t.faultTolerant()\n\t\t\t\t.skipLimit(<span class="hljs-number">10</span>)\n\t\t\t\t.skip(FlatFileParseException.class)\n\t\t\t\t.build();\n}\n</code></pre>\n<p>代码的含义是当处理过程中抛出<code>FlatFileParseException</code>异常时就跳过该条记录的处理。<code>skip-limit</code>（skipLimit方法）配置的参数表示当跳过的次数超过数值时则会导致整个<code>Step</code>失败，从而停止继续运行。还可以通过反向配置的方式来忽略某些异常：\n</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Step <span class="code-title">step1</span><span\n        class="hljs-params">()</span> </span>{\n\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>.stepBuilderFactory.get(<span\n            class="code-string">"step1"</span>)\n\t\t\t\t.&lt;String, String&gt;chunk(<span class="hljs-number">10</span>)\n\t\t\t\t.reader(flatFileItemReader())\n\t\t\t\t.writer(itemWriter())\n\t\t\t\t.faultTolerant()\n\t\t\t\t.skipLimit(<span class="hljs-number">10</span>)\n\t\t\t\t.skip(Exception.class)\n\t\t\t\t.noSkip(FileNotFoundException.class)\n\t\t\t\t.build();\n}\n</code></pre>\n<p><code>skip</code>表示要当捕捉到<em>Exception</em>异常就跳过。但是<em>Exception</em>有很多继承类，此时可以使用<code>noSkip</code>方法指定某些异常不能跳过。</p>\n<h2 id="h2-7">设置重试逻辑</h2>\n<p>当处理记录出个异常之后并不希望他立即跳过或者停止运行，而是希望可以多次尝试执行直到失败：</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Step <span class="code-title">step1</span><span\n        class="hljs-params">()</span> </span>{\n\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>.stepBuilderFactory.get(<span\n            class="code-string">"step1"</span>)\n\t\t\t\t.&lt;String, String&gt;chunk(<span class="hljs-number">2</span>)\n\t\t\t\t.reader(itemReader())\n\t\t\t\t.writer(itemWriter())\n\t\t\t\t.faultTolerant()\n\t\t\t\t.retryLimit(<span class="hljs-number">3</span>)\n\t\t\t\t.retry(DeadlockLoserDataAccessException.class)\n\t\t\t\t.build();\n}\n</code></pre>\n<p><code>retry(DeadlockLoserDataAccessException.class)</code>表示只有捕捉到该异常才会重试，<code>retryLimit(3)</code>表示最多重试3次，<code>faultTolerant()</code>表示启用对应的容错功能。\n</p>\n<h2 id="h2-8">事物回滚控制</h2>\n<p>默认情况下，无论是设置了重试（retry）还是跳过（skip），只要从<code>Writer</code>抛出一个异常都会导致事物回滚。如果配置了skip机制，那么在<code>Reader</code>中抛出的异常不会导致回滚。有些从<code>Writer</code>抛出一个异常并不需要回滚数据，<code>noRollback</code>属性为<code>Step</code>提供了不必进行事物回滚的异常配置：\n</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Step <span class="code-title">step1</span><span\n        class="hljs-params">()</span> </span>{\n\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>.stepBuilderFactory.get(<span\n            class="code-string">"step1"</span>)\n\t\t\t\t.&lt;String, String&gt;chunk(<span class="hljs-number">2</span>)\n\t\t\t\t.reader(itemReader())\n\t\t\t\t.writer(itemWriter())\n\t\t\t\t.faultTolerant()\n\t\t\t\t.noRollback(ValidationException.class) <span class="code-comment">//不必回滚的异常</span>\n\t\t\t\t.build();\n}\n</code></pre>\n<h2 id="h2-9">事物数据读取的缓存</h2>\n<p>一次<code>Setp</code>分为<code>Reader</code>、<code>Processor</code>和<code>Writer</code>三个阶段，这些阶段统称为<code>Item</code>。默认情况下如果错误不是发生在Reader阶段，那么没必要再去重新读取一次数据。但是某些场景下需要Reader部分也需要重新执行，比如Reader是从一个JMS队列中消费消息，当发生回滚的时候消息也会在队列上重放，因此也要将Reader纳入到回滚的事物中，根据这个场景可以使用<code>readerIsTransactionalQueue</code>来配置数据重读：\n</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Step <span class="code-title">step1</span><span\n        class="hljs-params">()</span> </span>{\n\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>.stepBuilderFactory.get(<span\n            class="code-string">"step1"</span>)\n\t\t\t\t.&lt;String, String&gt;chunk(<span class="hljs-number">2</span>)\n\t\t\t\t.reader(itemReader())\n\t\t\t\t.writer(itemWriter())\n\t\t\t\t.readerIsTransactionalQueue() <span class="code-comment">//数据重读</span>\n\t\t\t\t.build();\n}\n</code></pre>\n<h2 id="h2-10">事物属性</h2>\n<p>\n    事物的属性包括<strong>隔离等级（isolation）</strong>、<strong>传播方式（propagation）<strong>以及</strong>过期时间（timeout）</strong>。关于事物的控制详见<a\n        href="https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#transaction"\n        title="Spring Data Access">Spring Data Access</a>的说明，下面是相关配置的方法：</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Step <span class="code-title">step1</span><span\n        class="hljs-params">()</span> </span>{\n\t<span class="code-comment">//配置事物属性</span>\n\tDefaultTransactionAttribute attribute = <span class="code-keyword">new</span> DefaultTransactionAttribute();\n\tattribute.setPropagationBehavior(Propagation.REQUIRED.value());\n\tattribute.setIsolationLevel(Isolation.DEFAULT.value());\n\tattribute.setTimeout(<span class="hljs-number">30</span>);\n\n\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>.stepBuilderFactory.get(<span\n            class="code-string">"step1"</span>)\n\t\t\t\t.&lt;String, String&gt;chunk(<span class="hljs-number">2</span>)\n\t\t\t\t.reader(itemReader())\n\t\t\t\t.writer(itemWriter())\n\t\t\t\t.transactionAttribute(attribute) <span class="code-comment">//设置事物属性</span>\n\t\t\t\t.build();\n}\n</code></pre>\n<h2 id="h2-11">向Step注册 ItemStream</h2>\n<p><code>ItemStream</code>是用于每一个阶段（Reader、Processor、Writer）的“生命周期回调数据处理器”，后续的文章会详细介绍<code>ItemStream</code>。在4.×版本之后默认注入注册了通用的<code>ItemStream</code>。\n</p>\n<p>有2种方式将<code>ItemStream</code>注册到<code>Step</code>中，一是使用<code>stream</code>方法：</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Step <span class="code-title">step1</span><span\n        class="hljs-params">()</span> </span>{\n\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>.stepBuilderFactory.get(<span\n            class="code-string">"step1"</span>)\n\t\t\t\t.&lt;String, String&gt;chunk(<span class="hljs-number">2</span>)\n\t\t\t\t.reader(itemReader())\n\t\t\t\t.writer(compositeItemWriter())\n\t\t\t\t.stream(fileItemWriter1())\n\t\t\t\t.stream(fileItemWriter2())\n\t\t\t\t.build();\n}\n</code></pre>\n<p>二是使用相关方法的代理：</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> CompositeItemWriter <span class="code-title">compositeItemWriter</span><span\n        class="hljs-params">()</span> </span>{\n\tList&lt;ItemWriter&gt; writers = <span class="code-keyword">new</span> ArrayList&lt;&gt;(<span\n            class="hljs-number">2</span>);\n\twriters.add(fileItemWriter1());\n\twriters.add(fileItemWriter2());\n\tCompositeItemWriter itemWriter = <span class="code-keyword">new</span> CompositeItemWriter();\n\titemWriter.setDelegates(writers);\n\t<span class="code-keyword">return</span> itemWriter;\n}\n</code></pre>\n<h2 id="h2-12">StepExecution拦截器</h2>\n<p>在<code>Step</code>执行的过程中会产生各种各样的事件，开发人员可以利用各种<code>Listener</code>接口对<code>Step</code>及<code>Item</code>进行监听。通常在创建一个Step的时候添加拦截器：\n</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Step <span class="code-title">step1</span><span\n        class="hljs-params">()</span> </span>{\n\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>.stepBuilderFactory.get(<span\n            class="code-string">"step1"</span>)\n\t\t\t\t.&lt;String, String&gt;chunk(<span class="hljs-number">10</span>)\n\t\t\t\t.reader(reader())\n\t\t\t\t.writer(writer())\n\t\t\t\t.listener(chunkListener()) <span class="code-comment">//添加拦截器</span>\n\t\t\t\t.build();\n}\n</code></pre>\n<p>Spring Batch提供了多个接口以满足不同事件的监听。</p>\n<h3 id="h3-3">StepExecutionListener</h3>\n<p><code>StepExecutionListener</code>可以看做一个通用的<code>Step</code>拦截器，他的作用是在Step开始之前和结束之后进行拦截处理：</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">StepExecutionListener</span> <span class="code-keyword">extends</span> <span\n        class="code-title">StepListener</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">beforeStep</span><span\n            class="hljs-params">(StepExecution stepExecution)</span></span>; <span\n            class="code-comment">//Step执行之前</span>\n    <span class="hljs-function">ExitStatus <span class="code-title">afterStep</span><span class="hljs-params">(StepExecution stepExecution)</span></span>; <span\n            class="code-comment">//Step执行完毕之后</span>\n}\n</code></pre>\n<p>在结束的时候开发人员可以自己定义返回的<code>ExitStatus</code>，用于配合流程控制（见后文）实现对整个Step执行过程的控制。</p>\n<h3 id="h3-4">ChunkListener</h3>\n<p><code>ChunkListener</code>是在数据事物发生的两端被触发。<code>chunk</code>的配置决定了处理多少项记录才进行一次事物提交，<code>ChunkListener</code>的作用就是对一次事物开始之后或事物提交之后进行拦截：\n</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">ChunkListener</span> <span class="code-keyword">extends</span> <span class="code-title">StepListener</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">beforeChunk</span><span\n            class="hljs-params">(ChunkContext context)</span></span>; <span\n            class="code-comment">//事物开始之后，ItemReader调用之前</span>\n    <span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">afterChunk</span><span\n            class="hljs-params">(ChunkContext context)</span></span>; <span class="code-comment">//事物提交之后</span>\n    <span class="hljs-function"><span class="code-keyword">void</span> <span\n            class="code-title">afterChunkError</span><span\n            class="hljs-params">(ChunkContext context)</span></span>; <span class="code-comment">//事物回滚之后</span>\n}\n</code></pre>\n<p>如果没有设定chunk也可以使用<code>ChunkListener</code>，它会被<code>TaskletStep</code>调用（<code>TaskletStep</code>见后文）。</p>\n<h3 id="h3-5">ItemReadListener</h3>\n<p>该接口用于对<code>Reader</code>相关的事件进行监控：</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">ItemReadListener</span>&lt;<span class="code-title">T</span>&gt; <span class="code-keyword">extends</span> <span\n        class="code-title">StepListener</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">beforeRead</span><span\n            class="hljs-params">()</span></span>;\n    <span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">afterRead</span><span\n            class="hljs-params">(T item)</span></span>;\n    <span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">onReadError</span><span\n            class="hljs-params">(Exception ex)</span></span>;\n}\n</code></pre>\n<p><code>beforeRead</code>在每次<code>Reader</code>调用之前被调用，<code>afterRead</code>在每次<code>Reader</code>成功返回之后被调用，而<code>onReadError</code>会在出现异常之后被调用，可以将其用于记录异常日志。\n</p>\n<h3 id="h3-6">ItemProcessListener</h3>\n<p><code>ItemProcessListener</code>和<code>ItemReadListener</code>类似，是围绕着<code>ItemProcessor</code>进行处理的：</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">ItemProcessListener</span>&lt;<span class="code-title">T</span>, <span\n        class="code-title">S</span>&gt; <span class="code-keyword">extends</span> <span\n        class="code-title">StepListener</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">void</span> <span\n            class="code-title">beforeProcess</span><span class="hljs-params">(T item)</span></span>; <span\n            class="code-comment">//processor执行之前</span>\n    <span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">afterProcess</span><span\n            class="hljs-params">(T item, S result)</span></span>; <span class="code-comment">//processor直线成功之后</span>\n    <span class="hljs-function"><span class="code-keyword">void</span> <span\n            class="code-title">onProcessError</span><span class="hljs-params">(T item, Exception e)</span></span>; <span\n            class="code-comment">//processor执行出现异常</span>\n}\n</code></pre>\n<h3 id="h3-7">ItemWriteListener</h3>\n<p><code>ItemWriteListener</code>的功能和<code>ItemReadListener</code>、<code>ItemReadListener</code>类似，但是需要注意的是它接收和处理的数据对象是一个<code>List</code>。<code>List</code>的长度与chunk配置相关。\n</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">ItemWriteListener</span>&lt;<span class="code-title">S</span>&gt; <span class="code-keyword">extends</span> <span\n        class="code-title">StepListener</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">beforeWrite</span><span\n            class="hljs-params">(List&lt;? extends S&gt; items)</span></span>;\n    <span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">afterWrite</span><span\n            class="hljs-params">(List&lt;? extends S&gt; items)</span></span>;\n    <span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">onWriteError</span><span\n            class="hljs-params">(Exception exception, List&lt;? extends S&gt; items)</span></span>;\n}\n</code></pre>\n<h3 id="h3-8">SkipListener</h3>\n<p><code>ItemReadListener</code>、<code>ItemProcessListener</code>和<code>ItemWriteListener</code>都提供了错误拦截处理的机制，但是没有处理跳过（skip）的数据记录。因此框架提供了<code>SkipListener</code>来专门处理那么被跳过的记录：\n</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">SkipListener</span>&lt;<span class="code-title">T</span>,<span class="code-title">S</span>&gt; <span\n        class="code-keyword">extends</span> <span class="code-title">StepListener</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">onSkipInRead</span><span\n            class="hljs-params">(Throwable t)</span></span>; <span class="code-comment">//Read期间导致跳过的异常</span>\n    <span class="hljs-function"><span class="code-keyword">void</span> <span\n            class="code-title">onSkipInProcess</span><span\n            class="hljs-params">(T item, Throwable t)</span></span>; <span\n            class="code-comment">//Process期间导致跳过的异常</span>\n    <span class="hljs-function"><span class="code-keyword">void</span> <span\n            class="code-title">onSkipInWrite</span><span class="hljs-params">(S item, Throwable t)</span></span>; <span\n            class="code-comment">//Write期间导致跳过的异常</span>\n}\n</code></pre>\n<p><code>SkipListener</code>的价值是可以将那些未能成功处理的记录在某个位置保存下来，然后交给其他批处理进一步解决，或者人工来处理。Spring Batch保证以下2个特征：</p>\n<ol>\n    <li>跳过的元素只会出现一次。</li>\n    <li><code>SkipListener</code>始终在事物提交之前被调用，这样可以保证监听器使用的事物资源不会被业务事物影响。</li>\n</ol>\n<h2 id="h2-13">TaskletStep</h2>\n<p>面向分片（Chunk-oriented processing\n    ）的过程并不是Step的唯一执行方式。比如用数据库的存储过程来处理数据，这个时候使用标准的Reader、Processor、Writer会很奇怪，针对这些情况框架提供了<code>TaskletStep</code>。</p>\n<p><code>TaskletStep</code>是一个非常简单的接口，仅有一个方法——<code>execute</code>。<code>TaskletStep</code>会反复的调用这个方法直到获取一个<code>RepeatStatus.FINISHED</code>返回或者抛出一个异常。所有的<code>Tasklet</code>调用都会包装在一个事物中。\n</p>\n<p>注册一个<code>TaskletStep</code>非常简单，只要添加一个实现了<code>Tasklet</code>接口的类即可：</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Step <span class="code-title">step1</span><span\n        class="hljs-params">()</span> </span>{\n    <span class="code-keyword">return</span> <span class="code-keyword">this</span>.stepBuilderFactory.get(<span\n            class="code-string">"step1"</span>)\n    \t\t\t.tasklet(myTasklet()) <span class="code-comment">//注入Tasklet的实现</span>\n    \t\t\t.build();\n}\n</code></pre>\n<p><code>TaskletStep</code>还支持适配器处理等，详见<a\n        href="https://docs.spring.io/spring-batch/4.2.x/reference/html/step.html#taskletStep" title="官网说明">官网说明</a>。</p>\n<h2 id="h2-14">控制Step执行流程</h2>\n<h3 id="h3-9">顺序执行</h3>\n<p>默认情况下。Step与Step之间是顺序执行的，如下图：</p>\n<p><img src="https://docs.spring.io/spring-batch/4.2.x/reference/html/images/sequential-flow.png"\n        alt="Spring Batch(3)——Step控制" title="Step顺序执行" class="zoom-in-cursor"></p>\n<p>顺序执行通过<code>next</code>方法来标记：</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Job <span class="code-title">job</span><span\n        class="hljs-params">()</span> </span>{\n\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>.jobBuilderFactory.get(<span\n            class="code-string">"job"</span>)\n\t\t\t\t.start(stepA())\n\t\t\t\t.next(stepB()) <span class="code-comment">//顺序执行</span>\n\t\t\t\t.next(stepC())\n\t\t\t\t.build();\n}\n</code></pre>\n<h3 id="h3-10">条件执行</h3>\n<p>在顺序执行的过程中，在整个执行链条中有一个<code>Step</code>执行失败则整个<code>Job</code>就会停止。但是通过条件执行，可以指定各种情况下的执行分支：</p>\n<p><img src="https://docs.spring.io/spring-batch/4.2.x/reference/html/images/conditional-flow.png"\n        alt="Spring Batch(3)——Step控制" title="Step条件执行" class="zoom-in-cursor"></p>\n<p>为了实现更加复杂的控制，可以通过<code>Step</code>执行后的退出命名来定义条件分之。先看一个简单的代码：</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Job <span class="code-title">job</span><span\n        class="hljs-params">()</span> </span>{\n\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>.jobBuilderFactory.get(<span\n            class="code-string">"job"</span>)\n\t\t\t\t.start(stepA()) <span class="code-comment">//启动时执行的step</span>\n\t\t\t\t.on(<span class="code-string">"*"</span>).to(stepB()) <span class="code-comment">//默认跳转到stepB</span>\n\t\t\t\t.from(stepA()).on(<span class="code-string">"FAILED"</span>).to(stepC()) <span class="code-comment">//当返回的ExitStatus为"FAILED"时，执行。</span>\n\t\t\t\t.end()\n\t\t\t\t.build();\n}\n</code></pre>\n<p>这里使用*来表示默认处理，*是一个通配符表示处理任意字符串，对应的还可以使用?表示匹配任意字符。在<a\n        href="https://www.chkui.com/article/spring/spring_batch_introduction" title="Spring Batch(1)——数据批处理概念">Spring\n    Batch(1)——数据批处理概念</a>一文中介绍了Step的退出都会有<code>ExitStatus</code>，命名都来源于它。下面是一个更加全面的代码。</p>\n<ol>\n    <li>配置拦截器处理ExitCode：</li>\n</ol>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">SkipCheckingListener</span> <span class="code-keyword">extends</span> <span\n        class="code-title">StepExecutionListenerSupport</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> ExitStatus <span\n            class="code-title">afterStep</span><span class="hljs-params">(StepExecution stepExecution)</span> </span>{\n        String exitCode = stepExecution.getExitStatus().getExitCode();\n        <span class="code-keyword">if</span> (!exitCode.equals(ExitStatus.FAILED.getExitCode()) &amp;&amp;\n              stepExecution.getSkipCount() &gt; <span class="hljs-number">0</span>) { <span class="code-comment">//当Skip的Item大于0时，则指定ExitStatus的内容</span>\n            <span class="code-keyword">return</span> <span class="code-keyword">new</span> ExitStatus(<span\n            class="code-string">"COMPLETED WITH SKIPS"</span>);\n        }\n        <span class="code-keyword">else</span> {\n            <span class="code-keyword">return</span> <span class="code-keyword">null</span>;\n        }\n    }\n}\n</code></pre>\n<p>拦截器指示当有一个以上被跳过的记录时，返回的<code>ExitStatus</code>为"COMPLETED WITH SKIPS"。对应的控制流程：</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Job <span class="code-title">job</span><span\n        class="hljs-params">()</span> </span>{\n\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>.jobBuilderFactory.get(<span\n            class="code-string">"job"</span>)\n\t\t\t.start(step1()).on(<span class="code-string">"FAILED"</span>).end() <span\n            class="code-comment">//执行失败直接退出</span>\n\t\t\t.from(step1()).on(<span class="code-string">"COMPLETED WITH SKIPS"</span>).to(errorPrint1()) <span\n            class="code-comment">//有跳过元素执行 errorPrint1()</span>\n\t\t\t.from(step1()).on(<span class="code-string">"*"</span>).to(step2()) <span class="code-comment">//默认（成功）情况下执行 Step2</span>\n\t\t\t.end()\n\t\t\t.build();\n}\n</code></pre>\n<h3 id="h3-11">Step的停机退出机制</h3>\n<p>Spring Batch为<code>Job</code>提供了三种退出机制，这些机制为批处理的执行提供了丰富的控制方法。在介绍退出机制之前需要回顾一下 <a\n        href="https://www.chkui.com/article/spring/spring_batch_introduction" title="数据批处理概念">数据批处理概念</a>一文中关于<code>StepExecution</code>的内容。在<code>StepExecution</code>中有2个表示状态的值，一个名为<code>status</code>，另外一个名为<code>exitStatus</code>。前者也被称为<code>BatchStatus</code>。\n</p>\n<p>前面以及介绍了<code>ExitStatus</code>的使用，他可以控制Step执行链条的条件执行过程。除此之外<code>BatchStatus</code>也会参与到过程的控制。</p>\n<h4 id="h4-1">End退出</h4>\n<p>默认情况下（没有使用<code>end</code>、<code>fail</code>方法结束），<code>Job</code>要顺序执行直到退出，这个退出称为<code>end</code>。这个时候，<code>BatchStatus</code>=<code>COMPLETED</code>、<code>ExitStatus</code>=<code>COMPLETED</code>，表示成功执行。\n</p>\n<p>除了<code>Step</code>链式处理自然退出，也可以显示调用<code>end</code>来退出系统。看下面的例子：</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Job <span class="code-title">job</span><span\n        class="hljs-params">()</span> </span>{\n\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>.jobBuilderFactory.get(<span\n            class="code-string">"job"</span>)\n\t\t\t\t.start(step1()) <span class="code-comment">//启动</span>\n\t\t\t\t.next(step2()) <span class="code-comment">//顺序执行</span>\n\t\t\t\t.on(<span class="code-string">"FAILED"</span>).end()\n\t\t\t\t.from(step2()).on(<span class="code-string">"*"</span>).to(step3()) <span\n            class="code-comment">//条件执行</span>\n\t\t\t\t.end()\n\t\t\t\t.build();\n}\n</code></pre>\n<p>\n    上面的代码，<code>step1</code>到<code>step2</code>是顺序执行，当<code>step2</code>的<code>exitStatus</code>返回"FAILED"时则直接<em>End退出</em>。其他情况执行<code>Step3</code>。\n</p>\n<h4 id="h4-2">Fail退出</h4>\n<p>除了<code>end</code>还可以使用<code>fail</code>退出，这个时候，<code>BatchStatus</code>=<code>FAILED</code>、<code>ExitStatus</code>=<code>EARLY\n    TERMINATION</code>，表示执行失败。这个状态与<code>End</code>最大的区别是<code>Job</code>会尝试重启执行新的<code>JobExecution</code>。看下面代码的例子：\n</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Job <span class="code-title">job</span><span\n        class="hljs-params">()</span> </span>{\n\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>.jobBuilderFactory.get(<span\n            class="code-string">"job"</span>)\n\t\t\t.start(step1()) <span class="code-comment">//执行step1</span>\n\t\t\t.next(step2()).on(<span class="code-string">"FAILED"</span>).fail() <span class="code-comment">//step2的ExitStatus=FAILED 执行fail</span>\n\t\t\t.from(step2()).on(<span class="code-string">"*"</span>).to(step3()) <span\n            class="code-comment">//否则执行step3</span>\n\t\t\t.end()\n\t\t\t.build();\n}\n</code></pre>\n<h4 id="h4-3">在指定的节点中断</h4>\n<p>Spring Batch还支持在指定的节点退出，退出后下次重启会从中断的点继续执行。中断的作用是某些批处理到某个步骤后需要人工干预，当干预完之后又接着处理：</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Job <span class="code-title">job</span><span\n        class="hljs-params">()</span> </span>{\n\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>.jobBuilderFactory.get(<span\n            class="code-string">"job"</span>)\n\t \t\t<span class="code-comment">//如果step1的ExitStatus=COMPLETED则在step2中断</span>\n\t\t\t.start(step1()).on(<span class="code-string">"COMPLETED"</span>).stopAndRestart(step2())\n\t\t\t <span class="code-comment">//否则直接退出批处理</span>\n\t\t\t.end()\n\t\t\t.build();\n}\n</code></pre>\n<h3 id="h3-12">程序化流程的分支</h3>\n<p>可以直接进行编码来控制<code>Step</code>之间的扭转，Spring Batch提供了<code>JobExecutionDecider</code>接口来协助分支管理：</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">MyDecider</span> <span class="code-keyword">implements</span> <span class="code-title">JobExecutionDecider</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> FlowExecutionStatus <span class="code-title">decide</span><span\n            class="hljs-params">(JobExecution jobExecution, StepExecution stepExecution)</span> </span>{\n        String status;\n        <span class="code-keyword">if</span> (someCondition()) {\n            status = <span class="code-string">"FAILED"</span>;\n        }\n        <span class="code-keyword">else</span> {\n            status = <span class="code-string">"COMPLETED"</span>;\n        }\n        <span class="code-keyword">return</span> <span class="code-keyword">new</span> FlowExecutionStatus(status);\n    }\n}\n</code></pre>\n<p>接着将<code>MyDecider</code>作为过滤器添加到配置过程中：</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Job <span class="code-title">job</span><span\n        class="hljs-params">()</span> </span>{\n\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>.jobBuilderFactory.get(<span\n            class="code-string">"job"</span>)\n\t\t\t.start(step1())\n\t\t\t.next(decider()).on(<span class="code-string">"FAILED"</span>).to(step2())\n\t\t\t.from(decider()).on(<span class="code-string">"COMPLETED"</span>).to(step3())\n\t\t\t.end()\n\t\t\t.build();\n}\n</code></pre>\n<h3 id="h3-13">流程分裂</h3>\n<p>在线性处理过程中，流程都是一个接着一个执行的。但是为了满足某些特殊的需要，Spring Batch提供了执行的过程分裂并行<code>Step</code>的方法。参看下面的<code>Job</code>配置：</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Job <span class="code-title">job</span><span\n        class="hljs-params">()</span> </span>{\n\tFlow flow1 = <span class="code-keyword">new</span> FlowBuilder&lt;SimpleFlow&gt;(<span\n            class="code-string">"flow1"</span>)\n\t\t\t.start(step1())\n\t\t\t.next(step2())\n\t\t\t.build();<span class="code-comment">//并行流程1</span>\n\tFlow flow2 = <span class="code-keyword">new</span> FlowBuilder&lt;SimpleFlow&gt;(<span\n            class="code-string">"flow2"</span>)\n\t\t\t.start(step3())\n\t\t\t.build();<span class="code-comment">//并行流程2</span>\n\n\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>.jobBuilderFactory.get(<span\n            class="code-string">"job"</span>)\n\t\t\t\t.start(flow1)\n\t\t\t\t.split(<span class="code-keyword">new</span> SimpleAsyncTaskExecutor()) <span class="code-comment">//创建一个异步执行任务</span>\n\t\t\t\t.add(flow2)\n\t\t\t\t.next(step4()) <span class="code-comment">//2个分支执行完毕之后再执行step4。</span>\n\t\t\t\t.end()\n\t\t\t\t.build();\n}\n</code></pre>\n<p>这里表示flow1和flow2会并行执行，待2者执行成功后执行step4。</p>\n<h3 id="h3-14">数据绑定</h3>\n<p>在<code>Job</code>或<code>Step</code>的任何位置，都可以获取到统一配置的数据。比如使用标准的Spring Framework方式：</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> FlatFileItemReader <span class="code-title">flatFileItemReader</span><span\n        class="hljs-params">(@Value(<span class="code-string">"${input.file.name}"</span>)</span> String name) </span>{\n\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> FlatFileItemReaderBuilder&lt;Foo&gt;()\n\t\t\t.name(<span class="code-string">"flatFileItemReader"</span>)\n\t\t\t.resource(<span class="code-keyword">new</span> FileSystemResource(name))\n\t\t\t...\n}\n</code></pre>\n<p>当我们通过配置文件（application.properties中\n    <code>input.file.name=filepath</code>）或者jvm参数（<code>-Dinput.file.name=filepath</code>）指定某些数据时，都可以通过这种方式获取到对应的配置参数。\n</p>\n<p>此外，也可以从<code>JobParameters</code>从获取到<code>Job</code>运行的上下文参数：</p>\n<pre><code class="Java"><span class="code-meta">@StepScope</span>\n<span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> FlatFileItemReader <span class="code-title">flatFileItemReader</span><span\n        class="hljs-params">(@Value(<span class="code-string">"#{jobParameters[\'input.file.name\']}"</span>)</span> String name) </span>{\n\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> FlatFileItemReaderBuilder&lt;Foo&gt;()\n\t\t\t.name(<span class="code-string">"flatFileItemReader"</span>)\n\t\t\t.resource(<span class="code-keyword">new</span> FileSystemResource(name))\n\t\t\t...\n}\n</code></pre>\n<p>无论是<code>JobExecution</code>还是<code>StepExecution</code>，其中的内容都可以通过这种方式去获取参数，例如：</p>\n<pre><code class="Java"><span class="code-meta">@StepScope</span>\n<span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> FlatFileItemReader <span class="code-title">flatFileItemReader</span><span\n        class="hljs-params">(@Value(<span class="code-string">"#{jobExecutionContext[\'input.file.name\']}"</span>)</span> String name) </span>{\n\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> FlatFileItemReaderBuilder&lt;Foo&gt;()\n\t\t\t.name(<span class="code-string">"flatFileItemReader"</span>)\n\t\t\t.resource(<span class="code-keyword">new</span> FileSystemResource(name))\n\t\t\t...\n}\n</code></pre>\n<p>或者</p>\n<pre><code class="Java"><span class="code-meta">@StepScope</span>\n<span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> FlatFileItemReader <span class="code-title">flatFileItemReader</span><span\n        class="hljs-params">(@Value(<span\n        class="code-string">"#{stepExecutionContext[\'input.file.name\']}"</span>)</span> String name) </span>{\n\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> FlatFileItemReaderBuilder&lt;Foo&gt;()\n\t\t\t.name(<span class="code-string">"flatFileItemReader"</span>)\n\t\t\t.resource(<span class="code-keyword">new</span> FileSystemResource(name))\n\t\t\t...\n}\n</code></pre>\n<h4 id="h4-4">Step Scope</h4>\n<p>注意看上面的代码例子，都有一个<code>@StepScope</code>注解。这是为了进行后期绑定进行的标识。因为在Spring的IoCs容器进行初始化的阶段并没有任何的<code>*Execution</code>在执行，进而也不存在任何<code>*ExecutionContext</code>，所以这个时候根本无法注入标记的数据。所以需要使用注解显式的告诉容器直到<code>Step</code>执行的阶段才初始化这个<code>@Bean</code>。\n</p>\n<h4 id="h4-5">Job Scope</h4>\n<p>Job Scope的概念和 Step Scope类似，都是用于标识在到了某个执行时间段再添加和注入Bean。<code>@JobScope</code>用于告知框架知道<code>JobInstance</code>存在时候才初始化对应的<code>@Bean</code>：\n</p>\n<pre><code class="Java"><span class="code-meta">@JobScope</span>\n<span class="code-meta">@Bean</span>\n<span class="code-comment">// 初始化获取 jobParameters中的参数</span>\n<span class="hljs-function"><span class="code-keyword">public</span> FlatFileItemReader <span class="code-title">flatFileItemReader</span><span\n        class="hljs-params">(@Value(<span\n        class="code-string">"#{jobParameters[input]}"</span>)</span> String name) </span>{\n\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> FlatFileItemReaderBuilder&lt;Foo&gt;()\n\t\t\t.name(<span class="code-string">"flatFileItemReader"</span>)\n\t\t\t.resource(<span class="code-keyword">new</span> FileSystemResource(name))\n\t\t\t...\n}\n</code></pre>\n<pre><code class="Java"><span class="code-meta">@JobScope</span>\n<span class="code-meta">@Bean</span>\n<span class="code-comment">// 初始化获取jobExecutionContext中的参数</span>\n<span class="hljs-function"><span class="code-keyword">public</span> FlatFileItemReader <span class="code-title">flatFileItemReader</span><span\n        class="hljs-params">(@Value(<span class="code-string">"#{jobExecutionContext中的参数[\'input.name\']}"</span>)</span> String name) </span>{\n\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> FlatFileItemReaderBuilder&lt;Foo&gt;()\n\t\t\t.name(<span class="code-string">"flatFileItemReader"</span>)\n\t\t\t.resource(<span class="code-keyword">new</span> FileSystemResource(name))\n\t\t\t...\n}\n</code></pre>'}});