webpackJsonp([14],{348:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='\n<p>通常情况下，图形界面的发行版 <em><strong>linux</strong></em> 可以在 <strong><em>Setting-&gt;Device-&gt;Display</em></strong> 中直接设置多个屏幕的分辨率。但是坑总是无处不在的，有时候明明用得好好的分辨率就出毛病了，而且不能在界面上设置。此时可以通过 <em><strong>xrandr</strong></em> 命令来直接设置分辨率。</p>\n\n<h2 id="h2-1">常规方法</h2>\n<p>1.查看显示模式参数：</p>\n<pre class="bash"><code class="language-bash"><span class="code-comment"><span class="code-comment">#1440 900就是要修改的分辨率，根据需要可以使用1920 1080、1720 900等</span></span>\n<span class="code-variable"><span class="code-variable">$cvt</span></span> 1440 900\n<span class="code-comment"><span class="code-comment">#输出内容</span></span>\n1440x900 59.89 Hz (CVT 1.30MA) hsync: 55.93 kHz; pclk: 106.50 MHz\nModeline <span class="code-string"><span class="code-string">"1440x900_60.00"</span></span>  106.50  1440 1528 1672 1904  900 903 909 934 -hsync +vsync</code></pre>\n<p>Modeline之后的内容就是我们后面添加显示模式要使用的参数。</p>\n<p>2.通过addMode命令增加一个现实模式：</p>\n<pre class="bash"><code class="language-bash"><span class="code-comment"><span class="code-comment">#将Modeline的阿才能书复制到 --newmode之后即可</span></span>\n<span class="code-comment"><span class="code-comment">#后面的参数可以根据需要调整，请查阅cvt相关的说明</span></span>\n<span class="code-variable"><span class="code-variable">$xrandr</span></span> --newmode <span class="code-string"><span class="code-string">"1440x900_60.00"</span></span>  106.50  1440 1528 1672 1904  900 903 909 934 -hsync +vsync</code></pre>\n<p>3.增加到对应的显示器。</p>\n<p>先用xrandr命令查询对应的显示器：</p>\n<pre class="scss"><code class="language-bash"><span class="code-variable"><span class="code-variable">$xrandr</span></span>\n<span class="code-comment">#输出类似以下的内容</span>\nWAYLAND0 connected primary 1366x768+0+0 (<span class="code-attribute">normal</span> <span class="code-attribute">left</span> inverted <span class="code-attribute">right</span> x axis y axis) 309mm x 173mm\n   1366x768      60<span class="code-selector-class">.00</span>*+\n   1360x768      59<span class="code-selector-class">.80</span>    59<span class="code-selector-class">.96</span>\n   1024x768      60<span class="code-selector-class">.04</span>    60<span class="code-selector-class">.00</span>\n   960x720       60<span class="code-selector-class">.00</span>\n   928x696       60<span class="code-selector-class">.05</span>\nWAYLAND1 connected 1024x768+1366+0 (<span class="code-attribute">normal</span> <span class="code-attribute">left</span> inverted <span class="code-attribute">right</span> x axis y axis) 0mm x 0mm\n   1024x768      60<span class="code-selector-class">.00</span>*\n   800x600       60<span class="code-selector-class">.32</span>    56<span class="code-selector-class">.25</span>\n   848x480       60<span class="code-selector-class">.00</span>\n   640x480       59<span class="code-selector-class">.94</span>\n</code></pre>\n<p>记住WAYLAND0\\WAYLAND1的名称，这是我们显示器的代理名称。通常用手提的话WAYLAND0就是对应的手提电脑的显示器、其余的都是扩增屏幕。</p>\n<p>然后向对应显示器下增加一个模式：</p>\n<pre class="bash"><code class="language-bash"><span class="code-variable"><span class="code-variable">$xrandr</span></span> --addmode WAYLAND1 <span class="code-string"><span class="code-string">"1440x900_60.00"</span></span></code></pre>\n<p>然后就OK了..........</p>\n\n<h2 id="h2-2">遇到的问题</h2>\n<p>但是，要是天底下的事情都这么轻松世界就完美了。</p>\n\n<h3 id="h3-1">问题一，xrand命令指针对当前用户</h3>\n<p>在使用 xrand命令时切记是针对当前用户的。例如我就是创建了一个管理员用户，然后把root账户禁用了。在执行命令时习惯性的加 <strong><em>sudo</em></strong>，最后会输出类似于 <em>"MIT-MAGIC-COOKIE-1 keyCan\'t open display :0.0" </em>这样的内容。</p>\n\n<h3 id="h3-2"><strong><em>问题二，最后一步输出 xrandr: Configure crtc 0 failed</em></strong></h3>\n<p>在最后一行&nbsp;<strong><em>$xrandr --addmode WAYLAND1 "1440x900_60.00" </em></strong>命令之后并没有修改成功，而是输出了<strong><em>xrandr: Configure crtc 0 failed&nbsp;</em></strong>或&nbsp;<strong><em>xrandr: Configure crtc 1 failed</em></strong>这样的内容。查阅了一圈资料。在askubuntu找到说明。据说是升级到Ubuntu17.10之后，使用AMD/ATI的显卡容易遇到这个坑，wayland识别不了显示器。这个时候打开Setting的Displays面板显示的是 Unknown Display，最高分辨率只能到1024*768，最不费劲的方法是可以通过安装新的驱动源来解决（但是我安装了一次还是不行）。</p>\n<p>实际上，只要显卡和显示器都支持某个分辨率，直接告诉显卡按照这个分辨率输出图像就好了，不用wayland去识别显示器。</p>\n<p>首先关闭wayland服务，wayland是17.10之后新用的显示器服务（据说是可以在登陆界面选择和X.org切换，但是我的居然没有）。关闭方法：</p>\n<p>1.打开配置文件：</p>\n<pre class="nginx"><code class="language-bash"><span class="code-comment"><span class="code-comment">#打开custom.conf文件，不同发行版文件位置可能有差异</span></span>\n<span class="code-attribute">vim</span> /etc/gdm3/custom.conf</code></pre>\n<p>2.修改文件，找到 <strong><em>#WaylandEnable=false</em></strong> 这一行，然后去掉注释。</p>\n<pre class="ini"><code class="language-bash"><span class="code-comment"><span class="code-comment"># Uncoment the line below to force the login screen to use Xorg</span></span>\n<span class="hljs-attr">WaylandEnable</span>=<span class="hljs-literal"><span class="hljs-literal">false</span></span>\n<span class="code-comment"><span class="code-comment">#......</span></span></code></pre>\n<p>3.最后reboot重启电脑。</p>\n<p>4.启动完成后输入 xrandr 命令发现之前的&nbsp;WAYLAND0 和&nbsp;WAYLAND1 变成了输出端口的名称：</p>\n<pre class="swift"><code class="language-bash"><span class="code-variable">$xrandr</span>\n<span class="code-comment">#输出</span>\n<span class="code-type">Screen</span> <span class="hljs-number">0</span>: minimum <span class="hljs-number">320</span> x <span class="hljs-number">200</span>, current <span class="hljs-number">2806</span> x <span class="hljs-number">900</span>, maximum <span class="hljs-number">8192</span> x <span class="hljs-number">8192</span>\neDP-<span class="hljs-number">1</span> connected primary 1366x768+<span class="hljs-number">0</span>+<span class="hljs-number">0</span> (normal <span class="code-keyword">left</span> inverted <span class="code-keyword">right</span> x axis y axis) 309mm x 173mm\n   1366x768      <span class="hljs-number">60.00</span>*+\n   1360x768      <span class="hljs-number">59.80</span>    <span class="hljs-number">59.96</span>\n   1024x768      <span class="hljs-number">60.04</span>    <span class="hljs-number">60.00</span>\n   960x720       <span class="hljs-number">60.00</span>\n   928x696       <span class="hljs-number">60.05</span>\n<span class="code-type">HDMI</span>-<span class="hljs-number">1</span> disconnected (normal <span class="code-keyword">left</span> inverted <span class="code-keyword">right</span> x axis y axis)\n<span class="code-type">DP</span>-<span class="hljs-number">1</span> connected 1440x900+<span class="hljs-number">1366</span>+<span class="hljs-number">0</span> (normal <span class="code-keyword">left</span> inverted <span class="code-keyword">right</span> x axis y axis) 0mm x 0mm\n   1024x768      <span class="hljs-number">60.00</span>\n   800x600       <span class="hljs-number">60.32</span>    <span class="hljs-number">56.25</span>\n   848x480       <span class="hljs-number">60.00</span>\n   640x480       <span class="hljs-number">59.94</span>\n<span class="code-type">HDMI</span>-<span class="hljs-number">2</span> disconnected (normal <span class="code-keyword">left</span> inverted <span class="code-keyword">right</span> x axis y axis)</code></pre>\n<p>这里的DP-1就是我用的外接显示器，但是现在只能显示到1024*768。然后按照前面介绍的方法依次执行<em><strong>$cvt 1440 900</strong></em>、<strong><em>$xrandr newmode</em></strong>、<em><strong>$xrandr addmode DP-1 "1440x900_60.00"</strong></em>，仅仅是最后addmode的参数有些许差异。</p>\n<p>修改后，在Displays里可以看到最新的分辨率。</p>\n\n<h2 id="h2-3">永久性问题</h2>\n<p>最后，用这个方法有个最大的问题是没法保存。每次重启过后还是没法识别显示器的分辨率，又回到修改之前的状态。</p>\n<p>有些地方说可以像下面这样添加或修改&nbsp;/etc/X11/xorg.conf&nbsp; 文件：</p>\n<pre class="nginx"><code class="nginx"><span class="code-attribute"><span class="code-attribute">Section</span></span> <span class="code-string"><span class="code-string">"Monitor"</span></span>\nIdentifier <span class="code-string"><span class="code-string">"Configured Monitor"</span></span>\nModeline <span class="code-string"><span class="code-string">"1920x1080_60.00"</span></span>  <span class="hljs-number"><span class="hljs-number">173</span></span>.<span class="hljs-number"><span class="hljs-number">00</span></span>  <span class="hljs-number"><span class="hljs-number">1920</span></span> <span class="hljs-number"><span class="hljs-number">2048</span></span> <span class="hljs-number"><span class="hljs-number">2248</span></span> <span class="hljs-number"><span class="hljs-number">2576</span></span>  <span class="hljs-number"><span class="hljs-number">1080</span></span> <span class="hljs-number"><span class="hljs-number">1083</span></span> <span class="hljs-number"><span class="hljs-number">1088</span></span> <span class="hljs-number"><span class="hljs-number">1120</span></span> -hsync +vsync\nOption <span class="code-string"><span class="code-string">"PreferredMode"</span></span> <span class="code-string"><span class="code-string">"1920x1080_60.00"</span></span>\nEndSection\nSection <span class="code-string"><span class="code-string">"Screen"</span></span>\nIdentifier <span class="code-string"><span class="code-string">"Default Screen"</span></span>\nMonitor <span class="code-string"><span class="code-string">"Configured Monitor"</span></span>\nDevice <span class="code-string"><span class="code-string">"Configured Video Device"</span></span>\nEndSection\nSection <span class="code-string"><span class="code-string">"Device"</span></span>\nIdentifier <span class="code-string"><span class="code-string">"Configured Video Device"</span></span>\nEndSection</code></pre>\n<p>但是我修改之后没有任何效果。而且还多出一份&nbsp;/etc/X11/xorg.conf.failsafe 文件。不知道是不是17.0.4特有的原因，毕竟我也是将系统升级为17.0.4之后分辨率才出问题的。</p>\n<p>既然 xorg.conf 配置无法生效，我直接将命令创建为一个shell，然后开机运行即可：</p>\n<pre class="css"><code class="language-bash"><span class="code-comment"><span class="code-selector-id">#view-port-init</span><span class="code-selector-class">.sh</span></span>\n<span class="code-selector-tag">xrandr</span> <span class="code-selector-tag">--newmode</span> <span class="code-string">"1920<span class="code-selector-tag">x1080_60</span><span class="code-selector-class">.00</span>"</span>  173<span class="code-selector-class">.00</span>  1920 2048 2248 2576  1080 1083 1088 1120 <span class="code-selector-tag">-hsync</span> +<span class="code-selector-tag">vsync</span>\n<span class="code-selector-tag">xrandr</span> <span class="code-selector-tag">--addmode</span> <span class="code-selector-tag">DP-1</span> <span class="code-string">"1920<span class="code-selector-tag">x1080_60</span><span class="code-selector-class">.00</span>"</span>\n<span class="code-comment"><span class="code-selector-id">#DP-1</span>这里请根据自己的参数修改。</span>\n</code></pre>\n<p>参考：<a href="https://askubuntu.com/questions/136139/xrandr-configure-crtc-0-failed-when-trying-to-change-resolution-on-external-m?answertab=active#tab-top" rel="nofollow">xrandr-configure-crtc-0-failed-when-trying-to-change-resolution</a>。</p>\n'},388:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<p>在<a href="https://www.chkui.com/article/java/java_bean_validation" title="Java数据校验详解">Java数据校验详解</a>中详细介绍了Java数据校验相关的功能（简称<em>Bean\n    Validation，</em>涵盖<em>JSR-303、JSR-349、JSR-380</em>）,本文将在<em>Bean Validation</em>的基础上介绍Spring框架提供的数据校验功能。</p>\n<p>Spring提供的数据校验功能分为2个部分，一个是Spring自定义的数据校验功能（以下称为<em>Spring Validation</em>），一个是符合<em>Bean Validation</em>规范的数据校验功能。</p>\n\n<h2 id="h2-1">Spring Validation数据校验</h2>\n<p>Spring的自行开发的数据校验功能由3个部分组成：</p>\n<ol>\n    <li>校验器——Validator，他会运行校验代码。</li>\n    <li>校验对象，实际上就是一个JavaBean，Validator会对其进行校验。</li>\n    <li>校验结果——Errors，一次校验的结果都存放在Errors实例中。</li>\n</ol>\n<p>这是Spring在<em>Bean Validation</em>规范制定之前就实现的数据校验功能，ValidationUtils的注释中@since标签是2003年5月6号，而JSR-303定稿时间已经是6年之后（2009年）的事了。\n</p>\n<p>（文中仅为示例代码，可执行代码请到本人<a href="https://gitee.com/chkui-com/spring-core-sample" rel="nofollow">gitee库获取</a>，本文代码在<em>chkui.springcore.example.hybrid.springvalidation</em>包中。）\n</p>\n<p>Spring的数据校验功能就是实现检验器、校验对象、校验结果三个对象。先声明个一个校验对象（实体）：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.springvalidation.entity;\n<span class="code-comment">//车辆信息</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Vehicle</span> </span>{\n\t<span class="code-keyword">private</span> String name;\n\t<span class="code-keyword">private</span> String type;\n\t<span class="code-keyword">private</span> String engine;\n\t<span class="code-keyword">private</span> String manufacturer;\n\t<span class="code-keyword">private</span> Calendar productionDate; \n\n    <span class="code-comment">/**Getter Setter*/</span>\n}</code></pre>\n<p>然后针对这个实体声明一个校验器。校验器要实现<em>org.springframework.validation.Validator</em>接口：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.springvalidation.validator;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">VehicleValidator</span> <span class="code-keyword">implements</span> <span\n            class="code-title">Validator</span> </span>{\n\t<span class="code-keyword">private</span> List&lt;String&gt; _TYPE = Arrays.asList(<span\n            class="code-keyword">new</span> String[] { <span class="code-string">"CAR"</span>, <span\n            class="code-string">"SUV"</span>, <span class="code-string">"MPV"</span> });\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">boolean</span> <span\n            class="code-title">supports</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> </span>{\n        <span class="code-comment">//将验证器和实体类进行绑定，如果这里返回false在验证过程中会抛出类型不匹配的异常</span>\n\t\t<span class="code-keyword">return</span> Vehicle.class.isAssignableFrom(clazz);\n\t}\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">validate</span><span\n            class="hljs-params">(Object target, Errors errors)</span> </span>{ <span class="code-comment">//验证数据</span>\n\t\tVehicle vehicle = Vehicle.class.cast(target);\n\t\t<span class="code-keyword">if</span> (<span class="code-keyword">null</span> == vehicle.getName()) {\n            <span class="code-comment">//使用验证工具绑定结果</span>\n\t\t\tValidationUtils.rejectIfEmpty(errors, <span class="code-string">"name"</span>, <span class="code-string">"name.empty"</span>, <span\n            class="code-string">"车辆名称为空"</span>);\n\t\t}\n\t\t<span class="code-keyword">if</span> (!_TYPE.contains(vehicle.getType())) {\n            <span class="code-comment">//向Error添加验证错误信息</span>\n\t\t\t&lt;<span class="hljs-number">2</span>&gt; errors.rejectValue(<span class="code-string">"type"</span>, <span\n            class="code-string">"type.error"</span>, <span class="code-string">"汽车类型必须是"</span> + _TYPE);\n\t\t}\n        <span class="code-comment">//More validate ......</span>\n\t}\n}</code></pre>\n<p>有了验证对象（JavaBean）和对应的验证器（Validator）就完成了一组验证功能。注意<em>VehicleValidator::validate</em>方法传递的errors参数，验证工具会将错误实例传递进来交给开发者去组装验证结果。\n</p>\n<p>代码中的ValidationUtils就是数据校验工具，他提供了2个功能：</p>\n<ol>\n    <li>执行校验（接下来会马上介绍）。</li>\n    <li>提供错误信息绑定的功能，例如<em>ValidationUtils.rejectIfEmpty</em>这一行代码。会将对应的信息写入到Errors中。</li>\n</ol>\n<p>有了验证对象和验证器就可以执行验证：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">SpringValidationApp</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">private</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">springValidation</span><span class="hljs-params">(ApplicationContext ctx)</span> </span>{\n\t\tVehicleValidator vehicleValidator = <span class="code-keyword">new</span> VehicleValidator();<span\n            class="code-comment">//创建验证器</span>\n\t\tVehicle vehicle = <span class="code-keyword">new</span> Vehicle();<span class="code-comment">//创建验证对象</span>\n\t\t&lt;<span class="hljs-number">1</span>&gt; ValidationError error = <span class="code-keyword">new</span> ValidationError(<span\n            class="code-string">"Vehicle"</span>);<span class="code-comment">//创建错误信息</span>\n\t\tValidationUtils.invokeValidator(vehicleValidator, vehicle, error);<span class="code-comment">//执行验证</span>\n\t\tList&lt;FieldError&gt; list = error.getFieldErrors();\n\t\t<span class="code-keyword">int</span> count = <span class="hljs-number">1</span>;\n        <span class="code-comment">//输出验证结果</span>\n\t\t<span class="code-keyword">for</span>(FieldError res : list) {\n\t\t\tprint(<span class="code-string">"Error Info "</span>, count++ , <span class="code-string">"."</span>);\n\t\t\tprint(<span class="code-string">"Entity:"</span>, res.getObjectName());\n\t\t\tprint(<span class="code-string">"Field:"</span>, res.getField());\n\t\t\tprint(<span class="code-string">"Code:"</span>, res.getCode());\n\t\t\tprint(<span class="code-string">"Message:"</span>, res.getDefaultMessage());\n\t\t\tprint(<span class="code-string">"-"</span>);\n\t\t}\n\t}\n}</code></pre>\n<p>执行完毕后，ValidationError中记录了所有校验错误信息。错误信息分为4个部分：</p>\n<ul>\n    <li>验证的对象的名称：在执行验证器的代码中&lt;1&gt;部分创建错误对象时指定。Vehicle就是验证对象的名称。</li>\n    <li>错误的域、错误code和错误信息：每一个错误都有对应的域、错误编码以及错误信息，在验证器&lt;2&gt;位置的代码就是指定错误信息。</li>\n</ul>\n<p>以上错误信息可以通过<em>error.getFieldErrors();</em>来获取。</p>\n<p>如果JavaBean有嵌套的结构，可以在校验器中调用其他的校验器来实现嵌套检验。先为Vehicle类增加一个Gearbox（变速箱）域：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.springvalidation.entity;\n<span class="code-comment">//车辆信息</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Vehicle</span> </span>{\n\t<span class="code-keyword">private</span> String name;\n\t<span class="code-keyword">private</span> String type;\n\t<span class="code-keyword">private</span> String engine;\n\t<span class="code-keyword">private</span> String manufacturer;\n    <span class="code-keyword">private</span> Gearbox gearbox; <span class="code-comment">//Gearbox是另外一个实例</span>\n\t<span class="code-keyword">private</span> Calendar productionDate; \n\n    <span class="code-comment">/**Getter Setter*/</span>\n}</code></pre>\n<pre><code class="java"><span class="code-comment">//变速箱</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Gearbox</span> </span>{\n\t<span class="code-keyword">private</span> String name;\n\t<span class="code-keyword">private</span> String manufacturer;\n\n    <span class="code-comment">/**Getter Setter*/</span>\n}</code></pre>\n<p>在校验器VehicleValidator::validate中增加对Gearbox验证：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">VehicleValidator</span> <span class="code-keyword">implements</span> <span\n        class="code-title">Validator</span> </span>{\n\t<span class="code-meta">@Autowired</span>\n\tGearboxValidator gearboxValidator; <span class="code-comment">//用于校验Gearbox的校验器</span>\n\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">validate</span><span class="hljs-params">(Object target, Errors errors)</span> </span>{\n\t\tVehicle vehicle = Vehicle.class.cast(target);\n\n\t\t<span class="code-comment">//some code ......</span>\n        \n\t\t}\n\t\t<span class="code-keyword">if</span>(<span class="code-keyword">null</span> == vehicle.getGearbox()) {\n\t\t\terrors.rejectValue(<span class="code-string">"gearbox"</span>, <span\n            class="code-string">"gearbox.error"</span>, <span class="code-string">"变速箱信息为空"</span>);\n\t\t}<span class="code-keyword">else</span> {\n            <span class="code-comment">//指定子实体的名称</span>\n\t\t\terrors.pushNestedPath(<span class="code-string">"gearbox"</span>);\n            <span class="code-comment">//执行对Gearbox的校验</span>\n            ValidationUtils.invokeValidator(gearboxValidator, vehicle.getGearbox(), errors);\n\t\t}\n\t}\n}</code></pre>\n\n<h2 id="h2-2"><em>Bean Validation</em>数据校验</h2>\n<p>Spring现在推荐使用<em>Bean Validation</em>来进行数据校验，而且已经整合到Spring MVC框架中。</p>\n<p>在Spring中使用<em>Bean Validation</em>和<a href="https://www.chkui.com/article/java/java_bean_validation" title="Java数据校验详解">Java数据校验详解</a>一文中介绍的内容差不多——也是注解和校验器组成一个约束，通过注解来控制校验的过程。\n</p>\n<p>Spring核心部分没有提供<em>Bean Validation相关的实现类，所以需要引入对应的实现框架。本文引入的是</em><a href="http://hibernate.org/validator/"\n                                                                       rel="nofollow">Hibernate Validator</a>，他包括验证器和el，详情可以看源码根目录的build.gradle文件。\n</p>\n<p>首先我们向IoC容器中添加全局校验器：</p>\n<pre><code class="java"><span class="code-meta">@Configuration</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">SpringValidationConfig</span> </span>{\n\n\t<span class="code-meta">@Bean</span>(<span class="code-string">"validator"</span>)\n\t<span class="hljs-function"><span class="code-keyword">public</span> Validator <span\n            class="code-title">validator</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> LocalValidatorFactoryBean();\n}</code></pre>\n<p>这一段添加Bean的代码非常简单，就是新建了一个<em>LocalValidatorFactoryBean</em>实例。LocalValidatorFactoryBean实现了javax.validation.Validator接口，并且会自动使用已经引入的<em>Bean\n    Validation</em>框架。</p>\n<p>然后向Vehicle增加<em>Bean Validation相关的</em>注解：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">Vehicle</span> </span>{\n\t<span class="code-meta">@NotBlank</span>\n\t<span class="code-keyword">private</span> String name;\n\t<span class="code-meta">@NotBlank</span>\n\t<span class="code-meta">@VehicleType</span>\n\t<span class="code-keyword">private</span> String type;\n\t<span class="code-meta">@NotBlank</span>\n\t<span class="code-keyword">private</span> String engine;\n\t<span class="code-meta">@NotBlank</span>\n\t<span class="code-keyword">private</span> String manufacturer;\n\t&lt;<span class="hljs-number">3</span>&gt; <span class="code-meta">@Valid</span> <span class="code-comment">//@Valid的作用是对嵌套的解构进行校验</span>\n\t<span class="code-keyword">private</span> Gearbox gearbox;\n\t<span class="code-meta">@Valid</span>\n\t<span class="code-keyword">private</span> Tyre tyre;\n\t<span class="code-meta">@VehicleProductionDate</span>\n\t<span class="code-keyword">private</span> Calendar productionDate;\n\n    <span class="code-comment">/**Getter Setter*/</span>\n\n}</code></pre>\n<p>在上面的代码中，除了常规的@NotBlank等注解，还有@VehicleType这个自定义注解。在代码&lt;3&gt;的位置<em><a href="https://my.oschina.net/u/3652407"\n                                                                         class="referer" target="_blank">@Valid</a></em>是告诉校验器还要对gearbox的实例进行校验，相当于前面介绍的嵌套校验功能。最后我们使用检验器来对<em>Vehicle</em>的实例进行校验：\n</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">SpringValidationApp</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(SpringValidationConfig.class);\n\t\tBeanValidation(ctx);<span class="code-comment">//JSR规范验证</span>\n\t}\n\n\t<span class="hljs-function"><span class="code-keyword">private</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">BeanValidation</span><span class="hljs-params">(ApplicationContext ctx)</span> </span>{\n\t\tValidator validator = ctx.getBean(Validator.class);<span class="code-comment">//获取校验器</span>\n\t\tVehicle vehicle = <span class="code-keyword">new</span> Vehicle();<span class="code-comment">//新建要校验的对象</span>\n\t\tvalidator.validate(vehicle).forEach(err -&gt; { <span class="code-comment">//执行校验</span>\n\t\t\tprint(<span class="code-string">"Field: "</span>, err.getPropertyPath());\n\t\t\tprint(<span class="code-string">"Error: "</span>, err.getMessage());\n\t\t});\n\t}\n}</code></pre>\n<p>关于<em>Bean Validation的详细使用方法已经在</em>&nbsp;<a href="https://www.chkui.com/article/java/java_bean_validation"\n\t\t\t\t\t\t\t\t\t\t\t\ttitle="Java数据校验详解">Java数据校验详解</a>介绍。</p>\n\n<h2 id="h2-3">兼容Bean Validation和Spring Validation</h2>\n<p>一些相对比较久远的项目可能会遇见在<em>Spring Validation</em>的基础上新增<em>Bean Validation</em>功能的情况。可以使用SpringValidatorAdapter适配器来解决这个问题：\n</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">SpringValidationApp</span> </span>{\n\n\t<span class="hljs-function"><span class="code-keyword">private</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">adapterValidation</span><span class="hljs-params">(ApplicationContext ctx)</span> </span>{\n\t\t<span class="code-comment">// 获取校验器</span>\n\t\t<span class="code-comment">// LocalValidatorFactoryBean继承了SpringValidatorAdapter</span>\n        <span class="code-comment">// 所以这里就是获取LocalValidatorFactoryBean</span>\n\t\tSpringValidatorAdapter adapter = ctx.getBean(SpringValidatorAdapter.class);\n\n\t\tVehicle vehicle = <span class="code-keyword">new</span> Vehicle();<span class="code-comment">// 检验对象</span>\n\t\tValidationError error = <span class="code-keyword">new</span> ValidationError(<span class="code-string">"Vehicle"</span>);\n\t\t\n\t\t<span class="code-comment">// Spring Validation</span>\n\t\tValidationUtils.invokeValidator(adapter, vehicle, error);<span class="code-comment">//执行校验</span>\n\t\tList&lt;FieldError&gt; list = error.getFieldErrors();<span class="code-comment">//检验信息</span>\n\n\t\t<span class="code-comment">// Bean Validation 校验</span>\n\t\tadapter.validate(vehicle).forEach(err -&gt; { <span class="code-comment">// 执行检验&amp;输出校验结果</span>\n\t\t\tprint(<span class="code-string">"Field: "</span>, err.getPropertyPath());\n\t\t\tprint(<span class="code-string">"Error: "</span>, err.getMessage());\n\t\t});\n\t}\n}</code></pre>\n<p>上面的代码使用SpringValidatorAdapter分别执行了<em>Bean Validation</em>和<em>Spring\n    Validation</em>。可以将SpringValidatorAdapter看作一个<em>org.springframework.validation.Validator</em>的实现类用ValidationUtils来执行校验，而验证的过程完全是按照Bean\n    Validation的规范来执行的。</p>\n\n<h2 id="h2-4">方法参数校验</h2>\n<p>除了校验一个实体类，Spring在<em>Bean Validation</em>的基础上使用<a\n        href="https://www.chkui.com/article/spring/spring_core_bean_post_processors" title="IOC处理器扩展">后置处理器</a>和AOP实现了方法参数的检验。例如下面的方法：\n</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">PersonService</span> </span>{\n\t<span class="code-keyword">public</span> <span class="code-meta">@NotBlank</span> <span class="hljs-function">String <span\n            class="code-title">execute</span><span class="hljs-params">(@NotBlank(message = <span class="code-string">"必须设置人员名称"</span>)</span> String name,\n\t\t\t@<span class="code-title">Min</span><span class="hljs-params">(value = <span class="hljs-number">18</span>, message = <span\n                class="code-string">"年龄必须大于18"</span>)</span> <span class="code-keyword">int</span> age)</span>;\n}</code></pre>\n<p>他表示返回数据不能为空字符串，传入的2个参数name不能为空字符串、age必须大于18。</p>\n<p>要启用方法参数校验关键点是引入MethodValidationPostProcessor并在需要验证的Bean上增加一个@Validated注解。</p>\n<p>先通过@Configuration引入后置处理器：</p>\n<pre><code class="java"><span class="code-meta">@Configuration</span>\n<span class="code-meta">@ComponentScan</span>(<span class="code-string">"chkui.springcore.example.hybrid.springvalidation.service"</span>)\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">SpringValidationConfig</span> </span>{\n\t<span class="code-meta">@Bean</span>(<span class="code-string">"validator"</span>)\n\t<span class="hljs-function"><span class="code-keyword">public</span> Validator <span\n            class="code-title">validator</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> LocalValidatorFactoryBean();\n\t}\n\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> MethodValidationPostProcessor <span\n            class="code-title">methodValidationPostProcessor</span><span\n            class="hljs-params">(Validator validator)</span> </span>{\n\t\tMethodValidationPostProcessor postProcessor = <span class="code-keyword">new</span> MethodValidationPostProcessor();\n\t\tpostProcessor.setValidator(validator);\n\t\t<span class="code-keyword">return</span> postProcessor;\n\t}\n}</code></pre>\n<p>然后实现上面的PersonService接口并标记@Validated表示这个类中的方法要进行参数校验：</p>\n<pre><code class="java"><span class="code-meta">@Service</span>\n<span class="code-meta">@Validated</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">PersonServiceImpl</span> <span class="code-keyword">implements</span> <span\n            class="code-title">PersonService</span> </span>{\n\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span\n            class="code-title">execute</span><span class="hljs-params">(String name, <span\n            class="code-keyword">int</span> age)</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"I\'m "</span> + name + <span\n            class="code-string">". "</span> + age + <span class="code-string">" years old."</span>;\n\t}\n}</code></pre>\n<p>最后使用这个Service：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">SpringValidationApp</span> </span>{\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(SpringValidationConfig.class);\n\t\tmethodValidation(ctx);<span class="code-comment">//方法参数校验</span>\n\t}\n\t\n\t<span class="hljs-function"><span class="code-keyword">private</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">methodValidation</span><span class="hljs-params">(ApplicationContext ctx)</span> </span>{\n\t\t<span class="code-comment">//对方法进行参数校验</span>\n\t\t<span class="code-keyword">try</span> {\n\t\t\tPersonService personService = ctx.getBean(PersonService.class);\n\t\t\tpersonService.execute(<span class="code-keyword">null</span>, <span class="hljs-number">1</span>);<span\n            class="code-comment">//传递参数</span>\n\t\t} <span class="code-keyword">catch</span> (ConstraintViolationException error) {\n\t\t\terror.getConstraintViolations().forEach(err -&gt; {<span class="code-comment">//输出校验错误信息</span>\n\t\t\t\tprint(<span class="code-string">"Field: "</span>, err.getPropertyPath());\n\t\t\t\tprint(<span class="code-string">"Error: "</span>, err.getMessage());\n\t\t\t});\n\t\t}\n\t}\n}</code></pre>\n<p>在运行的过程中，如果参数或返回数据不符合验证规则会抛出ConstraintViolationException异常，可以从中获取校验错误的信息。</p>'},398:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<p>前面3篇分别介绍了<a href="https://www.chkui.com/article/spring/spring_core_design_pattern_and_ioc" title="IoC容器与Bean的关系">IoC容器与Bean的关系</a>、<a\n        href="https://www.chkui.com/article/spring/spring_core_dependency_injection_of_bean" title="Bean与Bean之间的关系">Bean与Bean之间的关系</a>以及<a\n        href="https://www.chkui.com/article/spring/spring_core_bean_lifecycle_callback" title="Bean自身的控制和管理">Bean自身的控制和管理</a>。在了解Spinrg核心模式时，一定要谨记他的基本工作元素就是IoC容器和Bean，所有的功能是围绕着这2者展开的。要实现的内容无非就是通过设计模式来解决<strong>IoC与Bean的关系</strong>、<strong>Bean与Bean的关系</strong>、<strong>IoC与IoC的关系，</strong>以及对Ioc和Bean的控制<strong>。</strong>\n</p>\n\n<h2 id="h2-1">IoC控制入口</h2>\n<p>看完整个<em>Spring Core</em>的<em>API\n    Doc</em>，你也不会发现任何一个名为<em>IoC</em>的类或者接口。唯一一个提到<em>IoC</em>这个词的是<strong>spring-beans</strong>工程下关于<em>org.springframework.beans.factory</em>这个包的介绍——"<em>The\n    core package implementing Spring\'s lightweight Inversion of Control (IoC)\n    container.</em>"。实际上<em>Spring</em>核心框架将对<em>IoC</em>容器的控制都交给了<em>BeanFactory</em>和<em>ApplicationContext</em>两个接口。\n</p>\n<p>这个2个接口有什么关系吗？一个叫<em>Factory</em>，一个叫<em>Context</em>，概念上完全是两码事，前者是创建模式的FLAG，后者是行为模式的FLAG。并且在工程结构上，一个属于spring-beans，另外一个属于spring-context。不过仔细看会发现<em>ApplicationContext</em>继承自<em>BeanFactory</em>的派生接口<em>（</em>\n    ListableBeanFactory、HierarchicalBeanFactory <em>）。</em>要想理解他们的关系和作用，还得一个一个来说。</p>\n\n<h2 id="h2-2">factory包中的接口</h2>\n<p>\n    在Spring核心工程中，BeanFactory及其派生被定义为“Ioc容器的轻量级实现”。这也是Spring最基础的IoC容器和Bean的管理接口。factory包中主要涉及5个接口BeanFactory、ListableBeanFactory、HierarchicalBeanFactory、ConfigurableBeanFactory和ConfigurableListableBeanFactory<strong>。</strong>初来咋到看到这5个接口八成懵逼，少数牛逼的码友估计能从名字猜测出他们的功能。其实他们有很清晰的层次结构，一层继承一层，一层扩展一层的功能。\n</p>\n<p style="text-align:center"><img alt="Spring核心——上下文与IoC" height="300"\n                                  src="https://oscimg.oschina.net/oscnet/c5634f6073bb56eae08c276f589ba14dcbb.jpg"\n                                  width="469"></p>\n<p style="text-align:center">（图片来源于他人博客，如有侵权请告知)</p>\n<p><strong>BeanFactory</strong>是IoC容器最基本的功能，他就是前面文章中一直提到的IoC设计模式的具体实现——处理IoC与Bean，Bean与Bean的关系。可以理解BeanFactory自身就是一个IoC容器，然后提供了getter、is、contains接口来获取和判断Bean的状态。对于单例或多例，BeanFactory只提供了BeanFactory::isSingleton和BeanFactory::isPrototype2个方法，这也是为什么我在<a\n        href="https://www.chkui.com/article/spring/spring_core_design_pattern_and_ioc">设计模式与IoC</a>一文中会说从设计模式的角度来说，Bean除了工厂方法外，只涉及<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-singleton"\n        rel="nofollow">singleton</a>和<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-prototype"\n        rel="nofollow">prototype</a>2个创建模式。</p>\n<p><strong>ListableBeanFactory</strong>继承自<strong>BeanFactory</strong>接口。看方法会发现，BeanFactory只提供单个Bean的操作，而ListableBeanFactory都是支持列表操作，比如获取Bean的总数、获取Bean的name列表、通过Bean的Type获取Bean的列表、根据注解获取Bean的列表等。从字面上的Listable也可以看出来其是在基本Factory的基础上扩展了相同类型、相同名称Bean的功能。\n</p>\n<p><strong>HierarchicalBeanFactory</strong>从字面上就应该大概知道他的作用的解决层级问题，提供子父容器的管理方法。</p>\n<p>再往下就是<strong>ConfigurableListableBeanFactory</strong>接口，这个接口提供的IoC控制功能，从子字面<strong>Configurable</strong>来看意思就是可以配置的。顶层的几个接口（<strong>BeanFactory、ListableBeanFactory</strong>）都没提供Setter或Creater的功能，而<strong>ConfigurableListableBeanFactory</strong>集成的3个接口ListableBeanFactory、AutowireCapableBeanFactor、ConfigurableBeanFactory提供了Setter、Creater的功能。实际上<strong>ConfigurableListableBeanFactory</strong>就是提供了Beans的“增改”功能，以及一些附加的依赖控制。\n</p>\n<p>网上关于<em><strong>BeanFactory</strong></em>及其派生结构介绍的资料很多，大部分都是从源码的角度详细说明他们之间的依存关系。不过从使用者的角度，实际上从总体上去了解他的组合模式思路，比你一个一个的去看源码有意义得多，更何况就算你现在看了源码，一年不碰你还能记得？总不能天天还复习吧？看源码主要是要理解作者针对实现所用设计模式。当然你要是要参加什么面试的话，还真得复习复习。记得以前我作为面试官曾叫别人当场写出ConfigurableListableBeanFactory的继承关系。现在想想当时自己有多脑残，被面试的那些小哥估计想拍我吧？开发能力的好坏是一种思维方式，而不是谁记得2个\n    new String("A")到底创建了几个String实例，或者Integer的0到128会被预设。</p>\n<p>实际上进经过多年的发展，Spring Core\n    的BeanFactory这块已经发生了多次改变。从最基础的BeanFactory到ConfigurableListableBeanFactory层层向下推进全是接口或抽象类，每一个接口都在父接口的基础上包装了的新的接口方法。通过多层继承，官方的代码中只有一个名为DefaultListableBeanFactory的类将所有的接口功能都实现了，然后XmlFactory又继承实现了资源读写的功能。XmlFactory并没有多少代码，Ioc的核心功能都在DefaultListableBeanFactory。</p>\n<p>从设计模式上来说，很难去定义这么多接口派生但是一个实现类提供所有功能的模式到底算什么。我个人认为这很像外观模式（Facade&nbsp;Pattern）和装饰模式（Decorator\n    Pattern）结合。现实中我们没也没必要像教科书似的模式来理解应用。下面解释这个思路。</p>\n<p>首先我们来看看效果。</p>\n<p>例如现在你用BeanFactory来“装载”ConfigurableListableBeanFactory的实例：</p>\n<pre><code class="java">BeanFactory ioc = <span\n        class="code-keyword">new</span> ConfigurableListableBeanFactory();</code></pre>\n<p>\n    这个时候对你来说，这个BeanFactory就是一个装饰器或外观，如果BeanFactory接口不发生改变，你所能用的功能仅仅是BeanFactory提供的几个接口方法。即使可能有人在之后的任何时间修改增加了ConfigurableListableBeanFactory的方法。此时尽管ConfigurableListableBeanFactory这个实现类的本质发生了改变，但是对于BeanFactory的使用位置来说一切照旧，他通过&nbsp;BeanFactory这个外观装饰接口看到的效果和之前一模一样。&nbsp;而扩展了接口之后的实现类，新的代码可以用新的接口。例如：</p>\n<pre><code class="java">ConfigurableListableBeanFactory ioc = <span class="code-keyword">new</span> ConfigurableListableBeanFactory();</code></pre>\n<p>然后我们还可以继续向下扩展接口和功能。</p>\n<p>如果你看过源码，你会发现spring\n    beans的BeanFactory代码最早的编写时间停留在2001年4月13号，距今已经很长的历史了。相信之后肯定不断演进扩展了大量的功能。而通过接口派生的实现外观的方式，让古老的代码和后续的新功能友好的共存。对于我们自己的设计系统或实现“代码级别的迭代”这是一个极好的例子——仅维护一个实现，通过增加外观或装饰器来演进功能，使用者一直都是看到的外观。虽然这样做似乎会违背类的单一职责的原则。</p>\n<p>在接下来介绍ApplicationContext之前先要说明，我们现在创建一个Spring应该不使用任何BeanFactory相关的接口了，关于这一点<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#context-introduction-ctx-vs-beanfactory"\n        rel="nofollow">官方文档</a>有明确的说明。除了在少数对内存大小有严苛要求的受限制的设备上进行嵌入式开发，其他时候都应该使用ApplicationContext。ApplicationContext实现了BeanFactory的所有功能，并对应用开发提供了很多有用的扩展。BeanFactory现在存在的主要作用是为一些历史第三方库提供支持，现在对于大多数使用Spring的用户来说他是一个历史性的接口。\n</p>\n\n<h2 id="h2-3">ApplicationContext</h2>\n<p>\n    不知道别人在学习编程开发的早年看到Context这个词是什么感觉，反正我是蒙逼了很久。也不知道这词最早是哪位哥翻译的，译成“上下文”?!英文里con-前缀表示聚集、集合吗，context的字面意思明明就是一堆数据的集合吧。其实码界类似让人翻译的翻译还真不少，handle=句柄（deal\n    with，处理器）、socket=套接字（就使用原意插座还好理解）。更狠的是Robustness，真不知道在哪年是哪位大爷出于什么原因把他翻成“鲁棒性”的。</p>\n<p>\n    回到正题，我真正理解Context是在开始了解设计模式之后。在设计模式中Context的概念出现在“策略模式”，该模式的标准解释是执行一个方法会根据当前的状态和对象执行不同的“策略”，“策略”因为实现类的性质不同而发生改变。实际上就是用一个Context对“策略”进行包装，而“策略”可以根据需要调整（细节请度娘）。我直接用Spring的ApplicationContext来说明。</p>\n<p style="text-align: center;"><img alt="Spring核心——上下文与IoC" height="400"\n                                    src="https://oscimg.oschina.net/oscnet/2eb09f38d1ad275a1297fd165e6bd07fb4c.jpg"\n                                    width="464"></p>\n<p style="text-align: center;">(图片来源于网络，如有侵权请告知)</p>\n<p>\n    ApplictionContext的继承思路和BeanFactory类似，就不再介绍了。在核心包中，Spring提供的ApplicationContext实现类目前有FileSystemXmlApplication和ClassPathXmlApplicationContext（Web包里还有Web环境专用的ApplicationContext）。</p>\n<p>\n    FileSystemXmlApplication和ClassPathXmlApplicationContext分别代表了2个不同的“策略”，在我们使用的时候在创建ApplicationContext时确定，并且在运行时也可以调整。</p>\n<pre><code class="java"><span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">App</span> <span class="code-keyword">implements</span> <span class="code-title">ApplicationContextAware</span></span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span\n            class="hljs-params">()</span> </span>{\n        <span class="code-comment">// 初始化为策略1</span>\n\t\tApplicationContext springContext = <span class="code-keyword">new</span> ClassPathXmlApplicationContext(<span\n            class="code-string">"myXml.xml"</span>);\n        <span class="code-comment">// 使用策略1的方法，使用者不用知道实现细节</span>\n        System.out.println(springContext.getApplicationName());\n\n        <span class="code-comment">// 修改为策略2</span>\n        springContext = <span class="code-keyword">new</span> FileSystemXmlApplicationContext(<span class="code-string">"/myProject/myXml.xml"</span>);\n        <span class="code-comment">// 使用策略2的方法，使用者不用知道实现细节</span>\n        System.out.println(springContext.getApplicationName());\n\t}\n}</code></pre>\n<p>如上面的代码，我们可以根据我们需要指定不同的“策略”。ClassPath和FIleSystem两个类功能都差不多，最大的区别就是加载文件路径的差异——一个从当前工作目录、一个从整个磁盘路径。理论上策略模式还有一个&nbsp;<em>Strategy</em>接口来包装策略，Spring直接将<em>Context</em>设定为一个接口，然后通过不同的实现类整合到了一起。从实现上来看策略模式并没有什么太神奇的东西，实际上还是一个接口多个实现类。那么看到这里你肯定已经忍不住要吼了：这到底有什么用？不就是创建一个实例给一个接口吗？\n</p>\n<p>实际上策略模式和Context是针对分层应用而设计的，很多设计模式的资料只会说模式是什么，但是不会提到模式的来源和立意。我所知道在设计模式中Context的最早概念是来源是来自这篇论文——<a\n        href="https://www.cse.wustl.edu/~schmidt/PDF/Context-Object-Pattern.pdf" rel="nofollow">Context Object A Design\n    Pattern for Efficient Information Sharing across Multiple System Layers</a>（直译为《上下文对象——多层系统的高效信息共享的设计模式》），它大致的结论是在分层应用系统中（例如MVC——view-controller-service-dao）层之间传递（共享）数据时，将相同适用范围和生命周期的所有数据组合到一个Context中去传递可以大大的提升分层之后开发效率——大概就是反正我所有东西都往里面放，你用得着就用，用不着就算，也不用来和我商量要什么了。\n</p>\n<p><span style="color:#e74c3c">所以Context实际上就是按照适用范围（Scope）而不是应用功能（functionality</span><span style="color:#e74c3c">）划分的一个数据对象。</span><span\n        > 这样在层与层之间传递数据的时候，无论有多少个接口都传递同一个的Context。</span></p>\n<p style="text-align: center;"><span><img alt="Spring核心——上下文与IoC" height="500"\n                                                             src="https://oscimg.oschina.net/oscnet/b54ba49ded2c3d92ef130edfc418a4a81ac.jpg"\n                                                             width="331"></span></p>\n<p>\n    例如Spring全局应用就是ApplicatonContext，把IoC和其他全局操作方法的丢到这个Context中。所以最后我们看到除了IoC的Bean控制接口（BeanFactory）外，他还提供资源控制接口（ResourcePatternResolver）、国际化接口（MessageSource）&nbsp;、事件发布管理接口（ApplicationEventPublisher）。这些功能并没有直接的联系，但是他们的适用范围都是Applicaton级别的，所以都被整合到了ApplicatonContext中。</p>\n<p>再例如在WebApplicationContext中，一次请求相关的所有资源以及相关的接口都会整合RequestContext中，RequestContext用于Servlet到我们自定义的Controller层传递数据。</p>\n<p>ApplicationContext继承了BeanFactory，其核心功能还是管理IoC以及Bean。前面也提到ApplicationContext还扩展了许多功能。下图来自于官方，表现了2者的功能差异。</p>\n<table>\n    <tbody>\n    <tr>\n        <th>Feature</th>\n        <th><code>BeanFactory</code></th>\n        <th><code>ApplicationContext</code></th>\n    </tr>\n    </tbody>\n    <tbody>\n    <tr>\n        <td><p>Bean 初始化与设定</p></td>\n        <td><p>Yes</p></td>\n        <td><p>Yes</p></td>\n    </tr>\n    <tr>\n        <td><code>BeanPostProcessor注册</code></td>\n        <td><p>No</p></td>\n        <td><p>Yes</p></td>\n    </tr>\n    <tr>\n        <td><code>BeanFactoryPostProcessor注册</code></td>\n        <td><p>No</p></td>\n        <td><p>Yes</p></td>\n    </tr>\n    <tr>\n        <td><p>国际化支持</p></td>\n        <td><p>No</p></td>\n        <td><p>Yes</p></td>\n    </tr>\n    <tr>\n        <td><p><span style="font-size:13px">事件发布与注册</span></p></td>\n        <td><p>No</p></td>\n        <td><p>Yes</p></td>\n    </tr>\n    </tbody>\n</table>\n<p>后续的文章会继续展开介绍这些功能以及背后设计模式的含义。</p>'}});