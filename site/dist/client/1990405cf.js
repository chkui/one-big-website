webpackJsonp([1],{307:function(n,s,a){"use strict";Object.defineProperty(s,"__esModule",{value:!0});s.content='<p>在hazelcast的官方文档中，提到了其支持read-through，write-through与write-behind三种模式。查阅资料，最后在oracle的官文中找到了比较靠谱的解释。</p>\n<p>read-throug、write-through、write-behind三个概念都是关于数据缓存管理的。其实这些概念在实际使用的过程中经常接触。</p>\n<h2 id="h2-1"><strong>Read-throug</strong></h2>\n<p>当应用系统向缓存系统请求数据时（例如使用key=x向缓存请求数据）；如果缓存中并没有对应的数据存在（key=x的value不存在），缓存系统将向底层数据源的读取数据。如果数据在缓存中存在（命中key=x），则直接返回缓存中存在的数据。这就是所谓的<strong>Read-throug。</strong></p>\n<p>hazelcast原文：</p>\n<blockquote>\n    <p>If an entry does not exist in the memory when an application asks for it, Hazelcast asks your loader implementation to load that entry from the data store。 &nbsp;If the entry exists there, the loader implementation gets it, hands it to Hazelcast, and Hazelcast puts it into the memory. This is read-through persistence mode。</p>\n</blockquote>\n<p>下图是Oracle官网的<strong>Read-throug</strong>图例。\n    <img alt="Hazelcast read-through、write-through与write-behind模式" src="https://file.mahoooo.com/res/file/read_through_write_through_and_write_behind_1.jpg">\n</p>\n<h2 id="h2-2">Write-Through</h2>\n<p>当应用系统对缓存中的数据进行更新时（例如调用put方法更新或添加条目），缓存系统会同步更新缓存数据和底层数据源。</p>\n<p>下图展示了执行过程：</p>\n<p><img alt="Hazelcast read-through、write-through与write-behind模式" src="https://file.mahoooo.com/res/file/read_through_write_through_and_write_behind_2.jpg"></p>\n<h2 id="h2-3">Write-Behind</h2>\n<p>当应用系统对缓存中的数据进行更新时（例如调用put方法更新或添加条目），缓存系统会在指定的时间后向底层数据源更新数据。</p>\n<p><img alt="Hazelcast read-through、write-through与write-behind模式" src="https://file.mahoooo.com/res/file/read_through_write_through_and_write_behind_3.jpg"></p>'},315:function(n,s,a){"use strict";Object.defineProperty(s,"__esModule",{value:!0});s.content='<h2 id="h2-1">分区规范</h2>\n<p>首先要明确，JVM规范中并没有常量池这一说法，都是各种不同的jvm实现为了便于处理加以区分的。在JVM规范中统一称呼为方法区（JDK7之后这样说也不准确，有些数据常量数据又迁移到堆中）。下面的常量池主要以Java8自带的HotSpot为例，其他版本的Jvm会有各种区别。在HotSpot中，JDK6之前的版本所有常量池都在永生代（permanent generation）中，而JDK8取消了永生带用元空间（metaspace）替换，可以简单的理解常量池被移动到元空间中了（但实际处理还是有很多差异，大部分以前放置在永生代数据被迁移到堆中，而元数据区仅存放引用。但是这样说便于理解）。JDK7是一个过渡版本，只是将字符串移动到堆中。</p>\n\n<h2 id="h2-2">class常量池</h2>\n<p>当 .java文件被<span style="color:#FF0000">转译</span>成.class文件之后的字节码中包含一系列描述信息、符号引用和字面量信息。在jvm启动时，这些信息会被加载到class常量池中，当一个类要被<span style="color:#FF0000">编译</span>加载之前这些符号和字符串会经过JVM的加载器将其实例化成为一个常量值（Class对象的实例）存在在运行时常量区。所谓的class常量池并不会真的需要分配一个内存空间（常量池），直接从本地磁盘上加载转换也是可行的，这主要取决与JVM的版本和一些参数的配置处理。</p>\n\n<h2 id="h2-3">运行时常量池</h2>\n<p>运行时常量池（Runtime Constant Pool）主要用于存放jvm在运行时所有静态量。参考"深入理解java虚拟机"一书2.2.6对其的描述：运行时常量池是方法区的一部分。class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是<strong>常量池表</strong>（Constant Pool Tabel），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入该常量池。运行时常量池并不仅仅局限于加载类时产生常量，与<strong>class常量池</strong>的区别是可以在运行期间添加各种数据到这个区域，例如jvm会将代码中直接声明的字符串放置到常量池中，这些字符串被称为字面量。通过<em>String::intern</em> 也可以向常量池表添加新的字面量。</p>\n\n<h2 id="h2-4">代码与字节码案例</h2>\n<p>下面通过一些例子来加深堆常量池的理解。</p>\n<p>字面量定义变量值：</p>\n<pre><code class="java"><span class="code-comment">//会直接在常量池中生成一个字符串常量，并将str1的引用（指针）指向它。</span>\nString str1 = <span class="code-string">"myString"</span>;\nString str2 = <span class="code-string">"myString"</span>;\n<span class="code-comment">//都是指向常量池的同一地址，所以这里输出为true;</span>\nSystem.out.println(str1 == str2);</code></pre>\n<p>与字符串相比，数字处理的情况就比较有趣了。先看一个单纯的例子：</p>\n<pre><code class="java">Integer num1 = <span class="hljs-number">127</span>;\nInteger num2 = <span class="hljs-number">127</span>;\nInteger num3 = <span class="hljs-number">128</span>;\nInteger num4 = <span class="hljs-number">128</span>;\nSystem.out.println(num1 == num2);<span class="code-comment">//TRUE</span>\nSystem.out.println(num3 == num4);<span class="code-comment">//FALSE</span></code></pre>\n<p>第一个对比输出为true，而第二个输出为false。这就是10次Java笔试9次都会遇到的Integer 预设-128~127对象的问题——为了循环、迭代等等常见处理不反复创建新的区域来存储值，Jvm预设了部分Integer整数值，无论哪申请这些值，都指定到固定的常量地址。</p>\n<p>再来看一个有意思的例子：</p>\n<pre><code class="java"><span class="code-keyword">int</span> i = <span class="hljs-number">128</span>;\nInteger I1 = <span class="hljs-number">128</span>;\nInteger I2 = <span class="hljs-number">128</span>;\nSystem.out.println(I1 == I2);<span class="code-comment">//false</span>\nSystem.out.println(I1 == i);<span class="code-comment">//true</span>\nSystem.out.println(I2 == i);<span class="code-comment">//true</span></code></pre>\n<p>输出的结果主要受到Java5之后装箱和拆箱的机制影响。</p>\n<blockquote>\n    <p>字节码解释说明：</p>\n    <p>在每一个字节码指令之后都会有注解说明。每一行注解包括2部分内容，1是指令进行的操作描述，2是操作之后的结果。2部分用;号分割。</p>\n    <p>操作结果中S代表<strong>stack</strong>——线程栈，L代表<strong>local</strong>——本地存储。I(128)表示类型为Integer值为128的引用。"string"标示一个常量，S("string")表示类型为String值为"string"的堆数据。例如，S=[I(128)],L=[128]标示线程栈中存在一个值为128的Integer类型引用，而缓存的L[0]位置存放了值为128的整数。</p>\n    <p>缓存的下标从1开始，因为0位置已经留给了this。</p>\n    <p>用于存放指令集运算结果的本地存储我们通称为缓存。</p>\n</blockquote>\n<p>首先，在Java5之前，是不能这样写的。Java5之后有了装箱机制，这样的语句实际上执行的是 <em>Integer I1 =&nbsp;Integer.valueOf(128)</em>。所以变量I1和I2是指向2个实例的引用地址，因此 "I1==I2"是false很好理解。那么另外2个==为什么是true呢。看下面的Java代码和对应的字节码：</p>\n<pre><code class="java"><span class="code-keyword">int</span> slot1 = <span class="hljs-number">128</span>;\nInteger slot2 = <span class="hljs-number">128</span>;\nSystem.out.println(slot1 == slot2);</code></pre>\n<p>对应的字节码是：&nbsp;</p>\n<pre><code class="apache"> <span class="code-attribute">0</span>: sipush        128 //128压栈;S=[128],L=[]\n <span class="code-attribute">3</span>: istore_1          //128出栈,写入缓存;S=[],L=[128]\n <span class="code-attribute">4</span>: sipush        128 //128压栈;S=[128],L=[128]\n <span class="code-attribute">7</span>: invokestatic  #16 //128出栈,执行I.valueOf(128)结果入栈;S=[I(128)],L=[128]\n<span class="code-attribute">10</span>: astore_2          //I(128)出栈写入缓存。S=[],L=[128,I(128)]\n<span class="code-attribute">11</span>: getstatic     #22 //从常量池读取PrintStream压栈;S=[PrintStream],L=[128,I(128)]\n<span class="code-attribute">14</span>: aload_2           //缓存数据[2]压栈；S=[I(128),PrintStream],L=[128,I(128)]\n<span class="code-attribute">15</span>: invokevirtual #28 //I(128)出栈，执行I.intValue结果入栈;S=[128,PrintStream],L=[128,I(128)]\n<span class="code-attribute">18</span>: iload_1           //缓存数据[1]压栈；S=[128,128,PrintStream],L=[128,I(128)]\n<span class="code-attribute">19</span>: if_icmpne     26  //S[0]和S[1]出栈使用if_icmpne数值对比。S=[PrintStream],L=[128,I(128)]\n<span class="code-attribute">22</span>: iconst_1          //将整数1压入栈;S=[1,PrintStream],L=[128,I(128)]\n<span class="code-attribute">23</span>: goto          27  //跳转到27行\n<span class="code-attribute">26</span>: iconst_0          //将整数0压入栈;S=[0,PrintStream],L=[128,I(128)]\n<span class="code-attribute">27</span>: invokevirtual #32 //S[0]和S[1]出栈使用println输出;S=[],L=[128,I(128)]\n<span class="code-attribute">30</span>: return            \n</code></pre>\n<p>核心在4~10行装箱，将一个128整数转换成一个Integer的引用，数据存储在堆中。然后在14～19行拆箱，将堆中的Integer数据转换成一个int整数，然后再用int整数和int整数进行==比较（if_icmpne）。所以比较之后会输出true。</p>\n<p>接下来是一个解释class常量池和常量池的例子。</p>\n<p>Java代码：</p>\n<pre><code class="java">String slot1 = <span class="code-string">"myString"</span>;\nString slot2 = <span class="code-keyword">new</span> String(<span class="code-string">"myString"</span>);\nSystem.out.println(slot1 == slot2); <span class="code-comment">//FALSE</span></code></pre>\n<p>"myString"这样的字符串，在类加载编译字节码时（从class常量池转变成运行时的常量池）就会生成一个常量并放置在常量池中，随后所有使用到这个字符串的位置，都是直接从常量池引用。下面是对应的字节码：</p>\n<pre><code class="apache"> <span class="code-attribute">0</span>: ldc           #16 //常量池读取<span class="code-string">"myString"</span>压栈;S=[<span class="code-string">"myString"</span>],L=[]\n <span class="code-attribute">2</span>: astore_1          //写入本地缓存;S=[],L=[<span class="code-string">"myString"</span>]\n <span class="code-attribute">3</span>: new           #18 //堆中创建一个String实例压栈;S=[S()],L=[<span class="code-string">"myString"</span>]\n <span class="code-attribute">6</span>: dup               //复制栈顶;S=[S(),S()],L=[<span class="code-string">"myString"</span>]\n <span class="code-attribute">7</span>: ldc           #16 //常量池读取<span class="code-string">"myString"</span>压栈;S=[<span class="code-string">"myString"</span>,S(),S()],L=[<span class="code-string">"myString"</span>]\n <span class="code-attribute">9</span>: invokespecial #20 //弹出S[0,1]作为参数使用init初始化;S=[S(<span class="code-string">"myString"</span>)],L=[<span class="code-string">"myString"</span>]\n<span class="code-attribute">12</span>: astore_2          //弹出栈顶写入缓存[2];S=[],L=[<span class="code-string">"myString"</span>,S(<span class="code-string">"myString"</span>)]\n<span class="code-attribute">13</span>: getstatic     #23 //获取输出常量;S=[PrintStream],L=[<span class="code-string">"myString"</span>,S(<span class="code-string">"myString"</span>)]\n<span class="code-attribute">16</span>: aload_1           //缓存[1]入栈;S=[<span class="code-string">"myString"</span>,PrintStream],L=[<span class="code-string">"myString"</span>,S(<span class="code-string">"myString"</span>)]\n<span class="code-attribute">17</span>: aload_2           //缓存[2]入栈;S=[S(<span class="code-string">"myString"</span>),<span class="code-string">"myString"</span>,PrintStream],L=[<span class="code-string">"myString"</span>,S(<span class="code-string">"myString"</span>)]\n<span class="code-attribute">18</span>: if_acmpne     25  //弹出S[0,1]比较;S=[PrintStream],L=[<span class="code-string">"myString"</span>,S(<span class="code-string">"myString"</span>)]\n<span class="code-attribute">21</span>: iconst_1          //整数1压栈;S=[1,PrintStream],L=[<span class="code-string">"myString"</span>,S(<span class="code-string">"myString"</span>)]\n<span class="code-attribute">22</span>: goto          26  //跳转26\n<span class="code-attribute">25</span>: iconst_0          //整数0压栈;S=[0,PrintStream],L=[<span class="code-string">"myString"</span>,S(<span class="code-string">"myString"</span>)]\n<span class="code-attribute">26</span>: invokevirtual #29 //弹出S[0,1]执行输出;S=[],L=[<span class="code-string">"myString"</span>,S(<span class="code-string">"myString"</span>)]\n<span class="code-attribute">29</span>: return\n</code></pre>\n<p>Java字节码中的ldc标示从常量池获取一个引用入栈，例子将常量池的引用#16压入栈，然后astore_1将#16写到本地存储[1]位置。所以slot1 = "myString"意味着slot1指向了常量池存放"myString"的位置。</p>\n<p>3~12行完成slot2 = new String("myString")的过程：3行，new指令先在栈上创建了一个指向一个String实例堆空间的引用；6行，在栈顶复制这个引用；7行，从常量池读取"myString"这个常量的引用；9行，弹出栈顶的"myString"引用作为执行String.init方法的参数，执行完都会更新堆中的数据；12）将栈顶dup指令复制出的引用弹出并写入本地存储[2]位置。此时slot2引用了堆空间中的一个String实例。所以slot1==slot2操作（if_acmpne）肯定返回false。</p>\n<p>这个例子揭开了一个Java基础问题的答案——String s = new String("String")是创建了2个字符串还是一个？我觉得回答1个或者2个都说得过去，字面常量"String"在加载期已经创建到常量池中了，然后在运行期执行这段代码时，只是从常量池ldc到栈上然后使用它在堆中创建一个新的String实例。从运行期看，确实这个时候只创建了一个实例，但是从整个JVM来看，确实存在2个地址都有"String"的字符串。其实这个问题扩展一下来聊更有价值：</p>\n<pre><code class="java"><span class="code-keyword">package</span> example;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">StringExample</span> </span>{\n\t<span class="code-keyword">final</span> <span class="code-keyword">static</span> String static1 = <span class="code-string">"myString"</span>;\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tString slot1 = static1;\n\t\tString slot2 = <span class="code-string">"my"</span> + <span class="code-string">"String"</span>;\n\t\tString slot3 = <span class="code-keyword">new</span> String(static1);\n\t\tString slot4 = <span class="code-keyword">new</span> String(<span class="code-string">"myString"</span>);\n\t\tString slot5 = <span class="code-keyword">new</span> String(slot1);\n\t}\n}</code></pre>\n<p>问题是这个main方法运行后在整个JVM内存中创建了几个"myString"？先看了字节码再给答案。</p>\n<pre><code class="apache"><span class="code-attribute">public</span> class string.StringExample {\n  <span class="code-attribute">static</span> final java.lang.String static1; //static签名\n\n  <span class="code-attribute">public</span> string.StringExample();\n    <span class="code-attribute">Code</span>:                    //构造方法\n       <span class="code-attribute">0</span>: aload_0            //读取本地存储[0]压入栈\n       <span class="code-attribute">1</span>: invokespecial #13  //弹出栈顶引用执行Object.init方法\n       <span class="code-attribute">4</span>: return\n\n  <span class="code-attribute">public</span> static void main(java.lang.String[]); //main方法\n    <span class="code-attribute">Code</span>:\n       <span class="code-attribute">0</span>: ldc           #8   //从常量池读引用#8(<span class="code-string">"myString"</span>)压入栈\n       <span class="code-attribute">2</span>: astore_1           //弹出栈顶引用写入本地内存[1],即slot1=static1\n       <span class="code-attribute">3</span>: ldc           #8   //从常量池读#8(<span class="code-string">"myString"</span>)压入栈\n       <span class="code-attribute">5</span>: astore_2           //弹出栈顶引用写入本地内存[2],即slot2=<span class="code-string">"my"</span>+<span class="code-string">"String"</span>\n       <span class="code-attribute">6</span>: new           #21  //在堆中创建一个String实例并将引用压入栈\n       <span class="code-attribute">9</span>: dup                //复制栈顶元素\n      <span class="code-attribute">10</span>: ldc           #8   //从常量池读#8(<span class="code-string">"myString"</span>)压入栈\n      <span class="code-attribute">12</span>: invokespecial #23  //弹出栈顶引用，使用String.init方法初始化堆   \n      <span class="code-attribute">15</span>: astore_3           //弹出栈顶堆引用写入本地存储[3]\n      <span class="code-attribute">16</span>: new           #21  //16～25行执行过错和6～15行一样               \n      <span class="code-attribute">19</span>: dup\n      <span class="code-attribute">20</span>: ldc           #8                  \n      <span class="code-attribute">22</span>: invokespecial #23  \n      <span class="code-attribute">25</span>: astore        4    //栈顶元素写入本地存储[4]\n      <span class="code-attribute">27</span>: new           #21  //与16～15行一致               \n      <span class="code-attribute">30</span>: dup\n      <span class="code-attribute">31</span>: aload_1            //区别在31行是从本地存储[1]的位置读取数据，而[1]引用#8(<span class="code-string">"myString"</span>)\n      <span class="code-attribute">32</span>: invokespecial #23  \n      <span class="code-attribute">35</span>: astore        5    //栈顶元素写入本地存储[5]\n      <span class="code-attribute">37</span>: return\n}\n</code></pre>\n<p>如果看明白了字节码，这个答案就很清晰了，整个JVM一共三个值等于"myString"的字符串，即创建了3个字符串。</p>\n<p>首先，在java代码编译成字节码时，static关键字定义的常量会直接替换为字面量放置在class常量池，所以例子中&nbsp;<em>String slot3 = new String(static1)</em> 这样的写法等于&nbsp;<em>String slot3 = new String("myString") </em>。</p>\n<p>其次，常量池值只有#8的引用值为"myString"的字面量，所以在声明字符串时"my"+"String"这样的写法并不会额外生成多的字符串，编译器会直接合并为"myString"。</p>'},318:function(n,s,a){"use strict";Object.defineProperty(s,"__esModule",{value:!0});s.content='<h2 id="h2-1">jolokia架构</h2>\n<p>虽然jolokia是为了满足JSR-160的要求，但是他和JSR-160连接器有巨大的差异。其中最引人注目的区别是jolokia传递数据是无类型的数据（<span style="color:#FF8C00"><em>说白了就是使用了Json数据传递，替代了RMI传递Java序列化数据的方式</em></span>）。\n</p>\n<p>2003年提交的JSR-160规定客户端可以透明的调用MBean服务，无论被调用的MBean是驻留在本地还是在远程的MBean服务中。这样做的好处是提供了一个简洁通用的Java\n    API接口。但是JSR-160的实现存在许多问题：</p>\n<ol>\n    <li>它非常危险，因为它隐性暴露了JMX的远程接口。</li>\n    <li>它还存在性能问题。无论是远程还是本地调用，调用者至少要知道调用过程是怎么样的、会收到什么结果。在实际使用时，需要有明确的远程消息传递模式，让调用者知道现在是在使用响应较慢的远程调用。</li>\n    <li>使用RMI（<em><span style="color:#FF8C00">JSR-160连接器的默认协议栈</span></em>）时需要使用Java对象的序列化与反序列化机制来构建传递管道。这样做就阻碍了Java技术栈之外的环境来使用它。\n    </li>\n</ol>\n<p>以上3个原因大概就是RMI（<span style="color:#FF8C00"><em>JSR-160连接器的默认协议栈</em></span>）在远程传输协议上逐渐失去市场份额的原因。</p>\n<p>Jolokia是无类型的数据，使用了Json这种轻量化的序列化方案来替代RMI方案。使用这样的方法当然存在一些缺点（<em>比如需要额外增加一层代理</em>），但是带来了一些优势，至少这样的实现方案在JMX世界是独一无二的。</p>\n\n<h2 id="h2-2">Jolokia植入模式（Agent mode）</h2>\n<p><img alt="Jolokia——架构与使用介绍" height="489"\n        src="https://file.mahoooo.com/res/file/jolokia_how_to_use_2.png" width="666"></p>\n<p>上如展示了Jolokia 植入模式的体系结构，说明了与之有关的运行环境。</p>\n<p>Jolokia植入模式是在本地基于http协议提供了一个使用Json作为数据格式的外部接口，此时Jolokia会桥接到本地的JMX\n    MBeans接口。Jolokia使用http服务扩展了JSR-160，因此需要针对Jolokia的运行进行一些额外的处理。多种技术可以工作于http协议，最常规的方法是将jolokia放置到servlet容器中，比如Tomcat或Jetty，这样Jolokia完全可以看做是一个常规的Java\n    web应用，让所有的开发人员都能够很好理解并快速的从中读取数据。</p>\n<p>当然还有更多的方式使用Jolokia植入，比如使用OSGi HttpService或嵌入到有Jetty-Server的应用中。Jvm代理者需要使用Java1.6以上版本，在他运行时，可以连接到任何本地运行的Java进程。</p>\n<p><span style="color:#FF8C00"><em>附注——关于“植入模式”的称呼的说明：官方名为“Agent mode”，按照字面意思应该译为“代理者模式”。但是后面又一个模式叫代理模式（Proxy Mode），为了更便于理解和表达中文意思，这里命名其为“植入模式”。</em></span>\n</p>\n\n<h2 id="h2-3">Jolokia代理模式</h2>\n<p>代理模式用于无法将Jolokia部署到目标平台上（说白了就是无法部署到同一台服务器）。在这个模式下，唯一可用的方式就是目标服务开启了JSR-160连接。这样做大部分是规范原因（原文是“political\n    reasons”——政治原因-_-）——有时候根本不允许在目标服务器部署一个额外的软件系统，或者是这样做需要等待一个漫长的审批流程。还有一个原因是目标服务器已经通过RMI开启了JSR-160连接，并且我们不想额外再去在本地部署Jolokia。</p>\n<p>可以将jolokia.war部署到servlet容器中（这个war包也可用于植入模式）。下图是一个典型的代理模式架构。</p>\n<p><img alt="Jolokia——架构与使用介绍" height="439"\n        src="https://file.mahoooo.com/res/file/jolokia_how_to_use_1.png" width="617"></p>\n<p>一个jolokia客户端发送常规的请求到jolokia代理服务，这个请求包含了额外的数据用于标记要查询的目标。所有的路由信息包含在请求信息中，使得代理服务无需特别的配置即可工作。</p>\n\n<h2 id="h2-4">结尾</h2>\n<p>如果没有什么特别的限制，优先使用植入模式。植入模式比代理模式有更多的优势，因为他没有附加层、减少了维度成本和技术复杂性、而且性能也优于代理模式。此外，一些jolokia特性也无法在代理模式中使用，例如“merging of\n    MBeanServers”。</p>'},320:function(n,s,a){"use strict";Object.defineProperty(s,"__esModule",{value:!0});s.content='<p>使用apt安装好处在于统一升级方便，不用单独手工安装。默认情况下nginx已经支持apt-get安装，但是安装的包是比较老旧的10.x版本。我们可以通过添加nginx\n    deb安装源的方式来使用最新稳定版的nginx，还可以实时通过update和upgrade命令保持最新的未定版nginx。</p>\n\n<h2 id="h2-1">添加apt-key</h2>\n<pre class="css"><code class="language-bash"><span class="code-selector-tag">sudo</span> <span\n        class="code-selector-tag">apt-key</span> <span class="code-selector-tag">add</span> <span\n        class="code-selector-tag">nginx_signing</span><span class="code-selector-class">.key</span></code></pre>\n<p>由于需要使用nginx官方指定的deb源下载最新稳定版本的nginx，所以需要先添加一个信任公钥（PGP）。可以将下列公钥复制保存为一个名为nginx_signing.key的文件（也可到<a\n        href="http://nginx.org/keys/nginx_signing.key" rel="nofollow">官网</a>去下载）：</p>\n<pre class="groovy"><code class="groovy">-----BEGIN PGP PUBLIC KEY BLOCK-----\n<span class="code-string"><span class="code-string">Version:</span></span> GnuPG v2<span class="hljs-number"><span\n            class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.22</span></span> (GNU/Linux)\n\nmQENBE5OMmIBCAD+FPYKGriGGf7NqwKfWC83cBV01gabgVWQmZbMcFzeW+hMsgxH\nW6iimD0RsfZ9oEbfJCPG0CRSZ7ppq5pKamYs2+EJ8Q2ysOFHHwpGrA2C8zyNAs4I\nQxnZZIbETgcSwFtDun0XiqPwPZgyuXVm9PAbLZRbfBzm8wR/<span class="hljs-number"><span class="hljs-number">3</span></span>SWygqZBBLdQk5TE\nfDR+Eny<span class="hljs-regexp"><span class="hljs-regexp">/M1RVR4xClECONF9UBB2ejFdI1LD45APbP2hsN/</span></span>piFByU1t7yK2gpFyRt\n<span class="hljs-number"><span class="hljs-number">97</span></span>WzGHn9MV5/TL7AmRPM4pcr3JacmtCnxXeCZ8nLqedoSuHFuhwyDnlAbu8I16O5\nXRrfzhrHRJFM1JnIiGmzZi6zBvH0ItfyX6ttABEBAAG0KW5naW54IHNpZ25pbmcg\na2V5IDxzaWduaW5nLWtleUBuZ2lueC5jb20+iQE+BBMBAgAoAhsDBgsJCAcDAgYV\nCAIJCgsEFgIDAQIeAQIXgAUCV2K1+AUJGB4fQQAKCRCr9b2Ce9m<span class="hljs-regexp"><span\n            class="hljs-regexp">/YloaB/</span></span><span class="hljs-number"><span class="hljs-number">9</span></span>XGrol\nkocm7l<span class="hljs-regexp"><span class="hljs-regexp">/tsVjaBQCteXKuwsm4XhCuAQ6YAwA1L1UheGOG/</span></span>aa2xJvrXE8X32tgcTjr\nKoYoXWcdxaFjlXGTt6jV85qRguUzvMOxxSEM2Dn115etN9piPl0Zz+<span class="hljs-number"><span\n            class="hljs-number">4</span></span>rkx8+<span class="hljs-number"><span class="hljs-number">2</span></span>vJG\nF+eMlruPXg/zd88NvyLq5gGHEsFRBMVufYmHtNfcp4okC1klWiRIRSdp4QY1wdrN\n<span class="hljs-number"><span class="hljs-number">1</span></span>O+<span class="hljs-regexp"><span\n            class="hljs-regexp">/oCTl8Bzy6hcHjLIq3aoumcLxMjtBoclc/</span></span><span class="hljs-number"><span\n            class="hljs-number">5</span></span>OTioLDwSDfVx7rWyfRhcBzVbwD\noe<span class="hljs-regexp"><span class="hljs-regexp">/PD08AoAA6fxXvWjSxy+dGhEaXoTHjkCbz/</span></span>l6NxrK3JFyauDgU4K4MytsZ1HDi\nMgMW8hZXxszoICTTiQEcBBABAgAGBQJOTkelAAoJEKZP1bF62zmo79oH/<span class="hljs-number"><span\n            class="hljs-number">1</span></span>XDb29S\nYtWp+MTJTPFEwlWRiyRuDXy3wBd/BpwBRIWfWzMs1gnCjNjk0EVBVGa2grvy9Jtx\nJKMd6l<span class="hljs-regexp"><span class="hljs-regexp">/PWXVucSt+U/</span></span>+GO8rBkw14SdhqxaS2l14v6gyMeUrSbY3XfToGfwHC4sa/\nThn8X4jFaQ2XN5dAIzJGU1s5JA0tjEzUwCnmrKmyMlXZaoQVrmORGjCuH0I0aAFk\nRS0UtnB9HPpxhGVbs24xXZQnZDNbUQeulFxS4uP3OLDBAeCHl+v4t/uotIad8v6J\nSO93vc1evIje6lguE81HHmJn9noxPItvOvSMb2yPsE8mH4cJHRTFNSEhPW6ghmlf\nWa9ZwiVX5igxcvaIRgQQEQIABgUCTk5b0gAKCRDs8OkLLBcgg1G+AKCnacLb/+W6\ncflirUIExgZdUJqoogCeNPVwXiHEIVqithAM1pdY/gcaQZmIRgQQEQIABgUCTk5f\nYQAKCRCpN2E5pSTFPnNWAJ9gUozyiS+<span class="hljs-number"><span class="hljs-number">9</span></span>jf2rJvqmJSeWuCgVRwCcCUFhXRCpQO2Y\nVa3l3WuB+rgKjsQ=\n=EWWI\n-----END PGP PUBLIC KEY BLOCK-----</code></pre>\n<p>然后执行以下命令：</p>\n<pre class="css"><code class="language-bash"><span class="code-selector-tag">sudo</span> <span\n        class="code-selector-tag">apt-key</span> <span class="code-selector-tag">add</span> <span\n        class="code-selector-tag">nginx_signing</span><span class="code-selector-class">.key</span></code></pre>\n\n<h2 id="h2-2">设置apt的deb源</h2>\n<p>首先需要明确当前的ubuntu版本，在安装nginx时不同的ubuntu版本对应不同的nginx安装包。对照如下：</p>\n<table border="1" cellpadding="1" cellspacing="1" style="width:500px">\n    <tbody>\n    <tr>\n        <td>版本</td>\n        <td>安装包别名</td>\n        <td>适用平台</td>\n    </tr>\n    <tr>\n        <td>14.04</td>\n        <td>trusty</td>\n        <td>x86_64, i386, aarch64/arm64</td>\n    </tr>\n    <tr>\n        <td>16.04</td>\n        <td>xenial</td>\n        <td>x86_64, i386, ppc64el, aarch64/arm64</td>\n    </tr>\n    <tr>\n        <td>17.10</td>\n        <td>artful</td>\n        <td>x86_64, i386</td>\n    </tr>\n    </tbody>\n</table>\n<p>打开apt的安装源配置文件——/etc/apt/sources.list。在文件尾部添加：</p>\n<ul>\n    <li>deb http://nginx.org/packages/ubuntu/ <span style="color:#FF0000">code</span> nginx</li>\n    <li>deb-src http://nginx.org/packages/ubuntu/ <span style="color:#FF0000">code</span> nginx</li>\n</ul>\n<p>注意标红的code需要根据ubuntu的版本号按照上面的表替换对应的别名。</p>\n<p>设置好之后使用checklog命令可以看到现在已经切换到最新的稳定版本了。（不会输出日志，只有一个版本号）</p>\n\n<h2 id="h2-3">安装nginx</h2>\n<p>最后更新安装源列表，然后安装nginx。</p>\n<pre class="sql"><code class="language-bash">apt-get <span class="code-keyword">update</span>\napt-<span class="code-keyword">get</span> <span class="code-keyword">install</span> nginx</code></pre>\n\n<h2 id="h2-4">安装最新发布版本</h2>\n<p>除了稳定版本，也可以通过apt的方式安装最新发布版本（Mainline）。只需要修改安装源头的路径即可——将/etc/apt/sources.list中的deb源修改为：</p>\n<ul>\n    <li>deb http://nginx.org/packages/mainline/ubuntu/ <span style="color:#FF0000"><em>code</em></span> nginx</li>\n    <li>deb-src http://nginx.org/packages/mainline/ubuntu/ <span style="color:#FF0000"><em>code</em></span> nginx</li>\n</ul>\n<p>更多的安装方式详见<a href="http://nginx.org/en/docs/install.html" rel="nofollow">官网</a></p>'},322:function(n,s,a){"use strict";Object.defineProperty(s,"__esModule",{value:!0});s.content='<p>使用react到现在，让人头疼的一个问题是安装node-sass。其实导致问题的根源在于安装过程需要下载一个binding.node文件，而因“你懂的”原因，访问不了这个地址。根据这个原因，总结了以下几个解决方案：</p>\n<h2 id="h2-1">翻墙</h2>\n<p>这没什么好说的了，这是最轻松最彪悍的解决方案。只要能翻墙直接一个&nbsp;<span style="background-color:#D3D3D3">&nbsp;npm i&nbsp;</span>命令就完事了，什么都不必去操心。至于怎么翻墙…………\n</p>\n\n<h2 id="h2-2">使用cnpm</h2>\n<p>cnpm是一个强悍的工具，几乎能解决所有npm安装第三方包时遇到的问题。执行如下命令即可：</p>\n<pre class="sql"><code class="language-bash">npm <span class="code-keyword">install</span>\nnpm rm node-sass\ncnpm <span class="code-keyword">install</span> node-sass\nnpm <span class="code-keyword">install</span></code></pre>\n<p>\n    但是我们在使用cnpm时也遇到了一个坑，在ubuntu14.04打出来的包运行报错，不用cnpm下载居然就不会有这问题，由于没有时间，没有详细去了解原因是什么。如果你是Windows开发而使用Linux环境打包或运行，可能会碰到这个问题。</p>\n\n<h2 id="h2-3">下载后编译</h2>\n<p>\n    实际上为了得到binding.node，是可以直接从github上把源码下载下来之后再编译出来的，node-sass自己也会这样做，但是编译要依赖其他工具。在各种发行版的linux下还好，几乎所有需要的环境（python等）都是预安装的，如果是root权限直接<span\n        style="background-color:#A9A9A9"> upm install </span>就搞定了，所以有时候根本感觉不到这个问题。在windows下就得花时间根据install时的错误日志了解还要安装什么。\n</p>\n<p>linux下遇到权限问题请执行：</p>\n<pre class="lua"><code class="language-bash">npm i <span class="code-comment">--unsafe -perm</span></code></pre>\n\n<h2 id="h2-4">附送一个最奇葩的坑</h2>\n<p>这是我用所有的开源工具遇到过最奇葩的坑。我将一个文件命名为“./dropDown.scss”，然后在linux(是ubuntu\n    14.04其他发行版没时间去测试，windows没这毛病)上用webpack打包，打包过程没有任何异常，但是放到服务器上运行打开某个页面就抛出无法找到"./dropDown.scss"的异常，然后node直接停机了········。我前后跟进了2天寻找问题的原因。最后突发奇想将文件名由dropDown.scss修改为pullDown.scss后一切都好了。我强烈的怀疑是某个临时工在node-sass里写了什么“硬编码”对字符串进行判断，发现“/drop[*]”这样的前缀进行一些特殊处理。在此记录下来。</p>'}});