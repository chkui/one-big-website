webpackJsonp([4],{340:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<h2 id="h2-1">分区规范</h2>\n<p>首先要明确，JVM规范中并没有常量池这一说法，都是各种不同的jvm实现为了便于处理加以区分的。在JVM规范中统一称呼为方法区（JDK7之后这样说也不准确，有些数据常量数据又迁移到堆中）。下面的常量池主要以Java8自带的HotSpot为例，其他版本的Jvm会有各种区别。在HotSpot中，JDK6之前的版本所有常量池都在永生代（permanent generation）中，而JDK8取消了永生带用元空间（metaspace）替换，可以简单的理解常量池被移动到元空间中了（但实际处理还是有很多差异，大部分以前放置在永生代数据被迁移到堆中，而元数据区仅存放引用。但是这样说便于理解）。JDK7是一个过渡版本，只是将字符串移动到堆中。</p>\n\n<h2 id="h2-2">class常量池</h2>\n<p>当 .java文件被<span style="color:#FF0000">转译</span>成.class文件之后的字节码中包含一系列描述信息、符号引用和字面量信息。在jvm启动时，这些信息会被加载到class常量池中，当一个类要被<span style="color:#FF0000">编译</span>加载之前这些符号和字符串会经过JVM的加载器将其实例化成为一个常量值（Class对象的实例）存在在运行时常量区。所谓的class常量池并不会真的需要分配一个内存空间（常量池），直接从本地磁盘上加载转换也是可行的，这主要取决与JVM的版本和一些参数的配置处理。</p>\n\n<h2 id="h2-3">运行时常量池</h2>\n<p>运行时常量池（Runtime Constant Pool）主要用于存放jvm在运行时所有静态量。参考"深入理解java虚拟机"一书2.2.6对其的描述：运行时常量池是方法区的一部分。class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是<strong>常量池表</strong>（Constant Pool Tabel），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入该常量池。运行时常量池并不仅仅局限于加载类时产生常量，与<strong>class常量池</strong>的区别是可以在运行期间添加各种数据到这个区域，例如jvm会将代码中直接声明的字符串放置到常量池中，这些字符串被称为字面量。通过<em>String::intern</em> 也可以向常量池表添加新的字面量。</p>\n\n<h2 id="h2-4">代码与字节码案例</h2>\n<p>下面通过一些例子来加深堆常量池的理解。</p>\n<p>字面量定义变量值：</p>\n<pre><code class="java"><span class="code-comment">//会直接在常量池中生成一个字符串常量，并将str1的引用（指针）指向它。</span>\nString str1 = <span class="code-string">"myString"</span>;\nString str2 = <span class="code-string">"myString"</span>;\n<span class="code-comment">//都是指向常量池的同一地址，所以这里输出为true;</span>\nSystem.out.println(str1 == str2);</code></pre>\n<p>与字符串相比，数字处理的情况就比较有趣了。先看一个单纯的例子：</p>\n<pre><code class="java">Integer num1 = <span class="hljs-number">127</span>;\nInteger num2 = <span class="hljs-number">127</span>;\nInteger num3 = <span class="hljs-number">128</span>;\nInteger num4 = <span class="hljs-number">128</span>;\nSystem.out.println(num1 == num2);<span class="code-comment">//TRUE</span>\nSystem.out.println(num3 == num4);<span class="code-comment">//FALSE</span></code></pre>\n<p>第一个对比输出为true，而第二个输出为false。这就是10次Java笔试9次都会遇到的Integer 预设-128~127对象的问题——为了循环、迭代等等常见处理不反复创建新的区域来存储值，Jvm预设了部分Integer整数值，无论哪申请这些值，都指定到固定的常量地址。</p>\n<p>再来看一个有意思的例子：</p>\n<pre><code class="java"><span class="code-keyword">int</span> i = <span class="hljs-number">128</span>;\nInteger I1 = <span class="hljs-number">128</span>;\nInteger I2 = <span class="hljs-number">128</span>;\nSystem.out.println(I1 == I2);<span class="code-comment">//false</span>\nSystem.out.println(I1 == i);<span class="code-comment">//true</span>\nSystem.out.println(I2 == i);<span class="code-comment">//true</span></code></pre>\n<p>输出的结果主要受到Java5之后装箱和拆箱的机制影响。</p>\n<blockquote>\n    <p>字节码解释说明：</p>\n    <p>在每一个字节码指令之后都会有注解说明。每一行注解包括2部分内容，1是指令进行的操作描述，2是操作之后的结果。2部分用;号分割。</p>\n    <p>操作结果中S代表<strong>stack</strong>——线程栈，L代表<strong>local</strong>——本地存储。I(128)表示类型为Integer值为128的引用。"string"标示一个常量，S("string")表示类型为String值为"string"的堆数据。例如，S=[I(128)],L=[128]标示线程栈中存在一个值为128的Integer类型引用，而缓存的L[0]位置存放了值为128的整数。</p>\n    <p>缓存的下标从1开始，因为0位置已经留给了this。</p>\n    <p>用于存放指令集运算结果的本地存储我们通称为缓存。</p>\n</blockquote>\n<p>首先，在Java5之前，是不能这样写的。Java5之后有了装箱机制，这样的语句实际上执行的是 <em>Integer I1 =&nbsp;Integer.valueOf(128)</em>。所以变量I1和I2是指向2个实例的引用地址，因此 "I1==I2"是false很好理解。那么另外2个==为什么是true呢。看下面的Java代码和对应的字节码：</p>\n<pre><code class="java"><span class="code-keyword">int</span> slot1 = <span class="hljs-number">128</span>;\nInteger slot2 = <span class="hljs-number">128</span>;\nSystem.out.println(slot1 == slot2);</code></pre>\n<p>对应的字节码是：&nbsp;</p>\n<pre><code class="apache"> <span class="code-attribute">0</span>: sipush        128 //128压栈;S=[128],L=[]\n <span class="code-attribute">3</span>: istore_1          //128出栈,写入缓存;S=[],L=[128]\n <span class="code-attribute">4</span>: sipush        128 //128压栈;S=[128],L=[128]\n <span class="code-attribute">7</span>: invokestatic  #16 //128出栈,执行I.valueOf(128)结果入栈;S=[I(128)],L=[128]\n<span class="code-attribute">10</span>: astore_2          //I(128)出栈写入缓存。S=[],L=[128,I(128)]\n<span class="code-attribute">11</span>: getstatic     #22 //从常量池读取PrintStream压栈;S=[PrintStream],L=[128,I(128)]\n<span class="code-attribute">14</span>: aload_2           //缓存数据[2]压栈；S=[I(128),PrintStream],L=[128,I(128)]\n<span class="code-attribute">15</span>: invokevirtual #28 //I(128)出栈，执行I.intValue结果入栈;S=[128,PrintStream],L=[128,I(128)]\n<span class="code-attribute">18</span>: iload_1           //缓存数据[1]压栈；S=[128,128,PrintStream],L=[128,I(128)]\n<span class="code-attribute">19</span>: if_icmpne     26  //S[0]和S[1]出栈使用if_icmpne数值对比。S=[PrintStream],L=[128,I(128)]\n<span class="code-attribute">22</span>: iconst_1          //将整数1压入栈;S=[1,PrintStream],L=[128,I(128)]\n<span class="code-attribute">23</span>: goto          27  //跳转到27行\n<span class="code-attribute">26</span>: iconst_0          //将整数0压入栈;S=[0,PrintStream],L=[128,I(128)]\n<span class="code-attribute">27</span>: invokevirtual #32 //S[0]和S[1]出栈使用println输出;S=[],L=[128,I(128)]\n<span class="code-attribute">30</span>: return            \n</code></pre>\n<p>核心在4~10行装箱，将一个128整数转换成一个Integer的引用，数据存储在堆中。然后在14～19行拆箱，将堆中的Integer数据转换成一个int整数，然后再用int整数和int整数进行==比较（if_icmpne）。所以比较之后会输出true。</p>\n<p>接下来是一个解释class常量池和常量池的例子。</p>\n<p>Java代码：</p>\n<pre><code class="java">String slot1 = <span class="code-string">"myString"</span>;\nString slot2 = <span class="code-keyword">new</span> String(<span class="code-string">"myString"</span>);\nSystem.out.println(slot1 == slot2); <span class="code-comment">//FALSE</span></code></pre>\n<p>"myString"这样的字符串，在类加载编译字节码时（从class常量池转变成运行时的常量池）就会生成一个常量并放置在常量池中，随后所有使用到这个字符串的位置，都是直接从常量池引用。下面是对应的字节码：</p>\n<pre><code class="apache"> <span class="code-attribute">0</span>: ldc           #16 //常量池读取<span class="code-string">"myString"</span>压栈;S=[<span class="code-string">"myString"</span>],L=[]\n <span class="code-attribute">2</span>: astore_1          //写入本地缓存;S=[],L=[<span class="code-string">"myString"</span>]\n <span class="code-attribute">3</span>: new           #18 //堆中创建一个String实例压栈;S=[S()],L=[<span class="code-string">"myString"</span>]\n <span class="code-attribute">6</span>: dup               //复制栈顶;S=[S(),S()],L=[<span class="code-string">"myString"</span>]\n <span class="code-attribute">7</span>: ldc           #16 //常量池读取<span class="code-string">"myString"</span>压栈;S=[<span class="code-string">"myString"</span>,S(),S()],L=[<span class="code-string">"myString"</span>]\n <span class="code-attribute">9</span>: invokespecial #20 //弹出S[0,1]作为参数使用init初始化;S=[S(<span class="code-string">"myString"</span>)],L=[<span class="code-string">"myString"</span>]\n<span class="code-attribute">12</span>: astore_2          //弹出栈顶写入缓存[2];S=[],L=[<span class="code-string">"myString"</span>,S(<span class="code-string">"myString"</span>)]\n<span class="code-attribute">13</span>: getstatic     #23 //获取输出常量;S=[PrintStream],L=[<span class="code-string">"myString"</span>,S(<span class="code-string">"myString"</span>)]\n<span class="code-attribute">16</span>: aload_1           //缓存[1]入栈;S=[<span class="code-string">"myString"</span>,PrintStream],L=[<span class="code-string">"myString"</span>,S(<span class="code-string">"myString"</span>)]\n<span class="code-attribute">17</span>: aload_2           //缓存[2]入栈;S=[S(<span class="code-string">"myString"</span>),<span class="code-string">"myString"</span>,PrintStream],L=[<span class="code-string">"myString"</span>,S(<span class="code-string">"myString"</span>)]\n<span class="code-attribute">18</span>: if_acmpne     25  //弹出S[0,1]比较;S=[PrintStream],L=[<span class="code-string">"myString"</span>,S(<span class="code-string">"myString"</span>)]\n<span class="code-attribute">21</span>: iconst_1          //整数1压栈;S=[1,PrintStream],L=[<span class="code-string">"myString"</span>,S(<span class="code-string">"myString"</span>)]\n<span class="code-attribute">22</span>: goto          26  //跳转26\n<span class="code-attribute">25</span>: iconst_0          //整数0压栈;S=[0,PrintStream],L=[<span class="code-string">"myString"</span>,S(<span class="code-string">"myString"</span>)]\n<span class="code-attribute">26</span>: invokevirtual #29 //弹出S[0,1]执行输出;S=[],L=[<span class="code-string">"myString"</span>,S(<span class="code-string">"myString"</span>)]\n<span class="code-attribute">29</span>: return\n</code></pre>\n<p>Java字节码中的ldc标示从常量池获取一个引用入栈，例子将常量池的引用#16压入栈，然后astore_1将#16写到本地存储[1]位置。所以slot1 = "myString"意味着slot1指向了常量池存放"myString"的位置。</p>\n<p>3~12行完成slot2 = new String("myString")的过程：3行，new指令先在栈上创建了一个指向一个String实例堆空间的引用；6行，在栈顶复制这个引用；7行，从常量池读取"myString"这个常量的引用；9行，弹出栈顶的"myString"引用作为执行String.init方法的参数，执行完都会更新堆中的数据；12）将栈顶dup指令复制出的引用弹出并写入本地存储[2]位置。此时slot2引用了堆空间中的一个String实例。所以slot1==slot2操作（if_acmpne）肯定返回false。</p>\n<p>这个例子揭开了一个Java基础问题的答案——String s = new String("String")是创建了2个字符串还是一个？我觉得回答1个或者2个都说得过去，字面常量"String"在加载期已经创建到常量池中了，然后在运行期执行这段代码时，只是从常量池ldc到栈上然后使用它在堆中创建一个新的String实例。从运行期看，确实这个时候只创建了一个实例，但是从整个JVM来看，确实存在2个地址都有"String"的字符串。其实这个问题扩展一下来聊更有价值：</p>\n<pre><code class="java"><span class="code-keyword">package</span> example;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">StringExample</span> </span>{\n\t<span class="code-keyword">final</span> <span class="code-keyword">static</span> String static1 = <span class="code-string">"myString"</span>;\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tString slot1 = static1;\n\t\tString slot2 = <span class="code-string">"my"</span> + <span class="code-string">"String"</span>;\n\t\tString slot3 = <span class="code-keyword">new</span> String(static1);\n\t\tString slot4 = <span class="code-keyword">new</span> String(<span class="code-string">"myString"</span>);\n\t\tString slot5 = <span class="code-keyword">new</span> String(slot1);\n\t}\n}</code></pre>\n<p>问题是这个main方法运行后在整个JVM内存中创建了几个"myString"？先看了字节码再给答案。</p>\n<pre><code class="apache"><span class="code-attribute">public</span> class string.StringExample {\n  <span class="code-attribute">static</span> final java.lang.String static1; //static签名\n\n  <span class="code-attribute">public</span> string.StringExample();\n    <span class="code-attribute">Code</span>:                    //构造方法\n       <span class="code-attribute">0</span>: aload_0            //读取本地存储[0]压入栈\n       <span class="code-attribute">1</span>: invokespecial #13  //弹出栈顶引用执行Object.init方法\n       <span class="code-attribute">4</span>: return\n\n  <span class="code-attribute">public</span> static void main(java.lang.String[]); //main方法\n    <span class="code-attribute">Code</span>:\n       <span class="code-attribute">0</span>: ldc           #8   //从常量池读引用#8(<span class="code-string">"myString"</span>)压入栈\n       <span class="code-attribute">2</span>: astore_1           //弹出栈顶引用写入本地内存[1],即slot1=static1\n       <span class="code-attribute">3</span>: ldc           #8   //从常量池读#8(<span class="code-string">"myString"</span>)压入栈\n       <span class="code-attribute">5</span>: astore_2           //弹出栈顶引用写入本地内存[2],即slot2=<span class="code-string">"my"</span>+<span class="code-string">"String"</span>\n       <span class="code-attribute">6</span>: new           #21  //在堆中创建一个String实例并将引用压入栈\n       <span class="code-attribute">9</span>: dup                //复制栈顶元素\n      <span class="code-attribute">10</span>: ldc           #8   //从常量池读#8(<span class="code-string">"myString"</span>)压入栈\n      <span class="code-attribute">12</span>: invokespecial #23  //弹出栈顶引用，使用String.init方法初始化堆   \n      <span class="code-attribute">15</span>: astore_3           //弹出栈顶堆引用写入本地存储[3]\n      <span class="code-attribute">16</span>: new           #21  //16～25行执行过错和6～15行一样               \n      <span class="code-attribute">19</span>: dup\n      <span class="code-attribute">20</span>: ldc           #8                  \n      <span class="code-attribute">22</span>: invokespecial #23  \n      <span class="code-attribute">25</span>: astore        4    //栈顶元素写入本地存储[4]\n      <span class="code-attribute">27</span>: new           #21  //与16～15行一致               \n      <span class="code-attribute">30</span>: dup\n      <span class="code-attribute">31</span>: aload_1            //区别在31行是从本地存储[1]的位置读取数据，而[1]引用#8(<span class="code-string">"myString"</span>)\n      <span class="code-attribute">32</span>: invokespecial #23  \n      <span class="code-attribute">35</span>: astore        5    //栈顶元素写入本地存储[5]\n      <span class="code-attribute">37</span>: return\n}\n</code></pre>\n<p>如果看明白了字节码，这个答案就很清晰了，整个JVM一共三个值等于"myString"的字符串，即创建了3个字符串。</p>\n<p>首先，在java代码编译成字节码时，static关键字定义的常量会直接替换为字面量放置在class常量池，所以例子中&nbsp;<em>String slot3 = new String(static1)</em> 这样的写法等于&nbsp;<em>String slot3 = new String("myString") </em>。</p>\n<p>其次，常量池值只有#8的引用值为"myString"的字面量，所以在声明字符串时"my"+"String"这样的写法并不会额外生成多的字符串，编译器会直接合并为"myString"。</p>'},348:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<p>使用apt安装好处在于统一升级方便，不用单独手工安装。默认情况下nginx已经支持apt-get安装，但是安装的包是比较老旧的10.x版本。我们可以通过添加nginx\n    deb安装源的方式来使用最新稳定版的nginx，还可以实时通过update和upgrade命令保持最新的未定版nginx。</p>\n\n<h2 id="h2-1">添加apt-key</h2>\n<pre class="css"><code class="language-bash"><span class="code-selector-tag">sudo</span> <span\n        class="code-selector-tag">apt-key</span> <span class="code-selector-tag">add</span> <span\n        class="code-selector-tag">nginx_signing</span><span class="code-selector-class">.key</span></code></pre>\n<p>由于需要使用nginx官方指定的deb源下载最新稳定版本的nginx，所以需要先添加一个信任公钥（PGP）。可以将下列公钥复制保存为一个名为nginx_signing.key的文件（也可到<a\n        href="http://nginx.org/keys/nginx_signing.key" rel="nofollow">官网</a>去下载）：</p>\n<pre class="groovy"><code class="groovy">-----BEGIN PGP PUBLIC KEY BLOCK-----\n<span class="code-string"><span class="code-string">Version:</span></span> GnuPG v2<span class="hljs-number"><span\n            class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.22</span></span> (GNU/Linux)\n\nmQENBE5OMmIBCAD+FPYKGriGGf7NqwKfWC83cBV01gabgVWQmZbMcFzeW+hMsgxH\nW6iimD0RsfZ9oEbfJCPG0CRSZ7ppq5pKamYs2+EJ8Q2ysOFHHwpGrA2C8zyNAs4I\nQxnZZIbETgcSwFtDun0XiqPwPZgyuXVm9PAbLZRbfBzm8wR/<span class="hljs-number"><span class="hljs-number">3</span></span>SWygqZBBLdQk5TE\nfDR+Eny<span class="hljs-regexp"><span class="hljs-regexp">/M1RVR4xClECONF9UBB2ejFdI1LD45APbP2hsN/</span></span>piFByU1t7yK2gpFyRt\n<span class="hljs-number"><span class="hljs-number">97</span></span>WzGHn9MV5/TL7AmRPM4pcr3JacmtCnxXeCZ8nLqedoSuHFuhwyDnlAbu8I16O5\nXRrfzhrHRJFM1JnIiGmzZi6zBvH0ItfyX6ttABEBAAG0KW5naW54IHNpZ25pbmcg\na2V5IDxzaWduaW5nLWtleUBuZ2lueC5jb20+iQE+BBMBAgAoAhsDBgsJCAcDAgYV\nCAIJCgsEFgIDAQIeAQIXgAUCV2K1+AUJGB4fQQAKCRCr9b2Ce9m<span class="hljs-regexp"><span\n            class="hljs-regexp">/YloaB/</span></span><span class="hljs-number"><span class="hljs-number">9</span></span>XGrol\nkocm7l<span class="hljs-regexp"><span class="hljs-regexp">/tsVjaBQCteXKuwsm4XhCuAQ6YAwA1L1UheGOG/</span></span>aa2xJvrXE8X32tgcTjr\nKoYoXWcdxaFjlXGTt6jV85qRguUzvMOxxSEM2Dn115etN9piPl0Zz+<span class="hljs-number"><span\n            class="hljs-number">4</span></span>rkx8+<span class="hljs-number"><span class="hljs-number">2</span></span>vJG\nF+eMlruPXg/zd88NvyLq5gGHEsFRBMVufYmHtNfcp4okC1klWiRIRSdp4QY1wdrN\n<span class="hljs-number"><span class="hljs-number">1</span></span>O+<span class="hljs-regexp"><span\n            class="hljs-regexp">/oCTl8Bzy6hcHjLIq3aoumcLxMjtBoclc/</span></span><span class="hljs-number"><span\n            class="hljs-number">5</span></span>OTioLDwSDfVx7rWyfRhcBzVbwD\noe<span class="hljs-regexp"><span class="hljs-regexp">/PD08AoAA6fxXvWjSxy+dGhEaXoTHjkCbz/</span></span>l6NxrK3JFyauDgU4K4MytsZ1HDi\nMgMW8hZXxszoICTTiQEcBBABAgAGBQJOTkelAAoJEKZP1bF62zmo79oH/<span class="hljs-number"><span\n            class="hljs-number">1</span></span>XDb29S\nYtWp+MTJTPFEwlWRiyRuDXy3wBd/BpwBRIWfWzMs1gnCjNjk0EVBVGa2grvy9Jtx\nJKMd6l<span class="hljs-regexp"><span class="hljs-regexp">/PWXVucSt+U/</span></span>+GO8rBkw14SdhqxaS2l14v6gyMeUrSbY3XfToGfwHC4sa/\nThn8X4jFaQ2XN5dAIzJGU1s5JA0tjEzUwCnmrKmyMlXZaoQVrmORGjCuH0I0aAFk\nRS0UtnB9HPpxhGVbs24xXZQnZDNbUQeulFxS4uP3OLDBAeCHl+v4t/uotIad8v6J\nSO93vc1evIje6lguE81HHmJn9noxPItvOvSMb2yPsE8mH4cJHRTFNSEhPW6ghmlf\nWa9ZwiVX5igxcvaIRgQQEQIABgUCTk5b0gAKCRDs8OkLLBcgg1G+AKCnacLb/+W6\ncflirUIExgZdUJqoogCeNPVwXiHEIVqithAM1pdY/gcaQZmIRgQQEQIABgUCTk5f\nYQAKCRCpN2E5pSTFPnNWAJ9gUozyiS+<span class="hljs-number"><span class="hljs-number">9</span></span>jf2rJvqmJSeWuCgVRwCcCUFhXRCpQO2Y\nVa3l3WuB+rgKjsQ=\n=EWWI\n-----END PGP PUBLIC KEY BLOCK-----</code></pre>\n<p>然后执行以下命令：</p>\n<pre class="css"><code class="language-bash"><span class="code-selector-tag">sudo</span> <span\n        class="code-selector-tag">apt-key</span> <span class="code-selector-tag">add</span> <span\n        class="code-selector-tag">nginx_signing</span><span class="code-selector-class">.key</span></code></pre>\n\n<h2 id="h2-2">设置apt的deb源</h2>\n<p>首先需要明确当前的ubuntu版本，在安装nginx时不同的ubuntu版本对应不同的nginx安装包。对照如下：</p>\n<table border="1" cellpadding="1" cellspacing="1" style="width:500px">\n    <tbody>\n    <tr>\n        <td>版本</td>\n        <td>安装包别名</td>\n        <td>适用平台</td>\n    </tr>\n    <tr>\n        <td>14.04</td>\n        <td>trusty</td>\n        <td>x86_64, i386, aarch64/arm64</td>\n    </tr>\n    <tr>\n        <td>16.04</td>\n        <td>xenial</td>\n        <td>x86_64, i386, ppc64el, aarch64/arm64</td>\n    </tr>\n    <tr>\n        <td>17.10</td>\n        <td>artful</td>\n        <td>x86_64, i386</td>\n    </tr>\n    </tbody>\n</table>\n<p>打开apt的安装源配置文件——/etc/apt/sources.list。在文件尾部添加：</p>\n<ul>\n    <li>deb http://nginx.org/packages/ubuntu/ <span style="color:#FF0000">code</span> nginx</li>\n    <li>deb-src http://nginx.org/packages/ubuntu/ <span style="color:#FF0000">code</span> nginx</li>\n</ul>\n<p>注意标红的code需要根据ubuntu的版本号按照上面的表替换对应的别名。</p>\n<p>设置好之后使用checklog命令可以看到现在已经切换到最新的稳定版本了。（不会输出日志，只有一个版本号）</p>\n\n<h2 id="h2-3">安装nginx</h2>\n<p>最后更新安装源列表，然后安装nginx。</p>\n<pre class="sql"><code class="language-bash">apt-get <span class="code-keyword">update</span>\napt-<span class="code-keyword">get</span> <span class="code-keyword">install</span> nginx</code></pre>\n\n<h2 id="h2-4">安装最新发布版本</h2>\n<p>除了稳定版本，也可以通过apt的方式安装最新发布版本（Mainline）。只需要修改安装源头的路径即可——将/etc/apt/sources.list中的deb源修改为：</p>\n<ul>\n    <li>deb http://nginx.org/packages/mainline/ubuntu/ <span style="color:#FF0000"><em>code</em></span> nginx</li>\n    <li>deb-src http://nginx.org/packages/mainline/ubuntu/ <span style="color:#FF0000"><em>code</em></span> nginx</li>\n</ul>\n<p>更多的安装方式详见<a href="http://nginx.org/en/docs/install.html" rel="nofollow">官网</a></p>'},383:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<p>使用spring的这几个配置，可以将旧&lt;xml&gt;配置形式完全使用Java实现，也可以和&lt;xml&gt;嵌套使用。</p>\n<p>@Configuration和@Bean可以配合使用,案例：</p>\n<p>传统XML配置：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n                class="code-string">"classA"</span> <span class="hljs-attr">class</span>=<span class="code-string">"com.ClassA"</span>&gt;</span>\n                <span class="code-tag">&lt;<span class="code-name">constructor-arg</span> <span\n                        class="hljs-attr">ref</span>=<span class="code-string">"ClassB"</span>/&gt;</span>\n        <span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n                class="code-string">"classB"</span> <span class="hljs-attr">class</span>=<span class="code-string">"com.ClassB"</span>&gt;</span>\n                <span class="code-tag">&lt;<span class="code-name">constructor-arg</span> <span\n                        class="hljs-attr">ref</span>=<span class="code-string">"c"</span>/&gt;</span>\n        <span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n                class="code-string">"classC"</span> <span class="hljs-attr">class</span>=<span class="code-string">"com.ClassC"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>对应的可以使用@Configuration和@Bean来实现：</p>\n<pre><code class="java"><span class="code-meta">@Configuration</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">config</span></span>{\n        <span class="code-keyword">public</span> <span class="code-meta">@Bean</span> <span class="hljs-function">ClassA <span\n            class="code-title">classA</span><span class="hljs-params">()</span> </span>{\n                <span class="code-keyword">return</span> <span class="code-keyword">new</span> ClassA(classB());\n        }\n        <span class="code-keyword">public</span> <span class="code-meta">@Bean</span> <span class="hljs-function">ClassB <span\n            class="code-title">classB</span><span class="hljs-params">()</span> </span>{\n                <span class="code-keyword">return</span> <span class="code-keyword">new</span> ClassB(c());\n        }\n        <span class="code-keyword">public</span> <span class="code-meta">@Bean</span> <span class="hljs-function">ClassC <span\n            class="code-title">classC</span><span class="hljs-params">()</span> </span>{\n\n        }\n}</code></pre>\n<p>@DependsOn注解类似于&lt;xml&gt;的depends-on元素，案例如下：</p>\n<pre><code class="java"><span class="code-meta">@DependsOn</span>({<span class="code-string">"classA"</span>,<span\n        class="code-string">"classB"</span>})\n<span class="code-meta">@Component</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">ClassC</span></span>{\n   <span class="code-comment">//codes here</span>\n}</code></pre>\n<p>这样，在初始化ClassC之前，一定会先初始化ClassA和ClassB。</p>\n<p>@Import是导入通过@Configuration配置的Bean。</p>\n<p>先通过@Configuration声明配置类</p>\n<pre><code class="java"><span class="code-meta">@Configuration</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Config</span> </span>{\n    <span class="code-keyword">public</span> <span class="code-meta">@Bean</span> <span\n            class="hljs-function">ClassA <span class="code-title">classA</span> <span\n            class="hljs-params">()</span> </span>{\n        <span class="code-keyword">return</span> <span class="code-keyword">new</span> ClassA();\n    }\n}</code></pre>\n<p>然后使用@Import导入配置类</p>\n<pre><code class="java"><span class="code-meta">@Configuration</span>\n<span class="code-meta">@Import</span>(Config.class)  <span class="code-comment">//导入CDConfig的配置</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">ConfigExt</span> </span>{\n    <span class="code-meta">@Bean</span>(name = <span class="code-string">"classB"</span>)\n    <span class="hljs-function"><span class="code-keyword">public</span> ClassB <span\n            class="code-title">classB</span><span class="hljs-params">(ClassA classA)</span> </span>{\n        <span class="code-comment">// 注入ClassA类型的bean</span>\n        <span class="code-keyword">return</span> <span class="code-keyword">new</span> ClassB(classA);\n    }\n}</code></pre>\n<p>@ImportResource类似于XML配置的&lt;import&gt;元素，如：&lt;import resource="importxml.xml" /&gt;。</p>\n<p>使用方式如下：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"classA"</span> <span class="hljs-attr">class</span>=<span\n        class="code-string">"com.ClassA"</span>&gt;</span>\n       <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n               class="code-string">"classB"</span> <span class="hljs-attr">ref</span>=<span\n               class="code-string">"classB"</span> /&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"classB"</span> <span class="hljs-attr">class</span>=<span\n        class="code-string">"com.ClassB"</span>/</span></code></pre>\n<p>Java类注入：</p>\n<pre><code class="java"><span class="code-meta">@Configuration</span>\n<span class="code-meta">@Import</span>(Config.class)  \n<span class="code-meta">@ImportResource</span>(<span class="code-string">"classpath:importxml.xml"</span>) <span\n            class="code-comment">//导入xml配置项</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">ConfigExt</span></span>{\n\n}</code></pre>'},384:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<h2 id="h2-1">Spring的国际化</h2>\n<p>在<a href="https://www.chkui.com/article/spring/spring_core_context_and_ioc" title="上下文与IoC">上下文与IoC</a>对ApplicationContext以及Context相关的设计模式进行了介绍。ApplicationContext作为一个Context在应用的运行层提供了IoC容器、事件、国际化等功能接口。\n</p>\n<p>Spring的国际化（i18n）功能是通过MessageSource接口实现的，他提供了MessageSource::getMessage方法从预设的资源中获取对应的数据。</p>\n\n<h2 id="h2-2">Java标准资源绑定</h2>\n<p>\n    在介绍MessageSource之前，得先说清楚Java（J2SE）对国际化的基本实现——ResourceBundle，因为MessageSource是用它实现的。ResourceBundle很好理解，他就是按照规范的格式放置*.properties资源文件，然后根据输入的语言环境来返回资源。看一个代码例子就很容易明白了。</p>\n<p>（可执行代码请到<a href="https://gitee.com/chkui-com/spring-core-sample" rel="nofollow">gitee</a>下载，本文的示例代码在<em>chkui.springcore.example.hybrid.i18n</em>包中。）\n</p>\n<p>\n    我们有3个资源文件放置在<strong><em>classpath的根目录</em></strong>（本例是放在src/main/resource）中，文件名分别为<em>i18n_en_US.properties</em>、<em>i18n_zh_CN.properties</em>和<em>i18n_web_BASE64.properties。文件中的内容如下：</em>\n</p>\n<pre><code class="apache"><span class="code-comment">#i18n_en_US.properties</span>\n<span class="code-attribute">say</span>=Hallo world!\n\n<span class="code-comment">#i18n_zh_CN.properties</span>\n<span class="code-attribute">say</span>=大家好！\n\n<span class="code-comment">#i18n_web_BASE64.properties</span>\n<span class="code-attribute">say</span>=+-+-+-ABC</code></pre>\n<p>然后我们通过ResourceBundle类来使用这些i18n的资源文件：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.i18n;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">I18nApp</span> </span>{\n\t\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n        <span class="code-comment">//使用当前操作系统的语言环境</span>\n\t\tResourceBundle rb = ResourceBundle.getBundle(<span class="code-string">"i18n"</span>, Locale.getDefault());\n\t\tSystem.out.println(rb.getString(<span class="code-string">"say"</span>));\n\n        <span class="code-comment">//指定简体中文环境</span>\n        rb = ResourceBundle.getBundle(<span class="code-string">"i18n"</span>, <span class="code-keyword">new</span> Locale(<span\n            class="code-string">"zh"</span>, <span class="code-string">"CN"</span>));\n\t\tSystem.out.println(rb.getString(<span class="code-string">"say"</span>));\n        <span class="code-comment">//通过预设指定简体英文环境</span>\n\t\trb = ResourceBundle.getBundle(<span class="code-string">"i18n"</span>, Locale.SIMPLIFIED_CHINESE);\n\t\tSystem.out.println(rb.getString(<span class="code-string">"say"</span>));\n\n        <span class="code-comment">//指定美国英语</span>\n\t\trb = ResourceBundle.getBundle(<span class="code-string">"i18n"</span>, Locale.US);\n\t\tSystem.out.println(rb.getString(<span class="code-string">"say"</span>));\n\n        <span class="code-comment">//使用自定义的语言环境</span>\n\t\tLocale locale = <span class="code-keyword">new</span> Locale(<span class="code-string">"web"</span>, <span\n            class="code-string">"BASE64"</span>);\n\t\trb = ResourceBundle.getBundle(<span class="code-string">"i18n"</span>, locale);\n\t\tSystem.out.println(rb.getString(<span class="code-string">"say"</span>));\n\t}\n}\n</code></pre>\n<p>按照开发文档的要求，使用ResourceBundle加载的资源文件都必须放置在根目录，并且必须按照${<em>name}_${language}_${region}</em>的方式来命名。这个命名方式正好能对应ResourceBundle::getBundle方法中的参数，例如<em>ResourceBundle.getBundle("i18n",\n    new Locale("zh", "CN"))</em>。"i18n"对应${name}，"zh"定位${language}，而“CN”对应${<em>region</em>}。这样我们就可以通过传导参数来使用不同的资源。如果不指定<em>${language}</em>和<em>${region}</em>，该文件就是一个默认文件。\n</p>\n<p><em>Locale</em>类预设了很多资源类型，比如<em>Locale.SIMPLIFIED_CHINESE、Locale.US</em>，实际上他们就等价于<em>new Locale("zh", "CN")</em>和new\n    Locale<em>("en", "US")。</em>只是Java的开发人员做了一些静态的预设。</p>\n<p>除了预设内容的Locale，我们还可以像<em>Locale locale = new Locale("web", "BASE64")</em>这样添加自定义的内容，他对应名为<em>i18n_web_BASE64.properties</em>的资源文件。\n</p>\n\n<h2 id="h2-3">MessageSource的使用</h2>\n<p>MessageSource的功能就是用Java标准库的ResourceBundle实现的，所以使用起来也差不多。</p>\n<p>首先得将用于处理国际化资源的Bean添加到IoC容器中：</p>\n<pre><code class="java"><span class="code-meta">@Configuration</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">I18nApp</span> </span>{\n\t<span class="code-meta">@Bean</span>(<span class="code-string">"messageSource"</span>)\n\t<span class="hljs-function">ResourceBundleMessageSource <span\n            class="code-title">resourceBundleMessageSource</span><span class="hljs-params">()</span> </span>{\n\t\tResourceBundleMessageSource messageSource = <span class="code-keyword">new</span> ResourceBundleMessageSource();\n\t\tmessageSource.setBasenames(<span class="code-keyword">new</span> String[] { <span\n            class="code-string">"i18n"</span>, <span class="code-string">"extend"</span> });<span class="code-comment">//添加资源名称</span>\n\t\t<span class="code-keyword">return</span> messageSource;\n\t}\n}</code></pre>\n<p>或</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n            class="code-string">"messageSource"</span>\n            <span class="hljs-attr">class</span>=<span class="code-string">"org.springframework.context.support.ResourceBundleMessageSource"</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"basenames"</span>&gt;</span>\n            <span class="code-tag">&lt;<span class="code-name">list</span>&gt;</span>\n                <span class="code-tag">&lt;<span class="code-name">value</span>&gt;</span>i18n<span class="code-tag">&lt;/<span\n            class="code-name">value</span>&gt;</span>\n                <span class="code-tag">&lt;<span class="code-name">value</span>&gt;</span>extend<span class="code-tag">&lt;/<span\n            class="code-name">value</span>&gt;</span>\n            <span class="code-tag">&lt;/<span class="code-name">list</span>&gt;</span>\n        <span class="code-tag">&lt;/<span class="code-name">property</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>切记一定要标记<em>id=messageSource</em>。basenames这个Setter用于指定*.properties资源文件的名称，规则和前面介绍的ResourceBundle一样。然后就可以通过ApplicationContext::getMessage方法获取对应的资源了：\n</p>\n<pre><code class="java"><span class="code-meta">@Configuration</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">I18nApp</span> </span>{\n\t<span class="code-meta">@Bean</span>(<span class="code-string">"messageSource"</span>)\n\t<span class="hljs-function">ResourceBundleMessageSource <span\n            class="code-title">resourceBundleMessageSource</span><span class="hljs-params">()</span> </span>{\n\t\tResourceBundleMessageSource messageSource = <span class="code-keyword">new</span> ResourceBundleMessageSource();\n\t\tmessageSource.setBasenames(<span class="code-keyword">new</span> String[] { <span\n            class="code-string">"i18n"</span>, <span class="code-string">"extend"</span> });\n\t\t<span class="code-keyword">return</span> messageSource;\n\t}\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tApplicationContext context = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(I18nApp.class);\n\t\tSystem.out.println(<span class="code-string">"Spring Default 1:"</span> + context.getMessage(<span\n            class="code-string">"say"</span>, <span class="code-keyword">null</span>, Locale.getDefault()));\n\t\tSystem.out.println(<span class="code-string">"Spring Default 2:"</span> + context.getMessage(<span\n            class="code-string">"say"</span>, <span class="code-keyword">null</span>, <span\n            class="code-keyword">null</span>));\n\t\tSystem.out.println(<span class="code-string">"Spring Chinese:"</span> + context.getMessage(<span\n            class="code-string">"say"</span>, <span class="code-keyword">null</span>, Locale.SIMPLIFIED_CHINESE));\n\t\tSystem.out.println(<span class="code-string">"Spring Us English:"</span> + context.getMessage(<span\n            class="code-string">"say"</span>, <span class="code-keyword">null</span>, Locale.US));\n\t\tSystem.out.println(<span class="code-string">"Spring Custom:"</span> + context.getMessage(<span\n            class="code-string">"say"</span>, <span class="code-keyword">null</span>, <span\n            class="code-keyword">new</span> Locale(<span class="code-string">"web"</span>, <span class="code-string">"BASE64"</span>)));\n\t\tSystem.out.println(<span class="code-string">"Spring Argument:"</span> + context.getMessage(<span\n            class="code-string">"info"</span>, <span class="code-keyword">new</span> String[] {<span\n            class="code-string">"chkui"</span>},<span class="code-keyword">null</span>));\n\t\tSystem.out.println(<span class="code-string">"Spring Info:"</span> + context.getMessage(<span\n            class="code-string">"say"</span>, <span class="code-keyword">null</span>, <span\n            class="code-keyword">null</span>));\n\t}\n}</code></pre>\n\n<h2 id="h2-4">占位符替换</h2>\n<p>注意上面的示例代码的这一行：<em>context.getMessage("info", new String[] {"chkui"},null))，</em>这里的<em>getMessage</em>向方法传递了一个数组，他用于替换资源文件中的占位符号。在例子中我们除了i18n还加载了一个<em>extend.properties</em>文件，文件内容如下：\n</p>\n<pre><code class="ini"><span class="hljs-attr">info</span>={<span class="hljs-number">0</span>}帅的让人没脾气。</code></pre>\n<p>文件中的<em>{0}</em>表示这个位置用数组中的[0]位置的元素替换。</p>\n<p>还有一点需要注意的是，*.properties文件输入中文等UTF-8的符号时需要保留上面这种ACS的格式，现在大部分IDE都会自动处理的，切记不要为了方便看内容将*.properties的编码格式切换为UTF-8。</p>\n\n<h2 id="h2-5">获取MessageSource接口</h2>\n<p>我们有三种方式获取MessageSource接口：</p>\n<pre><code class="java"><span class="code-comment">//直接使用</span>\nApplicationContext context = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(I18nApp.class);\ncontext.getMessage(<span class="code-string">"say"</span>, <span class="code-keyword">null</span>, Locale.getDefault()));\n\n<span class="code-comment">//MessageSourceAware（ApplicationContextAware）接口</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">ExtendBean</span> <span class="code-keyword">implements</span> <span class="code-title">MessageSourceAware</span> </span>{\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setMessageSource</span><span\n            class="hljs-params">(MessageSource messageSource)</span> </span>{\n\t\t<span class="code-keyword">this</span>.setterMs = messageSource;\n\t}\n}\n\n<span class="code-comment">//从容器直接注入</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">ExtendBean</span> <span class="code-keyword">implements</span> <span class="code-title">MessageSourceAware</span> </span>{\n\t<span class="code-meta">@Autowired</span>\n\t<span class="code-keyword">private</span> MessageSource autowiredMs;\n}</code></pre>\n<p>需要注意的是，使用@Autowired等方式直接获取MessageSource类型的数据得到的是添加到容器的那个Bean，而其他方式获取到的是ApplicationContext。</p>'},405:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<h2 id="h2-1">问题</h2>\n<ol>\n    <li>\n        在一组相同类型的数据中（对象、数组、字符串、整形等任意类型的数据结构）请用时间空间最优的方式查找缺失的一项。例如有一组数据["A","B","C","D","E","F","G"]，现在给到["B","D","A","F"."G"]，需要找到缺失数据"C"？数据的个数不定。\n    </li>\n    <li>扩展上面的问题，用最优的方式查找缺失的多项。</li>\n</ol>\n<h2 id="h2-2">解决</h2>\n<h3 id="h3-1">2层循环逐个比对查找</h3>\n<p>最简单的办法当然是逐项比对，几乎所有语言都提供对象实例、字符串、数字的比对方法。</p>\n<p>但是这样做有2个问题：</p>\n<ol>\n    <li>少量数据可行，但是海量数据肯定会非常慢，因为时间复杂度是O(n^2)。而且第一层循环是全遍历，第二层循要遍历n/2。</li>\n    <li>在比对过程中如果是字符串比对，效率会非常差。</li>\n</ol>\n<h3 id="h3-2">编码2叉树查找</h3>\n<p>可以对所有的事物进行有序编码，然后通过编码索引到对应的元素。编码也没有什么特别的要求，只要每增加一项将编码加一即可。例如上面的例子["A","B","C","D","E","F","G"]，对其编码建立索引：</p>\n<pre><code class="json">{1:<span class="code-string">"A"</span>,2:<span class="code-string">"B"</span>,3:<span\n        class="code-string">"C"</span>,4:<span class="code-string">"D"</span>,5:<span\n        class="code-string">"E"</span>,6:<span class="code-string">"F"</span>,7:<span class="code-string">"G"</span>}\n</code></pre>\n<p>这是一个标准的dict结构（Java中的map结构）。任何时候增加新的项目只要编码加一即可：</p>\n<pre><code class="json">{1:<span class="code-string">"A"</span>,2:<span class="code-string">"B"</span>,3:<span\n        class="code-string">"C"</span>,4:<span class="code-string">"D"</span>,5:<span\n        class="code-string">"E"</span>,6:<span class="code-string">"F"</span>,7:<span\n        class="code-string">"G"</span>,8:<span class="code-string">"ADD ITEM"</span>}\n</code></pre>\n<p>使用编码还有一个好处是还可以查找一组不同类型的数据。</p>\n<p>建立编码之后实际上就转换为一个数字查询问题。</p>\n<p>如果仅仅是查找一个缺失项，实际上有一个非常简便的算法——求和计算差值：</p>\n<pre><code class="python">    <span class="code-comment"># origin_numbers是所有编码的列表，例如[1,2,3,4,5,6,7,8,9,10]。</span>\n    <span class="code-comment"># random_numbers是缺失了一项的编码无序表，例如[6,2,5,4,7,8,9,10,1]。</span>\n    <span class="code-keyword">for</span> _num <span class="code-keyword">in</span> origin_numbers:\n        total_sum = total_sum + _num\n\n    <span class="code-keyword">for</span> _num <span class="code-keyword">in</span> random_numbers:\n        without_sum = without_sum + _num\n</code></pre>\n<p>差值正好是缺失的项目索引值。</p>\n<p>但是如果是查找多个缺失项，只能用2叉树：</p>\n<pre><code class="python"><span class="code-keyword">import</span> copy\n<span class="code-keyword">import</span> random <span class="code-keyword">as</span> rand\n<span class="code-keyword">import</span> datetime\n<span class="code-keyword">import</span> time\n\n\n<span class="code-comment"># 2叉树结构</span>\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">Link</span>:</span>\n    <span class="hljs-function"><span class="code-keyword">def</span> <span class="code-title">__init__</span><span\n            class="hljs-params">(self, value)</span>:</span>\n        self.value = value\n        self.left = <span class="code-keyword">None</span>\n        self.right = <span class="code-keyword">None</span>\n\n    <span class="hljs-function"><span class="code-keyword">def</span> <span class="code-title">insert</span><span\n            class="hljs-params">(self, value)</span>:</span>\n        <span class="code-keyword">if</span> value &lt; self.value:\n            self.__addLeftLeaf__(value)\n        <span class="code-keyword">else</span>:\n            self.__addRightLeaf__(value)\n\n    <span class="hljs-function"><span class="code-keyword">def</span> <span\n            class="code-title">__addLeftLeaf__</span><span class="hljs-params">(self, value)</span>:</span>\n        <span class="code-keyword">if</span> self.left <span class="code-keyword">is</span> <span class="code-keyword">not</span> <span\n            class="code-keyword">None</span>:\n            self.left.insert(value)\n        <span class="code-keyword">else</span>:\n            self.left = Link(value)\n\n    <span class="hljs-function"><span class="code-keyword">def</span> <span\n            class="code-title">__addRightLeaf__</span><span class="hljs-params">(self, value)</span>:</span>\n        <span class="code-keyword">if</span> self.right <span class="code-keyword">is</span> <span class="code-keyword">not</span> <span\n            class="code-keyword">None</span>:\n            self.right.insert(value)\n        <span class="code-keyword">else</span>:\n            self.right = Link(value)\n\n    <span class="hljs-function"><span class="code-keyword">def</span> <span class="code-title">traversal</span><span\n            class="hljs-params">(self, _list, _without)</span>:</span>\n        <span class="code-keyword">if</span> self.left <span class="code-keyword">is</span> <span class="code-keyword">not</span> <span\n            class="code-keyword">None</span>:\n            self.left.traversal(_list, _without)\n\n        length = len(_list)\n        <span class="code-keyword">if</span> <span class="hljs-number">0</span> &lt; length:\n            tail = _list[length - <span class="hljs-number">1</span>]\n            diff = self.value - (tail + <span class="hljs-number">1</span>)\n            <span class="code-keyword">if</span> <span class="hljs-number">0</span> &lt; diff:\n                <span class="code-keyword">for</span> _d <span class="code-keyword">in</span> range(<span\n            class="hljs-number">1</span>, diff + <span class="hljs-number">1</span>):\n                    _without.append(self.value - _d)\n\n        _list.append(self.value)\n\n        <span class="code-keyword">if</span> self.right <span class="code-keyword">is</span> <span class="code-keyword">not</span> <span\n            class="code-keyword">None</span>:\n            self.right.traversal(_list, _without)\n\n\n<span class="code-comment"># 从队列中移除项目</span>\n<span class="hljs-function"><span class="code-keyword">def</span> <span class="code-title">remove_number</span><span\n        class="hljs-params">(without_size, numbers)</span>:</span>\n    <span class="code-keyword">for</span> count <span class="code-keyword">in</span> range(without_size):\n        <span class="code-keyword">del</span> numbers[rand.randrange(len(numbers))]\n    <span class="code-keyword">return</span> numbers\n\n\n<span class="code-comment"># 使用有序数组生成随机数组</span>\n<span class="hljs-function"><span class="code-keyword">def</span> <span class="code-title">generation_random</span><span\n        class="hljs-params">(without_size, origin_numbers)</span>:</span>\n    origin_numbers_options = copy.copy(origin_numbers)\n    length = len(origin_numbers)\n    random_numbers = []\n\n    <span class="code-comment"># 随机</span>\n    <span class="code-keyword">while</span> <span class="hljs-number">0</span> &lt; length:\n        rand_number = rand.randrange(length)\n        random_numbers.append(origin_numbers_options[rand_number])\n        <span class="code-keyword">del</span> origin_numbers_options[rand_number]\n        length = len(origin_numbers_options)\n\n    <span class="code-keyword">return</span> remove_number(without_size, random_numbers)\n\n\n<span class="code-comment"># </span>\n<span class="hljs-function"><span class="code-keyword">def</span> <span\n        class="code-title">generation_origin_numbers</span><span class="hljs-params">(without_size=<span\n        class="hljs-number">1</span>, total=<span class="hljs-number">10000</span>)</span>:</span>\n    origin_numbers = list(range(total))\n    <span class="code-keyword">return</span> origin_numbers, generation_random(without_size, origin_numbers)\n\n\n<span class="hljs-function"><span class="code-keyword">def</span> <span class="code-title">tree_2_leaf</span><span\n        class="hljs-params">(numbers)</span>:</span>\n    root = Link(numbers[<span class="hljs-number">0</span>])\n    <span class="code-keyword">for</span> pos <span class="code-keyword">in</span> range(<span\n            class="hljs-number">1</span>, len(numbers)):\n        root.insert(numbers[pos])\n\n    <span class="code-comment"># 使用二叉树</span>\n    _list = []\n    _without = []\n\n    root.traversal(_list=_list, _without=_without)\n\n    <span class="code-keyword">return</span> _without\n\n\n<span class="hljs-function"><span class="code-keyword">def</span> <span\n        class="code-title">without_one_number</span><span\n        class="hljs-params">(origin_numbers, random_numbers)</span>:</span>\n    print(<span class="code-string">"=============== without_one_number start =================="</span>)\n    sum_search_start = time.time()\n    total_sum = <span class="hljs-number">0</span>\n    without_sum = <span class="hljs-number">0</span>\n    print(<span class="code-string">"Sum Search Begin.({})"</span>.format(datetime.datetime.now().strftime(<span\n            class="code-string">\'%H:%M:%S\'</span>)))\n    <span class="code-keyword">for</span> _num <span class="code-keyword">in</span> origin_numbers:\n        total_sum = total_sum + _num\n\n    <span class="code-keyword">for</span> _num <span class="code-keyword">in</span> random_numbers:\n        without_sum = without_sum + _num\n    tree_search_start = sum_search_end = time.time()\n    print(<span class="code-string">"Sum Search Complete.({})"</span>.format(datetime.datetime.now().strftime(<span\n            class="code-string">\'%H:%M:%S\'</span>)))\n    print(<span class="code-string">"Timer:{} S"</span>.format(sum_search_end - sum_search_start))\n    print(<span class="code-string">"Total Sum:{}"</span>.format(total_sum))\n    print(<span class="code-string">"Without One Number Sum:{}"</span>.format(without_sum))\n    print(<span class="code-string">"Without Number:{}"</span>.format(total_sum - without_sum))\n    print(<span class="code-string">"---"</span>)\n    print(<span class="code-string">"2 Tree Search Begin.({})"</span>.format(datetime.datetime.now().strftime(<span\n            class="code-string">\'%H:%M:%S\'</span>)))\n    without_number = tree_2_leaf(random_numbers)\n    print(<span class="code-string">"2 Tree Complete.({})"</span>.format(datetime.datetime.now().strftime(<span\n            class="code-string">\'%H:%M:%S\'</span>)))\n    print(<span class="code-string">"Timer:{} S"</span>.format(time.time() - tree_search_start))\n    print(<span class="code-string">"Without Element:{}"</span>.format(without_number))\n    print(<span class="code-string">"=============== without_one_number end =================="</span>)\n\n\n<span class="hljs-function"><span class="code-keyword">def</span> <span\n        class="code-title">without_multi_number</span><span class="hljs-params">(random_numbers)</span>:</span>\n    print(<span class="code-string">"=============== without_multi_number start =================="</span>)\n    start = time.time()\n    print(<span class="code-string">"Search Begin.({})"</span>.format(datetime.datetime.now().strftime(<span\n            class="code-string">\'%H:%M:%S\'</span>)))\n    without_number = tree_2_leaf(random_numbers)\n    print(<span class="code-string">"Search End.({})"</span>.format(datetime.datetime.now().strftime(<span\n            class="code-string">\'%H:%M:%S\'</span>)))\n    print(<span class="code-string">"Timer:{} S"</span>.format(time.time() - start))\n    print(<span class="code-string">"Without Element:{}"</span>.format(without_number))\n    print(<span class="code-string">"=============== without_multi_number end =================="</span>)\n\n\n<span class="code-keyword">if</span> __name__ == <span class="code-string">\'__main__\'</span>:\n    print(<span class="code-string">"Generation Numbers Begin.({})"</span>.format(datetime.datetime.now().strftime(<span\n            class="code-string">\'%H:%M:%S\'</span>)))\n    generation_number_start = time.time()\n    origin, random = generation_origin_numbers()\n    print(<span\n            class="code-string">"Generation Numbers Complete.({})"</span>.format(datetime.datetime.now().strftime(<span\n            class="code-string">\'%H:%M:%S\'</span>)))\n    generation_number_end = time.time()\n    print(<span class="code-string">"Timer:{} S"</span>.format(generation_number_end - generation_number_start))\n\n    without_one_number(origin, random)\n    without_multi_number(remove_number(<span class="hljs-number">4</span>, random))\n</code></pre>'}});