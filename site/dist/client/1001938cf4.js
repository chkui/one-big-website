webpackJsonp([10],{341:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<p>在前2篇博文中，介绍了&nbsp;\n    <a href="https://www.chkui.com/article/hazelcast/hazelcast_get_started_and_code_sample">Hazelcast的基本原理</a> 和\n    <a href="https://www.chkui.com/article/hazelcast/hazelcast_configuration_management">\n        Hazelcast基本配置\n    </a>。\n    后续的博文会逐一介绍<em>Hazelcast</em>的主要功能组件。本篇将详细说明Hazelcast集群组建、集群数据通信相关的内容，大家可以用来当做使用Hazelcast的帮助文档、或进行技术决策分析的指导文档。\n</p>\n<h2 id="h2-1"><em>Hazelcst</em>组网</h2>\n<p><em>Hazelcast</em>自称"分布式数据网格”，那他最基本、最重要的功能就是时时刻刻都在多台服务器之间工作，这样必须有网络环境对其分布式功能提供支持。<em>Hazelcast</em>在网络环境中工作分为2个阶段：首先是组网阶段，随后是数据传输阶段。\n</p>\n<p>组网是指每个<em>Hazelcast</em>节点启动时，都会搜寻是否有<em>Hazelcast</em>节点可以连接，组网过程支持多种协议。完成组网后，节点会和其他组建成集群的节点进行通信，这个阶段就是数据传输阶段，此时只支持使用TCP/IP协议来传递数据。<em>Hazelcast</em>的所有网络行为，都是通过<em>&lt;networt&gt;&lt;/network&gt;</em>元素配置决定的。<em>&lt;join&gt;</em>元素用来配置组建集群的相关的参数。\n</p>\n<h3 id="h3-1">组播协议（Multicast）组建集群</h3>\n<p>在使用组播协议（<em>Multicast</em>）作为自动组建集群机制时，集群中的成员不需要知道其他成员的详细地址（<em>IP</em>），他们仅仅是通过组播将信号广播到其他成员的监听端口中。使用之前确保网络环境支持&nbsp;<em>Multicast</em>。\n</p>\n<p>下面是一个通过组播协议（<em>Multicast</em>）组网的例子：</p>\n<pre class="xml"><code class="language-xml"><span class="code-tag"><span class="code-tag">&lt;</span><span\n        class="code-name"><span class="code-tag"><span class="code-name">hazelcast</span></span></span><span\n        class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">network</span></span></span><span class="code-tag">&gt;</span></span>\n        <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n                class="code-name">join</span></span></span><span class="code-tag">&gt;</span></span>\n            <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span\n                    class="code-tag"><span class="code-name">multicast</span></span></span><span\n                    class="code-tag"> </span><span class="hljs-attr"><span class="code-tag"><span class="hljs-attr">enabled</span></span></span><span\n                    class="code-tag">=</span><span class="code-string"><span class="code-tag"><span class="code-string">"true"</span></span></span><span\n                    class="code-tag">&gt;</span></span>\n                <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n                        class="code-name">multicast-group</span></span></span><span class="code-tag">&gt;</span></span>224.2.2.3<span\n            class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">multicast-group</span></span></span><span class="code-tag">&gt;</span></span>\n                <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n                        class="code-name">multicast-port</span></span></span><span class="code-tag">&gt;</span></span>54327<span\n            class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">multicast-port</span></span></span><span class="code-tag">&gt;</span></span>\n                <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n                        class="code-name">multicast-time-to-live</span></span></span><span class="code-tag">&gt;</span></span>32<span\n            class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">multicast-time-to-live</span></span></span><span class="code-tag">&gt;</span></span>\n                <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n                        class="code-name">multicast-timeout-seconds</span></span></span><span\n                        class="code-tag">&gt;</span></span>2<span class="code-tag"><span\n            class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span class="code-name">multicast-timeout-seconds</span></span></span><span\n            class="code-tag">&gt;</span></span>\n                <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n                        class="code-name">trusted-interfaces</span></span></span><span\n                        class="code-tag">&gt;</span></span>\n                   <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span\n                           class="code-tag"><span class="code-name">interface</span></span></span><span\n                           class="code-tag">&gt;</span></span>192.168.1.102<span class="code-tag"><span\n            class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span class="code-name">interface</span></span></span><span\n            class="code-tag">&gt;</span></span>\n                <span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span\n                        class="code-tag"><span class="code-name">trusted-interfaces</span></span></span><span\n                        class="code-tag">&gt;</span></span>\n            <span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span\n                    class="code-tag"><span class="code-name">multicast</span></span></span><span\n                    class="code-tag">&gt;</span></span>\n            <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span\n                    class="code-tag"><span class="code-name">tcp-ip</span></span></span><span\n                    class="code-tag"> </span><span class="hljs-attr"><span class="code-tag"><span class="hljs-attr">enabled</span></span></span><span\n                    class="code-tag">=</span><span class="code-string"><span class="code-tag"><span class="code-string">"false"</span></span></span><span\n                    class="code-tag">&gt;</span></span>\n            <span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span\n                    class="code-tag"><span class="code-name">tcp-ip</span></span></span><span\n                    class="code-tag">&gt;</span></span>\n            <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span\n                    class="code-tag"><span class="code-name">aws</span></span></span><span\n                    class="code-tag"> </span><span class="hljs-attr"><span class="code-tag"><span class="hljs-attr">enabled</span></span></span><span\n                    class="code-tag">=</span><span class="code-string"><span class="code-tag"><span class="code-string">"false"</span></span></span><span\n                    class="code-tag">&gt;</span></span>\n            <span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span\n                    class="code-tag"><span class="code-name">aws</span></span></span><span class="code-tag">&gt;</span></span>\n        <span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n                class="code-name">join</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">network</span></span></span><span class="code-tag">&gt;</span></span></code></pre>\n<p>组网功能的配置由&nbsp;<em>&lt;join&gt;</em> 及其子元素来确定。其中 <em>&lt;multicast&gt;</em> 元素用来配置 <em>组播协议</em> 组网的相关参数。当设置&nbsp;<em>&lt;multicast&gt;</em>\n    元素中 <em>enabled </em>属性为 <em>true </em>时，表示启用 <em>组播协议</em> 组网。下面将详细说明每一个参数：</p>\n<p><strong><em>enabled</em></strong>：<em>[true|false]</em>，指定是否使用组播协议来组建集群。</p>\n<p><em><strong>multicast-group</strong></em>：组播分组的IP地址。当要创建同一个网段的集群时，需要配置这个参数。取值范围从224.0.0.0到239.255.255.255，默认224.2.2.3。\n</p>\n<p><em><strong>multicast-port</strong></em>：组播协议启用套接字的端口（socket port），这个端口用于Hazelcast监听外部发送来的组网请求。默认54327。</p>\n<p><strong><em>multicast-time-to-live</em></strong>：组播协议发送包的生存时间周期（TTL）。可以从 <a title="组播协议的TTL"\n        href="http://www.tldp.org/HOWTO/Multicast-HOWTO-2.html" rel="nofollow">协议官方文档</a>&nbsp;详细了解 组播协议的TTL。</p>\n<p><strong><em>multicast-timeout-seconds</em></strong>：当节点启动后，这个参数（单位：秒）指定了当前节点等待其他节点响应的时间周期。例如，设置为60秒时，每一个节点启动后通过组播协议广播消息，如果主节点在60秒内返回响应消息，则新启动的节点加入这个主节点所在的集群，如果设定时间内没有返回消息，那么节点会把自己设置为一个主节点，并创建新的集群（主节点可以理解为集群的第一个节点）。默认值为2秒。\n</p>\n<p><strong><em>trusted-interfaces</em></strong>：可信任成员的IP地址。当一个节点试图加入集群，如果其不是一个可信任节点，他的加入请求将被拒绝。可以在IP的最后一个数字上使用通配符（*）来设置一个IP范围（例如：192.168.1.*\n    或192.168.1.100-110）。</p>\n\n<h2 id="h2-2">TCP协议组建集群</h2>\n<p>除了使用 组播协议，还可以使用<em>TCP/IP</em>协议来组建集群。当使用<em>TCP/IP</em>来组建新集群时，第一个节点必须将所有要加入集群的节点IP地址添加到对应列表中。在集群已经运行之后，新加入的节点不必知道所有的集群节点，但是至少要知道并连接到一个已经启动的集群节点。\n</p>\n<p>下面是一个使用<em>TCP/IP</em>协议来组建集群的例子：</p>\n<pre class="xml"><code class="language-xml"><span class="code-tag"><span class="code-tag">&lt;</span><span\n        class="code-name"><span class="code-tag"><span class="code-name">hazelcast</span></span></span><span\n        class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">network</span></span></span><span class="code-tag">&gt;</span></span>\n    <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">join</span></span></span><span class="code-tag">&gt;</span></span>\n      <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n              class="code-name">multicast</span></span></span><span class="code-tag"> </span><span\n              class="hljs-attr"><span class="code-tag"><span class="hljs-attr">enabled</span></span></span><span\n              class="code-tag">=</span><span class="code-string"><span class="code-tag"><span class="code-string">"false"</span></span></span><span\n              class="code-tag">&gt;</span></span>\n      <span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n              class="code-name">multicast</span></span></span><span class="code-tag">&gt;</span></span>\n      <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n              class="code-name">tcp-ip</span></span></span><span class="code-tag"> </span><span class="hljs-attr"><span\n              class="code-tag"><span class="hljs-attr">enabled</span></span></span><span class="code-tag">=</span><span\n              class="code-string"><span class="code-tag"><span class="code-string">"true"</span></span></span><span\n              class="code-tag">&gt;</span></span>\n          <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n                  class="code-name">required-member</span></span></span><span class="code-tag">&gt;</span></span>192.168.1.104<span\n            class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">required-member</span></span></span><span class="code-tag">&gt;</span></span>\n          <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n                  class="code-name">member</span></span></span><span\n                  class="code-tag">&gt;</span></span>192.168.1.104<span class="code-tag"><span\n            class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">member</span></span></span><span class="code-tag">&gt;</span></span>\n          <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n                  class="code-name">members</span></span></span><span class="code-tag">&gt;</span></span>192.168.1.105,192.168.1.106<span\n            class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">members</span></span></span><span class="code-tag">&gt;</span></span>\n          <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n                  class="code-name">connection-timeout-seconds</span></span></span><span\n                  class="code-tag">&gt;</span></span>60<span class="code-tag"><span class="code-tag">&lt;/</span><span\n            class="code-name"><span class="code-tag"><span\n            class="code-name">connection-timeout-seconds</span></span></span><span class="code-tag">&gt;</span></span>\n      <span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n              class="code-name">tcp-ip</span></span></span><span class="code-tag">&gt;</span></span>\n    <span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">join</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">network</span></span></span><span class="code-tag">&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n        class="code-name">hazelcast</span></span></span><span class="code-tag">&gt;</span></span></code></pre>\n<p>从上面的例子可以看出使用<em>TCP/IP</em>组建网络涉及的配置参数并不多。首先需要将<em>&lt;tcp-ip&gt;</em>元素中的<em>enabled</em>属性设置为<em>true</em>表示启用<em>TCP/IP</em>协议来组网。然后每个元素对应的含义如下\n</p>\n<p><em><strong>&nbsp;required-member</strong></em>：加入集群的成员<em>IP</em>地址，只有这些<em>IP</em>地址的成员存在时集群才会组建。也就是说如果要当前节点加入集群，必须<em>&lt;required-member&gt;</em>元素中的指定的<em>IP</em>地址已经有集群节点先启动了，该节点才能启动，可以用于限制节点的启动顺序。\n</p>\n<p><strong><em>member</em></strong>：成员的<em>IP</em>地址。指定要加入集群的成员IP地址，这些IP地址中的成员会相互发现对方。</p>\n<p><em><strong>members</strong></em>：<em>member</em>的复数形态。在元素中可以使用逗号（“,”）分割多个IP地址。还可以使用-或*等符号来表达多个<em>IP</em>地址。</p>\n<p><em><strong>connection-timeout-seconds</strong></em>：定义连接超时时间。<em>Hazelcast</em>尝试连接到一个已知的节点（member元素指定）的最大超时时间，如果在指定时间内连接失败，将会放弃连接。当参数设置太小时，可能会导致一个成员可能无法连接到集群。设置太高时，成员启动的等待时间会比较久，因为当某些<em>&lt;member&gt;</em>元素标记的节点未启动时，需要花费较多时间等待。如果有较多的不同<em>IP</em>地址的成员需要加入集群，可以适当增加这个值，以保证所有的成员可以正确加入集群。默认值为5。\n</p>\n\n<h3 id="h3-2">其他组网方式</h3>\n<p>除了上面说的 组播协议 和 <em>TCP/IP</em>协议\n    组建集群的方式，<em>Hazelcast</em>还为某些特定的使用场景提供了组建集群的方法。目前提供了基于亚马逊的<em>EC2</em>环境和<em>jclouds</em>组建集群，目前还没有亚马逊的云服务的使用经验，相关配置就不详细说明了，如果需要在亚马逊云部署集群可以留言一起聊聊，我会尽量把知道的分享给有需要的朋友。\n</p>\n\n<h2 id="h2-3">Hazelcast网络运行</h2>\n<p>在完成集群组网完成以后<em>Hazelcast</em>的节点之间就会开始数据通信，因此<em>Hazelcast</em>还提供了大量的元素来对数据通信进行配置，看下面这个例子：</p>\n<pre class="xml"><code class="language-xml">   <span class="code-tag"><span class="code-tag">&lt;</span><span\n        class="code-name"><span class="code-tag"><span class="code-name">network</span></span></span><span\n        class="code-tag">&gt;</span></span>\n        <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n                class="code-name">public-address</span></span></span><span class="code-tag">&gt;</span></span>11.22.33.44:5555<span\n            class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">public-address</span></span></span><span class="code-tag">&gt;</span></span>\n        <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n                class="code-name">port</span></span></span><span class="code-tag"> </span><span class="hljs-attr"><span\n                class="code-tag"><span class="hljs-attr">auto-increment</span></span></span><span\n                class="code-tag">=</span><span class="code-string"><span class="code-tag"><span class="code-string">"true"</span></span></span><span\n                class="code-tag"> </span><span class="hljs-attr"><span class="code-tag"><span class="hljs-attr">port-count</span></span></span><span\n                class="code-tag">=</span><span class="code-string"><span class="code-tag"><span class="code-string">"100"</span></span></span><span\n                class="code-tag">&gt;</span></span>5701<span class="code-tag"><span class="code-tag">&lt;/</span><span\n            class="code-name"><span class="code-tag"><span class="code-name">port</span></span></span><span\n            class="code-tag">&gt;</span></span>\n        <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n                class="code-name">outbound-ports</span></span></span><span class="code-tag">&gt;</span></span>\n            <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span\n                    class="code-tag"><span class="code-name">ports</span></span></span><span\n                    class="code-tag">&gt;</span></span>0<span class="code-tag"><span class="code-tag">&lt;/</span><span\n            class="code-name"><span class="code-tag"><span class="code-name">ports</span></span></span><span\n            class="code-tag">&gt;</span></span>\n        <span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n                class="code-name">outbound-ports</span></span></span><span class="code-tag">&gt;</span></span>\n        <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n                class="code-name">reuse-address</span></span></span><span class="code-tag">&gt;</span></span>false<span\n            class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">reuse-address</span></span></span><span class="code-tag">&gt;</span></span>\n        <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n                class="code-name">interfaces</span></span></span><span class="code-tag"> </span><span class="hljs-attr"><span\n                class="code-tag"><span class="hljs-attr">enabled</span></span></span><span\n                class="code-tag">=</span><span class="code-string"><span class="code-tag"><span class="code-string">"false"</span></span></span><span\n                class="code-tag">&gt;</span></span>\n            <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span\n                    class="code-tag"><span class="code-name">interface</span></span></span><span\n                    class="code-tag">&gt;</span></span>10.10.1.*<span class="code-tag"><span\n            class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span class="code-name">interface</span></span></span><span\n            class="code-tag">&gt;</span></span>\n        <span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n                class="code-name">interfaces</span></span></span><span class="code-tag">&gt;</span></span>\n        <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n                class="code-name">ssl</span></span></span><span class="code-tag"> </span><span class="hljs-attr"><span\n                class="code-tag"><span class="hljs-attr">enabled</span></span></span><span\n                class="code-tag">=</span><span class="code-string"><span class="code-tag"><span class="code-string">"false"</span></span></span><span\n                class="code-tag"> /&gt;</span></span>\n        <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n                class="code-name">socket-interceptor</span></span></span><span class="code-tag"> </span><span\n                class="hljs-attr"><span class="code-tag"><span class="hljs-attr">enabled</span></span></span><span\n                class="code-tag">=</span><span class="code-string"><span class="code-tag"><span class="code-string">"false"</span></span></span><span\n                class="code-tag"> /&gt;</span></span>\n        <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n                class="code-name">symmetric-encryption</span></span></span><span class="code-tag"> </span><span\n                class="hljs-attr"><span class="code-tag"><span class="hljs-attr">enabled</span></span></span><span\n                class="code-tag">=</span><span class="code-string"><span class="code-tag"><span class="code-string">"false"</span></span></span><span\n                class="code-tag">&gt;</span></span>\n            <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span\n                    class="code-tag"><span class="code-name">algorithm</span></span></span><span\n                    class="code-tag">&gt;</span></span>PBEWithMD5AndDES<span class="code-tag"><span class="code-tag">&lt;/</span><span\n            class="code-name"><span class="code-tag"><span class="code-name">algorithm</span></span></span><span\n            class="code-tag">&gt;</span></span>\n            <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span\n                    class="code-tag"><span class="code-name">salt</span></span></span><span class="code-tag">&gt;</span></span>thesalt<span\n            class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">salt</span></span></span><span class="code-tag">&gt;</span></span>\n            <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span\n                    class="code-tag"><span class="code-name">password</span></span></span><span\n                    class="code-tag">&gt;</span></span>thepass<span class="code-tag"><span class="code-tag">&lt;/</span><span\n            class="code-name"><span class="code-tag"><span class="code-name">password</span></span></span><span\n            class="code-tag">&gt;</span></span>\n            <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span\n                    class="code-tag"><span class="code-name">iteration-count</span></span></span><span class="code-tag">&gt;</span></span>19<span\n            class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">iteration-count</span></span></span><span class="code-tag">&gt;</span></span>\n        <span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n                class="code-name">symmetric-encryption</span></span></span><span class="code-tag">&gt;</span></span>\n    <span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">network</span></span></span><span class="code-tag">&gt;</span></span></code></pre>\n<p>除了<em>&lt;join&gt;</em>元素，Hazelcast还提供了上面XML中的元素来配置网络数据通信，下面我们一一介绍他的作用。</p>\n\n<h3 id="h3-3"><strong><em>public-address</em></strong></h3>\n<p><strong><em>&nbsp;&nbsp;&nbsp;&nbsp;</em></strong>配置当前节点的对外公开地址。什么叫对外公开地址呢？默认情况下，一个节点会使用它的套接字（<em>sockets</em>）地址作为公开地址。但是经过网络地址转换（<em>NAT</em>），2个节点可能无法彼此访问。此时只有将2个节点的公开地址设置为在<em>NAT</em>上定义的地址才能完成连接。这种情况下，公开地址并不是本地的地址，而是一个由<em>NAT</em>定义的虚拟地址。这个设置对于在私有云的环境中使用<em>Hazelcasst</em>会非常有用。需要注意的是，这个元素的配置需要制定端口，即<em>\n    [domain|ip]:port</em>&nbsp;的格式。</p>\n\n<h3 id="h3-4"><strong><em>port</em></strong></h3>\n<p><strong><em>&nbsp;&nbsp;&nbsp;&nbsp;</em></strong>指定<em>Hazelcast</em>用于集群成员之间数据通信的端口。<em>Hazelcast</em>会根据端口的使用情况自动检查可以使用的端口。检查方式主要通过<em>&lt;port&gt;</em>元素中的<em>port-count</em>和<em>auto-increment</em>来决定。下面是关于他们的说明：\n</p>\n<ul>\n    <li><strong><em>port-count</em></strong>：默认时，<em>Hazelcast</em>将尝试绑定100个端口。意思是，如果将端口设置为5701，当有一个成员加入到集群，<em>Hazelcast</em>将尝试在5701到5801之间寻找一个端口。当有大量的实例运行在同一个机器，而端口较为紧缺时，可以适当的加大这个数字。这个参数就是用于此目的，默认是100。\n    </li>\n    <li><strong><em>auto-increment</em></strong>：<em>Hazelcast</em>将会尝试在5701到5801之间寻找未被使的端口。通常情况下，不需要去修改这个值，这个配置已经非常方便使用。但是在某些时候，系统希望使用指定的端口，此时可以通过关闭自动增长功能来实现——将<em>auto-increment</em>属性设置设为false。\n    </li>\n</ul>\n\n<h3 id="h3-5"><strong><em>outbound-ports</em></strong></h3>\n<p><strong><em>&nbsp;&nbsp;&nbsp;&nbsp;</em></strong>默认情况下，在打开一个套接字（socket）用于传输数据时系统会选择一个临时端口。但是如果启用某些安全策略或防火墙可能会限制某些临时端口的使用。为了解决这个问题，<em>Hazelcast</em>提供&lt;outbound-ports&gt;元素来指定套接字的临时对外传输端口。可以像下面这样配置多个套接字端口：\n</p>\n<pre class="xml"><code class="language-xml"><span class="code-tag"><span class="code-tag">&lt;</span><span\n        class="code-name"><span class="code-tag"><span class="code-name">network</span></span></span><span\n        class="code-tag">&gt;</span></span>\n    <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">outbound-ports</span></span></span><span class="code-tag">&gt;</span></span>\n      <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n              class="code-name">ports</span></span></span><span class="code-tag">&gt;</span></span>33000-35000<span\n            class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">ports</span></span></span><span class="code-tag">&gt;</span></span>\n      <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n              class="code-name">ports</span></span></span><span class="code-tag">&gt;</span></span>37000,37001,37002,37003<span\n            class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">ports</span></span></span><span class="code-tag">&gt;</span></span>\n      <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n              class="code-name">ports</span></span></span><span\n              class="code-tag">&gt;</span></span>38000,38500-38600<span class="code-tag"><span\n            class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">ports</span></span></span><span class="code-tag">&gt;</span></span>\n    <span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">outbound-ports</span></span></span><span class="code-tag">&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n        class="code-name">network</span></span></span><span class="code-tag">&gt;</span></span></code></pre>\n<p>默认为<em>&lt;ports&gt;0&lt;/ports&gt;</em>，表示由<em>Hazelcast</em>自己选择可用端口。</p>\n\n<h3 id="h3-6"><em><strong>Reuse Address</strong></em></h3>\n<p>配置地址是否可以重用。当关闭一个集群节点时，服务器的套接字（<em>socket</em>）端口会处于 <em>TIME_WAIT<span style="background-color:rgb(253, 246, 227)">&nbsp;</span></em>状态。如果将<em>&lt;reuse-address&gt;</em>元素设置为true，那么<em>TIME_WAIT</em>状态将被忽略，新加入的节点可以重复使用已经释放的端口。\n</p>\n\n<h3 id="h3-7"><em><strong>Interfaces</strong></em></h3>\n<p><em><strong>&nbsp;&nbsp;&nbsp;&nbsp;</strong></em>指定Hazelcast使用的网络接口地址。一些服务器可能有多个网络接口（多个网卡），因此可能需要限定可用的IP地址。范围字符(\'*\'\n    and \'-\')可以用于多个地址，例如&nbsp;10.3.10.*是指从10.3.10.0到10.3.10.255的端口均可使用，又例如：10.3.10.4-18是指从10.3.10.4到10.3.10.18的IP地址（包含4和18）。将<em>&lt;interfaces&gt;</em>的enabled设置为true，则会启用网络接口配置（默认是禁用的），在启用网络接口配置后如果Hazelcast找不到配置的IP地址，将会输出一个异常信息，并停止启动节点。\n</p>\n\n<h3 id="h3-8">其他商用授权配置</h3>\n<p>除了前面提到的几个配置，<em>Hazelcast</em>还额外提供了<em>&lt;ssl&gt;</em>、<em>&lt;socket-interceptor&gt;</em>、<em>&lt;symmetric-encryption&gt;</em>四个安全相关的配置，但是需要获取<em>Hazlecast</em>的商用授权下载商用版本这些配置才能生效。<em>ssl</em>表示启用<em>ssl</em>传输、<em>interceptor</em>用于传输拦截器、<em>symmetric-encryption</em>用于传输数据加密。\n</p>\n\n<h3 id="h3-9">IPV6支持</h3>\n<p><em>Hazelcast</em>的所有网络<em>IP</em>配置都支持IPV6。例如可以使用下面的方式来配置<em>IP</em>地址：</p>\n<pre class="xml"><code class="language-xml"><span class="code-tag"><span class="code-tag">&lt;</span><span\n        class="code-name"><span class="code-tag"><span class="code-name">hazelcast</span></span></span><span\n        class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">network</span></span></span><span class="code-tag">&gt;</span></span>\n    <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">port</span></span></span><span class="code-tag"> </span><span class="hljs-attr"><span\n            class="code-tag"><span class="hljs-attr">auto-increment</span></span></span><span\n            class="code-tag">=</span><span class="code-string"><span class="code-tag"><span\n            class="code-string">"true"</span></span></span><span class="code-tag">&gt;</span></span>5701<span\n            class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">port</span></span></span><span class="code-tag">&gt;</span></span>\n    <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">join</span></span></span><span class="code-tag">&gt;</span></span>\n      <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n              class="code-name">multicast</span></span></span><span class="code-tag"> </span><span\n              class="hljs-attr"><span class="code-tag"><span class="hljs-attr">enabled</span></span></span><span\n              class="code-tag">=</span><span class="code-string"><span class="code-tag"><span class="code-string">"false"</span></span></span><span\n              class="code-tag">&gt;</span></span>\n        <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n                class="code-name">multicast-group</span></span></span><span class="code-tag">&gt;</span></span>FF02:0:0:0:0:0:0:1<span\n            class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">multicast-group</span></span></span><span class="code-tag">&gt;</span></span>\n        <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n                class="code-name">multicast-port</span></span></span><span class="code-tag">&gt;</span></span>54327<span\n            class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">multicast-port</span></span></span><span class="code-tag">&gt;</span></span>\n      <span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n              class="code-name">multicast</span></span></span><span class="code-tag">&gt;</span></span>\n      <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n              class="code-name">tcp-ip</span></span></span><span class="code-tag"> </span><span class="hljs-attr"><span\n              class="code-tag"><span class="hljs-attr">enabled</span></span></span><span class="code-tag">=</span><span\n              class="code-string"><span class="code-tag"><span class="code-string">"true"</span></span></span><span\n              class="code-tag">&gt;</span></span>\n        <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n                class="code-name">member</span></span></span><span class="code-tag">&gt;</span></span>fe80::223:6cff:fe93:7c7e:5701<span\n            class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">member</span></span></span><span class="code-tag">&gt;</span></span>\n        <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n                class="code-name">interface</span></span></span><span class="code-tag">&gt;</span></span>fe80:0:0:0:45c5:47ee:fe15:493a<span\n            class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">interface</span></span></span><span class="code-tag">&gt;</span></span>\n      <span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n              class="code-name">tcp-ip</span></span></span><span class="code-tag">&gt;</span></span>\n    <span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">join</span></span></span><span class="code-tag">&gt;</span></span>\n    <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">interfaces</span></span></span><span class="code-tag"> </span><span\n            class="hljs-attr"><span class="code-tag"><span class="hljs-attr">enabled</span></span></span><span\n            class="code-tag">=</span><span class="code-string"><span class="code-tag"><span\n            class="code-string">"true"</span></span></span><span class="code-tag">&gt;</span></span>\n      <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n              class="code-name">interface</span></span></span><span class="code-tag">&gt;</span></span>fe80:0:0:0:45c5:47ee:fe15:*<span\n            class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">interface</span></span></span><span class="code-tag">&gt;</span></span>\n      <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n              class="code-name">interface</span></span></span><span class="code-tag">&gt;</span></span>fe80::223:6cff:fe93:0-5555<span\n            class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">interface</span></span></span><span class="code-tag">&gt;</span></span>\n    <span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">interfaces</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">network</span></span></span><span class="code-tag">&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n        class="code-name">hazelcast</span></span></span><span class="code-tag">&gt;</span></span></code></pre>\n<p>需要强调的是，并不是所有的环境都能有效的支持<em>IPV6</em>。而<em>Hazelcast</em>有个坑时在同时支持<em>IPV6</em>和<em>IPV4</em>的环境会优先使用<em>IPV6</em>作为默认地址协议，这样会导致有时组网会失败。可以将jvm系统参数<em>java.net.preferIPv4Stack</em>设置为<em>true</em>（<em>java&nbsp;-Djava.net.preferIPv4Stack=[true|false]...</em>）来指定<em>jvm</em>环境强制使用<em>ipv4</em>。\n</p>\n<p>到此，<em>Hazelcast</em>组建集群和网络通信相关的内容介绍完毕，总的来说都是网络配置相关的说明。后续的博文会逐一介绍Hazelcast的分布式数据结构（Map、List等）和分布式功能。</p>'},360:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h2 id="h2-1">Web组件</h2>\n<p>从概念上说，React 和 <a title="Web组件" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components" rel="nofollow">Web组件</a>&nbsp;分别用于解决不同的问题。Web组件提供了强大的封装特性来支持其可重复使用性，而React提供了一系列声明性（declarative）接口保证Dom结构和数据同步。但是某些时候这2个目标是互补的。对于开发人员来说将React用于Web组件、或将Web组件用于React、或2者皆有并非难事。\n</p>\n<p>虽然大部分使用React的开发人员并不需要使用Web组件，但是在某些情况，特别是引入了某些第三方库，还是需要使用到相关机制。</p>\n\n<h3 id="h3-1">在React中使用Web组件</h3>\n<pre class="scala"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span\n        class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span\n        class="code-title"><span class="hljs-class"><span class="code-title">HelloMessage</span></span></span><span\n        class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="xml"><span class="code-tag">&lt;<span\n            class="code-name">div</span>&gt;</span><span class="code-type">Hello</span> <span class="code-tag">&lt;<span\n            class="code-name">x-search</span>&gt;</span>{<span class="code-keyword">this</span>.props.name}<span\n            class="code-tag">&lt;/<span class="code-name">x-search</span>&gt;</span>!<span class="code-tag">&lt;/<span\n            class="code-name">div</span>&gt;</span>;\n  }\n}</span></code></pre>\n<blockquote>\n    <p>Web组件常会暴露一些必要的API接口，例如一个 video Web组件可能会暴露&nbsp;&nbsp;<code>play()</code>&nbsp;和&nbsp;<code>pause()</code>&nbsp;方法。为了获取Web组件暴露的这些API接口，需要在React编码使用Refs特性来直接获取真实的Dom节点。如果引入第三方的Web组件，最好的解决方案使用一个React组件来包装引入的Web组件并最终作为一个React组件来使用。\n    </p>\n    <p>由第三方Web组件触发的事件也许并不能通过React的渲染树传递，此时需要在组件中去手工的触发事件。&nbsp;</p>\n</blockquote>\n<p>一个经常导致混乱的地方是，Web组件使用的是“class”而React使用的是“className”，例如：</p>\n<pre class="javascript"><code class="language-javascript"><span class="hljs-function"><span class="code-keyword"><span\n        class="hljs-function"><span class="code-keyword">function</span></span></span><span\n        class="hljs-function"> </span><span class="code-title"><span class="hljs-function"><span class="code-title">BrickFlipbox</span></span></span><span\n        class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span\n        class="hljs-params"></span>) </span></span>{\n  <span class="code-keyword"><span class="code-keyword">return</span></span> (\n    <span class="xml"><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span\n            class="code-name">brick-flipbox</span></span></span></span><span class="xml"><span class="code-tag"> </span></span><span\n            class="hljs-attr"><span class="xml"><span class="code-tag"><span\n            class="hljs-attr">class</span></span></span></span><span class="xml"><span\n            class="code-tag">=</span></span><span class="code-string"><span class="xml"><span class="code-tag"><span\n            class="code-string">"demo"</span></span></span></span><span class="xml"><span\n            class="code-tag">&gt;</span></span></span><span class="xml">\n      </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">div</span></span></span></span><span\n            class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">front</span><span\n            class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span\n            class="xml"><span class="code-tag"><span class="code-name">div</span></span></span></span><span class="xml"><span\n            class="code-tag">&gt;</span></span></span><span class="xml">\n      </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">div</span></span></span></span><span\n            class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">back</span><span\n            class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span\n            class="xml"><span class="code-tag"><span class="code-name">div</span></span></span></span><span class="xml"><span\n            class="code-tag">&gt;</span></span></span><span class="xml">\n    </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span\n            class="code-name">brick-flipbox</span></span></span></span><span class="xml"><span\n            class="code-tag">&gt;</span></span></span><span class="xml">\n  );\n}</span></span></code></pre>\n\n<h3 id="h3-2">在Web组件中使用React</h3>\n<pre class="javascript"><code class="language-javascript"><span class="code-keyword"><span\n        class="code-keyword">const</span></span> proto = <span class="code-built_in"><span\n        class="code-built_in">Object</span></span>.create(HTMLElement.prototype, {\n  attachedCallback: {\n    value: <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">function</span></span></span><span class="hljs-function">(</span><span\n            class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{\n      <span class="code-keyword"><span class="code-keyword">const</span></span> mountPoint = <span\n            class="code-built_in"><span class="code-built_in">document</span></span>.createElement(<span\n            class="code-string"><span class="code-string">\'span\'</span></span>);\n      <span class="code-keyword"><span class="code-keyword">this</span></span>.createShadowRoot().appendChild(mountPoint);\n\n      <span class="code-keyword"><span class="code-keyword">const</span></span> name = <span class="code-keyword"><span\n            class="code-keyword">this</span></span>.getAttribute(<span class="code-string"><span class="code-string">\'name\'</span></span>);\n      <span class="code-keyword"><span class="code-keyword">const</span></span> url = <span class="code-string"><span\n            class="code-string">\'https://www.google.com/search?q=\'</span></span> + <span class="code-built_in"><span\n            class="code-built_in">encodeURIComponent</span></span>(name);\n      ReactDOM.render(<span class="xml"><span class="code-tag"><span class="xml"><span\n            class="code-tag">&lt;</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span\n            class="code-name">a</span></span></span></span><span class="xml"><span class="code-tag"> </span></span><span\n            class="hljs-attr"><span class="xml"><span class="code-tag"><span class="hljs-attr">href</span></span></span></span><span\n            class="xml"><span class="code-tag">=</span></span><span class="code-string"><span class="xml"><span\n            class="code-tag"><span class="code-string">{url}</span></span></span></span><span class="xml"><span\n            class="code-tag">&gt;</span></span></span><span class="xml">{name}</span><span class="code-tag"><span\n            class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span class="xml"><span\n            class="code-tag"><span class="code-name">a</span></span></span></span><span class="xml"><span\n            class="code-tag">&gt;</span></span></span></span>, mountPoint);\n    }\n  }\n});\n<span class="code-built_in"><span class="code-built_in">document</span></span>.registerElement(<span\n            class="code-string"><span class="code-string">\'x-search\'</span></span>, {prototype: proto});</code></pre>\n\n<h3 id="h3-3">React整合Jquery这一类直接操作Dom的技术</h3>\n<p>\n    React在发生真实Dom渲染之前都会先产生与之对应的虚拟Dom结构，然后再“合适”的时候将虚拟Dom的内容渲染到真实Dom上，完成渲染之后componentDidMount会被调用。Jquery这一类真实Dom的操作技术投入实际使用时最好在componentDidMount中使用，然后保证这个组件不会的虚拟Dom不发生任何改变。</p>'},368:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h2 id="h2-1">在一般组件中使用Forwarding Refs</h2>\n<p>通常情况下，我们想获取一个组建或则一个HTML元素的实例通过 <a\n        href="https://www.chkui.com/article/react/react_typechecking_with_proptypes_and_dom_element" title="Ref特性">Ref特性</a>\n    就可以实现，但是某些时候我们需要在子父级组建中传递使用实例，Forwarding Refs提供了一种技术手段来满足这个要求，特别是开发一些重复使用的组建库时。比如下面的例子：</p>\n<pre><code class="javascript"><span class="hljs-function"><span class="code-keyword">function</span> <span\n        class="code-title">MyButton</span>(<span class="hljs-params">props</span>) </span>{\n  <span class="code-keyword">return</span> (\n    <span class="xml"><span class="code-tag">&lt;<span class="code-name">button</span> <span\n            class="hljs-attr">className</span>=<span class="code-string">"MyButton"</span>&gt;</span>\n      {props.children}\n    <span class="code-tag">&lt;/<span class="code-name">button</span>&gt;</span></span>\n  );\n}</code></pre>\n<p>上面的代码中MyButton组件渲染了一个HTML元素。对于使用者而言，React隐藏了将代码渲染成页面元素的过程，当其他组件使用MyButton时，并没有任何直接的方法来获取MyButton中的&lt;button&gt;元素，这样的设计方法有利于组建的分片管理，降低耦合。</p>\n<p>\n    但是像MyButton这样的组建，其实仅仅是对基本的HTML元素进行了简单的封装。某些时候，上层组建使用他时更希望将其作为一个基本的HTML元素来看待，实现某些效果需要直接操作DOM，比如focus、selection和animations效果。</p>\n<p>下面的例子将Forwarding Refs添加到MyButton组件中，以实现实例传递的效果。</p>\n<pre><code class="javascript"><span class="code-keyword">const</span> MyButton = React.forwardRef(<span\n        class="hljs-function">(<span class="hljs-params">props, ref</span>) =&gt;</span> (\n  <span class="xml"><span class="code-tag">&lt;<span class="code-name">button</span> <span class="hljs-attr">ref</span>=<span\n          class="code-string">{ref}</span> <span class="hljs-attr">className</span>=<span\n          class="code-string">"MyButton"</span>&gt;</span>\n    {props.children}\n  <span class="code-tag">&lt;/<span class="code-name">button</span>&gt;</span></span>\n));\n\n<span class="code-comment">// 通过ref可以直接操作&lt;button&gt;元素:</span>\n<span class="code-keyword">const</span> ref = React.createRef();\n<span class="xml"><span class="code-tag">&lt;<span class="code-name">MyButton</span> <span class="hljs-attr">ref</span>=<span\n        class="code-string">{ref}</span>&gt;</span>Click me!<span class="code-tag">&lt;/<span\n        class="code-name">MyButton</span>&gt;</span></span>;</code></pre>\n<p>这个时候，ref可以直接操作&lt;button&gt;元素。其实执行过程非常简单，也就下面5步：</p>\n<ol>\n    <li>通过React.createRef()方法创建一个ref实例。</li>\n    <li>和通常使用Ref一样，将其作为一个ref属性参数传递给MyButton组件。</li>\n    <li>使用React.forwardRef方法来创建一个组件，并将ref作为第二个参数传递。</li>\n    <li>将ref参数以ref属性的方式传递给&lt;button&gt;元素。</li>\n    <li>在渲染之后，可以使用ref.current来获取&lt;button&gt;元素的实例。</li>\n</ol>\n<p><span style="color:#e74c3c">需要注意的是只有使用React.forwardRef来创建一个组件时，第二个ref参数才会存在。固定的方法或者使用类来创建组件并不会接收到ref参数。Forwarding Refs特性并不仅仅局限于用在HTML DOM元素上，这种方式也实用于组件之间传递Ref。&nbsp;</span>\n</p>\n\n<h2 id="h2-2">在高阶组件中使用Forwarding Refs</h2>\n<p><a href="https://www.chkui.com/article/react/react_high_order_component" title="高阶组件">高阶组件（HOCs）</a>仅仅对一般组件的包装。一般组件被包装之后对于使用者来说并不清晰其是否是被包装过，此时使用Ref得到的是高阶组件的实例。因此Forwarding\n    Refs特性对于高阶组件来说更有价值。</p>\n<p>下面是一个高阶组件记录日志的例子：</p>\n<pre><code class="javascript"><span class="hljs-function"><span class="code-keyword">function</span> <span\n        class="code-title">logProps</span>(<span class="hljs-params">WrappedComponent</span>) </span>{\n  <span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">LogProps</span> <span\n          class="code-keyword">extends</span> <span class="code-title">React</span>.<span\n          class="code-title">Component</span> </span>{\n    componentDidUpdate(prevProps) {\n      <span class="code-built_in">console</span>.log(<span class="code-string">\'old props:\'</span>, prevProps);\n      <span class="code-built_in">console</span>.log(<span class="code-string">\'new props:\'</span>, <span\n            class="code-keyword">this</span>.props);\n    }\n\n    render() {\n      <span class="code-keyword">return</span> <span class="xml"><span class="code-tag">&lt;<span class="code-name">WrappedComponent</span> {<span\n            class="hljs-attr">...this.props</span>} /&gt;</span>;\n    }\n  }\n\n  return LogProps;\n}</span></code></pre>\n<p>logProps组件用于在每次数据更新前后记录props中的数据。我们用其包装前面的MyButton组件。</p>\n<pre><code class="javascript"><span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MyButton</span> <span\n        class="code-keyword">extends</span> <span class="code-title">React</span>.<span\n        class="code-title">Component</span> </span>{\n  focus() {\n    <span class="code-comment">// ...</span>\n  }\n\n  render() {\n    <span class="code-comment">//</span>\n  }\n}\n\n<span class="code-keyword">export</span> <span class="code-keyword">default</span> logProps(MyButton);</code></pre>\n<p>此时通过import并使用Refs实际上得到的是LogProps的实例：</p>\n<pre><code class="javascript"><span class="code-keyword">import</span> FancyButton <span\n        class="code-keyword">from</span> <span class="code-string">\'./FancyButton\'</span>;\n\n<span class="code-keyword">const</span> ref = React.createRef();\n<span class="xml"><span class="code-tag">&lt;<span class="code-name">MyButton</span>\n  <span class="hljs-attr">label</span>=<span class="code-string">"Click Me"</span>\n  <span class="hljs-attr">handleClick</span>=<span class="code-string">{handleClick}</span>\n  <span class="hljs-attr">ref</span>=<span class="code-string">{ref}</span>\n/&gt;</span>;</span></code></pre>\n<p>我们使用Forwarding Refs对高阶组件进行简单的改造即可解决这个问题：</p>\n<pre><code class="javascript"><span class="hljs-function"><span class="code-keyword">function</span> <span\n        class="code-title">logProps</span>(<span class="hljs-params">Component</span>) </span>{\n  <span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">LogProps</span> <span\n          class="code-keyword">extends</span> <span class="code-title">React</span>.<span\n          class="code-title">Component</span> </span>{\n    componentDidUpdate(prevProps) {\n      <span class="code-built_in">console</span>.log(<span class="code-string">\'old props:\'</span>, prevProps);\n      <span class="code-built_in">console</span>.log(<span class="code-string">\'new props:\'</span>, <span\n            class="code-keyword">this</span>.props);\n    }\n\n    render() {\n      <span class="code-keyword">const</span> {forwardedRef, ...rest} = <span class="code-keyword">this</span>.props;\n\n      <span class="code-comment">// 通过forwardedRef参数传递ref的值</span>\n      <span class="code-keyword">return</span> &lt;Component ref={forwardedRef} {...rest} /&gt;;\n    }\n  }\n  \n  //然后使用 React.forwardRef 来包装创建 LogProps组件的实例\n  //注意这里使用 forwardedRef 来传递 父组件的 ref\n  //\n  return React.forwardRef((props, ref) =&gt; {\n    return &lt;LogProps {...props} forwardedRef={ref} /&gt;;\n  });\n}</code></pre>\n\n<h2 id="h2-3">开发调试组件名称显示</h2>\n<p>如果我们不进行任何调整，下面的代码在调试工具中输出的组件名称为："ForwardRef(MyComonent)"：</p>\n<pre><code class="javascript"><span class="code-keyword">const</span> WrappedComponent = React.forwardRef(\n  <span class="hljs-function"><span class="code-keyword">function</span> <span\n          class="code-title">myFunction</span>(<span class="hljs-params">props, ref</span>) </span>{\n    <span class="code-keyword">return</span> <span class="xml"><span class="code-tag">&lt;<span class="code-name">LogProps</span> {<span\n            class="hljs-attr">...props</span>} <span class="hljs-attr">forwardedRef</span>=<span class="code-string">{ref}</span> /&gt;</span>;\n  }\n);</span></code></pre>\n<p>可以通过displayName来设定想要现实的名字：</p>\n<pre><code class="javascript"><span class="hljs-function"><span class="code-keyword">function</span> <span\n        class="code-title">logProps</span>(<span class="hljs-params">Component</span>) </span>{\n  <span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">LogProps</span> <span\n          class="code-keyword">extends</span> <span class="code-title">React</span>.<span\n          class="code-title">Component</span> </span>{\n    <span class="code-comment">// ...</span>\n  }\n\n  <span class="code-comment">//先定义返回的高阶组件方法</span>\n  <span class="hljs-function"><span class="code-keyword">function</span> <span\n          class="code-title">forwardRef</span>(<span class="hljs-params">props, ref</span>) </span>{\n    <span class="code-keyword">return</span> <span class="xml"><span class="code-tag">&lt;<span class="code-name">LogProps</span> {<span\n            class="hljs-attr">...props</span>} <span class="hljs-attr">forwardedRef</span>=<span class="code-string">{ref}</span> /&gt;</span>;\n  }\n\n  //然后设定这个组件的名称\n  const name = Component.displayName || Component.name;\n  forwardRef.displayName = `logProps(${name})`;\n\n  //构建组件\n  return React.forwardRef(forwardRef);\n}</span></code></pre>'},399:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<p>在 <a href="https://www.chkui.com/article/spring/spring_batch_introduction" title="Spring Batch(1)——数据批处理概念">Spring\n    Batch(1)——数据批处理概念</a> 文中介绍了批处理的概念以及Spring Batch相关的使用场景，后续将会陆续说明在代码层面如何使用。</p>\n<h2 id="h2-1">引入</h2>\n<p>Spring batch的引入非常简单，只需要引入Spring Framework、Datasource以及Spring Batch。在Spring\n    Boot体系下只需引入<code>spring-boot-starter-batch</code> 即可。他已经涵盖了以上所有内容。</p>\n<h2 id="h2-2">Job配置</h2>\n<p><code>Job</code>接口有多种多样的实现类，通常我们使用configuration类来构建获取一个<code>Job</code>：</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Job <span\n        class="code-title">footballJob</span><span class="hljs-params">()</span> </span>{\n&nbsp; &nbsp; <span class="code-keyword">return</span> <span\n            class="code-keyword">this</span>.jobBuilderFactory.get(<span class="code-string">"footballJob"</span>) <span\n            class="code-comment">//Job名称</span>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.start(playerLoad()) <span\n            class="code-comment">//Job Step</span>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.next(gameLoad()) <span\n            class="code-comment">//Job Step</span>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.next(playerSummarization()) <span\n            class="code-comment">//Job Step</span>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.end()\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.build();\n}\n</code></pre>\n<p>上面的代码定义了一个<code>Job</code>实例，并且在这个实例中包含了三个Step实例</p>\n<h3 id="h3-1">重启（启动）配置</h3>\n<p>批处理的一个核心问题是需要定义重启（启动）时的一些行为。当指定的<code>JobInstance</code>被<code>JobExecution</code>执行时候即认为某个<code>Job</code>已经重启（启动）。理想状态下，所有的任务都应该可以从它们之前中断的位置启动，但是某些情况下这样做是无法实现的。开发人员可以关闭重启机制或认为每次启动都是新的<code>JobInstance</code>：\n</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Job <span\n        class="code-title">footballJob</span><span class="hljs-params">()</span> </span>{\n&nbsp; &nbsp; <span class="code-keyword">return</span> <span\n            class="code-keyword">this</span>.jobBuilderFactory.get(<span class="code-string">"footballJob"</span>)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.preventRestart() <span\n            class="code-comment">//防止重启</span>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;...\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.build();\n}\n</code></pre>\n<h3 id="h3-2">监听Job Execution</h3>\n<p>当任务执行完毕或开始执行时，需要执行一些处理工作。这个时候可以使用<code>JobExecutionListener</code>：</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">JobExecutionListener</span> </span>{\n&nbsp; &nbsp; <span class="hljs-function"><span class="code-keyword">void</span> <span\n            class="code-title">beforeJob</span><span class="hljs-params">(JobExecution jobExecution)</span></span>;\n&nbsp; &nbsp; <span class="hljs-function"><span class="code-keyword">void</span> <span\n            class="code-title">afterJob</span><span class="hljs-params">(JobExecution jobExecution)</span></span>;\n}\n</code></pre>\n<p>添加方式：</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Job <span\n        class="code-title">footballJob</span><span class="hljs-params">()</span> </span>{\n&nbsp; &nbsp; <span class="code-keyword">return</span> <span\n            class="code-keyword">this</span>.jobBuilderFactory.get(<span class="code-string">"footballJob"</span>)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.listener(sampleListener()) <span\n            class="code-comment">//JobExecutionListener的实现类</span>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;...\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.build();\n}\n</code></pre>\n<p>需要注意的是<code>afterJob</code>方法无论批处理任务成功还是失败都会被执行，所以增加以下判断：</p>\n<pre><code class="Java"><span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n        class="code-title">afterJob</span><span class="hljs-params">(JobExecution jobExecution)</span></span>{\n&nbsp; &nbsp; <span class="code-keyword">if</span>( jobExecution.getStatus() == BatchStatus.COMPLETED ){\n&nbsp; &nbsp; &nbsp; &nbsp; <span class="code-comment">//job success</span>\n&nbsp; &nbsp; }\n&nbsp; &nbsp; <span class="code-keyword">else</span> <span class="code-keyword">if</span>(jobExecution.getStatus() == BatchStatus.FAILED){\n&nbsp; &nbsp; &nbsp; &nbsp; <span class="code-comment">//job failure</span>\n&nbsp; &nbsp; }\n}\n</code></pre>\n<p>除了直接实现接口还可以用 @BeforeJob 和 @AfterJob 注解。</p>\n<h3 id="h3-3">Java配置</h3>\n<p>在Spring Batch 2.2.0版本之后（Spring 3.0+）支持纯Java配置。其核心是<code>@EnableBatchProcessing</code>注解和两个构造器。<code>@EnableBatchProcessing</code>的作用类似于Spring中的其他@Enable*,使用<code>@EnableBatchProcessing</code>之后会提供一个基本的配置用于执行批处理任务。对应的会有一系列<code>StepScope</code>实例被注入到Ioc容器中：<code>JobRepository</code>、<code>JobLauncher</code>、<code>JobRegistry</code>、<code>PlatformTransactionManager</code>、<code>JobBuilderFactory</code>以及<code>StepBuilderFactory</code>。\n</p>\n<p>\n    配置的核心接口是<code>BatchConfigurer</code>，默认情况下需要在容器中指定<code>DataSource</code>，该数据源用于JobRepository相关的表。开发的过程中可以使用自定义的<code>BatchConfigurer</code>实现来提供以上所有的Bean。通常情况下可以扩展重载<code>DefaultBatchConfigurer</code>类中的Getter方法用于实现部分自定义功能：\n</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> BatchConfigurer <span class="code-title">batchConfigurer</span><span\n        class="hljs-params">()</span> </span>{\n&nbsp;&nbsp; &nbsp;<span class="code-keyword">return</span> <span class="code-keyword">new</span> DefaultBatchConfigurer() {\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<span class="code-meta">@Override</span>\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<span class="hljs-function"><span class="code-keyword">public</span> PlatformTransactionManager <span\n            class="code-title">getTransactionManager</span><span class="hljs-params">()</span> </span>{\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<span class="code-keyword">return</span> <span\n            class="code-keyword">new</span> MyTransactionManager();\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}\n&nbsp;&nbsp; &nbsp;};\n}\n</code></pre>\n<p>使用了<code>@EnableBatchProcessing</code>之后开发人员可以使用以下的方法来配置一个Job：</p>\n<pre><code class="Java"><span class="code-meta">@Configuration</span>\n<span class="code-meta">@EnableBatchProcessing</span>\n<span class="code-meta">@Import</span>(DataSourceConfiguration.class)\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">AppConfig</span> </span>{\n\n&nbsp; &nbsp; <span class="code-meta">@Autowired</span>\n&nbsp; &nbsp; <span class="code-keyword">private</span> JobBuilderFactory jobs;\n\n&nbsp; &nbsp; <span class="code-meta">@Autowired</span>\n&nbsp; &nbsp; <span class="code-keyword">private</span> StepBuilderFactory steps;\n\n&nbsp; &nbsp; <span class="code-meta">@Bean</span>\n&nbsp; &nbsp; <span class="hljs-function"><span class="code-keyword">public</span> Job <span\n            class="code-title">job</span><span class="hljs-params">(@Qualifier(<span class="code-string">"step1"</span>)</span> Step step1, @<span\n            class="code-title">Qualifier</span><span class="hljs-params">(<span\n            class="code-string">"step2"</span>)</span> Step step2) </span>{\n&nbsp; &nbsp; &nbsp; &nbsp; <span class="code-keyword">return</span> jobs.get(<span class="code-string">"myJob"</span>).start(step1).next(step2).build();\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; <span class="code-meta">@Bean</span>\n&nbsp; &nbsp; <span class="hljs-function"><span class="code-keyword">protected</span> Step <span class="code-title">step1</span><span\n            class="hljs-params">(ItemReader&lt;Person&gt; reader,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ItemProcessor&lt;Person, Person&gt; processor,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ItemWriter&lt;Person&gt; writer)</span> </span>{\n&nbsp; &nbsp; &nbsp; &nbsp; <span class="code-keyword">return</span> steps.get(<span class="code-string">"step1"</span>)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .&lt;Person, Person&gt; chunk(<span class="hljs-number">10</span>)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .reader(reader)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .processor(processor)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .writer(writer)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .build();\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; <span class="code-meta">@Bean</span>\n&nbsp; &nbsp; <span class="hljs-function"><span class="code-keyword">protected</span> Step <span class="code-title">step2</span><span\n            class="hljs-params">(Tasklet tasklet)</span> </span>{\n&nbsp; &nbsp; &nbsp; &nbsp; <span class="code-keyword">return</span> steps.get(<span class="code-string">"step2"</span>)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .tasklet(tasklet)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .build();\n&nbsp; &nbsp; }\n}\n</code></pre>\n<h2 id="h2-3">JobRepository配置</h2>\n<p>一旦使用了<code>@EnableBatchProcessing</code>\n    注解，<code>JobRepository</code>即会被注入到IoCs容器中并自动使用容器中的<code>DataSource</code>。<code>JobRepository</code>用于处理批处理表的CURD，整个Spring\n    Batch的运行都会使用到它。除了使用容器中默认的<code>DataSoruce</code>以及其他组件，还可以在<code>BatchConfigurer</code>中进行配置：</p>\n<pre><code class="Java"><span class="code-meta">@Override</span>\n<span class="hljs-function"><span class="code-keyword">protected</span> JobRepository <span class="code-title">createJobRepository</span><span\n        class="hljs-params">()</span> <span class="code-keyword">throws</span> Exception </span>{\n&nbsp; &nbsp; JobRepositoryFactoryBean factory = <span class="code-keyword">new</span> JobRepositoryFactoryBean();\n&nbsp; &nbsp; factory.setDataSource(dataSource);\n&nbsp; &nbsp; factory.setTransactionManager(transactionManager);\n&nbsp; &nbsp; factory.setIsolationLevelForCreate(<span class="code-string">"ISOLATION_SERIALIZABLE"</span>);\n&nbsp; &nbsp; factory.setTablePrefix(<span class="code-string">"BATCH_"</span>);\n&nbsp; &nbsp; factory.setMaxVarCharLength(<span class="hljs-number">1000</span>);\n&nbsp; &nbsp; <span class="code-keyword">return</span> factory.getObject();\n}\n</code></pre>\n<p>在代码中可以看到，设置<code>JobRepository</code>需要<code>DataSource</code>和<code>TransactionManager</code>，如果没有指定将会使用容器中的默认配置。\n</p>\n<h3 id="h3-4">JobRepository的事物配置</h3>\n<p>默认情况下框架为<code>JobRepository</code>提供了默认<code>PlatformTransactionManager</code>事物管理。它用于确保批处理执行过程中的元数据正确的写入到指定数据源中。如果缺乏事物，那么框架产生元数据就无法和整个处理过程完全契合。\n</p>\n<p>如下图，在BatchConfigurer中的<code>setIsolationLevelForCreate</code>方法中可以指定事物的隔离等级：</p>\n<pre><code class="Java"><span class="hljs-function"><span class="code-keyword">protected</span> JobRepository <span\n        class="code-title">createJobRepository</span><span class="hljs-params">()</span> <span class="code-keyword">throws</span> Exception </span>{\n&nbsp; &nbsp; JobRepositoryFactoryBean factory = <span class="code-keyword">new</span> JobRepositoryFactoryBean();\n&nbsp; &nbsp; factory.setDataSource(dataSource);\n&nbsp; &nbsp; factory.setTransactionManager(transactionManager);\n&nbsp; &nbsp; factory.setIsolationLevelForCreate(<span class="code-string">"ISOLATION_REPEATABLE_READ"</span>);\n&nbsp; &nbsp; <span class="code-keyword">return</span> factory.getObject();\n}\n</code></pre>\n<p><code>setIsolationLevelForCreate</code>方法支持2个值：<em>ISOLATION_SERIALIZABLE</em>、<em>ISOLATION_REPEATABLE_READ</em>，前者是默认配置，类似于<code>@Transactional(isolation\n    = Isolation.SERIALIZABLE)</code>，表示查询和写入都是一次事物，会对事物进行严格的锁定，当事物完成提交后才能进行其他的读写操作，容易死锁。后者是读事物开放，写事物锁定。任何时候都可以快速的读取数据，但是写入事物有严格的事物机制。当一个事物挂起某些记录时，其他写操作必须排队。\n</p>\n<h3 id="h3-5">修改表名称</h3>\n<p>默认情况下，<code>JobRepository</code>管理的表都以*BATCH_*开头。需要时可以修改前缀：</p>\n<pre><code class="java"><span class="code-comment">// This would reside in your BatchConfigurer implementation</span>\n<span class="code-meta">@Override</span>\n<span class="hljs-function"><span class="code-keyword">protected</span> JobRepository <span class="code-title">createJobRepository</span><span\n        class="hljs-params">()</span> <span class="code-keyword">throws</span> Exception </span>{\n&nbsp; &nbsp; JobRepositoryFactoryBean factory = <span class="code-keyword">new</span> JobRepositoryFactoryBean();\n&nbsp; &nbsp; factory.setDataSource(dataSource);\n&nbsp; &nbsp; factory.setTransactionManager(transactionManager);\n&nbsp; &nbsp; factory.setTablePrefix(<span class="code-string">"SYSTEM.TEST_"</span>); <span\n            class="code-comment">//修改前缀</span>\n&nbsp; &nbsp; <span class="code-keyword">return</span> factory.getObject();\n}\n</code></pre>\n<h3 id="h3-6">内存级存储</h3>\n<p>Spring Batch支持将运行时的状态数据（元数据）仅保存在内存中。重载<code>JobRepository</code>不设置<code>DataSource</code>即可：</p>\n<pre><code class="Java"><span class="code-meta">@Override</span>\n<span class="hljs-function"><span class="code-keyword">protected</span> JobRepository <span class="code-title">createJobRepository</span><span\n        class="hljs-params">()</span> <span class="code-keyword">throws</span> Exception </span>{\n&nbsp; &nbsp; MapJobRepositoryFactoryBean factory = <span class="code-keyword">new</span> MapJobRepositoryFactoryBean();\n&nbsp; &nbsp; factory.setTransactionManager(transactionManager);\n&nbsp; &nbsp; <span class="code-keyword">return</span> factory.getObject();\n}\n</code></pre>\n<p>需要注意的是，内存级存储无法满足分布式系统。</p>\n<h2 id="h2-4">JobLauncher配置</h2>\n<p>启用了<code>@EnableBatchProcessing</code>之后<code>JobLauncher</code>会自动注入到容器中以供使用。此外可以自行进行配置：</p>\n<pre><code class="Java"><span class="code-meta">@Override</span>\n<span class="hljs-function"><span class="code-keyword">protected</span> JobLauncher <span class="code-title">createJobLauncher</span><span\n        class="hljs-params">()</span> <span class="code-keyword">throws</span> Exception </span>{\n&nbsp;&nbsp; &nbsp;SimpleJobLauncher jobLauncher = <span class="code-keyword">new</span> SimpleJobLauncher();\n&nbsp;&nbsp; &nbsp;jobLauncher.setJobRepository(jobRepository);\n&nbsp;&nbsp; &nbsp;jobLauncher.afterPropertiesSet();\n&nbsp;&nbsp; &nbsp;<span class="code-keyword">return</span> jobLauncher;\n}\n</code></pre>\n<p><code>JobLauncher</code>唯一的必要依赖只有<code>JobRepository</code>。如下图，Job的执行通常是一个同步过程：\n    <img src="https://docs.spring.io/spring-batch/4.2.x/reference/html/images/job-launcher-sequence-sync.png"\n         alt="Spring Batch(2)——Job配置与运行" class="zoom-in-cursor"></p>\n<p>可以通过修改TaskExecutor来指定Job的执行过程：</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> JobLauncher <span\n        class="code-title">jobLauncher</span><span class="hljs-params">()</span> </span>{\n&nbsp;&nbsp; &nbsp;SimpleJobLauncher jobLauncher = <span class="code-keyword">new</span> SimpleJobLauncher();\n&nbsp;&nbsp; &nbsp;jobLauncher.setJobRepository(jobRepository());\n&nbsp;&nbsp; &nbsp;jobLauncher.setTaskExecutor(<span class="code-keyword">new</span> SimpleAsyncTaskExecutor()); <span\n            class="code-comment">//转换为异步任务</span>\n&nbsp;&nbsp; &nbsp;jobLauncher.afterPropertiesSet();\n&nbsp;&nbsp; &nbsp;<span class="code-keyword">return</span> jobLauncher;\n}\n</code></pre>\n<p>这样执行过程变为：</p>\n<p><img src="https://docs.spring.io/spring-batch/4.2.x/reference/html/images/job-launcher-sequence-async.png"\n        alt="Spring Batch(2)——Job配置与运行" class="zoom-in-cursor"></p>\n<h2 id="h2-5">运行一个Job</h2>\n<p>以一个Http为例：</p>\n<pre><code class="Java"><span class="code-meta">@Controller</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">JobLauncherController</span> </span>{\n\n&nbsp; &nbsp; <span class="code-meta">@Autowired</span>\n&nbsp; &nbsp; JobLauncher jobLauncher;\n\n&nbsp; &nbsp; <span class="code-meta">@Autowired</span>\n&nbsp; &nbsp; Job job;\n\n&nbsp; &nbsp; <span class="code-meta">@RequestMapping</span>(<span class="code-string">"/jobLauncher.html"</span>)\n&nbsp; &nbsp; <span class="hljs-function"><span class="code-keyword">public</span> <span\n            class="code-keyword">void</span> <span class="code-title">handle</span><span\n            class="hljs-params">()</span> <span class="code-keyword">throws</span> Exception</span>{\n&nbsp; &nbsp; &nbsp; &nbsp; jobLauncher.run(job, <span class="code-keyword">new</span> JobParameters());\n&nbsp; &nbsp; }\n}\n</code></pre>\n<p>单单是配置好<code>Job</code>是肯定无法执行的，还需要对Step进行配置。后面会陆续介绍。</p>'}});