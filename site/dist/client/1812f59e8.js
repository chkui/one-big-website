webpackJsonp([1],{333:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<p>在hazelcast的官方文档中，提到了其支持read-through，write-through与write-behind三种模式。查阅资料，最后在oracle的官文中找到了比较靠谱的解释。</p>\n<p>read-throug、write-through、write-behind三个概念都是关于数据缓存管理的。其实这些概念在实际使用的过程中经常接触。</p>\n<h2 id="h2-1"><strong>Read-throug</strong></h2>\n<p>当应用系统向缓存系统请求数据时（例如使用key=x向缓存请求数据）；如果缓存中并没有对应的数据存在（key=x的value不存在），缓存系统将向底层数据源的读取数据。如果数据在缓存中存在（命中key=x），则直接返回缓存中存在的数据。这就是所谓的<strong>Read-throug。</strong></p>\n<p>hazelcast原文：</p>\n<blockquote>\n    <p>If an entry does not exist in the memory when an application asks for it, Hazelcast asks your loader implementation to load that entry from the data store。 &nbsp;If the entry exists there, the loader implementation gets it, hands it to Hazelcast, and Hazelcast puts it into the memory. This is read-through persistence mode。</p>\n</blockquote>\n<p>下图是Oracle官网的<strong>Read-throug</strong>图例。\n    <img alt="Hazelcast read-through、write-through与write-behind模式" src="https://file.mahoooo.com/res/file/read_through_write_through_and_write_behind_1.jpg">\n</p>\n<h2 id="h2-2">Write-Through</h2>\n<p>当应用系统对缓存中的数据进行更新时（例如调用put方法更新或添加条目），缓存系统会同步更新缓存数据和底层数据源。</p>\n<p>下图展示了执行过程：</p>\n<p><img alt="Hazelcast read-through、write-through与write-behind模式" src="https://file.mahoooo.com/res/file/read_through_write_through_and_write_behind_2.jpg"></p>\n<h2 id="h2-3">Write-Behind</h2>\n<p>当应用系统对缓存中的数据进行更新时（例如调用put方法更新或添加条目），缓存系统会在指定的时间后向底层数据源更新数据。</p>\n<p><img alt="Hazelcast read-through、write-through与write-behind模式" src="https://file.mahoooo.com/res/file/read_through_write_through_and_write_behind_3.jpg"></p>'},347:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h2 id="h2-1">jolokia架构</h2>\n<p>虽然jolokia是为了满足JSR-160的要求，但是他和JSR-160连接器有巨大的差异。其中最引人注目的区别是jolokia传递数据是无类型的数据（<span style="color:#FF8C00"><em>说白了就是使用了Json数据传递，替代了RMI传递Java序列化数据的方式</em></span>）。\n</p>\n<p>2003年提交的JSR-160规定客户端可以透明的调用MBean服务，无论被调用的MBean是驻留在本地还是在远程的MBean服务中。这样做的好处是提供了一个简洁通用的Java\n    API接口。但是JSR-160的实现存在许多问题：</p>\n<ol>\n    <li>它非常危险，因为它隐性暴露了JMX的远程接口。</li>\n    <li>它还存在性能问题。无论是远程还是本地调用，调用者至少要知道调用过程是怎么样的、会收到什么结果。在实际使用时，需要有明确的远程消息传递模式，让调用者知道现在是在使用响应较慢的远程调用。</li>\n    <li>使用RMI（<em><span style="color:#FF8C00">JSR-160连接器的默认协议栈</span></em>）时需要使用Java对象的序列化与反序列化机制来构建传递管道。这样做就阻碍了Java技术栈之外的环境来使用它。\n    </li>\n</ol>\n<p>以上3个原因大概就是RMI（<span style="color:#FF8C00"><em>JSR-160连接器的默认协议栈</em></span>）在远程传输协议上逐渐失去市场份额的原因。</p>\n<p>Jolokia是无类型的数据，使用了Json这种轻量化的序列化方案来替代RMI方案。使用这样的方法当然存在一些缺点（<em>比如需要额外增加一层代理</em>），但是带来了一些优势，至少这样的实现方案在JMX世界是独一无二的。</p>\n\n<h2 id="h2-2">Jolokia植入模式（Agent mode）</h2>\n<p><img alt="Jolokia——架构与使用介绍" height="489"\n        src="https://file.mahoooo.com/res/file/jolokia_how_to_use_2.png" width="666"></p>\n<p>上如展示了Jolokia 植入模式的体系结构，说明了与之有关的运行环境。</p>\n<p>Jolokia植入模式是在本地基于http协议提供了一个使用Json作为数据格式的外部接口，此时Jolokia会桥接到本地的JMX\n    MBeans接口。Jolokia使用http服务扩展了JSR-160，因此需要针对Jolokia的运行进行一些额外的处理。多种技术可以工作于http协议，最常规的方法是将jolokia放置到servlet容器中，比如Tomcat或Jetty，这样Jolokia完全可以看做是一个常规的Java\n    web应用，让所有的开发人员都能够很好理解并快速的从中读取数据。</p>\n<p>当然还有更多的方式使用Jolokia植入，比如使用OSGi HttpService或嵌入到有Jetty-Server的应用中。Jvm代理者需要使用Java1.6以上版本，在他运行时，可以连接到任何本地运行的Java进程。</p>\n<p><span style="color:#FF8C00"><em>附注——关于“植入模式”的称呼的说明：官方名为“Agent mode”，按照字面意思应该译为“代理者模式”。但是后面又一个模式叫代理模式（Proxy Mode），为了更便于理解和表达中文意思，这里命名其为“植入模式”。</em></span>\n</p>\n\n<h2 id="h2-3">Jolokia代理模式</h2>\n<p>代理模式用于无法将Jolokia部署到目标平台上（说白了就是无法部署到同一台服务器）。在这个模式下，唯一可用的方式就是目标服务开启了JSR-160连接。这样做大部分是规范原因（原文是“political\n    reasons”——政治原因-_-）——有时候根本不允许在目标服务器部署一个额外的软件系统，或者是这样做需要等待一个漫长的审批流程。还有一个原因是目标服务器已经通过RMI开启了JSR-160连接，并且我们不想额外再去在本地部署Jolokia。</p>\n<p>可以将jolokia.war部署到servlet容器中（这个war包也可用于植入模式）。下图是一个典型的代理模式架构。</p>\n<p><img alt="Jolokia——架构与使用介绍" height="439"\n        src="https://file.mahoooo.com/res/file/jolokia_how_to_use_1.png" width="617"></p>\n<p>一个jolokia客户端发送常规的请求到jolokia代理服务，这个请求包含了额外的数据用于标记要查询的目标。所有的路由信息包含在请求信息中，使得代理服务无需特别的配置即可工作。</p>\n\n<h2 id="h2-4">结尾</h2>\n<p>如果没有什么特别的限制，优先使用植入模式。植入模式比代理模式有更多的优势，因为他没有附加层、减少了维度成本和技术复杂性、而且性能也优于代理模式。此外，一些jolokia特性也无法在代理模式中使用，例如“merging of\n    MBeanServers”。</p>'},348:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='\n<p>通常情况下，图形界面的发行版 <em><strong>linux</strong></em> 可以在 <strong><em>Setting-&gt;Device-&gt;Display</em></strong> 中直接设置多个屏幕的分辨率。但是坑总是无处不在的，有时候明明用得好好的分辨率就出毛病了，而且不能在界面上设置。此时可以通过 <em><strong>xrandr</strong></em> 命令来直接设置分辨率。</p>\n\n<h2 id="h2-1">常规方法</h2>\n<p>1.查看显示模式参数：</p>\n<pre class="bash"><code class="language-bash"><span class="code-comment"><span class="code-comment">#1440 900就是要修改的分辨率，根据需要可以使用1920 1080、1720 900等</span></span>\n<span class="code-variable"><span class="code-variable">$cvt</span></span> 1440 900\n<span class="code-comment"><span class="code-comment">#输出内容</span></span>\n1440x900 59.89 Hz (CVT 1.30MA) hsync: 55.93 kHz; pclk: 106.50 MHz\nModeline <span class="code-string"><span class="code-string">"1440x900_60.00"</span></span>  106.50  1440 1528 1672 1904  900 903 909 934 -hsync +vsync</code></pre>\n<p>Modeline之后的内容就是我们后面添加显示模式要使用的参数。</p>\n<p>2.通过addMode命令增加一个现实模式：</p>\n<pre class="bash"><code class="language-bash"><span class="code-comment"><span class="code-comment">#将Modeline的阿才能书复制到 --newmode之后即可</span></span>\n<span class="code-comment"><span class="code-comment">#后面的参数可以根据需要调整，请查阅cvt相关的说明</span></span>\n<span class="code-variable"><span class="code-variable">$xrandr</span></span> --newmode <span class="code-string"><span class="code-string">"1440x900_60.00"</span></span>  106.50  1440 1528 1672 1904  900 903 909 934 -hsync +vsync</code></pre>\n<p>3.增加到对应的显示器。</p>\n<p>先用xrandr命令查询对应的显示器：</p>\n<pre class="scss"><code class="language-bash"><span class="code-variable"><span class="code-variable">$xrandr</span></span>\n<span class="code-comment">#输出类似以下的内容</span>\nWAYLAND0 connected primary 1366x768+0+0 (<span class="code-attribute">normal</span> <span class="code-attribute">left</span> inverted <span class="code-attribute">right</span> x axis y axis) 309mm x 173mm\n   1366x768      60<span class="code-selector-class">.00</span>*+\n   1360x768      59<span class="code-selector-class">.80</span>    59<span class="code-selector-class">.96</span>\n   1024x768      60<span class="code-selector-class">.04</span>    60<span class="code-selector-class">.00</span>\n   960x720       60<span class="code-selector-class">.00</span>\n   928x696       60<span class="code-selector-class">.05</span>\nWAYLAND1 connected 1024x768+1366+0 (<span class="code-attribute">normal</span> <span class="code-attribute">left</span> inverted <span class="code-attribute">right</span> x axis y axis) 0mm x 0mm\n   1024x768      60<span class="code-selector-class">.00</span>*\n   800x600       60<span class="code-selector-class">.32</span>    56<span class="code-selector-class">.25</span>\n   848x480       60<span class="code-selector-class">.00</span>\n   640x480       59<span class="code-selector-class">.94</span>\n</code></pre>\n<p>记住WAYLAND0\\WAYLAND1的名称，这是我们显示器的代理名称。通常用手提的话WAYLAND0就是对应的手提电脑的显示器、其余的都是扩增屏幕。</p>\n<p>然后向对应显示器下增加一个模式：</p>\n<pre class="bash"><code class="language-bash"><span class="code-variable"><span class="code-variable">$xrandr</span></span> --addmode WAYLAND1 <span class="code-string"><span class="code-string">"1440x900_60.00"</span></span></code></pre>\n<p>然后就OK了..........</p>\n\n<h2 id="h2-2">遇到的问题</h2>\n<p>但是，要是天底下的事情都这么轻松世界就完美了。</p>\n\n<h3 id="h3-1">问题一，xrand命令指针对当前用户</h3>\n<p>在使用 xrand命令时切记是针对当前用户的。例如我就是创建了一个管理员用户，然后把root账户禁用了。在执行命令时习惯性的加 <strong><em>sudo</em></strong>，最后会输出类似于 <em>"MIT-MAGIC-COOKIE-1 keyCan\'t open display :0.0" </em>这样的内容。</p>\n\n<h3 id="h3-2"><strong><em>问题二，最后一步输出 xrandr: Configure crtc 0 failed</em></strong></h3>\n<p>在最后一行&nbsp;<strong><em>$xrandr --addmode WAYLAND1 "1440x900_60.00" </em></strong>命令之后并没有修改成功，而是输出了<strong><em>xrandr: Configure crtc 0 failed&nbsp;</em></strong>或&nbsp;<strong><em>xrandr: Configure crtc 1 failed</em></strong>这样的内容。查阅了一圈资料。在askubuntu找到说明。据说是升级到Ubuntu17.10之后，使用AMD/ATI的显卡容易遇到这个坑，wayland识别不了显示器。这个时候打开Setting的Displays面板显示的是 Unknown Display，最高分辨率只能到1024*768，最不费劲的方法是可以通过安装新的驱动源来解决（但是我安装了一次还是不行）。</p>\n<p>实际上，只要显卡和显示器都支持某个分辨率，直接告诉显卡按照这个分辨率输出图像就好了，不用wayland去识别显示器。</p>\n<p>首先关闭wayland服务，wayland是17.10之后新用的显示器服务（据说是可以在登陆界面选择和X.org切换，但是我的居然没有）。关闭方法：</p>\n<p>1.打开配置文件：</p>\n<pre class="nginx"><code class="language-bash"><span class="code-comment"><span class="code-comment">#打开custom.conf文件，不同发行版文件位置可能有差异</span></span>\n<span class="code-attribute">vim</span> /etc/gdm3/custom.conf</code></pre>\n<p>2.修改文件，找到 <strong><em>#WaylandEnable=false</em></strong> 这一行，然后去掉注释。</p>\n<pre class="ini"><code class="language-bash"><span class="code-comment"><span class="code-comment"># Uncoment the line below to force the login screen to use Xorg</span></span>\n<span class="hljs-attr">WaylandEnable</span>=<span class="hljs-literal"><span class="hljs-literal">false</span></span>\n<span class="code-comment"><span class="code-comment">#......</span></span></code></pre>\n<p>3.最后reboot重启电脑。</p>\n<p>4.启动完成后输入 xrandr 命令发现之前的&nbsp;WAYLAND0 和&nbsp;WAYLAND1 变成了输出端口的名称：</p>\n<pre class="swift"><code class="language-bash"><span class="code-variable">$xrandr</span>\n<span class="code-comment">#输出</span>\n<span class="code-type">Screen</span> <span class="hljs-number">0</span>: minimum <span class="hljs-number">320</span> x <span class="hljs-number">200</span>, current <span class="hljs-number">2806</span> x <span class="hljs-number">900</span>, maximum <span class="hljs-number">8192</span> x <span class="hljs-number">8192</span>\neDP-<span class="hljs-number">1</span> connected primary 1366x768+<span class="hljs-number">0</span>+<span class="hljs-number">0</span> (normal <span class="code-keyword">left</span> inverted <span class="code-keyword">right</span> x axis y axis) 309mm x 173mm\n   1366x768      <span class="hljs-number">60.00</span>*+\n   1360x768      <span class="hljs-number">59.80</span>    <span class="hljs-number">59.96</span>\n   1024x768      <span class="hljs-number">60.04</span>    <span class="hljs-number">60.00</span>\n   960x720       <span class="hljs-number">60.00</span>\n   928x696       <span class="hljs-number">60.05</span>\n<span class="code-type">HDMI</span>-<span class="hljs-number">1</span> disconnected (normal <span class="code-keyword">left</span> inverted <span class="code-keyword">right</span> x axis y axis)\n<span class="code-type">DP</span>-<span class="hljs-number">1</span> connected 1440x900+<span class="hljs-number">1366</span>+<span class="hljs-number">0</span> (normal <span class="code-keyword">left</span> inverted <span class="code-keyword">right</span> x axis y axis) 0mm x 0mm\n   1024x768      <span class="hljs-number">60.00</span>\n   800x600       <span class="hljs-number">60.32</span>    <span class="hljs-number">56.25</span>\n   848x480       <span class="hljs-number">60.00</span>\n   640x480       <span class="hljs-number">59.94</span>\n<span class="code-type">HDMI</span>-<span class="hljs-number">2</span> disconnected (normal <span class="code-keyword">left</span> inverted <span class="code-keyword">right</span> x axis y axis)</code></pre>\n<p>这里的DP-1就是我用的外接显示器，但是现在只能显示到1024*768。然后按照前面介绍的方法依次执行<em><strong>$cvt 1440 900</strong></em>、<strong><em>$xrandr newmode</em></strong>、<em><strong>$xrandr addmode DP-1 "1440x900_60.00"</strong></em>，仅仅是最后addmode的参数有些许差异。</p>\n<p>修改后，在Displays里可以看到最新的分辨率。</p>\n\n<h2 id="h2-3">永久性问题</h2>\n<p>最后，用这个方法有个最大的问题是没法保存。每次重启过后还是没法识别显示器的分辨率，又回到修改之前的状态。</p>\n<p>有些地方说可以像下面这样添加或修改&nbsp;/etc/X11/xorg.conf&nbsp; 文件：</p>\n<pre class="nginx"><code class="nginx"><span class="code-attribute"><span class="code-attribute">Section</span></span> <span class="code-string"><span class="code-string">"Monitor"</span></span>\nIdentifier <span class="code-string"><span class="code-string">"Configured Monitor"</span></span>\nModeline <span class="code-string"><span class="code-string">"1920x1080_60.00"</span></span>  <span class="hljs-number"><span class="hljs-number">173</span></span>.<span class="hljs-number"><span class="hljs-number">00</span></span>  <span class="hljs-number"><span class="hljs-number">1920</span></span> <span class="hljs-number"><span class="hljs-number">2048</span></span> <span class="hljs-number"><span class="hljs-number">2248</span></span> <span class="hljs-number"><span class="hljs-number">2576</span></span>  <span class="hljs-number"><span class="hljs-number">1080</span></span> <span class="hljs-number"><span class="hljs-number">1083</span></span> <span class="hljs-number"><span class="hljs-number">1088</span></span> <span class="hljs-number"><span class="hljs-number">1120</span></span> -hsync +vsync\nOption <span class="code-string"><span class="code-string">"PreferredMode"</span></span> <span class="code-string"><span class="code-string">"1920x1080_60.00"</span></span>\nEndSection\nSection <span class="code-string"><span class="code-string">"Screen"</span></span>\nIdentifier <span class="code-string"><span class="code-string">"Default Screen"</span></span>\nMonitor <span class="code-string"><span class="code-string">"Configured Monitor"</span></span>\nDevice <span class="code-string"><span class="code-string">"Configured Video Device"</span></span>\nEndSection\nSection <span class="code-string"><span class="code-string">"Device"</span></span>\nIdentifier <span class="code-string"><span class="code-string">"Configured Video Device"</span></span>\nEndSection</code></pre>\n<p>但是我修改之后没有任何效果。而且还多出一份&nbsp;/etc/X11/xorg.conf.failsafe 文件。不知道是不是17.0.4特有的原因，毕竟我也是将系统升级为17.0.4之后分辨率才出问题的。</p>\n<p>既然 xorg.conf 配置无法生效，我直接将命令创建为一个shell，然后开机运行即可：</p>\n<pre class="css"><code class="language-bash"><span class="code-comment"><span class="code-selector-id">#view-port-init</span><span class="code-selector-class">.sh</span></span>\n<span class="code-selector-tag">xrandr</span> <span class="code-selector-tag">--newmode</span> <span class="code-string">"1920<span class="code-selector-tag">x1080_60</span><span class="code-selector-class">.00</span>"</span>  173<span class="code-selector-class">.00</span>  1920 2048 2248 2576  1080 1083 1088 1120 <span class="code-selector-tag">-hsync</span> +<span class="code-selector-tag">vsync</span>\n<span class="code-selector-tag">xrandr</span> <span class="code-selector-tag">--addmode</span> <span class="code-selector-tag">DP-1</span> <span class="code-string">"1920<span class="code-selector-tag">x1080_60</span><span class="code-selector-class">.00</span>"</span>\n<span class="code-comment"><span class="code-selector-id">#DP-1</span>这里请根据自己的参数修改。</span>\n</code></pre>\n<p>参考：<a href="https://askubuntu.com/questions/136139/xrandr-configure-crtc-0-failed-when-trying-to-change-resolution-on-external-m?answertab=active#tab-top" rel="nofollow">xrandr-configure-crtc-0-failed-when-trying-to-change-resolution</a>。</p>\n'},351:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<p>使用react到现在，让人头疼的一个问题是安装node-sass。其实导致问题的根源在于安装过程需要下载一个binding.node文件，而因“你懂的”原因，访问不了这个地址。根据这个原因，总结了以下几个解决方案：</p>\n<h2 id="h2-1">翻墙</h2>\n<p>这没什么好说的了，这是最轻松最彪悍的解决方案。只要能翻墙直接一个&nbsp;<span style="background-color:#D3D3D3">&nbsp;npm i&nbsp;</span>命令就完事了，什么都不必去操心。至于怎么翻墙…………\n</p>\n\n<h2 id="h2-2">使用cnpm</h2>\n<p>cnpm是一个强悍的工具，几乎能解决所有npm安装第三方包时遇到的问题。执行如下命令即可：</p>\n<pre class="sql"><code class="language-bash">npm <span class="code-keyword">install</span>\nnpm rm node-sass\ncnpm <span class="code-keyword">install</span> node-sass\nnpm <span class="code-keyword">install</span></code></pre>\n<p>\n    但是我们在使用cnpm时也遇到了一个坑，在ubuntu14.04打出来的包运行报错，不用cnpm下载居然就不会有这问题，由于没有时间，没有详细去了解原因是什么。如果你是Windows开发而使用Linux环境打包或运行，可能会碰到这个问题。</p>\n\n<h2 id="h2-3">下载后编译</h2>\n<p>\n    实际上为了得到binding.node，是可以直接从github上把源码下载下来之后再编译出来的，node-sass自己也会这样做，但是编译要依赖其他工具。在各种发行版的linux下还好，几乎所有需要的环境（python等）都是预安装的，如果是root权限直接<span\n        style="background-color:#A9A9A9"> upm install </span>就搞定了，所以有时候根本感觉不到这个问题。在windows下就得花时间根据install时的错误日志了解还要安装什么。\n</p>\n<p>linux下遇到权限问题请执行：</p>\n<pre class="lua"><code class="language-bash">npm i <span class="code-comment">--unsafe -perm</span></code></pre>\n\n<h2 id="h2-4">附送一个最奇葩的坑</h2>\n<p>这是我用所有的开源工具遇到过最奇葩的坑。我将一个文件命名为“./dropDown.scss”，然后在linux(是ubuntu\n    14.04其他发行版没时间去测试，windows没这毛病)上用webpack打包，打包过程没有任何异常，但是放到服务器上运行打开某个页面就抛出无法找到"./dropDown.scss"的异常，然后node直接停机了········。我前后跟进了2天寻找问题的原因。最后突发奇想将文件名由dropDown.scss修改为pullDown.scss后一切都好了。我强烈的怀疑是某个临时工在node-sass里写了什么“硬编码”对字符串进行判断，发现“/drop[*]”这样的前缀进行一些特殊处理。在此记录下来。</p>'},354:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h2 id="h2-1">Context</h2>\n<p>在使用React时，很容易在自定义的React组件之间跟踪数据流。当监控一个组件时，可以监控到那些props被传递进入组件了，这非常有利于了解数据流在什么地方出现了问题。</p>\n<p>在某些情况下，开发者想要通过组件树直接传递数据，而不是在一层又一层的组件之间手工传递数据。此时，可以使用React的“context”特性接口来快速实现这个功能。</p>\n\n<h2 id="h2-2">尽量不要使用Context</h2>\n<p>React在16.x版本之后算是将Context调整为正式接口，不过还是建议如果组件之间传递数据的层次不算太深，尽量不要使用Context。而且 <a title="redux" href="https://github.com/reactjs/redux"\n                                                                               rel="nofollow">Redux </a>或 <a title="MobX"\n        href="https://github.com/mobxjs/mobx" rel="nofollow">MobX</a>&nbsp;等技术能提供比Context特性更为优雅的实现方式。</p>\n\n<h2 id="h2-3">最新实现方式</h2>\n<p>Context功能在16.x之后所有的API和使用方法都发生了巨大的改变，如果你使用的是最新版本（16.x）看这里最新方式就够了，如果是较早的版本，请看下方的历史实现小节。</p>\n<p>新版本的Context实现方式简洁清晰许多，方式还是以类似于 <a title="高阶组件" href="https://my.oschina.net/chkui/blog/876956" rel="nofollow">高阶组件</a> 包裹的方式为主。\n</p>\n\n<h3 id="h3-1">入门使用案例</h3>\n<p>这是一个没有使用Context特性3个组件组合的使用例子：</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span\n        class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span\n        class="code-title"><span class="hljs-class"><span class="code-title">App</span></span></span><span\n        class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> &lt;<span\n            class="code-type">Toolbar</span> theme=<span class="code-string">"dark"</span> /&gt;;\n  }\n}\n\nfunction <span class="code-type">Toolbar</span>(props) {\n  <span class="code-comment">//为了让子组件能获取必要的参数，这里需要使用props.theme继续向子组件传递参数，</span>\n  <span class="code-comment">//但是实际上theme参数对于Toolbal组件来说并没有任何价值。</span>\n  <span class="code-comment">//例如项目全局设置了一个theme参数来控制很多组件的主题样式，</span>\n  <span class="code-comment">//那么这个参数需要在几乎所有的组件出现，并且不断的传递他</span>\n  <span class="code-keyword">return</span> (\n    &lt;div&gt;\n      &lt;<span class="code-type">ThemedButton</span> theme={props.theme} /&gt;\n    &lt;/div&gt;\n  );\n}\n\nfunction <span class="code-type">ThemedButton</span>(props) {\n  <span class="code-keyword">return</span> &lt;<span class="code-type">Button</span> theme={props.theme} /&gt;;\n}</code></pre>\n<p>上面的theme参数表示全局主题样式，很多组件通过他来控制自己当前应该呈现的样式。如果我们在根组件控制这个参数，那么几乎所有的组件都要向下传递这个参数。</p>\n<p>下面是用Context特性实现的方式：</p>\n<pre class="scala"><code class="language-javascript"><span class="code-comment"><span class="code-comment">// 创建一个Context组件，可以理解为一种特殊的高阶组件。</span></span>\n<span class="code-comment"><span class="code-comment">// \'light\'是当前的默认值</span></span>\n<span class="code-keyword">const</span> <span class="code-type">ThemeContext</span> = <span\n            class="code-type">React</span>.createContext(<span class="code-string"><span\n            class="hljs-symbol">\'ligh</span>t\'</span>);\n\n<span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span\n        class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">App</span></span></span><span class="hljs-class"> </span><span\n        class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  render() {\n    <span class="code-comment"><span class="code-comment">//使用Provider将子组件包裹起来。</span></span>\n    <span class="code-comment"><span class="code-comment">//将值修改为\'dark\'</span></span>\n    <span class="code-keyword"><span class="code-keyword">return</span></span> (\n      &lt;<span class="code-type">ThemeContext</span>.<span class="code-type">Provider</span> value=<span\n            class="code-string">"dark"</span>&gt;\n        &lt;<span class="code-type">Toolbar</span> /&gt;\n      &lt;/<span class="code-type">ThemeContext</span>.<span class="code-type">Provider</span>&gt;\n    );\n  }\n}\n\n<span class="code-comment">//中间组件，并不关心和他无关的参数</span>\nfunction <span class="code-type">Toolbar</span>(props) {\n  <span class="code-keyword">return</span> (\n    &lt;div&gt;\n      &lt;<span class="code-type">ThemedButton</span> /&gt;\n    &lt;/div&gt;\n  );\n}\n\n<span class="code-comment">//使用参数的组件</span>\nfunction <span class="code-type">ThemedButton</span>(props) {\n  <span class="code-comment">// 使用Consumer组件包裹需要获取参数的组件</span>\n  <span class="code-comment">// 在这个案例中，命名为light的Context被赋值"dark"，然后在Consumer中获取这个值</span>\n  <span class="code-keyword">return</span> (\n    &lt;<span class="code-type">ThemeContext</span>.<span class="code-type">Consumer</span>&gt;\n      {theme =&gt; &lt;<span class="code-type">Button</span> {...props} theme={theme} /&gt;}\n    &lt;/<span class="code-type">ThemeContext</span>.<span class="code-type">Consumer</span>&gt;\n  );\n}</code></pre>\n<p>上面就是简单使用Context的例子，16.x之后也是通过高阶组件的方式来实现，是不是看了之后感觉很想Redux。只要是通过 Provider 包裹的组件，在其后的整个组件树中都可以用&nbsp;Consumer\n    来获取指定的数据。</p>\n<p>上面的代码我们也可以修改为下面这样更直观的形式：</p>\n<pre class="javascript"><code class="language-javascript"><span class="code-keyword"><span\n        class="code-keyword">const</span></span> {Provider, Consumer} = React.createContext(<span\n        class="code-string"><span class="code-string">\'light\'</span></span>);\n<span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span\n        class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">App</span></span></span><span class="hljs-class"> </span><span\n        class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> (\n      <span class="xml"><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n              class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">Provider</span></span></span></span><span\n              class="xml"><span class="code-tag"> </span></span><span class="hljs-attr"><span class="xml"><span\n              class="code-tag"><span class="hljs-attr">value</span></span></span></span><span class="xml"><span\n              class="code-tag">=</span></span><span class="code-string"><span class="xml"><span class="code-tag"><span\n              class="code-string">"dark"</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span\n              class="xml">\n        </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n              class="code-name"><span class="xml"><span class="code-tag"><span\n              class="code-name">Toolbar</span></span></span></span><span class="xml"><span\n              class="code-tag"> /&gt;</span></span></span><span class="xml">\n      </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span\n              class="xml"><span class="code-tag"><span class="code-name">Provider</span></span></span></span><span\n              class="xml"><span class="code-tag">&gt;</span></span></span></span>\n    );\n  }\n}\n<span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span\n        class="code-keyword">function</span></span></span><span class="hljs-function"> </span><span\n        class="code-title"><span class="hljs-function"><span class="code-title">Toolbar</span></span></span><span\n        class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span\n        class="hljs-function">) </span></span>{\n  <span class="code-keyword"><span class="code-keyword">return</span></span> (\n    <span class="xml"><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">div</span></span></span></span><span\n            class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n      </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span\n            class="code-name">ThemedButton</span></span></span></span><span class="xml"><span\n            class="code-tag"> /&gt;</span></span></span><span class="xml">\n    </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">div</span></span></span></span><span\n            class="xml"><span class="code-tag">&gt;</span></span></span></span>\n  );\n}\n<span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span\n        class="code-keyword">function</span></span></span><span class="hljs-function"> </span><span\n        class="code-title"><span class="hljs-function"><span class="code-title">ThemedButton</span></span></span><span\n        class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span\n        class="hljs-function">) </span></span>{\n  <span class="code-keyword"><span class="code-keyword">return</span></span> (\n    <span class="xml"><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span\n            class="code-name">Consumer</span></span></span></span><span class="xml"><span\n            class="code-tag">&gt;</span></span></span><span class="xml">\n      {theme =&gt; </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span\n            class="code-name">Button</span></span></span></span><span class="xml"><span\n            class="code-tag"> {</span></span><span class="hljs-attr"><span class="xml"><span class="code-tag"><span\n            class="hljs-attr">...props</span></span></span></span><span class="xml"><span\n            class="code-tag">} </span></span><span class="hljs-attr"><span class="xml"><span class="code-tag"><span\n            class="hljs-attr">theme</span></span></span></span><span class="xml"><span\n            class="code-tag">=</span></span><span class="code-string"><span class="xml"><span class="code-tag"><span\n            class="code-string">{theme}</span></span></span></span><span class="xml"><span\n            class="code-tag"> /&gt;</span></span></span><span class="xml">}\n    </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span\n            class="code-name">Consumer</span></span></span></span><span class="xml"><span\n            class="code-tag">&gt;</span></span></span><span class="xml">\n  );\n}</span></span></code></pre>\n<p>使用Context需要注意：</p>\n<ol>\n    <li>由于&nbsp;Provider 和&nbsp;Consumer都是返回一个组件，所以我们最好设定一个默认的context.value，以防止出现渲染错误。</li>\n    <li>当Provider发生数据变更时，会触发到 Consumer 发生渲染，所有被其包裹的子组件都会发生渲染（render方法被调用）。</li>\n</ol>\n\n<h3 id="h3-2">任意组件更新Context</h3>\n<p>某些时候需要在内部组件需要去更新Context的数据，其实我们仅仅需要向上下文增加一个回调即可，看下面的例子：</p>\n<pre class="scala"><code class="language-javascript"><span class="code-comment"><span\n        class="code-comment">//创建Context组件</span></span>\n<span class="code-keyword">const</span> <span class="code-type">ThemeContext</span> = <span\n            class="code-type">React</span>.createContext({\n  theme: <span class="code-string"><span class="hljs-symbol">\'dar</span>k\'</span>,\n  toggle: () =&gt; {}, <span class="code-comment"><span class="code-comment">//向上下文设定一个回调方法</span></span>\n});\n\n<span class="hljs-function"><span class="code-keyword">function</span> <span class="code-title"><span class="code-type">Button</span></span>(<span\n        class="hljs-params"></span>) </span>{\n  <span class="code-keyword"><span class="code-keyword">return</span></span> (\n    &lt;<span class="code-type">ThemeContext</span>.<span class="code-type">Consumer</span>&gt;\n      {({theme, toggle}) =&gt; (\n        &lt;button\n          onClick={toggle} <span class="code-comment">//调用回调</span>\n          style={{backgroundColor: theme}}&gt;\n          <span class="code-type">Toggle</span> <span class="code-type">Theme</span>\n        &lt;/button&gt;\n      )}\n    &lt;/<span class="code-type">ThemeContext</span>.<span class="code-type">Consumer</span>&gt;\n  );\n}\n\n<span class="code-comment">//中间组件</span>\nfunction <span class="code-type">Content</span>() {\n  <span class="code-keyword">return</span> (\n    &lt;div&gt;\n      &lt;<span class="code-type">Button</span> /&gt;\n    &lt;/div&gt;\n  );\n}\n\n<span class="code-comment">//运行APP</span>\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">App</span> <span\n        class="code-keyword">extends</span> <span class="code-title">React</span>.<span\n        class="code-title">Component</span> </span>{\n  constructor(props) {\n    <span class="code-keyword">super</span>(props);\n\n    <span class="code-keyword">this</span>.toggle = () =&gt; { <span\n            class="code-comment">//设定toggle方法，会作为context参数传递</span>\n      <span class="code-keyword">this</span>.setState(state =&gt; ({\n        theme:\n          state.theme === themes.dark\n            ? themes.light\n            : themes.dark,\n      }));\n    };\n\n    <span class="code-keyword">this</span>.state = {\n      theme: themes.light,\n      toggle: <span class="code-keyword">this</span>.toggle,\n    };\n  }\n\n  render() {\n    <span class="code-keyword">return</span> (\n      &lt;<span class="code-type">ThemeContext</span>.<span class="code-type">Provider</span> value={<span\n            class="code-keyword">this</span>.state}&gt; <span class="code-comment">//state包含了toggle方法</span>\n        &lt;<span class="code-type">Content</span> /&gt;\n      &lt;/<span class="code-type">ThemeContext</span>.<span class="code-type">Provider</span>&gt;\n    );\n  }\n}</code></pre>\n<p>App组件创建了Provider，并向其参数传递了一个回调方法，之后任何使用了 Consumer 的子孙组件都可以使用这个回调方法了触发更新。</p>\n\n<h3 id="h3-3">多个Context复合使用</h3>\n<p>React支持设置多个Context，看下面的例子：</p>\n<pre class="haskell"><code class="language-javascript"><span class="code-keyword"><span class="code-title">const</span></span> <span\n        class="code-type">ThemeContext</span> = <span class="code-type">React</span>.createContext(<span\n        class="code-string">\'light\'</span>)，\n       <span class="code-type">UserContext</span> = <span class="code-type">React</span>.createContext({\n           name: <span class="code-string">\'<span class="code-type">Guest\'</span></span>,\n       });\n<span class="hljs-class">\n</span><span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span\n            class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span\n            class="code-title"><span class="hljs-class"><span class="code-type">App</span></span></span><span\n            class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class">extends</span></span><span\n            class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n            class="code-type">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n            class="hljs-class"><span class="code-type">Component</span></span></span><span\n            class="hljs-class"> </span></span><span class="hljs-class">{\n  render() {\n    </span><span class="code-keyword"><span class="hljs-class">const</span></span><span class="hljs-class"> {signedInUser, theme} = </span><span\n            class="code-keyword"><span class="hljs-class">this</span></span><span class="hljs-class">.props;\n    </span><span class="code-keyword"><span class="hljs-class">return</span></span><span class="hljs-class"> (\n      &lt;<span class="code-type">ThemeContext</span>.<span class="code-type">Provider</span> <span class="code-title">value</span>={<span\n                class="code-title">theme</span>}&gt;\n        &lt;<span class="code-type">UserContext</span>.<span class="code-type">Provider</span> <span class="code-title">value</span>={<span\n                class="code-title">signedInUser</span>}&gt;\n          &lt;<span class="code-type">Layout</span> /&gt;\n        &lt;/<span class="code-type">UserContext</span>.<span class="code-type">Provider</span>&gt;\n      &lt;/<span class="code-type">ThemeContext</span>.<span class="code-type">Provider</span>&gt;\n    );\n  }\n}\n\nfunction <span class="code-type">Layout</span>() {\n  return (\n    &lt;<span class="code-title">div</span>&gt;\n      &lt;<span class="code-type">Sidebar</span> /&gt;\n      &lt;<span class="code-type">Content</span> /&gt;\n    &lt;/<span class="code-title">div</span>&gt;\n  );\n}\n\nfunction <span class="code-type">Content</span>() {\n  return (\n    &lt;<span class="code-type">ThemeContext</span>.<span class="code-type">Consumer</span>&gt;\n      {<span class="code-title">theme</span> =&gt; (\n        &lt;<span class="code-type">UserContext</span>.<span class="code-type">Consumer</span>&gt;\n          {<span class="code-title">user</span> =&gt; (\n            &lt;<span class="code-type">ProfilePage</span> <span class="code-title">user</span>={<span\n                class="code-title">user</span>} <span class="code-title">theme</span>={<span\n                class="code-title">theme</span>} /&gt;\n          )}\n        &lt;/<span class="code-type">UserContext</span>.<span class="code-type">Consumer</span>&gt;\n      )}\n    &lt;/<span class="code-type">ThemeContext</span>.<span class="code-type">Consumer</span>&gt;\n  );\n}</span></code></pre>\n<p>和使用单个Context也没多大区别，相互包装一层即可。</p>\n<p>使用Context时需要牢记一点：和Redux一样，只要 <strong><em>Provider </em></strong>的value发生变更都会触发所有 <strong><em>Consumer</em></strong>\n    包裹的子组件渲染。</p>\n<p>16.x之后的Context使用起来比旧版本的简单明了太多，实现思路上还是学习了Redux等将状态抽取出来统一管理并触发更新的方式来实现，在使用时选择一种方式来实现就行。</p>\n\n<h2 id="h2-4">历史实现</h2>\n\n<h4 id="h4-1">如何使用Context</h4>\n<p>假设有下面这样一个组件结构：</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span\n        class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span\n        class="code-title"><span class="hljs-class"><span class="code-title">Button</span></span></span><span\n        class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> (\n      <span class="xml"><span class="code-tag">&lt;<span class="code-name">button</span> <span\n              class="hljs-attr">style</span>=<span class="code-string">{{background:</span> <span\n              class="hljs-attr"><span class="code-keyword">this</span>.props.color</span>}}&gt;</span>\n        {<span class="code-keyword">this</span>.props.children}\n      <span class="code-tag">&lt;/<span class="code-name">button</span>&gt;</span></span>\n    );\n  }\n}\n\n<span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span\n        class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Message</span></span></span><span class="hljs-class"> </span><span\n        class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> (\n      <span class="xml"><span class="code-tag">&lt;<span class="code-name">div</span>&gt;</span>\n        {<span class="code-keyword">this</span>.props.text} <span class="code-tag">&lt;<span class="code-name"><span\n                  class="code-type">Button</span></span> <span class="hljs-attr">color</span>=<span class="code-string">{<span\n                  class="code-keyword">this</span>.props.color}</span>&gt;</span><span\n                  class="code-type">Delete</span><span class="code-tag">&lt;/<span class="code-name"><span\n                  class="code-type">Button</span></span>&gt;</span>\n      <span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>\n    );\n  }\n}\n\n<span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span\n        class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">MessageList</span></span></span><span\n        class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  render() {\n    <span class="code-keyword">const</span> color = <span class="code-string"><span class="code-string">"purple"</span></span>;\n    <span class="code-keyword">const</span> children = <span class="code-keyword"><span class="code-keyword">this</span></span>.props.messages.map((message) =&gt;\n      <span class="xml"><span class="code-tag">&lt;<span class="code-name"><span class="code-type">Message</span></span> <span\n              class="hljs-attr">text</span>=<span class="code-string">{message.text}</span> <span class="hljs-attr">color</span>=<span\n              class="code-string">{color}</span> /&gt;</span>\n    );\n    <span class="code-keyword">return</span> <span class="code-tag">&lt;<span class="code-name">div</span>&gt;</span>{children}<span\n                  class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span>;\n  }\n}</span></code></pre>\n<p>在上面的例子中，在最外层组件手工传入一个<code>color</code>属性参数来指定<code>Button</code>组件的颜色。如果使用Context特性，我们可以直接将属性自动的传递给整个组件树：</p>\n<pre class="scala"><code class="language-javascript"><span class="code-keyword">const</span> <span class="code-type">PropTypes</span> = <span\n        class="code-built_in">require</span>(<span class="code-string"><span\n        class="hljs-symbol">\'prop</span>-types\'</span>);\n\n<span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span\n        class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Button</span></span></span><span class="hljs-class"> </span><span\n        class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  render() {\n    <span class="code-comment"><span class="code-comment">// 注意this.context.color</span></span>\n    <span class="code-keyword"><span class="code-keyword">return</span></span> (\n      <span class="xml"><span class="code-tag">&lt;<span class="code-name">button</span> <span\n              class="hljs-attr">style</span>=<span class="code-string">{{background:</span> <span\n              class="hljs-attr"><span class="code-keyword">this</span>.context.color</span>}}&gt;</span>\n        {<span class="code-keyword">this</span>.props.children}\n      <span class="code-tag">&lt;/<span class="code-name">button</span>&gt;</span></span>\n    );\n  }\n}\n\n<span class="code-comment"><span class="code-comment">// 限定color属性只接收string类型的参数</span></span>\n<span class="code-type">Button</span>.contextTypes = {\n  color: <span class="code-type">PropTypes</span>.string\n};\n\n<span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span\n        class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Message</span></span></span><span class="hljs-class"> </span><span\n        class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> (\n      <span class="xml"><span class="code-tag">&lt;<span class="code-name">div</span>&gt;</span>\n        {<span class="code-keyword">this</span>.props.text} <span class="code-tag">&lt;<span class="code-name"><span\n                  class="code-type">Button</span></span>&gt;</span><span class="code-type">Delete</span><span\n                  class="code-tag">&lt;/<span class="code-name"><span class="code-type">Button</span></span>&gt;</span>\n      <span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>\n    );\n  }\n}\n\n<span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span\n        class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">MessageList</span></span></span><span\n        class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  <span class="code-comment"><span class="code-comment">// 在后续组件中设定一个Context的值</span></span>\n  getChildContext() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> {color: <span class="code-string"><span\n            class="code-string">"purple"</span></span>};\n  }\n\n  render() {\n    <span class="code-keyword">const</span> children = <span class="code-keyword"><span class="code-keyword">this</span></span>.props.messages.map((message) =&gt;\n      <span class="xml"><span class="code-tag">&lt;<span class="code-name"><span class="code-type">Message</span></span> <span\n              class="hljs-attr">text</span>=<span class="code-string">{message.text}</span> /&gt;</span>\n    );\n    <span class="code-keyword">return</span> <span class="code-tag">&lt;<span class="code-name">div</span>&gt;</span>{children}<span\n                  class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span>;\n  }\n}\n\n<span class="code-comment">//限定子组件的color值只接收string类型的参数</span>\n<span class="code-type">MessageList</span>.childContextTypes = {\n  color: <span class="code-type">PropTypes</span>.string\n};</span></code></pre>\n<p>\n    通过在&nbsp;<code>MessageList</code>&nbsp;组件（Context的制定者）中增加&nbsp;&nbsp;<code>childContextTypes</code>&nbsp;和&nbsp;<code>getChildContext</code>&nbsp;，React会自动将这个指定的context值传递到所有子组件中（比如例子中的&nbsp;<code>Button</code>组件），而子组件也可以定义一个&nbsp;<code>contextTypes</code>&nbsp;来指定接收context的内容。如果未定义子组件的&nbsp;<code>contextTypes</code>&nbsp;，那么调用&nbsp;&nbsp;<code>context</code>&nbsp;只能得到一个空对象。\n</p>\n\n<h4 id="h4-2">父子组件耦合</h4>\n<p>Context特性还可以让开发人员快速构建父组件与子组件之间的联系。例如在&nbsp;<a href="https://reacttraining.com/react-router" rel="nofollow">React\n    Router V4</a>&nbsp;包中：</p>\n<pre class="dust"><code class="language-javascript"><span class="code-keyword"><span\n        class="xml">import</span></span><span class="xml"> </span><span\n        class="code-template-variable">{ BrowserRouter </span><span class="code-keyword"><span\n        class="code-template-variable">as</span></span><span\n        class="code-template-variable"> Router, Route, Link }</span><span class="xml"> </span><span\n        class="code-keyword"><span class="xml">from</span></span><span class="xml"> </span><span\n        class="code-string"><span class="xml">\'react-router-dom\'</span></span><span class="xml">;\n\n</span><span class="code-keyword"><span class="xml">const</span></span><span class="xml"> BasicExample = () =&gt; (\n  <span class="code-tag">&lt;<span class="code-name">Router</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">div</span>&gt;</span>\n      <span class="code-tag">&lt;<span class="code-name">ul</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">li</span>&gt;</span><span class="code-tag">&lt;<span\n            class="code-name">Link</span> <span class="hljs-attr">to</span>=<span\n            class="code-string">"/"</span>&gt;</span>Home<span class="code-tag">&lt;/<span class="code-name">Link</span>&gt;</span><span\n            class="code-tag">&lt;/<span class="code-name">li</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">li</span>&gt;</span><span class="code-tag">&lt;<span\n            class="code-name">Link</span> <span class="hljs-attr">to</span>=<span class="code-string">"/about"</span>&gt;</span>About<span\n            class="code-tag">&lt;/<span class="code-name">Link</span>&gt;</span><span class="code-tag">&lt;/<span\n            class="code-name">li</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">li</span>&gt;</span><span class="code-tag">&lt;<span\n            class="code-name">Link</span> <span class="hljs-attr">to</span>=<span class="code-string">"/topics"</span>&gt;</span>Topics<span\n            class="code-tag">&lt;/<span class="code-name">Link</span>&gt;</span><span class="code-tag">&lt;/<span\n            class="code-name">li</span>&gt;</span>\n      <span class="code-tag">&lt;/<span class="code-name">ul</span>&gt;</span>\n\n      <span class="code-tag">&lt;<span class="code-name">hr</span> /&gt;</span>\n\n      <span class="code-tag">&lt;<span class="code-name">Route</span> <span class="hljs-attr">exact</span> <span\n              class="hljs-attr">path</span>=<span class="code-string">"/"</span> <span\n              class="hljs-attr">component</span>=</span></span><span class="code-template-variable">{Home}</span><span\n        class="xml"><span class="code-tag"> /&gt;</span>\n      <span class="code-tag">&lt;<span class="code-name">Route</span> <span class="hljs-attr">path</span>=<span\n              class="code-string">"/about"</span> <span class="hljs-attr">component</span>=</span></span><span\n        class="code-template-variable">{About}</span><span class="xml"><span class="code-tag"> /&gt;</span>\n      <span class="code-tag">&lt;<span class="code-name">Route</span> <span class="hljs-attr">path</span>=<span\n              class="code-string">"/topics"</span> <span class="hljs-attr">component</span>=</span></span><span\n        class="code-template-variable">{Topics}</span><span class="xml"><span class="code-tag"> /&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span>\n  <span class="code-tag">&lt;/<span class="code-name">Router</span>&gt;</span>\n);</span></code></pre>\n<p>例子通过Router组件传递一些数据，每一个被<code>Router</code>包含的&nbsp;<code>Link</code>&nbsp;和&nbsp;<code>Route</code>&nbsp;都可以直接通信。但是建议在使用这些API构建组件时，先思考是否还有其他更清晰的实现方式。例如可以使用回调的方式去组合组件。\n</p>\n\n<h4 id="h4-3">在生命周期方法中引入Context</h4>\n<p>如果在某个组件上定义了&nbsp;<code>contextTypes</code>&nbsp;，下面这些生命周期方法将会接收到额外的参数—— &nbsp;<code>context</code>&nbsp;对象。我们这里这样调整参数接口：\n</p>\n<ul>\n    <li><a href="https://facebook.github.io/react/docs/react-component.html#constructor" rel="nofollow"><code>constructor(props,\n        context)</code></a></li>\n    <li><a href="https://facebook.github.io/react/docs/react-component.html#componentwillreceiveprops"\n           rel="nofollow"><code>componentWillReceiveProps(nextProps, nextContext)</code></a></li>\n    <li><a href="https://facebook.github.io/react/docs/react-component.html#shouldcomponentupdate" rel="nofollow"><code>shouldComponentUpdate(nextProps,\n        nextState, nextContext)</code></a></li>\n    <li><a href="https://facebook.github.io/react/docs/react-component.html#componentwillupdate" rel="nofollow"><code>componentWillUpdate(nextProps,\n        nextState, nextContext)</code></a></li>\n    <li><a href="https://facebook.github.io/react/docs/react-component.html#componentdidupdate" rel="nofollow"><code>componentDidUpdate(prevProps,\n        prevState, prevContext)</code></a></li>\n</ul>\n\n<h4 id="h4-4">在无状态的方法性组件中引入Context</h4>\n<p>无状态的方法性组件也可以引入Context，前提是给组件定义了&nbsp;<code>contextTypes</code>&nbsp;。下面的代码展示了在无状态的组件——&nbsp;<code>Button</code>&nbsp;中引入context的表达式：\n</p>\n<pre class="javascript"><code class="language-javascript"><span class="code-keyword"><span\n        class="code-keyword">const</span></span> PropTypes = <span class="code-built_in"><span class="code-built_in">require</span></span>(<span\n        class="code-string"><span class="code-string">\'prop-types\'</span></span>);\n\n<span class="code-keyword"><span class="code-keyword">const</span></span> Button = ({children}, context) =&gt;\n  <span class="xml"><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n          class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">button</span></span></span></span><span\n          class="xml"><span class="code-tag"> </span></span><span class="hljs-attr"><span class="xml"><span\n          class="code-tag"><span class="hljs-attr">style</span></span></span></span><span class="xml"><span\n          class="code-tag">=</span></span><span class="code-string"><span class="xml"><span class="code-tag"><span\n          class="code-string">{{background:</span></span></span></span><span class="xml"><span class="code-tag"> </span></span><span\n          class="hljs-attr"><span class="xml"><span class="code-tag"><span class="hljs-attr">context.color</span></span></span></span><span\n          class="xml"><span class="code-tag">}}&gt;</span></span></span><span class="xml">\n    {children}\n  </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span\n          class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">button</span></span></span></span><span\n          class="xml"><span class="code-tag">&gt;</span></span></span></span>;\n\nButton.contextTypes = {color: PropTypes.string};</code></pre>\n\n<h4 id="h4-5">更新Context</h4>\n<p>首先，千万不要更新Context。</p>\n<p>React提供一个更新Context的接口，但是它会从根本上破坏React的结构所以建议不要使用他。</p>\n<p><code>getChildContext</code>&nbsp;在state或props变更时会被调用。为了更新context中的数据可以使用&nbsp;<code>this.setState</code>方法来触发变更，触发之后context的更新会被子组件接收到。\n</p>\n<pre class="scala"><code class="language-javascript"><span class="code-keyword">const</span> <span class="code-type">PropTypes</span> = <span\n        class="code-built_in">require</span>(<span class="code-string"><span\n        class="hljs-symbol">\'prop</span>-types\'</span>);\n\n<span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span\n        class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">MediaQuery</span></span></span><span\n        class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  <span class="code-keyword">constructor</span>(props) {\n    <span class="code-keyword"><span class="code-keyword">super</span></span>(props);\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.state = {<span class="hljs-class"><span\n            class="code-keyword">type</span></span>:<span class="code-string"><span class="hljs-symbol">\'deskto</span>p\'</span>};\n  }\n\n  getChildContext() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> {<span class="hljs-class"><span\n            class="code-keyword">type</span></span>: <span class="code-keyword"><span\n            class="code-keyword">this</span></span>.state.<span class="code-keyword">type</span>};\n  }\n\n  componentDidMount() {\n    <span class="code-keyword">const</span> checkMediaQuery = () =&gt; {\n      <span class="code-keyword">const</span> <span class="hljs-class"><span\n            class="code-keyword">type</span> </span>= <span class="code-built_in">window</span>.matchMedia(<span\n            class="code-string"><span class="code-string">"(min-width: 1025px)"</span></span>).matches ? <span\n            class="code-string"><span class="hljs-symbol">\'deskto</span>p\'</span> : <span class="code-string"><span\n            class="hljs-symbol">\'mobil</span>e\'</span>;\n      <span class="code-keyword"><span class="code-keyword">if</span></span> (<span class="hljs-class"><span\n            class="code-keyword">type</span> <span class="code-title">!==</span> </span><span class="code-keyword"><span\n            class="hljs-class"><span class="code-title">this</span></span></span><span class="hljs-class">.<span\n            class="code-title">state</span>.<span class="code-title">type</span>) </span>{\n        <span class="code-keyword"><span class="code-keyword">this</span></span>.setState({<span\n            class="hljs-class"><span class="code-keyword">type</span>})</span>;\n      }\n    };\n\n    <span class="code-built_in">window</span>.addEventListener(<span class="code-string"><span class="hljs-symbol">\'resiz</span>e\'</span>, checkMediaQuery);\n    checkMediaQuery();\n  }\n\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="code-keyword"><span\n            class="code-keyword">this</span></span>.props.children;\n  }\n}\n<span class="code-type">MediaQuery</span>.childContextTypes = {\n  <span class="hljs-class"><span class="code-keyword">type</span></span>: <span class="code-type">PropTypes</span>.string\n};</code></pre>\n<p>这里的问题在于，如果一个context在组件变更时才产生，接下来如果中间某个组件的&nbsp;<code>shouldComponentUpdate</code>方法返回fasle值，那么后续组件无法从context中得到任何值。所以，如果使用context来维护管理状态，那么就需要从全局去控制组件，这和React单向数据流和组件化的思路有些背道而驰。而且随着应用的扩展以及人员的更变，全局管理状态会越来越难。如果你还想了解更多关于context的问题，可以阅读这篇博客文章——“<a\n        href="https://medium.com/@mweststrate/how-to-safely-use-react-context-b7e343eff076" rel="nofollow">How To Safely\n    Use React Context</a>"（翻墙），里面讨论了如果绕开这些问题。</p>'},372:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h3 id="h3-1">非受控组件（Uncontrolled Components）</h3>\n<h4 id="h4-1">使用非受控组件</h4>\n<p>在大部分情况下，推荐使用 <a title="受控组件" href="https://www.chkui.com/article/react/react_list_key_and_form#h1-2">受控组件</a> 来实现表单、输入框等状态控制。在受控组件中，表单等数据都有React组件自己处理。这里将介绍另外一种非受控组件，表单的数据有Dom自己控制。</p>\n<p>非受控组件实现的重点是用Refs特性获取真实Dom来代替每次数据变更去更新组件的状态值。</p>\n<p>例如下面的代码，在非受控组件中记录被用户输入的名字：</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">NameForm</span></span></span><span class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span class="hljs-class"><span class="code-title">Component</span></span></span><span class="hljs-class"> </span></span>{\n  <span class="code-keyword">constructor</span>(props) {\n    <span class="code-keyword"><span class="code-keyword">super</span></span>(props);\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.handleSubmit = <span class="code-keyword"><span class="code-keyword">this</span></span>.handleSubmit.bind(<span class="code-keyword"><span class="code-keyword">this</span></span>);\n  }\n\n  handleSubmit(event) {\n    <span class="code-comment"><span class="code-comment">//在提交时，直接使用ref获取的真实Dom获取值</span></span>\n    alert(<span class="code-string"><span class="hljs-symbol">\'A</span> name was submitted: \'</span> + <span class="code-keyword"><span class="code-keyword">this</span></span>.input.value);\n    event.preventDefault();\n  }\n\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> (\n      &lt;form onSubmit={<span class="code-keyword">this</span>.handleSubmit}&gt;\n        &lt;label&gt;\n          <span class="code-type">Name</span>:\n          &lt;input <span class="hljs-class"><span class="code-keyword">type</span></span>=<span class="code-string">"text"</span> ref={(input) =&gt; <span class="code-keyword">this</span>.input = input} /&gt;\n        &lt;/label&gt;\n        &lt;input <span class="hljs-class"><span class="code-keyword">type</span></span>=<span class="code-string">"submit"</span> value=<span class="code-string">"Submit"</span> /&gt;\n      &lt;/form&gt;\n    );\n  }\n}</code></pre>\n<p><a title="代码测试" href="https://codepen.io/gaearon/pen/WooRWa?editors=0010" rel="nofollow">尝试代码</a>。</p>\n<p>由于在非受控组件中使用Refs特性获取了真实Dom的实例，所以在使用非受控组建时，更容易集成React和非React代码，在某些时候也可以省略一些代码。但是建议除了特殊情况，都使用受控组件。</p>\n<p>如果想要深入理解什么情况下使用哪种组件，建议阅读 <a title="受控组件与非受控组件的差异" href="https://goshakkk.name/controlled-vs-uncontrolled-inputs-react/" rel="nofollow">受控和不受控表单输入</a> 一文。</p>\n<h4 id="h4-2">组件默认值</h4>\n<p>在React渲染的生命周期，表单中的value属性会被覆盖Dom中的value值。在使用非受控组件时，通常需要React设定一个默认初始值但是不再控制后续更新。基于这个案例，你可以指定一个<code>defaultValue</code>&nbsp;属性来代替&nbsp;<code>value</code>。</p>\n<pre class="xml"><code class="language-javascript">render() {\n  <span class="code-keyword">return</span> (\n    <span class="code-tag">&lt;<span class="code-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="code-string">{this.handleSubmit}</span>&gt;</span>\n      <span class="code-tag">&lt;<span class="code-name">label</span>&gt;</span>\n        Name:\n        <span class="code-tag">&lt;<span class="code-name">input</span>\n          <span class="hljs-attr">defaultValue</span>=<span class="code-string">"Bob"</span>\n          <span class="hljs-attr">type</span>=<span class="code-string">"text"</span>\n          <span class="hljs-attr">ref</span>=<span class="code-string">{(input)</span> =&gt;</span> this.input = input} /&gt;\n      <span class="code-tag">&lt;/<span class="code-name">label</span>&gt;</span>\n      <span class="code-tag">&lt;<span class="code-name">input</span> <span class="hljs-attr">type</span>=<span class="code-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="code-string">"Submit"</span> /&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">form</span>&gt;</span>\n  );\n}</code></pre>\n<p>例如中“defaultValue = "Bob"”就是指定了一个默认值。同样地，&nbsp;<code>&lt;input type="checkbox"&gt;</code>&nbsp;和&nbsp;<code>&lt;input type="radio"&gt;</code>&nbsp;支持&nbsp;<code>defaultChecked</code>属性，&nbsp;<code>&lt;select&gt;</code>&nbsp;标签支持&nbsp;<code>defaultValue</code>属性。</p>'},393:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h3 id="h3-1">初始化Spring-boot</h3>\n\n<h4 id="h4-1">最佳的文档结构。</h4>\n<pre><code class="ruby">com\n +- example\n     +- myproject\n         +- Application.java\n         <span class="hljs-params">|\n         +- domain\n         |</span>   +- Customer.java\n         <span class="hljs-params">|   +- CustomerRepository.java\n         |</span>\n         +- service\n         <span class="hljs-params">|   +- CustomerService.java\n         |</span>\n         +- web\n             +- CustomerController.java</code></pre>\n<p>spring-boot还是建议按照标准的controller-service-dao结构分层。有一个独立的Application.java作为系统启动入口。</p>\n\n<h4 id="h4-2">引入</h4>\n<p>这里仅仅以Maven为例：</p>\n<pre><code class="xml"><span class="php"><span class="code-meta">&lt;?</span>xml version=<span\n        class="code-string">"1.0"</span> encoding=<span class="code-string">"UTF-8"</span><span\n        class="code-meta">?&gt;</span></span>\n<span class="code-tag">&lt;<span class="code-name">project</span> <span class="hljs-attr">xmlns</span>=<span\n        class="code-string">"http://maven.apache.org/POM/4.0.0"</span> <span class="hljs-attr">xmlns:xsi</span>=<span\n        class="code-string">"http://www.w3.org/2001/XMLSchema-instance"</span>\n    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="code-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">modelVersion</span>&gt;</span>4.0.0<span\n            class="code-tag">&lt;/<span class="code-name">modelVersion</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">groupId</span>&gt;</span>org.springframework<span\n            class="code-tag">&lt;/<span class="code-name">groupId</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">artifactId</span>&gt;</span>gs-spring-boot-demo<span\n            class="code-tag">&lt;/<span class="code-name">artifactId</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">version</span>&gt;</span>0.1.0<span class="code-tag">&lt;/<span\n            class="code-name">version</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">dependencies</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">dependency</span>&gt;</span>\n            <span class="code-tag">&lt;<span class="code-name">groupId</span>&gt;</span>org.springframework.boot<span\n            class="code-tag">&lt;/<span class="code-name">groupId</span>&gt;</span>\n            <span class="code-tag">&lt;<span class="code-name">artifactId</span>&gt;</span>spring-boot-starter-web<span\n            class="code-tag">&lt;/<span class="code-name">artifactId</span>&gt;</span>\n\t    \t<span class="code-tag">&lt;<span class="code-name">version</span>&gt;</span>1.5.9.RELEASE<span\n            class="code-tag">&lt;/<span class="code-name">version</span>&gt;</span>\n        <span class="code-tag">&lt;/<span class="code-name">dependency</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">dependencies</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">properties</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">java.version</span>&gt;</span>1.8<span class="code-tag">&lt;/<span\n            class="code-name">java.version</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">properties</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">project</span>&gt;</span></code></pre>\n<p>引入了&nbsp;spring-boot-starter-web，基本上开发一个web应用所需的包都会引入其中。如果需要使用JPA等等功能需要另外引入对应的<strong><em>starter</em></strong>。spring-boot用pom的方式整合了许多开箱即用的工具，官方称之为<em><strong>starter</strong></em>特性，后面会介绍什么是<em><strong>starter。</strong></em>\n</p>\n\n<h4 id="h4-3">启动</h4>\n<p>Spring boot提供了多种启动方式，最简单的方式是在main方法中调用&nbsp;SpringApplication.run 方法即可启动Spring Boot。当然，run方法必须要配合相关的注解才能实现Spring\n    Boot目标功能。关于spring boot打包以及<strong><em>jara -jar</em></strong>或者<em><strong>CLI</strong></em>启动，后续的博文会介绍。</p>\n\n<h4 id="h4-4">DEBUG模式</h4>\n<p>通常情况下，启动Spting Boot时日志输出都是生产模式（关闭DEBUG级别的日志），在启动参数中增加--debug参数即可开启调试模式的日志输出。</p>\n<p>Eclipse的设置：工程右键-&gt;Debug As-&gt;Debug Configurations-&gt;打开Arguments选项-&gt;在Program arguments中增加 --debug 参数。</p>\n<p><img height="429" src="https://file.mahoooo.com/res/file/spring_boot_features_get_started_1.png" width="879"\n        alt="Spring Boot特性入门篇"></p>\n\n<h4 id="h4-5">纯Java配置——@Configuration</h4>\n<p>\n    <em>@Configuration</em>是一个用于类的注解，他可以替换原来定义在<em>xml</em>文件中的<em>spring</em>配置。当为某一个类增加这个注解后，会将其视作一个源自配置文件的<em>Bean</em>。<br>\n    其实<em>spring</em>的<em>ioc</em>容器一直以来都没多大变化，延续基于单例的<em>IOC</em>的机制一直向下衍生功能线，不管使用什么注解，基本上所有用到的实例都是一个<em>Bean</em>，所有的<em>Bean</em>都放在同一个的<em>IOC</em>容器中（当然也可以创建多个容器，但是似乎并没什么应用需要这么特殊的实现）。<em>Spring\n    Xml</em>配置是根据<em>xml</em>的描述生成多个<em>Bean</em>，而引入<em>@Configuration</em>注解使得配置可以彻底基于<em>Java</em>代码。</p>\n\n<h4 id="h4-6">自动配置注入——@EnableAutoConfiguration&nbsp;</h4>\n<p>这个注解用于在<em>Spring</em>的<em>IOC</em>容器中启用自动推导配置功能（使用boot中定义的默认配置）。其执行过程实际就是根据<em>classpath</em>中的包来决定是否需要注入某个用于资源配置的Bean来支持其工作。比如在<em>classpath</em>中发现了<code>tomcat-embedded.jar</code>&nbsp;这个包，那么可以推定需要启用tomcat的嵌入工具，那么boot会帮助我们创建一个&nbsp;<a\n        href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/api/org/springframework/boot/context/embedded/tomcat/TomcatEmbeddedServletContainerFactory.html"\n        rel="nofollow"><code>TomcatEmbeddedServletContainerFactory</code></a>&nbsp;的实例作为Bean放置到容器中以供其使用。我们可以通过注解的&nbsp;&nbsp;<a\n        href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/api/org/springframework/boot/autoconfigure/EnableAutoConfiguration.html#exclude--"\n        rel="nofollow"><code>exclude()</code></a>&nbsp;和&nbsp;<a\n        href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/api/org/springframework/boot/autoconfigure/EnableAutoConfiguration.html#excludeName--"\n        rel="nofollow"><code>excludeName()</code></a>&nbsp;方法告知不需要自动生成某些配置。也可以通过声明&nbsp;&nbsp;<code>spring.autoconfigure.exclude</code>&nbsp;JVM参数。&nbsp;\n</p>\n<p>\n    实质上Spring-Boot-Web就是一个更加自动化的Spring-Webmvc——不用整合servlet容器并且分分钟启动。而Spring-Boot最大的亮点之一就是根据引入的包自动注入配置。如果打开--debug模式会看到很多匹配相关的内容输出。下面是自动匹配输出的一些内容，为了便于说明只选取了很小一部分，实际输出的内容比这个多得多。</p>\n<pre><code class="ruby">=========================\nAUTO-CONFIGURATION REPORT\n=========================\n\nPositive <span class="hljs-symbol">matches:</span>\n-----------------\n\n   DispatcherServletAutoConfiguration <span class="hljs-symbol">matched:</span>\n      - @ConditionalOnClass found required <span class="hljs-class"><span class="code-keyword">class</span> \'<span\n            class="code-title">org</span>.<span class="code-title">springframework</span>.<span\n            class="code-title">web</span>.<span class="code-title">servlet</span>.<span class="code-title">DispatcherServlet</span>\';</span> @ConditionalOnMissingClass did <span\n            class="code-keyword">not</span> find unwanted <span class="hljs-class"><span\n            class="code-keyword">class</span> (<span class="code-title">OnClassCondition</span>)</span>\n      - @ConditionalOnWebApplication (required) found StandardServletEnvironment (OnWebApplicationCondition)\n\n   DispatcherServletAutoConfiguration.DispatcherServletConfiguration <span class="hljs-symbol">matched:</span>\n      - @ConditionalOnClass found required <span class="hljs-class"><span class="code-keyword">class</span> \'<span\n            class="code-title">javax</span>.<span class="code-title">servlet</span>.<span class="code-title">ServletRegistration</span>\';</span> @ConditionalOnMissingClass did <span\n            class="code-keyword">not</span> find unwanted <span class="hljs-class"><span\n            class="code-keyword">class</span> (<span class="code-title">OnClassCondition</span>)</span>\n      - Default DispatcherServlet did <span class="code-keyword">not</span> find dispatcher servlet beans (DispatcherServletAutoConfiguration.DefaultDispatcherServletCondition)\n\n\nNegative <span class="hljs-symbol">matches:</span>\n-----------------\n\n   <span class="hljs-symbol">ActiveMQAutoConfiguration:</span>\n      Did <span class="code-keyword">not</span> <span class="hljs-symbol">match:</span>\n         - @ConditionalOnClass did <span class="code-keyword">not</span> find required classes <span\n            class="code-string">\'javax.jms.ConnectionFactory\'</span>, <span class="code-string">\'org.apache.activemq.ActiveMQConnectionFactory\'</span> (OnClassCondition)\n\n</code></pre>\n<p>从<em>AUTO-CONFIGURATION REPORT </em>开始就是匹配日志，<em>Positive matche</em>&nbsp;之后的表示匹配上的配置，<em>Negative matches</em>之后表示未匹配上的配置。每一项的内容都详细说明了匹配上的依赖关系和未匹配的原因。\n</p>\n\n<h4 id="h4-7">包扫描——@ComponentScan</h4>\n<p>\n    <em>@ComponentScan</em>注解用于设定<em>IOC</em>容器加载<em>Bean</em>的扫描路径，等价于<em>xml</em>配置中的<em>&lt;context:component-scan&gt;</em>元素（<em>@ComponentScan</em>属于<em>Spring\n    Framework的Context</em>模块）。在指定的路径中会将<em>@Component</em>及其子类限定的类（如<em>@Service</em>、<em>@Repository</em>、<em>@Controller</em>）作为一个<em>Bean</em>添加到<em>IOC</em>容器中。\n</p>\n<p><em>@ComponentScan</em>中包含多个参数，例如<em>basePackages</em>、<em>basePackageClasses</em>、<em>excludeFilters</em>等，都是用于定义扫描的包路径或限定名。如果没有为@ComponentScan注解设定任何参数，则会扫描当前包以及所有子孙包。\n</p>\n\n<h4 id="h4-8">Spring-boot整合——@SpringBootApplication</h4>\n<p><em>@SpringBootApplication</em>注解整合了<em>@Configuration</em>、<em>@EnableAutoConfiguration</em>、<em>@ComponentScan</em>的效果。当为一个入口类（包含启动的main方法）定义一个@SpringBootApplication注解后，意味着增加了上述三个注解的功能——1）当前类是一个资源Bean，2）启用spring\n    boot的自动推导配置（开箱即用）、3）自动扫描入口类之后的所有子包。</p>\n<p>所以下面2种写法实现的效果是几乎一致的（在<em>@SpringBootApplication</em>中对<em>@ComponentScan</em>做了参数限定，所以只能说几乎一致。）：</p>\n<pre><code class="java"><span class="code-meta">@EnableAutoConfiguration</span>\n<span class="code-meta">@ComponentScan</span>\n<span class="code-meta">@Configuration</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Demo</span></span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> <span\n            class="code-keyword">throws</span> Exception </span>{\n        SpringApplication.run(Demo.class, args);\n    }\n}</code></pre>\n<pre><code class="java"><span class="code-meta">@SpringBootApplication</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Demo</span></span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> <span\n            class="code-keyword">throws</span> Exception </span>{\n        SpringApplication.run(Demo.class, args);\n    }\n}</code></pre>\n\n<h4 id="h4-9">开箱即用——Starter</h4>\n<p>Spring Boot通过Maven的方式提供了一系列开箱即用（一站式服务）的工具，包括MQ、AOP、JPA等，文档上将这个特性命名为<em><strong>Starter。</strong></em>前面 <em><strong>引入</strong></em>\n    部分使用的&nbsp;<em>spring-boot-starter-web </em>就是一个<em><strong>Starter</strong></em>&nbsp;。<strong><em>Starter </em></strong>特性并没有什么新的技术，仅仅是通过pom文件的方式引用了一些必要的包，然后在引入之后通过<em>Spring\n        Boot</em>的自动推导配置为引入的<em>jar包</em>注入必要的配置Bean。<a\n            href="https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-build-systems.html#using-boot-starter"\n            rel="nofollow">官网的表13.1</a> 列举了所有<em>Sprint Boot</em>官方提供的<em><strong>Starter</strong></em>。</p>\n<p>当然除了官方提供的<strong><em>Starter</em></strong>我们还可以自定义。不过需要注意的是命名规则——由官方提供的<strong><em>Starter</em></strong>命名规则为<em>spring-boot-starter-*</em>，而自定义（第三方提供）的规则为<em>&nbsp;acme-spring-boot-starter-*。自定义的<strong>Starter</strong>在某些使用需要额外指定自动配置功能，详情请看\n    <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-auto-configuration.html#boot-features-custom-starter"\n       rel="nofollow">关于自定义Starter的说明</a>。</em></p>\n\n<h4 id="h4-10">逐渐替换默认配置</h4>\n<p>这也是<em>Spring Boot</em>的最佳实践之一。虽然它提供了相当丰富的默认配置，但是并不是所有的东西用默认配置就可以解决。Spring Boot建议根据需要逐渐替换工程所需的配置。例如默认情况下工程引入了 <a\n        href="http://hsqldb.org/" rel="nofollow">HSQLDB</a>&nbsp;，并且没有配置<strong><em>DataSource</em></strong>，那么我们所有的数据库操作（例如<em>JPA</em>）都会直接使用<a\n        href="http://hsqldb.org/" rel="nofollow">HSQLDB</a>内存数据库。如果我们向<em>容器</em>注入了<strong><em>DataSource</em></strong>实例，那么我们定义的配置将会替换默认配置。\n</p>\n\n<h3 id="h3-2">开发Spring-boot</h3>\n\n<h4 id="h4-11">全局定义开发环境——spring-boot-devtools</h4>\n<p><em>spring-boot-devtools</em>（以下简称<em>Devtools</em>）为开发环境提供了许多快速便捷的设置，仅需要增加一个依赖即可实现开发所需的配置，以<em>Maven</em>为例：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">dependencies</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">dependency</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">groupId</span>&gt;</span>org.springframework.boot<span\n            class="code-tag">&lt;/<span class="code-name">groupId</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">artifactId</span>&gt;</span>spring-boot-devtools<span\n            class="code-tag">&lt;/<span class="code-name">artifactId</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">optional</span>&gt;</span>true<span\n            class="code-tag">&lt;/<span class="code-name">optional</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">dependency</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">dependencies</span>&gt;</span></code></pre>\n<p>在引入他之后当前环境自动变为开发环境。需要注意的是如果运行完整打包的工程<em>Spring Boot</em>不启用任何<em>Devtools</em>相关的功能（实际上打包工具<em>spring-boot-maven-plugin</em>默认情况下不会去打包<em>Devtools</em>），为了防止<em>Devtools</em>的作用域污染子项目，我们最好增加\n    <em>Maven </em>的 <em>optional</em> 标记。</p>\n<p>下面介绍<em>Devtools</em>具体提供了什么功能。</p>\n<p><strong>1.代码修改与热部署</strong></p>\n<p><em>Devtools&nbsp;</em>的一项功能就是能够监控代码的变更，并在发现变更时“热部署”最新的代码。不过这里的热部署不是Jvm bytecode级别的热部属，也和OGSI没任何关系。</p>\n<p>根据官方的介绍是实现了两个ClassLoader——BaseClassLoader和RestartClassLoader（推断这2个ClassLoader应该破坏了双亲委派模型）。第一次启动<em>JVM</em>时所有的<em>.class</em>文件和<em>.jar</em>文件中的类都用<em>BaseClassLoader</em>加载，然后在开发的过程中凡是变更过的<em>.class</em>\n    文件都会被标记，这些被标记的<em>.class</em>之后都会使用<em>RestartClassLoader</em>加载。在初始化一个类时，被标记了用RestartClassLoader加载的Class&lt;?&gt;实例，没有被标则委派给BaseClassLoader加载，每次发起“热部署”时都会新建一个RestartClassLoader重新加载类，这样可以保证变更过的代码都是重新加载的。\n</p>\n<p>在<em>Devtools</em>进行“热部署”时会调用<a href="https://www.concretepage.com/spring/registershutdownhook_spring"\n                                   rel="nofollow">spring的上下文挂钩（spring context hook）</a>来重新部署IOC容器。如果你关闭了它——<span\n        style="color:#FF0000"><em>SpringApplication.setRegisterShutdownHook(false)</em></span>，“热部署”无法将新加载的类实例部署到<em>IOC</em>容器中导致代码替换失败。\n</p>\n<p><img height="385" src="https://file.mahoooo.com/res/file/spring_boot_features_get_started_2.png" width="807"\n        alt="Spring Boot特性入门篇"></p>\n<p>上面是开发过程中Jconsole的输出，每一次修改代码保存都会新增一些非堆（方法区）的空间，这说明重新加载了新的字节码数据并解析到非堆中。</p>\n<p><em>jvm</em>环境中classPath路径下的任何文件修改都会触发<em>Devtools&nbsp;</em>的热部署，某些时候并不需要都监控所有的路径，例如/resources、/static、/template等，我们可以通过设定<em>spring.devtools.restart.exclude</em>属性来排除热部署监控的位置。例如：\n</p>\n<pre><code class="javascript">spring.devtools.restart.exclude=<span class="code-keyword">static</span><span\n        class="code-comment">/**</span></code></pre>\n<p>此外，使用“热部署”时还需注意以下几点（个个都有可能是引发问题的坑啊）：</p>\n<ol>\n    <li>属性<em>spring.devtools.restart.additional-paths</em>属性可以用来增加监控<em>classpath</em>之外的路径。</li>\n    <li><em>Devtools</em>内嵌了<a href="http://livereload.com/extensions/" rel="nofollow">LiveReload</a>，如果不想启用它可以将<em>spring.devtools.livereload.enabled</em>属性设置为<em>fasles</em>。\n    </li>\n    <li><em>Devtools</em>会自动忽略某些包的扫描，例如<em>spring-boot、spring-boot-devtools、spring-boot-autoconfigure、spring-boot-actuator、spring-boot-starter</em>。\n    </li>\n    <li><em>Devtools</em>会修改<em>SpringContext</em>指定的<em>ResourceLoader</em>，如果自定义了一个新的<em>ResourceLoader</em>，修改后的<em>getResource</em>方法将无法生效。\n    </li>\n    <li>将<em>spring.devtools.restart.enabled</em>属性设置为<em>false</em>可以关闭<em>Devtools</em>的“热部署”功能。</li>\n    <li>\n        某些<em>IDE</em>整合了代码监控功能，可以通过<em>spring.devtools.restart.trigger-file</em>属性指定要监控的文件，只有这个文件发生变更时才会触发<em>Devtools</em>进行全局的文件变更检查。\n    </li>\n    <li>前面介绍了<em>Devtools</em>的“热部署”是通过2个<em>ClassLoader</em>（<em>BaseClassLoader、RestartClassLoader</em>）实现的，默认情况下<em>.jar</em>包中的类只会使用<em>BaseClassLoader</em>加载。我们可以通过在根目录新建一个<em>META-INF/spring-devtools.properties</em>文件，然后在其中设置restart.exclude.\n        和&nbsp;restart.include. 属性来指定被&nbsp;RestartClassLoader 加载的 .jar 类。详情见<a\n                href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#using-boot-devtools-customizing-classload"\n                rel="nofollow">官网例子</a>。\n    </li>\n</ol>\n<p><strong>2.缓存启用和停用</strong></p>\n<p>很多框架、工具都提供了缓存功能，在生产环境中对某些热数据进行适当的缓存能够有效的提高性能。但是在开发环境这些缓存反而会影响我们验证功能。所以<em>Devtools</em>全局提供了缓存管理，并默认关闭大部分工具或框架的缓存。开发人员可用通过设置运行环境properties的方式来指定缓存功能，例如：\n</p>\n<pre><code class="java">System.setProperty(<span class="code-string">"spring.thymeleaf.cache"</span>, <span\n        class="code-string">"true"</span>);</code></pre>\n<p>就可以指定启用thymeleaf模板引擎的缓存。缓存管理相关的配置请看 <a\n        href="https://github.com/spring-projects/spring-boot/blob/v1.5.9.RELEASE/spring-boot-devtools/src/main/java/org/springframework/boot/devtools/env/DevToolsPropertyDefaultsPostProcessor.java"\n        rel="nofollow">github上spring-<em>boot-devtools环境设置</em>相关的代码</a> 。</p>\n<p><strong>3.文件配置</strong></p>\n<p>除了使用参数，我们可以把<em>Devtools</em>的所有配置写到<em>$HOME</em>目录下一个"<em>.spring-boot-devtools.properties</em>"的文件中。例如：</p>\n<pre>spring.devtools.reload.trigger-file=.reloadtrigger</pre>\n<p><strong>4.远程开发</strong></p>\n<p>Devtools除了提供本机开发的增强功能之外，还增加了强大的远程开发与调试功能。</p>\n<p>首先，<a href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#using-boot-devtools-remote"\n         rel="nofollow">我们需要在打包的时候连同spring-boot-devtools一起打包并发布</a>，而<em>spring-boot-maven-plugin</em>默认不是打包<em>Devtools</em>的，所以我们需要将<em>Pom</em>文件的<em>plugins</em>配置简单修改一下：\n</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">build</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">plugins</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">plugin</span>&gt;</span>\n            <span class="code-tag">&lt;<span class="code-name">groupId</span>&gt;</span>org.springframework.boot<span\n            class="code-tag">&lt;/<span class="code-name">groupId</span>&gt;</span>\n            <span class="code-tag">&lt;<span class="code-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span\n            class="code-tag">&lt;/<span class="code-name">artifactId</span>&gt;</span>\n            <span class="code-tag">&lt;<span class="code-name">configuration</span>&gt;</span>\n                <span class="code-tag">&lt;<span class="code-name">excludeDevtools</span>&gt;</span>false<span\n            class="code-tag">&lt;/<span class="code-name">excludeDevtools</span>&gt;</span>\n            <span class="code-tag">&lt;/<span class="code-name">configuration</span>&gt;</span>\n        <span class="code-tag">&lt;/<span class="code-name">plugin</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">plugins</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">build</span>&gt;</span></code></pre>\n<p>发布之前需要设置一个属性：</p>\n<pre>spring.devtools.remote.secret=mysecret</pre>\n<p><span style="color:#FF0000">&nbsp;特别需要注意：这个属性会带来安全风险，所以仅仅用于测试和开发，切记不要用于生产运行。</span></p>\n<p>将打好的包部署到远程服务器即可，我们称之为服务端。</p>\n<p>然后，<a\n        href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#_running_the_remote_client_application"\n        rel="nofollow">要在本地开发环境配置一个客户端</a>。</p>\n<p>客户端需要配合IDE一起使用。假设你的工程名字为<em>my-app</em>在Eclipse下进行下面的配置：</p>\n<ol>\n    <li><em><strong>Run</strong></em> 菜单栏目里选择<em><strong>Run Configurations...</strong></em>。</li>\n    <li>创建一个新的&nbsp;<em><strong>Java Application</strong></em>（在<em><strong>Java\n        Application</strong></em>处右键，然后选择<em><strong>new</strong></em>）。\n    </li>\n    <li><strong><em>Project</em></strong>一栏里选择<em>my-app</em>工程。</li>\n    <li><strong><em>Main\n        Class</em></strong>一栏里使用<em>org.springframework.boot.devtools.RemoteSpringApplication</em>作为<em>main</em>方法类。\n    </li>\n    <li><em><strong>Arguments</strong></em>选项卡中，在<strong><em>Program arguments</em></strong>中添加服务端的地址（类似https://myapp.cfapps.io的格式）\n    </li>\n</ol>\n<p>最后，启用了<em>spring.devtools.remote.secret</em>之后，客户端会监控本地classpath下文件变更。一旦触发“热部署”它会先在本地完成，然后将变更的内容推送到远程服务端触发“热部署”。就像你在本地开发一样，这对开发一些回调应用和不同环境的调试带来了极大的便利。\n</p>\n<p>还有，<em>Devtools</em>在基于<em>jdwp</em>远程调式的基础上进行了扩展，提供支持<em>HTTP</em>传输远程调试信息。绝大部分情况下都能使用<em>Java</em>的远程调试能解问题，如有特殊需求（如用到<em>docker</em>等），可以看\n    <a href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#using-boot-devtools-remote-debugtunnel"\n       rel="nofollow">这里</a>。</p>'}});