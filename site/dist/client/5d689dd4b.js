webpackJsonp([5],{392:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<p>在<a href="https://www.chkui.com/article/java/java_bean_validation" title="Java数据校验详解">Java数据校验详解</a>中详细介绍了Java数据校验相关的功能（简称<em>Bean\n    Validation，</em>涵盖<em>JSR-303、JSR-349、JSR-380</em>）,本文将在<em>Bean Validation</em>的基础上介绍Spring框架提供的数据校验功能。</p>\n<p>Spring提供的数据校验功能分为2个部分，一个是Spring自定义的数据校验功能（以下称为<em>Spring Validation</em>），一个是符合<em>Bean Validation</em>规范的数据校验功能。</p>\n\n<h2 id="h2-1">Spring Validation数据校验</h2>\n<p>Spring的自行开发的数据校验功能由3个部分组成：</p>\n<ol>\n    <li>校验器——Validator，他会运行校验代码。</li>\n    <li>校验对象，实际上就是一个JavaBean，Validator会对其进行校验。</li>\n    <li>校验结果——Errors，一次校验的结果都存放在Errors实例中。</li>\n</ol>\n<p>这是Spring在<em>Bean Validation</em>规范制定之前就实现的数据校验功能，ValidationUtils的注释中@since标签是2003年5月6号，而JSR-303定稿时间已经是6年之后（2009年）的事了。\n</p>\n<p>（文中仅为示例代码，可执行代码请到本人<a href="https://gitee.com/chkui-com/spring-core-sample" rel="nofollow">gitee库获取</a>，本文代码在<em>chkui.springcore.example.hybrid.springvalidation</em>包中。）\n</p>\n<p>Spring的数据校验功能就是实现检验器、校验对象、校验结果三个对象。先声明个一个校验对象（实体）：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.springvalidation.entity;\n<span class="code-comment">//车辆信息</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Vehicle</span> </span>{\n\t<span class="code-keyword">private</span> String name;\n\t<span class="code-keyword">private</span> String type;\n\t<span class="code-keyword">private</span> String engine;\n\t<span class="code-keyword">private</span> String manufacturer;\n\t<span class="code-keyword">private</span> Calendar productionDate; \n\n    <span class="code-comment">/**Getter Setter*/</span>\n}</code></pre>\n<p>然后针对这个实体声明一个校验器。校验器要实现<em>org.springframework.validation.Validator</em>接口：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.springvalidation.validator;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">VehicleValidator</span> <span class="code-keyword">implements</span> <span\n            class="code-title">Validator</span> </span>{\n\t<span class="code-keyword">private</span> List&lt;String&gt; _TYPE = Arrays.asList(<span\n            class="code-keyword">new</span> String[] { <span class="code-string">"CAR"</span>, <span\n            class="code-string">"SUV"</span>, <span class="code-string">"MPV"</span> });\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">boolean</span> <span\n            class="code-title">supports</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> </span>{\n        <span class="code-comment">//将验证器和实体类进行绑定，如果这里返回false在验证过程中会抛出类型不匹配的异常</span>\n\t\t<span class="code-keyword">return</span> Vehicle.class.isAssignableFrom(clazz);\n\t}\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">validate</span><span\n            class="hljs-params">(Object target, Errors errors)</span> </span>{ <span class="code-comment">//验证数据</span>\n\t\tVehicle vehicle = Vehicle.class.cast(target);\n\t\t<span class="code-keyword">if</span> (<span class="code-keyword">null</span> == vehicle.getName()) {\n            <span class="code-comment">//使用验证工具绑定结果</span>\n\t\t\tValidationUtils.rejectIfEmpty(errors, <span class="code-string">"name"</span>, <span class="code-string">"name.empty"</span>, <span\n            class="code-string">"车辆名称为空"</span>);\n\t\t}\n\t\t<span class="code-keyword">if</span> (!_TYPE.contains(vehicle.getType())) {\n            <span class="code-comment">//向Error添加验证错误信息</span>\n\t\t\t&lt;<span class="hljs-number">2</span>&gt; errors.rejectValue(<span class="code-string">"type"</span>, <span\n            class="code-string">"type.error"</span>, <span class="code-string">"汽车类型必须是"</span> + _TYPE);\n\t\t}\n        <span class="code-comment">//More validate ......</span>\n\t}\n}</code></pre>\n<p>有了验证对象（JavaBean）和对应的验证器（Validator）就完成了一组验证功能。注意<em>VehicleValidator::validate</em>方法传递的errors参数，验证工具会将错误实例传递进来交给开发者去组装验证结果。\n</p>\n<p>代码中的ValidationUtils就是数据校验工具，他提供了2个功能：</p>\n<ol>\n    <li>执行校验（接下来会马上介绍）。</li>\n    <li>提供错误信息绑定的功能，例如<em>ValidationUtils.rejectIfEmpty</em>这一行代码。会将对应的信息写入到Errors中。</li>\n</ol>\n<p>有了验证对象和验证器就可以执行验证：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">SpringValidationApp</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">private</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">springValidation</span><span class="hljs-params">(ApplicationContext ctx)</span> </span>{\n\t\tVehicleValidator vehicleValidator = <span class="code-keyword">new</span> VehicleValidator();<span\n            class="code-comment">//创建验证器</span>\n\t\tVehicle vehicle = <span class="code-keyword">new</span> Vehicle();<span class="code-comment">//创建验证对象</span>\n\t\t&lt;<span class="hljs-number">1</span>&gt; ValidationError error = <span class="code-keyword">new</span> ValidationError(<span\n            class="code-string">"Vehicle"</span>);<span class="code-comment">//创建错误信息</span>\n\t\tValidationUtils.invokeValidator(vehicleValidator, vehicle, error);<span class="code-comment">//执行验证</span>\n\t\tList&lt;FieldError&gt; list = error.getFieldErrors();\n\t\t<span class="code-keyword">int</span> count = <span class="hljs-number">1</span>;\n        <span class="code-comment">//输出验证结果</span>\n\t\t<span class="code-keyword">for</span>(FieldError res : list) {\n\t\t\tprint(<span class="code-string">"Error Info "</span>, count++ , <span class="code-string">"."</span>);\n\t\t\tprint(<span class="code-string">"Entity:"</span>, res.getObjectName());\n\t\t\tprint(<span class="code-string">"Field:"</span>, res.getField());\n\t\t\tprint(<span class="code-string">"Code:"</span>, res.getCode());\n\t\t\tprint(<span class="code-string">"Message:"</span>, res.getDefaultMessage());\n\t\t\tprint(<span class="code-string">"-"</span>);\n\t\t}\n\t}\n}</code></pre>\n<p>执行完毕后，ValidationError中记录了所有校验错误信息。错误信息分为4个部分：</p>\n<ul>\n    <li>验证的对象的名称：在执行验证器的代码中&lt;1&gt;部分创建错误对象时指定。Vehicle就是验证对象的名称。</li>\n    <li>错误的域、错误code和错误信息：每一个错误都有对应的域、错误编码以及错误信息，在验证器&lt;2&gt;位置的代码就是指定错误信息。</li>\n</ul>\n<p>以上错误信息可以通过<em>error.getFieldErrors();</em>来获取。</p>\n<p>如果JavaBean有嵌套的结构，可以在校验器中调用其他的校验器来实现嵌套检验。先为Vehicle类增加一个Gearbox（变速箱）域：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.springvalidation.entity;\n<span class="code-comment">//车辆信息</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Vehicle</span> </span>{\n\t<span class="code-keyword">private</span> String name;\n\t<span class="code-keyword">private</span> String type;\n\t<span class="code-keyword">private</span> String engine;\n\t<span class="code-keyword">private</span> String manufacturer;\n    <span class="code-keyword">private</span> Gearbox gearbox; <span class="code-comment">//Gearbox是另外一个实例</span>\n\t<span class="code-keyword">private</span> Calendar productionDate; \n\n    <span class="code-comment">/**Getter Setter*/</span>\n}</code></pre>\n<pre><code class="java"><span class="code-comment">//变速箱</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Gearbox</span> </span>{\n\t<span class="code-keyword">private</span> String name;\n\t<span class="code-keyword">private</span> String manufacturer;\n\n    <span class="code-comment">/**Getter Setter*/</span>\n}</code></pre>\n<p>在校验器VehicleValidator::validate中增加对Gearbox验证：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">VehicleValidator</span> <span class="code-keyword">implements</span> <span\n        class="code-title">Validator</span> </span>{\n\t<span class="code-meta">@Autowired</span>\n\tGearboxValidator gearboxValidator; <span class="code-comment">//用于校验Gearbox的校验器</span>\n\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">validate</span><span class="hljs-params">(Object target, Errors errors)</span> </span>{\n\t\tVehicle vehicle = Vehicle.class.cast(target);\n\n\t\t<span class="code-comment">//some code ......</span>\n        \n\t\t}\n\t\t<span class="code-keyword">if</span>(<span class="code-keyword">null</span> == vehicle.getGearbox()) {\n\t\t\terrors.rejectValue(<span class="code-string">"gearbox"</span>, <span\n            class="code-string">"gearbox.error"</span>, <span class="code-string">"变速箱信息为空"</span>);\n\t\t}<span class="code-keyword">else</span> {\n            <span class="code-comment">//指定子实体的名称</span>\n\t\t\terrors.pushNestedPath(<span class="code-string">"gearbox"</span>);\n            <span class="code-comment">//执行对Gearbox的校验</span>\n            ValidationUtils.invokeValidator(gearboxValidator, vehicle.getGearbox(), errors);\n\t\t}\n\t}\n}</code></pre>\n\n<h2 id="h2-2"><em>Bean Validation</em>数据校验</h2>\n<p>Spring现在推荐使用<em>Bean Validation</em>来进行数据校验，而且已经整合到Spring MVC框架中。</p>\n<p>在Spring中使用<em>Bean Validation</em>和<a href="https://www.chkui.com/article/java/java_bean_validation" title="Java数据校验详解">Java数据校验详解</a>一文中介绍的内容差不多——也是注解和校验器组成一个约束，通过注解来控制校验的过程。\n</p>\n<p>Spring核心部分没有提供<em>Bean Validation相关的实现类，所以需要引入对应的实现框架。本文引入的是</em><a href="http://hibernate.org/validator/"\n                                                                       rel="nofollow">Hibernate Validator</a>，他包括验证器和el，详情可以看源码根目录的build.gradle文件。\n</p>\n<p>首先我们向IoC容器中添加全局校验器：</p>\n<pre><code class="java"><span class="code-meta">@Configuration</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">SpringValidationConfig</span> </span>{\n\n\t<span class="code-meta">@Bean</span>(<span class="code-string">"validator"</span>)\n\t<span class="hljs-function"><span class="code-keyword">public</span> Validator <span\n            class="code-title">validator</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> LocalValidatorFactoryBean();\n}</code></pre>\n<p>这一段添加Bean的代码非常简单，就是新建了一个<em>LocalValidatorFactoryBean</em>实例。LocalValidatorFactoryBean实现了javax.validation.Validator接口，并且会自动使用已经引入的<em>Bean\n    Validation</em>框架。</p>\n<p>然后向Vehicle增加<em>Bean Validation相关的</em>注解：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">Vehicle</span> </span>{\n\t<span class="code-meta">@NotBlank</span>\n\t<span class="code-keyword">private</span> String name;\n\t<span class="code-meta">@NotBlank</span>\n\t<span class="code-meta">@VehicleType</span>\n\t<span class="code-keyword">private</span> String type;\n\t<span class="code-meta">@NotBlank</span>\n\t<span class="code-keyword">private</span> String engine;\n\t<span class="code-meta">@NotBlank</span>\n\t<span class="code-keyword">private</span> String manufacturer;\n\t&lt;<span class="hljs-number">3</span>&gt; <span class="code-meta">@Valid</span> <span class="code-comment">//@Valid的作用是对嵌套的解构进行校验</span>\n\t<span class="code-keyword">private</span> Gearbox gearbox;\n\t<span class="code-meta">@Valid</span>\n\t<span class="code-keyword">private</span> Tyre tyre;\n\t<span class="code-meta">@VehicleProductionDate</span>\n\t<span class="code-keyword">private</span> Calendar productionDate;\n\n    <span class="code-comment">/**Getter Setter*/</span>\n\n}</code></pre>\n<p>在上面的代码中，除了常规的@NotBlank等注解，还有@VehicleType这个自定义注解。在代码&lt;3&gt;的位置<em><a href="https://my.oschina.net/u/3652407"\n                                                                         class="referer" target="_blank">@Valid</a></em>是告诉校验器还要对gearbox的实例进行校验，相当于前面介绍的嵌套校验功能。最后我们使用检验器来对<em>Vehicle</em>的实例进行校验：\n</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">SpringValidationApp</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(SpringValidationConfig.class);\n\t\tBeanValidation(ctx);<span class="code-comment">//JSR规范验证</span>\n\t}\n\n\t<span class="hljs-function"><span class="code-keyword">private</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">BeanValidation</span><span class="hljs-params">(ApplicationContext ctx)</span> </span>{\n\t\tValidator validator = ctx.getBean(Validator.class);<span class="code-comment">//获取校验器</span>\n\t\tVehicle vehicle = <span class="code-keyword">new</span> Vehicle();<span class="code-comment">//新建要校验的对象</span>\n\t\tvalidator.validate(vehicle).forEach(err -&gt; { <span class="code-comment">//执行校验</span>\n\t\t\tprint(<span class="code-string">"Field: "</span>, err.getPropertyPath());\n\t\t\tprint(<span class="code-string">"Error: "</span>, err.getMessage());\n\t\t});\n\t}\n}</code></pre>\n<p>关于<em>Bean Validation的详细使用方法已经在</em>&nbsp;<a href="https://www.chkui.com/article/java/java_bean_validation"\n\t\t\t\t\t\t\t\t\t\t\t\ttitle="Java数据校验详解">Java数据校验详解</a>介绍。</p>\n\n<h2 id="h2-3">兼容Bean Validation和Spring Validation</h2>\n<p>一些相对比较久远的项目可能会遇见在<em>Spring Validation</em>的基础上新增<em>Bean Validation</em>功能的情况。可以使用SpringValidatorAdapter适配器来解决这个问题：\n</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">SpringValidationApp</span> </span>{\n\n\t<span class="hljs-function"><span class="code-keyword">private</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">adapterValidation</span><span class="hljs-params">(ApplicationContext ctx)</span> </span>{\n\t\t<span class="code-comment">// 获取校验器</span>\n\t\t<span class="code-comment">// LocalValidatorFactoryBean继承了SpringValidatorAdapter</span>\n        <span class="code-comment">// 所以这里就是获取LocalValidatorFactoryBean</span>\n\t\tSpringValidatorAdapter adapter = ctx.getBean(SpringValidatorAdapter.class);\n\n\t\tVehicle vehicle = <span class="code-keyword">new</span> Vehicle();<span class="code-comment">// 检验对象</span>\n\t\tValidationError error = <span class="code-keyword">new</span> ValidationError(<span class="code-string">"Vehicle"</span>);\n\t\t\n\t\t<span class="code-comment">// Spring Validation</span>\n\t\tValidationUtils.invokeValidator(adapter, vehicle, error);<span class="code-comment">//执行校验</span>\n\t\tList&lt;FieldError&gt; list = error.getFieldErrors();<span class="code-comment">//检验信息</span>\n\n\t\t<span class="code-comment">// Bean Validation 校验</span>\n\t\tadapter.validate(vehicle).forEach(err -&gt; { <span class="code-comment">// 执行检验&amp;输出校验结果</span>\n\t\t\tprint(<span class="code-string">"Field: "</span>, err.getPropertyPath());\n\t\t\tprint(<span class="code-string">"Error: "</span>, err.getMessage());\n\t\t});\n\t}\n}</code></pre>\n<p>上面的代码使用SpringValidatorAdapter分别执行了<em>Bean Validation</em>和<em>Spring\n    Validation</em>。可以将SpringValidatorAdapter看作一个<em>org.springframework.validation.Validator</em>的实现类用ValidationUtils来执行校验，而验证的过程完全是按照Bean\n    Validation的规范来执行的。</p>\n\n<h2 id="h2-4">方法参数校验</h2>\n<p>除了校验一个实体类，Spring在<em>Bean Validation</em>的基础上使用<a\n        href="https://www.chkui.com/article/spring/spring_core_bean_post_processors" title="IOC处理器扩展">后置处理器</a>和AOP实现了方法参数的检验。例如下面的方法：\n</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">PersonService</span> </span>{\n\t<span class="code-keyword">public</span> <span class="code-meta">@NotBlank</span> <span class="hljs-function">String <span\n            class="code-title">execute</span><span class="hljs-params">(@NotBlank(message = <span class="code-string">"必须设置人员名称"</span>)</span> String name,\n\t\t\t@<span class="code-title">Min</span><span class="hljs-params">(value = <span class="hljs-number">18</span>, message = <span\n                class="code-string">"年龄必须大于18"</span>)</span> <span class="code-keyword">int</span> age)</span>;\n}</code></pre>\n<p>他表示返回数据不能为空字符串，传入的2个参数name不能为空字符串、age必须大于18。</p>\n<p>要启用方法参数校验关键点是引入MethodValidationPostProcessor并在需要验证的Bean上增加一个@Validated注解。</p>\n<p>先通过@Configuration引入后置处理器：</p>\n<pre><code class="java"><span class="code-meta">@Configuration</span>\n<span class="code-meta">@ComponentScan</span>(<span class="code-string">"chkui.springcore.example.hybrid.springvalidation.service"</span>)\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">SpringValidationConfig</span> </span>{\n\t<span class="code-meta">@Bean</span>(<span class="code-string">"validator"</span>)\n\t<span class="hljs-function"><span class="code-keyword">public</span> Validator <span\n            class="code-title">validator</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> LocalValidatorFactoryBean();\n\t}\n\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> MethodValidationPostProcessor <span\n            class="code-title">methodValidationPostProcessor</span><span\n            class="hljs-params">(Validator validator)</span> </span>{\n\t\tMethodValidationPostProcessor postProcessor = <span class="code-keyword">new</span> MethodValidationPostProcessor();\n\t\tpostProcessor.setValidator(validator);\n\t\t<span class="code-keyword">return</span> postProcessor;\n\t}\n}</code></pre>\n<p>然后实现上面的PersonService接口并标记@Validated表示这个类中的方法要进行参数校验：</p>\n<pre><code class="java"><span class="code-meta">@Service</span>\n<span class="code-meta">@Validated</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">PersonServiceImpl</span> <span class="code-keyword">implements</span> <span\n            class="code-title">PersonService</span> </span>{\n\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span\n            class="code-title">execute</span><span class="hljs-params">(String name, <span\n            class="code-keyword">int</span> age)</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"I\'m "</span> + name + <span\n            class="code-string">". "</span> + age + <span class="code-string">" years old."</span>;\n\t}\n}</code></pre>\n<p>最后使用这个Service：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">SpringValidationApp</span> </span>{\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(SpringValidationConfig.class);\n\t\tmethodValidation(ctx);<span class="code-comment">//方法参数校验</span>\n\t}\n\t\n\t<span class="hljs-function"><span class="code-keyword">private</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">methodValidation</span><span class="hljs-params">(ApplicationContext ctx)</span> </span>{\n\t\t<span class="code-comment">//对方法进行参数校验</span>\n\t\t<span class="code-keyword">try</span> {\n\t\t\tPersonService personService = ctx.getBean(PersonService.class);\n\t\t\tpersonService.execute(<span class="code-keyword">null</span>, <span class="hljs-number">1</span>);<span\n            class="code-comment">//传递参数</span>\n\t\t} <span class="code-keyword">catch</span> (ConstraintViolationException error) {\n\t\t\terror.getConstraintViolations().forEach(err -&gt; {<span class="code-comment">//输出校验错误信息</span>\n\t\t\t\tprint(<span class="code-string">"Field: "</span>, err.getPropertyPath());\n\t\t\t\tprint(<span class="code-string">"Error: "</span>, err.getMessage());\n\t\t\t});\n\t\t}\n\t}\n}</code></pre>\n<p>在运行的过程中，如果参数或返回数据不符合验证规则会抛出ConstraintViolationException异常，可以从中获取校验错误的信息。</p>'},393:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<p>笼统的说一个系统主要是由3个部分组成的：</p>\n<ol>\n    <li>执行程序：主要负责处理业务逻辑，对接用户操作。</li>\n    <li>内部数据：嵌套在源码中的数据，用于指导程序运行。</li>\n    <li>外部数据：业务数据，外部配置数据。</li>\n</ol>\n<p>\n    内部数据本身就是程序的一部分，在Java中这些数据通常停留在类的静态成员变量中。而外部数据往往与代码无关，所以对于程序而言要“读懂”它们需要进行一些前置处理。例如用户在前端页面提交的数据我们从RequestContext中获取的数据类型都是字符串，而我们的业务需要将字符串转换成数字、列表、对象等等，这就引入了我们接下来要介绍的内容——数据类型转换。</p>\n<p>JavaBean对于J2SE或者J2EE而言有着非常重要的意义，ORACLE为了统一各个组织对JavaBean的使用方式制定了详尽的JavaBean规范，包括<code><a\n        href="https://docs.oracle.com/javase/8/docs/api/java/beans/BeanInfo.html" target="_blank" rel="nofollow">BeanInfo</a>、<a\n        href="https://docs.oracle.com/javase/8/docs/api/java/beans/PropertyEditor.html" target="_blank" rel="nofollow">PropertyEditor</a>、</code><code><a\n        href="https://docs.oracle.com/javase/8/docs/api/java/beans/PropertyEditorSupport.html" target="_blank"\n        rel="nofollow">PropertyEditorSupport</a></code>等方面的内容。本文会涉及到JavaBean的一些规范，但是重点是介绍Spring的数据管理。</p>\n<p>（可执行代码请到本人gitee库下载，本文的代码在<em>chkui.springcore.example.hybrid.beanmanipulation</em>包）</p>\n\n<h2 id="h2-1">Properties结构转换为实体</h2>\n<p>标准资源文件*.properties是Java程序常用的数据存储文件，Spring提供了BeanWrapper接口将*.properties文件中的数据转换成一个标准的JavaBean对象。看下面的例子：</p>\n<p>有一个实体类Person：</p>\n<pre><code class="java"><span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">Person</span> </span>{\n\t<span class="code-keyword">private</span> String name;\n\t<span class="code-keyword">private</span> <span class="code-keyword">int</span> age;\n\t<span class="code-keyword">private</span> <span class="code-keyword">boolean</span> license;\n\t<span class="code-keyword">private</span> Date birtday;\n\t<span class="code-keyword">private</span> Address address;\n\t<span class="code-keyword">private</span> Map&lt;String, String&gt; otherInfo;\n\n    <span class="code-comment">// Getter &amp; Setter ......</span>\n}\n</code></pre>\n<p>然后可以通过BeanWrapper将Properties对象中的数据设置到对象中：</p>\n<pre><code class="java">   <span class="hljs-function"><span class="code-keyword">private</span> <span\n        class="code-keyword">void</span> <span class="code-title">simpleDataBind</span><span\n        class="hljs-params">()</span> </span>{\n\t\tBeanWrapper wrapper = <span class="code-keyword">new</span> BeanWrapperImpl(<span\n            class="code-keyword">new</span> Person());\n\t\t\n\t\t<span class="code-comment">//使用 BeanWrapper::setPropertyValue 接口设置数据</span>\n\t\twrapper.setPropertyValue(<span class="code-string">"name"</span>, <span class="code-string">"niubility"</span>);\n\t\twrapper.setPropertyValue(<span class="code-string">"age"</span>, <span class="hljs-number">18</span>);\n\t\twrapper.setPropertyValue(<span class="code-string">"license"</span>, <span class="code-keyword">true</span>);\n\t\tprint(wrapper.getWrappedInstance());\n\n\t\t<span class="code-comment">//使用 Properties对象设置数据，Properties实例可以来源于*.properties文件</span>\n\t\tProperties p = <span class="code-keyword">new</span> Properties();\n\t\tp.setProperty(<span class="code-string">"name"</span>, <span class="code-string">"From Properties"</span>);\n\t\tp.setProperty(<span class="code-string">"age"</span>, <span class="code-string">"25"</span>);\n\t\tp.setProperty(<span class="code-string">"license"</span>, <span class="code-string">"false"</span>);\n\t\tp.setProperty(<span class="code-string">"otherInfo[birthday]"</span>, <span\n            class="code-string">"2000-01-01"</span>);\n\t\twrapper.setPropertyValues(p);\n\t\tprint(wrapper.getWrappedInstance());\n\t}</code></pre>\n<p>这样，使用Spring的BeanWrapper接口，可以快速的将Properties数据结构转换为一个JavaBean实体。</p>\n<p>除了配置单个实体的数据，BeanWrapper还可以为嵌套结构的实体设置数据。现在增加一个实体Vehicle：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">Vehicle</span> </span>{\n\t<span class="code-keyword">private</span> String name;\n\t<span class="code-keyword">private</span> String manufacturer;\n\t<span class="code-keyword">private</span> Person person; <span class="code-comment">//Person对象</span>\n\n    <span class="code-comment">// Getter &amp; Setter ......</span>\n\n}</code></pre>\n<p>在Vehicle中有一个Person类型的成员变量（person域），我们可以利用下面具备嵌套结构的语法来设置数据：</p>\n<pre><code class="java">   <span class="hljs-function"><span\n        class="code-keyword">private</span> BeanManipulationApp <span class="code-title">nestedDataBind</span><span\n        class="hljs-params">()</span> </span>{\n\t\t<span class="code-comment">// 数据嵌套转换</span>\n\t\tBeanWrapper wrapper = <span class="code-keyword">new</span> BeanWrapperImpl(<span\n            class="code-keyword">new</span> Vehicle(<span class="code-keyword">new</span> Person()));\n\n\t\tProperties p = <span class="code-keyword">new</span> Properties();\n\t\tp.setProperty(<span class="code-string">"name"</span>, <span class="code-string">"Envision"</span>);\n\t\tp.setProperty(<span class="code-string">"manufacturer"</span>, <span class="code-string">"Buick"</span>);\n\t\t\n\t\t<span class="code-comment">//person.name表示设置person域的name变量数值</span>\n\t\tp.setProperty(<span class="code-string">"person.name"</span>, <span class="code-string">"Alice"</span>);\n\t\tp.setProperty(<span class="code-string">"person.age"</span>, <span class="code-string">"25"</span>);\n\t\tp.setProperty(<span class="code-string">"person.license"</span>, <span class="code-string">"true"</span>);\n\t\tp.setProperty(<span class="code-string">"person.otherInfo[license code]"</span>, <span class="code-string">"123456789"</span>);\n\t\twrapper.setPropertyValues(p);\n\t\tprint(wrapper.getWrappedInstance());\n\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>;\n\t}</code></pre>\n<p>在*.properties文件中，经常使用<em>path.name=param</em>的的语法来指定一个嵌套结构（比如LOG4J的配置文件），这里也使用类似的方式来指定嵌套结构。person.name在程序执行时会调用Vehicle::getPerson::setName方法来设定数据。\n</p>\n<p>除了设定单个数据BeanWrapper还提供了更丰富的方法来设置数据，以上面的Vehicle、person为例：</p>\n<table border="1" cellpadding="1" cellspacing="1" style="width:500px">\n    <tbody>\n    <tr>\n        <th>表达式</th>\n        <th>效果</th>\n    </tr>\n    </tbody>\n    <tbody>\n    <tr>\n        <td><em>p.setProperty("name", "Envision")</em></td>\n        <td>name域的数据设置为"Envision"</td>\n    </tr>\n    <tr>\n        <td><em>p.setProperty("person.name", "Alice")</em></td>\n        <td>将嵌套的person域下的name数据设置为"Alice"</td>\n    </tr>\n    <tr>\n        <td><em>p.setProperty("list[1]", "Step2")</em></td>\n        <td>list域是一个列表，将第二个数据设置为"Step2"</td>\n    </tr>\n    <tr>\n        <td><em>p.setProperty("otherInfo[birthday]", "2000-01-01")</em></td>\n        <td>otherInfo域是一个Map，将key=birthday、value="2000-01-01"的数据添加到Map中。</td>\n    </tr>\n    </tbody>\n</table>\n<p>上面这4条规则可以组合使用，比如<em>p.setProperty("person.otherInfo[license code]", "123456789")。</em></p>\n<p>关于在Java如何使用Properties有很多讨论（<a href="https://stackoverflow.com/questions/70471/no-properties-in-java" target="_blank" rel="nofollow">比如这篇stackoverflow的问答</a>），BeanWrapper不仅仅是针对资源文件，他还衍生扩展了数据类型转换等等功能。\n</p>\n\n<h2 id="h2-2">PropertyEditor转换数据</h2>\n<p>在JavaBean规范中定义了<em>java.beans.PropertyEditor，</em>他的作用简单的说就是将字符串转换为任意对象结构。</p>\n<blockquote>\n    <p>PropertyEditor最早是用来支持java.awt中的可视化接口编辑数据的（详情见<a\n            href="https://docs.oracle.com/javase/tutorial/javabeans/advanced/customization.html" target="_blank" rel="nofollow">Oracle关于IDE数据定制化的介绍</a>）。但是在Spring或其他应用场景中更多的仅仅是用来做字符串到特定数据格式的转换（毕竟java.awt应用不多），所以PropertyEditor提供的BeanWrapper::paintValue之类的支持awt的方法不用太去关心他，主要聚焦在BeanWrapper::setAsText方法上。\n    </p>\n</blockquote>\n<p>BeanWrapper继承了PropertyEditorRegistry接口用于注册PropertyEditor。BeanWrapperImpl已经预设了很多有价值的PropertyEditor，比如上面的例子的代码<em>p.setProperty("age",\n    "25");</em>，age域是一个数字整型，而Properties中的数据都是字符串，在设置数据时会自动启用CustomNumberEditor将字符串转换为数字。</p>\n<p>Spring已经提供的PropertyEditor可以看这里的<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-beans-conversion" target="_blank"\n        rel="nofollow">清单</a>。需要注意的是，这些PropertyEditor并不是每一个都默认启用，比如CustomDateEditor必须由开发者提供DateFormat才能使用，所以需要像下面这样将其添加注册到BeanWrapper中：\n</p>\n<pre><code class="java"><span class="hljs-function"><span class="code-keyword">private</span> <span\n        class="code-keyword">void</span> <span class="code-title">propertyEditor</span><span\n        class="hljs-params">()</span> </span>{\n\tBeanWrapper wrapper = <span class="code-keyword">new</span> BeanWrapperImpl(<span class="code-keyword">new</span> Person());\n\n\t<span class="code-comment">// 设定日期转换格式</span>\n\tDateFormat df = <span class="code-keyword">new</span> java.text.SimpleDateFormat(<span class="code-string">"yyyy-MM-dd"</span>);\n\t\t\n\t<span class="code-comment">// 将Editor与DateFormat进行帮顶，使用指定的格式</span>\n\tCustomDateEditor dateEditor = <span class="code-keyword">new</span> CustomDateEditor(df, <span class="code-keyword">false</span>);\n\t\t\n\t<span class="code-comment">// 注册dateEditor，将其与Date类进行绑定</span>\n\twrapper.registerCustomEditor(Date.class, dateEditor);\n\n\t<span class="code-comment">// CustomNumberEditor执行转换</span>\n\twrapper.setPropertyValue(<span class="code-string">"age"</span>, <span class="code-string">"18"</span>);\n\t<span class="code-comment">// CustomBooleanEditor执行转换</span>\n\twrapper.setPropertyValue(<span class="code-string">"license"</span>, <span class="code-string">"false"</span>);\n\t<span class="code-comment">// dateEditor执行转换</span>\n\twrapper.setPropertyValue(<span class="code-string">"birtday"</span>, <span class="code-string">"1999-01-30"</span>);\n\tprint(wrapper.getWrappedInstance());\n}</code></pre>\n<p>添加之后，设定<em>setPropertyValue("birtday", "1999-01-30")</em>时会自动使用指定的DateFormat转换日期。</p>\n\n<h2 id="h2-3">自定义PropertyEditor</h2>\n<p>除了预设的各种PropertyEditor，我们还可以开发自定义的PropertyEditor。Person中有一个类型为Address的成员变量：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">Address</span> </span>{\n\t<span class="code-keyword">private</span> String province; <span class="code-comment">//省</span>\n\t<span class="code-keyword">private</span> String city;  <span class="code-comment">//市</span>\n\t<span class="code-keyword">private</span> String district;  <span class="code-comment">//区</span>\n\n    <span class="code-comment">// Getter &amp; Setter</span>\n}</code></pre>\n<p>我们为Address实体添加一个PropertyEditor，将特定格式的字符串转换为Address结构：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">AddressEditor</span> <span class="code-keyword">extends</span> <span class="code-title">PropertyEditorSupport</span> </span>{\n\t<span class="code-keyword">private</span> String[] SPLIT_FLAG = { <span class="code-string">","</span>, <span\n            class="code-string">"-"</span>, <span class="code-string">";"</span>, <span class="code-string">":"</span> };\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setAsText</span><span class="hljs-params">(String text)</span> </span>{\n\t\t<span class="code-keyword">int</span> pos = -<span class="hljs-number">1</span>;\n\t\tAddress address = <span class="code-keyword">new</span> Address();\n\t\t<span class="code-keyword">for</span> (String flag : SPLIT_FLAG) {\n\t\t\tpos = text.indexOf(flag);\n\t\t\t<span class="code-keyword">if</span> (-<span class="hljs-number">1</span> &lt; pos) {\n\t\t\t\tString[] split = text.split(flag);\n\t\t\t\taddress.setProvince(split[<span class="hljs-number">0</span>]);\n\t\t\t\taddress.setCity(split[<span class="hljs-number">1</span>]);\n\t\t\t\taddress.setDistrict(split[<span class="hljs-number">2</span>]);\n\t\t\t\t<span class="code-keyword">break</span>;\n\t\t\t}\n\t\t}\n\t\t<span class="code-keyword">if</span> (-<span class="hljs-number">1</span> == pos) {\n\t\t\t<span class="code-keyword">throw</span> <span class="code-keyword">new</span> IllegalArgumentException(<span\n            class="code-string">"地址格式错误"</span>);\n\t\t}\n\t\tsetValue(address);<span class="code-comment">//设定Address实例</span>\n\t}\n}</code></pre>\n<p>\n    通过AddressEditor::setAsText方法，可以将输入的字符串最红转换为一个Address实例。通常情况下开发一个Editor转换器不会直接去实现PropertyEditor接口，而是继承PropertyEditorSupport。</p>\n<p>然后我们使用AddressEditor来将字符串转换为Address对象：</p>\n<pre><code class="java"><span class="hljs-function"><span class="code-keyword">private</span> BeanManipulationApp <span\n        class="code-title">propertyEditor</span><span class="hljs-params">()</span> </span>{\n\t<span class="code-comment">//使用预设转换工具和自定义转换工具</span>\n\tBeanWrapper wrapper = <span class="code-keyword">new</span> BeanWrapperImpl(<span class="code-keyword">new</span> Person());\n\n\t<span class="code-comment">// 创建AddressEditor实例</span>\n\tAddressEditor addressEditor = <span class="code-keyword">new</span> AddressEditor();\n\t\t\n\t<span class="code-comment">// 注册addressEditor，将其与Address类进行绑定</span>\n\twrapper.registerCustomEditor(Address.class, addressEditor);\n\n    <span class="code-comment">// 设置值自动进行转化</span>\n\twrapper.setPropertyValue(<span class="code-string">"address"</span>, <span class="code-string">"广东-广州-白云"</span>);\n\tprint(wrapper.getWrappedInstance());\n}</code></pre>\n<p>按照JavaBean规范，PropertyEditor和对应的JavaBean可以使用命名规则来表示绑定关系，而无需显式的调用注册方法。</p>\n<p>\n    绑定的规则是：有一个JavaBean命名为Tyre，在相同的包下（package）有一个实现了PropertyEditor接口并且命名为TyreEditor的类，那么框架认为TyreEditor就是Tyre的Editor，无需调用BeanWrapper::registerCustomEditor方法来声明Tyre和TyreEditor的绑定关系，详情请看源码中chkui.springcore.example.hybrid.beanmanipulation.bean.Tyre的使用。</p>\n\n<h2 id="h2-4">IoC与数据转换整合</h2>\n<p>对于Spring的ApplicationContext而言，BeanWrapper、PropertyEditor都是相对比较底层的功能，在使用Spring\n    Ioc容器的时候可以直接将这些功能嵌入到Bean初始化中或MVC的requestContext的数据转换中。</p>\n<p>从框架使用者的角度来看，Spring的XML配置数据或者通过MVC接口传递数据都是字符串，因此PropertyEditor在处理这些数据时有极大的用武之地。IoC容器使用<a\n        href="https://www.chkui.com/article/spring/spring_core_bean_post_processors" title="IOC处理器扩展">后置处理器</a>CustomEditorConfigurer来管理Bean初始化相关的PropertyEditor。通过CustomEditorConfigurer可以使用所有预设的Editor，还可以增加自定义的Editor，下面是使用@Configurable启用CustomEditorConfigurer的例子：\n</p>\n<pre><code class="java"><span class="code-meta">@Configurable</span>\n<span class="code-meta">@ImportResource</span>(<span\n            class="code-string">"classpath:hybrid/beanmanipulation/config.xml"</span>)\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">BeanManipulationConfig</span> </span>{\n\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function">CustomEditorConfigurer <span class="code-title">customEditorConfigurer</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-comment">// 构建CustomEditorConfigurer</span>\n\t\tCustomEditorConfigurer configurer = <span class="code-keyword">new</span> CustomEditorConfigurer();\n\t\t\n\t\tMap&lt;Class&lt;?&gt;, Class&lt;? extends PropertyEditor&gt;&gt; customEditors = <span\n            class="code-keyword">new</span> HashMap&lt;&gt;();\n\t\t\n\t\t<span class="code-comment">// 添加AddressEditor和Address的绑定</span>\n\t\tcustomEditors.put(Address.class, AddressEditor.class);\n\t\t\n\t\t<span class="code-comment">// 添加绑定列表</span>\n\t\tconfigurer.setCustomEditors(customEditors);\n\t\t\n\t\t<span class="code-comment">// 通过PropertyEditorRegistrar注册PropertyEditor</span>\n\t\tconfigurer.setPropertyEditorRegistrars(<span class="code-keyword">new</span> PropertyEditorRegistrar[] { <span\n            class="code-keyword">new</span> DateFormatRegistrar() });\n\t\t<span class="code-keyword">return</span> configurer;\n\t}\n}</code></pre>\n<p><em>CustomEditorConfigurer::setCustomEditors</em>和<em>CustomEditorConfigurer::setPropertyEditorRegistrars</em>都可以向容器中添加PropertyEditor，最主要区别在于：\n</p>\n<ol>\n    <li>前者是直接申明一对绑定关系的类对象（Class&lt;?&gt;），例如<em>customEditors.put(Address.class, AddressEditor.class);</em>\n        这行代码并没有实例化AddressEditor，而是将实例化交给后置处理器。\n    </li>\n    <li>\n        而后者是提供一个实例化的PropertyEditor，比前者更能实现更复杂的功能。比如下面的DateFormatRegistrar代码，由于需要组装DateFormat和CustomDateEditor，所以使用PropertyEditorRegistrar来实现这个过程更加合理，后置处理器会在某个时候调用这个注册方法。\n    </li>\n</ol>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">DateFormatRegistrar</span> <span class="code-keyword">implements</span> <span\n        class="code-title">PropertyEditorRegistrar</span> </span>{\n\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">registerCustomEditors</span><span\n            class="hljs-params">(PropertyEditorRegistry registry)</span> </span>{\n\t\tDateFormat df = <span class="code-keyword">new</span> java.text.SimpleDateFormat(<span class="code-string">"yyyy-MM-dd"</span>);\n\t\tCustomDateEditor editor = <span class="code-keyword">new</span> CustomDateEditor(df, <span class="code-keyword">false</span>);\n\t\tregistry.registerCustomEditor(Date.class, editor);\n\t}\n}</code></pre>\n<p>配置好CustomEditorConfigurer之后，就可以直接在配置Bean的时候直接使用预定的格式了，比如：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span>&gt;</span>\n\t<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n            class="code-string">"person"</span> <span class="hljs-attr">class</span>=<span class="code-string">"chkui.springcore.example.hybrid.beanmanipulation.bean.Person"</span>&gt;</span>\n\t\t<span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"name"</span> <span class="hljs-attr">value</span>=<span\n                class="code-string">"XML"</span> /&gt;</span>\n\t\t<span class="code-comment">&lt;!-- 使用CustomNumberEditor转换 --&gt;</span>\n\t\t<span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"age"</span> <span class="hljs-attr">value</span>=<span\n                class="code-string">"20"</span> /&gt;</span>\n\t\t<span class="code-comment">&lt;!-- 使用CustomBooleanEditor转换 --&gt;</span>\n\t\t<span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"license"</span> <span class="hljs-attr">value</span>=<span\n                class="code-string">"1"</span> /&gt;</span>\n\t\t<span class="code-comment">&lt;!-- 使用CustomDateEditor转换 --&gt;</span>\n\t\t<span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"birtday"</span> <span class="hljs-attr">value</span>=<span class="code-string">"1998-12-30"</span> /&gt;</span>\n\t\t<span class="code-comment">&lt;!-- 使用AddressEditor转换 --&gt;</span>\n\t\t<span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"address"</span> <span class="hljs-attr">value</span>=<span class="code-string">"广东,深圳,南山"</span> /&gt;</span>\n\t<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n\t\n\t<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"chkui.springcore.example.hybrid.beanmanipulation.bean.Vehicle"</span>&gt;</span>\n\t\t<span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"name"</span> <span class="hljs-attr">value</span>=<span class="code-string">"Mercedes-Benz C-Class"</span> /&gt;</span>\n\t\t<span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"manufacturer"</span> <span class="hljs-attr">value</span>=<span\n                class="code-string">"Mercedes-Benz"</span> /&gt;</span>\n\t\t<span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"person"</span> <span class="hljs-attr">ref</span>=<span class="code-string">"person"</span> /&gt;</span>\n\t<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>此外，在Spring MVC中，可以SimpleFormController::initBinder方法将外部传入的数据和某个Bean进行绑定：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="code-keyword">final</span> <span\n        class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MyController</span> <span\n        class="code-keyword">extends</span> <span class="code-title">SimpleFormController</span> </span>{\n\n    <span class="code-comment">// 通过任何方式获取PropertyEditorRegistrar</span>\n    <span class="code-meta">@Autowired</span>\n    <span class="code-keyword">private</span> MyPropertyEditorRegistrar editorRegistrar;\n\n    <span class="hljs-function"><span class="code-keyword">protected</span> <span class="code-keyword">void</span> <span\n            class="code-title">initBinder</span><span class="hljs-params">(HttpServletRequest request,\n            ServletRequestDataBinder binder)</span> <span class="code-keyword">throws</span> Exception </span>{\n        <span class="code-comment">// 将Editor与当前Controller进行绑定</span>\n        <span class="code-keyword">this</span>.editorRegistrar.registerCustomEditors(binder);\n    }\n}</code></pre>\n<p>Spring MVC并不属于Sring核心功能范畴，这里就不展开了，需要了解的话看看SimpleFormController的JavaDoc文档即可。</p>\n'},417:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<p>最近项目中需要针对Vert.x的运行效率进行监控，查阅Vert.x官文，发现目前提供了Dropwizard和Hawkular两种开箱即用的工具。本文将介绍使用Dropwizard\n    Metrics实现Vert.x性能统计的过程（当然还有踩过的坑）。</p>\n<p>首先简要说说dropwizard&nbsp;metrics。</p>\n<h2 id="h2-1">Dropwizard Metrics</h2>\n<p>按照官网的说法：Metrics是一个Java库，这个库可以让我们有无可比拟的能力去了解编码是如何在生产环境运行的。Metrics提供了强大的工具来测量关键组件在生产环境的运行行为。</p>\n<p>如果仅仅使用Metrics的功能，其实并没有什么复杂，也就是嵌入一些类去使用。把他理解log4j就很容易了。</p>\n<p>在运行之前，通过Maven引入依赖关系：</p>\n<blockquote>\n    <p><br> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&lt;dependency&gt;<br> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;\n        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&lt;groupId&gt;io.dropwizard.metrics&lt;/groupId&gt;<br> &nbsp;&nbsp;\n        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&lt;artifactId&gt;metrics-core&lt;/artifactId&gt;<br>\n        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&lt;version&gt;${metrics.version}&lt;/version&gt;<br>\n        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&lt;/dependency&gt;</p>\n</blockquote>\n<p><em>metrics.version&nbsp;</em>使用最新的版本号。</p>\n<p>下面的例子简要说明了如何使用metric。例子中先是包装了一个具有监控功能的队列，在调用add和remove方法时更新指标数据。</p>\n<pre class="cpp"><code class="cpp"><span class="code-comment"><span class="code-comment">//声明一个自带指标功能的队列</span></span>\n<span class="code-keyword"><span class="code-keyword">class</span></span> QueueWarp {\n\t<span class="code-comment"><span class="code-comment">// 真实队列</span></span>\n    <span class="code-keyword"><span class="code-keyword">private</span></span> final Queue&lt;Object&gt; <span\n            class="code-built_in"><span class="code-built_in">queue</span></span>;\n    <span class="code-comment"><span class="code-comment">// 计数器指标</span></span>\n    <span class="code-keyword"><span class="code-keyword">private</span></span> Counter counter;\n    <span class="code-comment"><span class="code-comment">// 柱状图指标</span></span>\n    <span class="code-keyword"><span class="code-keyword">private</span></span> Histogram size_rate;\n    <span class="code-comment"><span class="code-comment">// 计时器指标</span></span>\n    <span class="code-keyword"><span class="code-keyword">private</span></span> Timer optTimer;\n    <span class="code-comment"><span class="code-comment">// 构造函数</span></span>\n    <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">public</span></span></span><span class="hljs-function"> </span><span\n            class="code-title"><span class="hljs-function"><span class="code-title">QueueWarp</span></span></span><span\n            class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MetricRegistry metrics, String name)</span></span></span><span\n            class="hljs-function"> </span></span>{\n        <span class="code-keyword"><span class="code-keyword">this</span></span>.<span class="code-built_in"><span\n            class="code-built_in">queue</span></span> = <span class="code-keyword"><span class="code-keyword">new</span></span> LinkedList&lt;Object&gt;();\n\n        <span class="code-comment"><span class="code-comment">//注册一个测量值对象</span></span>\n        metrics.<span class="code-keyword"><span class="code-keyword">register</span></span>(MetricRegistry.name(QueueWarp.<span\n            class="code-keyword"><span class="code-keyword">class</span></span>, name, <span class="code-string"><span\n            class="code-string">"size"</span></span>),\n                         <span class="code-keyword"><span class="code-keyword">new</span></span> Gauge&lt;Integer&gt;() {\n                             @Override\n                             <span class="code-comment"><span class="code-comment">//每次发起统计时获取数据的接口</span></span>\n                             <span class="code-keyword"><span class="code-keyword">public</span></span> Integer getValue() {\n                                 <span class="code-keyword"><span class="code-keyword">return</span></span> <span\n            class="code-built_in"><span class="code-built_in">queue</span></span>.size();\n                             }\n                         });\n        <span class="code-comment"><span class="code-comment">// 注册计数器</span></span>\n        counter = metrics.<span class="code-keyword"><span class="code-keyword">register</span></span>(MetricRegistry.name(QueueWarp.<span\n            class="code-keyword"><span class="code-keyword">class</span></span>, name, <span class="code-string"><span\n            class="code-string">"count"</span></span>), <span class="code-keyword"><span class="code-keyword">new</span></span> Counter());\n        <span class="code-comment"><span class="code-comment">// 注册柱状图</span></span>\n        size_rate = metrics.histogram(MetricRegistry.name(QueueWarp.<span class="code-keyword"><span\n            class="code-keyword">class</span></span>, <span class="code-string"><span\n            class="code-string">"size-rate"</span></span>));\n        <span class="code-comment"><span class="code-comment">// 注册计时器</span></span>\n        optTimer = metrics.timer(MetricRegistry.name(QueueWarp.<span class="code-keyword"><span class="code-keyword">class</span></span>, <span\n            class="code-string"><span class="code-string">"opt-timer"</span></span>));\n    }\n    <span class="code-comment"><span class="code-comment">//增加</span></span>\n    <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">public</span></span></span><span class="hljs-function"> boolean </span><span\n            class="code-title"><span class="hljs-function"><span class="code-title">add</span></span></span><span\n            class="hljs-params"><span class="hljs-function"><span\n            class="hljs-params">(Object e)</span></span></span></span>{\n    \tfinal Timer.Context timerContext = optTimer.time();<span class="code-comment"><span\n            class="code-comment">//开始计时</span></span>\n    \tcounter.inc();<span class="code-comment"><span class="code-comment">//计数器+1</span></span>\n    \tsize_rate.update(<span class="code-built_in"><span class="code-built_in">queue</span></span>.size());<span\n            class="code-comment"><span class="code-comment">//柱状图更新</span></span>\n    \tboolean ret = <span class="code-keyword"><span class="code-keyword">this</span></span>.<span\n            class="code-built_in"><span class="code-built_in">queue</span></span>.add(e);<span\n            class="code-comment"><span class="code-comment">//添加数据到队列</span></span>\n    \ttimerContext.stop();<span class="code-comment"><span class="code-comment">//停止计时</span></span>\n        <span class="code-keyword"><span class="code-keyword">return</span></span> ret;\n    }\n    <span class="code-comment"><span class="code-comment">// 删除</span></span>\n    <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">public</span></span></span><span class="hljs-function"> Object </span><span\n            class="code-title"><span class="hljs-function"><span class="code-title">remove</span></span></span><span\n            class="hljs-params"><span class="hljs-function"><span\n            class="hljs-params">(Object e)</span></span></span></span>{\n    \tfinal Timer.Context timerContext = optTimer.time();\n    \tcounter.dec();\n    \tsize_rate.update(<span class="code-built_in"><span class="code-built_in">queue</span></span>.size());\n    \tObject ret = <span class="code-keyword"><span class="code-keyword">this</span></span>.<span\n            class="code-built_in"><span class="code-built_in">queue</span></span>.remove();\n    \ttimerContext.stop();\n        <span class="code-keyword"><span class="code-keyword">return</span></span> ret;\n    }\n}</code></pre>\n<p>在上面的代码中，当调用add、remove方法时，会记录：</p>\n<ol>\n    <li>方法从调用到返回的时间间隔。</li>\n    <li>更新队列中的数据规模。（Counter和Gauge都记录了规模）</li>\n    <li>更新当前队列成员个数和最大值的比率。</li>\n</ol>\n<p>然后使用一个main方法来测试这个类并输出指标数据：</p>\n<pre class="cpp"><code class="cpp"><span class="code-keyword"><span class="code-keyword">public</span></span> <span\n        class="code-keyword"><span class="code-keyword">class</span></span> MetricDemoRun {\n\t<span class="code-comment"><span class="code-comment">// 注册指标实例</span></span>\n\t<span class="code-keyword"><span class="code-keyword">static</span></span> final MetricRegistry metrics = <span\n            class="code-keyword"><span class="code-keyword">new</span></span> MetricRegistry();\n\t<span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">public</span></span></span><span class="hljs-function"> </span><span\n            class="code-keyword"><span class="hljs-function"><span class="code-keyword">static</span></span></span><span\n            class="hljs-function"> </span><span class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">void</span></span></span><span class="hljs-function"> </span><span\n            class="code-title"><span class="hljs-function"><span class="code-title">main</span></span></span><span\n            class="hljs-params"><span class="hljs-function"><span\n            class="hljs-params">(String args[])</span></span></span><span class="hljs-function"> </span></span>{\n\t\t<span class="code-comment"><span class="code-comment">//新建队列</span></span>\n\t\tQueueWarp <span class="code-built_in"><span class="code-built_in">queue</span></span> = <span\n            class="code-keyword"><span class="code-keyword">new</span></span> QueueWarp(metrics, <span\n            class="code-string"><span class="code-string">"jobss"</span></span>);\n\t\t<span class="code-built_in"><span class="code-built_in">queue</span></span>.add(<span class="code-string"><span\n            class="code-string">"1"</span></span>);\n\t\t<span class="code-comment"><span class="code-comment">// 启动指标数据输出</span></span>\n\t\tstartReport();\n\t\t<span class="code-keyword"><span class="code-keyword">try</span></span> {\n\t\t\tThread.sleep(<span class="hljs-number"><span class="hljs-number">5</span></span> * <span\n            class="hljs-number"><span class="hljs-number">1000</span></span>);\n\t\t} <span class="code-keyword"><span class="code-keyword">catch</span></span> (InterruptedException e) {\n\t\t}\n\t\t<span class="code-built_in"><span class="code-built_in">queue</span></span>.add(<span class="code-string"><span\n            class="code-string">"2"</span></span>);\n\t\tMeter requests = metrics.meter(<span class="code-string"><span class="code-string">"requests"</span></span>);\n\t\trequests.mark();\n\t\twait5Seconds();\n\t}\n\n\t<span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">static</span></span></span><span class="hljs-function"> </span><span\n            class="code-keyword"><span class="hljs-function"><span class="code-keyword">void</span></span></span><span\n            class="hljs-function"> </span><span class="code-title"><span class="hljs-function"><span class="code-title">startReport</span></span></span><span\n            class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span\n            class="hljs-function"> </span></span>{\n\t\t<span class="code-comment"><span class="code-comment">//注册报告对象</span></span>\n\t\tConsoleReporter reporter = ConsoleReporter.forRegistry(metrics).\n\t\t\t\tconvertRatesTo(TimeUnit.SECONDS).\n\t\t\t\tconvertDurationsTo(TimeUnit.MILLISECONDS)\n\t\t\t\t.build();\n\n\t\t<span class="code-comment"><span class="code-comment">// 开始输出报告</span></span>\n\t\treporter.start(<span class="hljs-number"><span class="hljs-number">1</span></span>, TimeUnit.SECONDS);\n\t}\n\n\t<span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">static</span></span></span><span class="hljs-function"> </span><span\n            class="code-keyword"><span class="hljs-function"><span class="code-keyword">void</span></span></span><span\n            class="hljs-function"> </span><span class="code-title"><span class="hljs-function"><span class="code-title">wait5Seconds</span></span></span><span\n            class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span\n            class="hljs-function"> </span></span>{\n\t\t<span class="code-keyword"><span class="code-keyword">try</span></span> {\n\t\t\tThread.sleep(<span class="hljs-number"><span class="hljs-number">300</span></span> * <span\n            class="hljs-number"><span class="hljs-number">1000</span></span>);\n\t\t} <span class="code-keyword"><span class="code-keyword">catch</span></span> (InterruptedException e) {\n\t\t}\n\t}\n}</code></pre>\n<p>MetricDemoRun类中还有2个静态方法，一个用来输出报告数据。一个用来将主线程睡眠一段的时间。运行main以后，会在控制台重复输出下列内容：</p>\n<blockquote>\n    <p>16-7-7 16:50:35 ================================================================</p>\n    <p>-- Gauges ----------------------------------------------------------------------<br>\n        com.oakss.demo.metrics.app.QueueWarp.jobss.size<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;value = 2\n    </p>\n    <p>-- Counters --------------------------------------------------------------------<br>\n        com.oakss.demo.metrics.app.QueueWarp.jobss.count<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;count = 2\n    </p>\n    <p>-- Histograms ------------------------------------------------------------------<br>\n        com.oakss.demo.metrics.app.QueueWarp.size-rate<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;count = 2<br>\n        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;min = 0<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n        &nbsp; &nbsp;max = 1<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mean = 0.52<br> &nbsp; &nbsp; &nbsp;\n        &nbsp; &nbsp; &nbsp; stddev = 0.50<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; median = 1.00<br> &nbsp; &nbsp;\n        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 75% &lt;= 1.00<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 95% &lt;=\n        1.00<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 98% &lt;= 1.00<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n        &nbsp; &nbsp; 99% &lt;= 1.00<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 99.9% &lt;= 1.00</p>\n    <p>-- Meters ----------------------------------------------------------------------<br> requests<br> &nbsp; &nbsp;\n        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;count = 1<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mean rate = 1.00 events/second<br>\n        &nbsp; &nbsp; &nbsp;1-minute rate = 0.00 events/second<br> &nbsp; &nbsp; &nbsp;5-minute rate = 0.00\n        events/second<br> &nbsp; &nbsp; 15-minute rate = 0.00 events/second</p>\n    <p>-- Timers ----------------------------------------------------------------------<br>\n        com.oakss.demo.metrics.app.QueueWarp.opt-timer<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;count = 2<br>\n        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mean rate = 0.33 calls/second<br> &nbsp; &nbsp; &nbsp;1-minute rate = 0.20\n        calls/second<br> &nbsp; &nbsp; &nbsp;5-minute rate = 0.20 calls/second<br> &nbsp; &nbsp; 15-minute rate = 0.20\n        calls/second<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;min = 0.07 milliseconds<br> &nbsp;\n        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;max = 2.75 milliseconds<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n        &nbsp; &nbsp; mean = 1.35 milliseconds<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stddev = 1.34\n        milliseconds<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; median = 0.07 milliseconds<br> &nbsp; &nbsp; &nbsp;\n        &nbsp; &nbsp; &nbsp; &nbsp; 75% &lt;= 2.75 milliseconds<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 95%\n        &lt;= 2.75 milliseconds<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 98% &lt;= 2.75 milliseconds<br>\n        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 99% &lt;= 2.75 milliseconds<br> &nbsp; &nbsp; &nbsp; &nbsp;\n        &nbsp; &nbsp; 99.9% &lt;= 2.75 milliseconds<br> &nbsp;</p>\n</blockquote>\n<p>看完上面的例子。并没有感受什么特别牛逼的地方，无非是在代码中嵌入一些统计点。&nbsp;看来看去都像一个增强版的日志工具。</p>\n\n<h2 id="h2-2">Vert.x指标统计&nbsp; &nbsp;&nbsp;</h2>\n\n<h3 id="h3-1">嵌入Metrics</h3>\n<p>说完基本的dropwizard&nbsp;metrics功能我们再看看如何整合Vert.x和dropwizard&nbsp;metrics用来统计各种有效的指标。</p>\n<p>\n    Vert.x通过MetricsService的SPI接口提供了接入指标统计工具的入口。在创建Vertx实例时使用DropwizardMetricsOptions来告诉Vertx使用对应的实现类。首先需要加入Vert.x的Dropwizard包：</p>\n<pre class="xml"><code class="xml"><span class="code-tag"><span class="code-tag">&lt;</span><span\n        class="code-name"><span class="code-tag"><span class="code-name">dependency</span></span></span><span\n        class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">groupId</span></span></span><span class="code-tag">&gt;</span></span>io.vertx<span\n            class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">groupId</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">artifactId</span></span></span><span class="code-tag">&gt;</span></span>vertx-dropwizard-metrics<span\n            class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">artifactId</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">version</span></span></span><span class="code-tag">&gt;</span></span>3.3.0<span\n            class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">version</span></span></span><span class="code-tag">&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n        class="code-name">dependency</span></span></span><span class="code-tag">&gt;</span></span></code></pre>\n<p>然后下列代码展示了创建一个具有Metrics功能的<em>Vertx</em>实例以及从中读取指标数据。</p>\n<pre class="cs"><code class="cs"><span class="code-keyword"><span class="code-keyword">public</span></span> <span\n        class="code-keyword"><span class="code-keyword">class</span></span> <span class="code-title"><span\n        class="code-title">VertxMetricDemo</span></span> {\n\t<span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">public</span></span></span><span class="hljs-function"> </span><span\n            class="code-keyword"><span class="hljs-function"><span class="code-keyword">static</span></span></span><span\n            class="hljs-function"> </span><span class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">void</span></span></span><span class="hljs-function"> </span><span\n            class="code-title"><span class="hljs-function"><span class="code-title">main</span></span></span><span\n            class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span\n            class="hljs-params">String[] args</span></span></span><span class="hljs-function">) </span></span>{\n\t\t<span class="code-comment"><span class="code-comment">// 使用DropwizardMetricsOptions配置创建单机Vertx实例</span></span>\n\t\tVertx vertx = Vertx.vertx(\n\t\t\t\t<span class="code-keyword"><span class="code-keyword">new</span></span> VertxOptions().setMetricsOptions(\n\t\t\t\t\t\t<span class="code-keyword"><span class="code-keyword">new</span></span> DropwizardMetricsOptions().setEnabled(<span\n            class="hljs-literal"><span class="hljs-literal">true</span></span>)\n\t\t\t\t));\n\n\t\t<span class="code-comment"><span class="code-comment">// 创建指标服务</span></span>\n\t\tMetricsService metricsService = MetricsService.create(vertx);\n\n\t\t<span class="code-comment"><span class="code-comment">// 获取当前的指标服务</span></span>\n\t\tJsonObject json = metricsService.getMetricsSnapshot(vertx);\n\n\t\t<span class="code-comment"><span class="code-comment">// 输出</span></span>\n\t\tSystem.<span class="code-keyword"><span class="code-keyword">out</span></span>.println(json);\n\t}\n}</code></pre>\n<p>Vert.x实现指标功能的原理是接口继承Measured，这些接口包括HttpServer、NetServer、EventBus、Vertx等。通过Measured可以注入对各种组件的指标统计。</p>\n<p><a title="MetricsService" href="http://vertx.io/docs/apidocs/io/vertx/ext/dropwizard/MetricsService.html"\n      rel="nofollow">MetricsService</a>提供了丰富的功能接口来获取各种指标数据，每一项指标数据都有自己特定的命名规则。我们可以过全称获取某一项指标，例如获取eventBus上的handler相关指标，可以使用以下方法：\n</p>\n<pre class="lua"><code class="lua">JsonObject metrics = metricsService.getMetricsSnapshot(vertx);\nmetrics.getJsonObject(<span class="code-string"><span\n            class="code-string">"vertx.eventbus.handlers"</span></span>);</code></pre>\n<p>或者直接从指定的eventBus获取数据：</p>\n<pre class="lua"><code class="lua">EventBus eventBus = vertx.eventBus();\nJsonObject metrics = metricsService.getMetricsSnapshot(eventBus);\nmetrics.getJsonObject(<span class="code-string"><span class="code-string">"handlers"</span></span>);</code></pre>\n<p>两种方式获得同样的数据，只要接口继承了Measured就可以用MetricsService::create来获取指标。</p>\n\n<h3 id="h3-2">指标格式和指标数据</h3>\n<p>Metric提供了丰富的数据格式。目前有：Gauge（测量值）、Counter（计数器）、Histogram（柱状图）、Meter（仪表）、ThroughputMeter（吞吐量统计）、Timer（计时器）和Throughput\n    Timer（吞吐量计时器）。</p>\n<p>Vert.x提供了丰富的指标数据内容，下面将一一列举说明。</p>\n\n<h4 id="h4-1">Vert.x指标</h4>\n<blockquote>\n    <ul>\n        <li><p><code>vertx.event-loop-size</code>&nbsp;- 类型：Gauge（测量值）含义：event loop线程池的线程数量。</p></li>\n        <li><p><code>vertx.worker-pool-size</code>&nbsp;- 类型：Gauge（测量值）含义：worker线程池的线程数量。</p></li>\n        <li><p><code>vertx.cluster-host</code>&nbsp;- 类型：Gauge（测量值）含义：集群主机的设置值。</p></li>\n        <li><p><code>vertx.cluster-port</code>&nbsp;- 类型：Gauge（测量值）含义：集群接口的设置值。</p></li>\n        <li><p><code>vertx.verticles</code>&nbsp;- 类型：Counter（计数器）含义：当前已部署的verticles数量。</p></li>\n        <li><p><code>vertx.verticles.&lt;verticle-name&gt;</code>&nbsp;- 类型：Counter（计数器）含义：&lt;verticle-name&gt;指定名称的verticle部署数量。\n        </p></li>\n    </ul>\n</blockquote>\n\n<h4 id="h4-2">Event bus 指标</h4>\n<p>基础名称:&nbsp;<code>vertx.eventbus</code></p>\n<blockquote>\n    <ul>\n        <li><p><code>handlers</code>&nbsp;- 类型：Counter（计数器）含义： event bus中已注册handler的数量。</p></li>\n        <li><p><code>handlers.myaddress</code>&nbsp;- 类型：Timer（计时器）含义：名为<em>myaddress</em>的handler出个单个messages的速率。</p>\n        </li>\n        <li><p><code>messages.bytes-read</code>&nbsp;- 类型：Meter（仪表）含义：获取远程信息的字节数总量。</p></li>\n        <li><p><code>messages.bytes-written</code>&nbsp;- 类型：Meter（仪表）含义：发送到远程地址的信息数据总量。</p></li>\n        <li><p><code>messages.pending</code>&nbsp;- 类型：Counter（计数器）含义：已经被eventbus接受，但是还未被handler处理的信息数。</p></li>\n        <li><p><code>messages.pending-local</code>&nbsp;- 类型：Counter（计数器）含义：由本地发送的已经被eventbus接受，但是还未被handler处理的信息数。</p>\n        </li>\n        <li><p><code>messages.pending-remote</code>&nbsp;- 类型：Counter（计数器）含义：由远程发送的已经被eventbus接受，但是还未被handler处理的信息数。</p>\n        </li>\n        <li><p><code>messages.received</code>&nbsp;- 类型：ThroughputMeter（吞吐量统计）含义：表示接受消息条目数的速率。</p></li>\n        <li><p><code>messages.received-local</code>&nbsp;- 类型：ThroughputMeter（吞吐量统计）含义：表示接受本地消息条目数的速率。</p></li>\n        <li><p><code>messages.received-remote</code>&nbsp;- 类型：ThroughputMeter（吞吐量统计）含义：表示接受远程消息条目数的速率。</p></li>\n        <li><p><code>messages.delivered</code>&nbsp;- 类型：ThroughputMeter（吞吐量统计）含义：表示消息被传递到一个处理程序的速率。</p></li>\n        <li><p><code>messages.delivered-local</code>&nbsp;- 类型：ThroughputMeter（吞吐量统计）含义：表示本地消息被传递到一个handler的速率。</p></li>\n        <li><p><code>messages.delivered-remote</code>&nbsp;- 类型：ThroughputMeter（吞吐量统计）含义：表示远程消息被传递到一个handler的速率。</p>\n        </li>\n        <li><p><code>messages.sent</code>&nbsp;- 类型：ThroughputMeter（吞吐量统计）含义：表示消息被发送的速率。</p></li>\n        <li><p><code>messages.sent-local</code>&nbsp;- 类型：ThroughputMeter（吞吐量统计）含义：表示消息被发送到本地的速率。</p></li>\n        <li><p><code>messages.sent-remote</code>&nbsp;- 类型：ThroughputMeter（吞吐量统计）含义：表示消息被发送到远程服务的速率。</p></li>\n        <li><p><code>messages.published</code>&nbsp;- 类型：ThroughputMeter（吞吐量统计）含义：表示发布消息的速率。</p></li>\n        <li><p><code>messages.published-local</code>&nbsp;- 类型：ThroughputMeter（吞吐量统计）含义：表示发布本地消息的速率。</p></li>\n        <li><p><code>messages.published-remote</code>&nbsp;- 类型：ThroughputMeter（吞吐量统计）含义：表示发布远程消息的速率。</p></li>\n        <li><p><code>messages.reply-failures</code>&nbsp;- 类型：Meter含义：表示回复失败的频率。</p></li>\n    </ul>\n</blockquote>\n\n<h4 id="h4-3">Http 服务指标</h4>\n<p>基础名称:&nbsp;<code>vertx.http.servers.&lt;host&gt;:&lt;port&gt;</code></p>\n<p>Http 服务的数据包括&nbsp;<strong><em>Net服务的指标&nbsp;</em></strong>加上以下指标：</p>\n<blockquote>\n    <ul>\n        <li><p><code>requests</code>&nbsp;- 类型：Throughput Timer（吞吐量计时器）含义：单个请求及其出现的频率。</p></li>\n        <li><p><code>&lt;http-method&gt;-requests</code>&nbsp;- 类型：Throughput Timer（吞吐量计时器）含义：指定由&lt;http-method&gt;（PUT、GET、POST等）表示方法获取的请求及其频率。\n        </p>\n            <ul>\n                <li><p>例如:&nbsp;<code>get-requests</code>,&nbsp;<code>post-requests</code></p></li>\n            </ul>\n        </li>\n        <li><p><code>&lt;http-method&gt;-requests./&lt;uri&gt;</code>&nbsp;- A&nbsp;Throughput Timer（吞吐量计时器）含义：指定由&lt;http-method&gt;表示的方法和/&lt;uri&gt;表示的路径的请求内容及其频率。\n        </p>\n            <ul>\n                <li><p>例如:&nbsp;<code>get-requests./some/uri</code>,&nbsp;<code>post-requests./some/uri?foo=bar</code>\n                </p></li>\n            </ul>\n        </li>\n        <li><p><code>responses-1xx</code>&nbsp;- 类型：ThroughputMeter（吞吐量统计）含义：1xx响应的频次。</p></li>\n        <li><p><code>responses-2xx</code>&nbsp;- 类型：ThroughputMeter（吞吐量统计）含义：2xx响应的频次。</p></li>\n        <li><p><code>responses-3xx</code>&nbsp;- 类型：ThroughputMeter（吞吐量统计）含义：3xx响应的频次。</p></li>\n        <li><p><code>responses-4xx</code>&nbsp;- 类型：ThroughputMeter（吞吐量统计）含义：4xx响应的频次。</p></li>\n        <li><p><code>responses-5xx</code>&nbsp;- 类型：ThroughputMeter（吞吐量统计）含义：5xx响应的频次。</p></li>\n        <li><p><code>open-websockets</code>&nbsp;- 类型：Counter（计数器）含义：打开网络套接字的连接个数。</p></li>\n        <li><p><code>open-websockets.&lt;remote-host&gt;</code>&nbsp;- 类型：Counter（计数器）含义：连接到&lt;remote-host&gt;指定的地址打开网络套接字的连接个数。\n        </p></li>\n    </ul>\n</blockquote>\n\n<h4 id="h4-4">Net 服务指标</h4>\n<p>基础名称:&nbsp;<code>vertx.net.servers.&lt;host&gt;:&lt;port&gt;</code></p>\n<blockquote>\n    <ul>\n        <li><p><code>open-netsockets</code>&nbsp;- 类型：Counter（计数器）含义：打开net socket的连接数。</p></li>\n        <li><p><code>open-netsockets.&lt;remote-host&gt;</code>&nbsp;- 类型：Counter（计数器）含义：连接到指定的远程主机所打开的net socket连接数。\n        </p></li>\n        <li><p><code>connections</code>&nbsp;- 类型：Timer（计时器）含义：创建连接的频率。</p></li>\n        <li><p><code>exceptions</code>&nbsp;- 类型：Counter（计数器）含义：出现异常的次数。</p></li>\n        <li><p><code>bytes-read</code>&nbsp;- 类型：Histogram（柱状图）含义：读取的字节数。</p></li>\n        <li><p><code>bytes-written</code>&nbsp;- 类型：Histogram（柱状图）含义：写入的字节数。</p></li>\n    </ul>\n</blockquote>\n\n<h4 id="h4-5">池指标（Pool metrics）</h4>\n<p>基础名称:&nbsp;<code>vertx.pool.&lt;type&gt;.&lt;name&gt;</code>。这里的<code>type</code>表示池类型(例如&nbsp;<em>worker</em>、<em>datasource</em>)，&nbsp;<code>name</code>表示池的名称(例如&nbsp;<code>vert.x-worker-thread</code>)。\n</p>\n<p>类型为<em>worker</em>的线程池是用于阻塞运行的工作线程池，Vert.x将其用于<em>vert.x-worker-thread</em>线程或<em>vert.x-internal-blocking</em>线程。\n    名为worker的执行线程都使用<code><a title="WorkerExecutor"\n                             href="http://vertx.io/docs/apidocs/io/vertx/core/WorkerExecutor.html" rel="nofollow">WorkerExecutor</a></code>来创建。\n</p>\n<p>数据源（Datasource）使用Vert.x的JDBC客户端创建，名为<em>datasource</em>.</p>\n<blockquote>\n    <ul>\n        <li><p><code>queue-delay</code>&nbsp;- 类型：Timer（计时器）含义：测量获取某个资源的等待时间，例如在队列中的等待时间。</p></li>\n        <li><p><code>queue-size</code>&nbsp;- 类型：Counter（计数器）含义：在队列中等待的资源数。</p></li>\n        <li><p><code>usage</code>&nbsp;- 类型：Timer（计时器）含义：测量某个资源被持续使用的时间。</p></li>\n        <li><p><code>in-use</code>&nbsp;- 类型：Counter（计数器）含义：使用资源的实际数量。</p></li>\n        <li><p><code>pool-ratio</code>&nbsp;- 类型：Gauge（测量值）含义：已使用的资源和池规模的比率。</p></li>\n        <li><p><code>max-pool-size</code>&nbsp;- 类型：Gauge（测量值）含义：池的最大规模。</p></li>\n    </ul>\n</blockquote>\n<p>当池的最大规模没有声明时，<code>pool-ratio</code>和<code>max_pool_size</code>将没有任何数据。</p>\n<p>除了以上服务器端的指标之外，Vertx还包括一些客户端指标，有需要可以去官网查看。</p>\n\n<h2 id="h2-3">图形化展示指标数据</h2>\n<p>在收集到各种指标数据之后，如果只能输出到console看各字符串就太没意思了。在互联网时代，必须有牛逼闪闪的图形统计工具啊，下面将介绍使用开源项目呈现数据报表。</p>\n<p>官网介绍了2个开源工具来实现呈现报表的功能——Jolokia和Hawtio。</p>\n\n<h3 id="h3-3">Jolokia代理</h3>\n<p><a title="Jolokia" href="https://jolokia.org/" rel="nofollow">Jolokia </a>是按照JSR-160的要求实现JMX-HTTP桥接的工具。按照官网的说法，有非常多的平台使用了Jolokia，并且Jolokia在处理远程连接时提供了更安全的支持。（另外一篇博文介绍了Jolokia，想了解点这里：<a\n        href="http://my.oschina.net/chkui/blog/708639" rel="nofollow">http://my.oschina.net/chkui/blog/708639</a>）</p>\n<p>首先，需要像下面这样创建一个Vertx实例：</p>\n<pre class="actionscript"><code class="language-java">Vertx vertx = Vertx.vertx(<span class="code-keyword"><span\n        class="code-keyword">new</span></span> VertxOptions().setMetricsOptions(\n    <span class="code-keyword"><span class="code-keyword">new</span></span> DropwizardMetricsOptions()\n        .setEnabled(<span class="code-keyword"><span class="hljs-literal">true</span></span>)\n        .setJmxEnabled(<span class="code-keyword"><span class="hljs-literal">true</span></span>)\n        .setJmxDomain(<span class="code-string"><span class="code-string">"vertx-metrics"</span></span>)));</code></pre>\n<p><em>Domain&nbsp;</em>参数是可以修改的，这个参数会影响Hawtio的服务的浏览名称，下文会有说明。完成这个配并启用统计功能后，vertx-dropwizard-metric会暴露本地的的Mbean服务接口，Jolokia可以通过这个接口获取指标数据。（<span\n        style="color:#FFA07A">以上配置也可以用于Vert.x的集群环境。</span>）</p>\n<p>然后，我们插入Jolokia来做桥接功能。</p>\n<p>首先到官网去下载最新的代理包&lt;<a title="Jolokia代理包"\n                        href="http://search.maven.org/remotecontent?filepath=org/jolokia/jolokia-jvm/1.3.3/jolokia-jvm-1.3.3-agent.jar"\n                        rel="nofollow">点我下载</a>&gt;。下载完成后，需要嵌入到我们自己的应用中，像下面这样在java启动命令中增加以下参数来植入Jolokia代理：</p>\n<pre class="xml"><code class="xml">-javaagent:%jolokia_home%/jolokia-jvm-<span class="code-tag"><span class="code-tag">&lt;</span><span\n        class="code-name"><span class="code-tag"><span class="code-name">version</span></span></span><span\n        class="code-tag">&gt;</span></span>-agent.jar=port=7777,host=localhost</code></pre>\n<p>下面是完整的例子：</p>\n<pre class="groovy"><code class="groovy">java -<span class="code-string"><span\n        class="code-string">javaagent:</span></span><span class="code-string"><span class="code-string">D:</span></span><span\n        class="hljs-regexp"><span class="hljs-regexp">/soft/</span></span>jolokia/jolokia-jvm<span\n        class="hljs-number"><span class="hljs-number">-1.3</span></span><span class="hljs-number"><span\n        class="hljs-number">.3</span></span>-agent.jar=port=<span class="hljs-number"><span\n        class="hljs-number">7777</span></span>,host=localhost com.a.b.c.runApp</code></pre>\n<p>在eclipse下，右键-&gt;[Debug|Run] As-&gt;[Debug|Run] Config。弹出的选项卡中，选择Arguments。然后在VM arguments中增加代理参数，如下图：</p>\n<p><img alt="Vert.x Dropwizard指标数据监控" height="535"\n        src="http://static.oschina.net/uploads/space/2016/0712/165407_jrTG_2649413.png" width="900"></p>\n<p>然后点击右下角的Debug启动。如果启动成功，会在控制台输出。</p>\n<blockquote>\n    <p>I&gt; No access restrictor found, access to any MBean is allowed<br> Jolokia: Agent started with URL\n        http://127.0.0.1:7777/jolokia/</p>\n</blockquote>\n<p>至此。我们的Vertx实例成功启动，启动的同时开启了：</p>\n<ol>\n    <li>Dropwizard Metrics用于指标收集；</li>\n    <li>Jmx暴露桥接接口；</li>\n    <li>Jolokia提供指标数据Rest接口；</li>\n</ol>\n<p>随后，我们需要添加一个Hawtio来获取Jolokia暴露的接口数据。</p>\n\n<h3 id="h3-4">Hawtio展示指标数据</h3>\n<p>Hawtio看做一个web服务即可，他按照servlet规范开发，是个标准的web服务。他功能就是从暴露的Jolokia接口中读取指标数据，然后以图像化的方式呈现给用户。下面说明如何搭建好Hawtio服务。</p>\n<p>首先下载Hawtio的war包&lt;<a title="Hawtio运行包"\n                         href="https://oss.sonatype.org/content/repositories/public/io/hawt/hawtio-default/1.4.65/hawtio-default-1.4.65.war"\n                         rel="nofollow">点我下载</a>&gt;。</p>\n<p>然后将war包放置到web容器中。Hawtio支持多种servlet规范的web容器，如中国javaer最喜欢的tomcat和jetty，还有Karaf\n    、Wildfly(Jboss)等。每种容器的配置都有些许不同，我们这里只说明如何配置Tomcat，其他容器的配置方法见<a title="Hawtio的配置说明"\n                                                                  href="http://hawt.io/configuration/index.html"\n                                                                  rel="nofollow">Hawtio的配置说明</a>。</p>\n<p>使用的tomcat并没有多少配置，如果不需要管理用户权限的话，把download的war包直接丢到webapps里启动tomcat就可以看到以下页面了：</p>\n<p><img alt="Vert.x Dropwizard指标数据监控" height="337"\n        src="https://file.mahoooo.com/res/file/vertx_metrics_using_dropwizard_2018_5_7_1.png" width="600"></p>\n<p>然后点击Connect栏,可以看到以下内容：</p>\n<p><img alt="Vert.x Dropwizard指标数据监控" height="319"\n        src="https://file.mahoooo.com/res/file/vertx_metrics_using_dropwizard_2018_5_7_2.png" width="600"></p>\n<p>\n    在表单中填写连接内容：Name随便取一个即可、Scheme选择默认的http、Host填写主机地址（本例是在本地运行，使用127.0.0.1或者localhost）、端口使用前面启动Jolokia使用的端口、Path选择Jolokia。然后点击Connect\n    to remote server。</p>\n<p>连接成功后点击左上角导航栏里的JMX（其他菜单可以看到cpu、内存、线程的使用情况等）。下图就是Hawtio图形化的指标数据，提供多种图标（Chart）。这里的文件夹名称“vertx-metrics”就是在上面代码 <span\n        style="color:#0000FF"><em>setJmxDomain("vertx-metrics")&nbsp;</em></span>中命名的domian名称。</p>\n<p><img alt="Vert.x Dropwizard指标数据监控" height="392"\n        src="https://file.mahoooo.com/res/file/vertx_metrics_using_dropwizard_2018_5_7_3.png" width="800">&nbsp;&nbsp;&nbsp;\n</p>\n<p>Hawtio除了展示Vertx相关的所有数据外，还可以看到Jvm相关的其他数据，例如Cpu、堆、栈、线程池等。如果需要的话，还可以把自己定义更多的监控数据传递到Hawtio显示。</p>\n\n<h3 id="h3-5">Hawtio权限管理</h3>\n<p>上面例子说明了如何使用Hawtio展示指标数据。但是任何使用者都可以查看到相关数据。Hawtio提供了开箱即用的用户权限控制功能。需要针对不同的容器环境进行配置。这里以tomcat为例。</p>\n<p>在tomcat的启动脚本中添加下面的参数：</p>\n<p>linux：</p>\n<pre class="bash"><code class="bash"><span class="code-built_in"><span class="code-built_in">export</span></span> CATALINA_OPTS=<span\n        class="code-string"><span class="code-string">\'-Dhawtio.authenticationEnabled=true -Dhawtio.role=manager\'</span></span></code></pre>\n<p>windows：</p>\n<pre class="bash"><code class="bash"><span class="code-built_in"><span class="code-built_in">set</span></span> JAVA_OPTS=-Dhawtio.authenticationEnabled=<span\n        class="hljs-literal"><span class="hljs-literal">true</span></span>\n</code></pre>\n<p>然后Hawtio会使用tomcat的用户权限来控制自身的用户权限。也就是说，如果在 %TOMCAT_HOME%/conf/tomcat-users.xml中配置了以下内容：</p>\n<pre class="xml"><code class="xml"><span class="code-tag"><span class="code-tag">&lt;</span><span\n        class="code-name"><span class="code-tag"><span class="code-name">user</span></span></span><span\n        class="code-tag"> </span><span class="hljs-attr"><span class="code-tag"><span class="hljs-attr">username</span></span></span><span\n        class="code-tag">=</span><span class="code-string"><span class="code-tag"><span\n        class="code-string">"user"</span></span></span><span class="code-tag"> </span><span class="hljs-attr"><span\n        class="code-tag"><span class="hljs-attr">password</span></span></span><span class="code-tag">=</span><span\n        class="code-string"><span class="code-tag"><span class="code-string">"passwd"</span></span></span><span\n        class="code-tag"> </span><span class="hljs-attr"><span class="code-tag"><span\n        class="hljs-attr">roles</span></span></span><span class="code-tag">=</span><span class="code-string"><span\n        class="code-tag"><span class="code-string">"tomcat"</span></span></span><span\n        class="code-tag">/&gt;</span></span></code></pre>\n<p>则可以使用user/passwd作为账号密码登录Hawtio。</p>\n<p>配置生效后输入Hawtio的地址会跳转到下面这个页面。</p>\n<p><img alt="Vert.x Dropwizard指标数据监控" height="243"\n        src="https://file.mahoooo.com/res/file/vertx_metrics_using_dropwizard_2018_5_7_4.png" width="400"></p>\n<p>只有登录成功才能继续访问其他资源。</p>\n<p>现在，你的Vert.x已经有了一个牛逼闪闪的图像化监控工具。当然，本文提到的工具不仅仅只能用于监控Vert.x，只要稍加改动，可以监控JVM的方方面面。</p>'},418:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<p>\n    微服务从2013年（或许更早）开始就越来越热，从BAT之类的巨头到小小的只有几个人的技术公司，无不在谈论微服务。虽然现在才火热起来，但是实际上微服务的概念早在半个世纪之前在理论层面就出现了。关于微服务理论介绍的文章太多，口才优秀的人可以分成上中下九章给你说上一天，本文仅用于总结微服务知识结构，略做引导。</p>\n<h2 id="h2-1">云源生（Cloud Native）</h2>\n<p>\n    现在但凡和软件技术有点裙带关系的机构、组织、人士都在谈论各种“云”。还有不少公司以云××、××云、×云×作为公司的名称。与IT技术沾一点边或者完全不沾边的各路人马都可以随时抛出“云应用”、“云计算”、“云数据”等听起来就很高大上的术语持续忽悠着你。</p>\n<p>对于云技术（微服务）而言，2013年是一个分水岭，在这之前有一些零散的分布式应用的意识，但是没有一个系统性的概括。然后在2013年<strong>Matt Stine</strong>的<strong>Cloud\n    Native</strong>概念横空出世。<strong>Cloud Native</strong>是一系列概念的集合，围绕这一系列标准可以构建从技术架构、到运维管理、再到团队协作的整体性框架。他让基于微服务的应用搭建过程成为一个标准流程，主要涵盖以下几点内容。\n</p>\n<ol>\n    <li>\n        <p><strong>微服务（分布式系统）</strong>。</p>\n        <ul>\n            <li>首先，微服务本身就是一个很具体的概念，简单的说就是：根据性能要求横向拆分为相同功能的负载均衡节点，根据业务要求纵向拆分为不同功能的服务节点。</li>\n            <li>其次，微服务这个术语下还涵盖了大量概念，也是一个概念的集合，比如：<em>熔断、降级、心跳检查、消息队列、负载均衡、服务注册、服务发现、去中心化、服务通信（RPC、RMI、TCP/IP)、分布式事物（分布式数据库）、分布式存储、分布式同步对象（数据）、缓存穿透、缓存雪崩、业务追踪、统一日志管理、API网关</em>等等。每一个概念都是一种标准，都有一项或多项技术在支撑。通常优秀的微服务框架都会实现以上部分功能，同时支持内部或外部扩展。比如要防止缓存穿透可以自己写一个Bloom\n                Filter（布隆过滤器），或者缓存用Redis（&gt;4.0)并添加过滤器插件，再或者在物理缓存之前再使用Redisson、Hazelcast之类的内存级缓存。\n            </li>\n            <li>最后，微服务也特指云服务分布式系统的底层技术。比如Dubbo、Spring Cloud、以及后面要提到的一系列Service Mesh框架等，都会把他们称为微服务框架。</li>\n        </ul>\n        <p>虽然微服务这个术语自身已经有了足够丰富的内容，但是他仅仅是“云”技术的一个环节。</p>\n    </li>\n    <li>\n        <p><strong>康威定律</strong>。</p>\n        <p>在使用微服务框架的时候，不知道各位有没有想过这些问题：为什么微服务技术或团队是现在的结构？为什么微服务开发需要和敏捷模型（迭代模型）配合？为什么使用微服务的公司能够容忍团队之间使用不同的语言？</p>\n        <p>以上这些问题早在半个世纪之前就给出了答案——康威定律。康威定律是微服务技术团队的基础理论，他主要由四个定律组成：</p>\n        <ol>\n            <li>\n                <p><strong>组织的沟通方式通过系统的设计结构来约束</strong>：沟通成本呈现指数增长（人于人之间的连线），必须把业务/小团队边界压缩在固定人员中（5~15人）。</p>\n            </li>\n            <li>\n                <p><strong>无法完美但能高效</strong>。Bug永远有，与其追求无Bug的完美系统，不如追求可允许的修复速度，进而通过反复验证强化系统。这是敏捷开发、持续集成发布、自动化监控的本源——即使测试覆盖到100%也没法避免不出现bug，但是能在波及面可控的范围内快速解决问题。\n                </p>\n            </li>\n            <li>\n                <p><strong>线性团队同质化，业务团队内聚化</strong>。看下面2个图就明白（图片来源于网络，如有侵权请联系立即删除）。</p>\n                <p>1）<img src="http://img4.tbcdn.cn/L1/461/1/f4c2d4a8f8390ca6be19b54a524c8272aced3e34" alt="微服务架构概念索引"\n                          class="zoom-in-cursor"></p>\n                <p>2）<img src="http://img3.tbcdn.cn/L1/461/1/c827db7a12d730140d4c0e6947535e168902a73e" alt="微服务架构概念索引"\n                          title="分布式团队" class="zoom-in-cursor"></p>\n                <p>图1）是一个线性团队，前端、后端、数据库分工明确层次清晰，然后开发出来的系统也会呈现出对应的样子，因为团队划分的结构决定了系统的最终形态。</p>\n                <p>图2）是一个以业务划分的团队，每一个团队都有一个完整的从前端到后端的“生态”。然后开发出来的系统就会各成一派别。</p>\n                <p>\n                    第三定律告诉我们小团队内部的沟通往往密集而且更加高效，按照这个方式划分的每个子系统自然会逐渐内聚，而团队之间更加倾向以接口沟通耦合性更低。仔细观察，现在包括BAT在内的互联网公司都是图2的团队结构。</p>\n            </li>\n            <li>\n                <p><strong>系统的拆解倾向性</strong>。在架构演进的过程中，随着系统规模的增加合理的解决方法都是将复杂的问题拆分。比如数据库并发太高无法承担了，我们一般会执行以下几个步骤：</p>\n                <ol>\n                    <li>增加Redis之类的缓存工具，将原本是物理数据库的一个问题拆解成2个子问题，并分别去解决对应的更多问题。</li>\n                    <li>横向按字段拆表，将一些频繁更新的字段独立到独立的表去以关联的形式存在。</li>\n                    <li>纵向按照数据业务特征（例如时间）分区数据。</li>\n                </ol>\n            </li>\n        </ol>\n    </li>\n    <li>\n        <p><strong>敏捷开发与敏捷基础设施</strong>：在康威定律中已经解释了敏捷开发（迭代开发）对于微服务架构的重要性。说白了敏捷开发就是一种流程规范外加一些适合与流程规范的工具，比如GitLab、Jira之类的工具等被称为敏捷基础设施，敏捷工具和方法众多，比如每日站会、卡片式任务等等，这需要根据团队的需要和结构因地适宜。\n        </p>\n    </li>\n    <li>\n        <p><strong>DevOps</strong>：DevOps（Development、Operations）并没有指定具体的技术实现，他就是一个从软件开发到产品上线发布的流程规范，只不过这个流程现在有大量的工具为我们提供支持。流程包括：\n        </p>\n        <ol>\n            <li>需求管理。</li>\n            <li>编码开发，单元测试（Junit、Jest白盒测试）。</li>\n            <li>QA（黑盒测试）。自动化测试（Server walker）、代码质量监控（Sonar、EsLint）、接口测试（Jmeter、Loadrunner）。</li>\n            <li>上线发布运维。包括压力测试、多节点的运维管理、以及<em>Cloud Foundry</em>, <em>Kubernetes</em>, <em>Apache YARN</em>, and <em>Apache\n                Mesos</em>等云平台的使用。\n            </li>\n        </ol>\n        <p>这其中每一个过程都可以写成一本书。本人比较推崇CMMI的敏捷模型配合各种工具来使用。</p>\n    </li>\n    <li>\n        <p><strong>CI（Continuous Integration）/CD（Continuous Deployment）</strong>：个人理解CI/CD应该属于DevOps的范畴，他的核心关注点在程序员代码交付和缺陷测试之上。我们知道在任何时候，技术开发人员和测试人员都应该是密切配合的，一个迭代周期之内应该是开发推进测试，测试驱动开发。并不用把这个过程想象得太复杂，实际上可以用Jenkins相关的各种插件实现代码持续集成、自动化检测、测试环境持续发布上线。\n        </p>\n    </li>\n    <li>\n        <p><strong>更多内容</strong>：除了以上几点，<strong>Cloud Native</strong>还涵盖了对一些细节的描述，比如分布式事物（最终一致性、容错性、可用性、缓存与实体同步）、弹性伸缩等。\n        </p>\n    </li>\n</ol>\n<p><strong>相关文章和博客</strong>：</p>\n<ol>\n    <li><a href="https://www.mattstine.com/microservices/">微服务学习阅读清单</a>：这是本节开始提到的<strong>Matt Stine</strong>个人博客提供的阅读学习清单，对于了解云技术非常有价值。附带说下，在<strong>Matt\n        Stine</strong>2013年提出<strong>Cloud Native</strong>时还是<em>Pivotal</em>的<em>Cloud Foundry</em>负责人之一，现在已经是<em>Pivotal</em>的CTO了。有空也可以看看他的各种推文。附带推荐这篇文章——<a\n            href="https://blog.csdn.net/xxfigo/article/details/78810405">关于Cloud Native架构与Matt Stine的一次对话</a>。\n    </li>\n    <li><a href="https://yq.aliyun.com/articles/8611">微服务架构的理论基础-康威定律</a>：这篇文章对康威定律的介绍非常透彻，也有许多自己的解读。值得一读。</li>\n</ol>\n<h2 id="h2-2">Micro Service与Service Mesh</h2>\n<p>到目前为止微服务这个概念或者相关技术已经发展了许多年，相关的问题不断的被发现和解决，理论也在不断的完善。现在最火热的技术当属Service\n    Mesh，在很多人看来它代表了微服务的最近技术潮流，或被称为第二代微服务技术。目前Service Mesh具有代表性的开源项目主要是：</p>\n<ol>\n    <li><a href="https://github.com/linkerd/linkerd" title="Linkerd">Linkerd</a>。</li>\n    <li><a href="https://github.com/envoyproxy/envoy">Envoy</a>。</li>\n    <li><a href="https://github.com/istio/istio">Istio</a>。</li>\n    <li><a href="https://github.com/runconduit/conduit">Conduit</a>。</li>\n    <li><a href="https://github.com/nginxinc/nginmesh">NginMesh</a>。</li>\n    <li><a href="https://github.com/Kong/kong">Kong</a>。</li>\n</ol>\n<p>上面这些项目，最火热的当属<strong>Istio</strong>了，含着金钥匙出生自大厂（Google、IBM）。上面的技术框架中前两者被称呼为第一代Service\n    Mesh，后面的被称为第二代。据说国内唯品会公司的技术团队长期致力于Service Mesh的使用，不过没看到什么开源的项目出现。</p>\n<p>一句话总结Service Mesh与之前微服务技术的差异：非侵入、分层设计、伴随模式（SideCar）。</p>\n<p>关于Micro Service与Service Mesh的几篇优秀的博文：</p>\n<ol>\n    <li><a href="https://www.cnblogs.com/xishuai/p/microservices-and-service-mesh.html">微服务和服务网格架构概念整理</a>这是百度搜索的排名第一，内容优秀。\n    </li>\n    <li><a href="https://www.itcodemonkey.com/article/8072.html">唯品会的Service Mesh三年进化史</a>我最早接触到Service\n        Mesh的概念是源于和一名前唯品会架构师的合作，后来搜到了这篇文章。本文优点在于他在介绍演进过程的同时还将很多实现基本功能的开源技术都罗列了出来，对新上项目做技术选型有不错的参考价值。\n    </li>\n    <li><a href="https://www.sohu.com/a/235831137_268033">蚂蚁金服的 Service Mesh 演进之道</a>这篇文章介绍了Service\n        Mesh在金融级别的解决方案，细节介绍比较透彻。同时还讲解了一些从传统架构迁移到Service Mesh的经验。\n    </li>\n</ol>\n<p>从后面的这2篇文章可以看到，国内的大公司虽然起初都有使用开源Service Mesh框架的意愿，但是都走上的自研的道路。目前的各路Service Mesh架构远没达到Spring\n    Cloud这种开箱即用层度，用来之后要花许多时间去解决各种坑，小规模团队慎用。</p>\n<h2 id="h2-3">Boiler Plate Patterns与Boilerplate</h2>\n<p><strong>Boiler Plate Patterns</strong>这个词来源于Spring官网关于Spring\n    Cloud的介绍，直译为“锅炉样板模式”。首次见到时略微迷惑，曾一度怀疑自己之前对设计模式的理解是不是有什么偏差。经过一番了解之后有了大致的心得，在此记录总结。</p>\n<p>原文在Spring Cloud的开篇位置：“Coordination of distributed systems leads to boiler plate patterns, and using Spring Cloud\n    developers can quickly stand up services and applications that implement those\n    patterns.”按字面意思直译为：一个平衡和谐的分布式系统会导致“锅炉样板模式”，使用Spring Cloud能够让开发者通过这个模式快速的搭建服务和应用。<strong>Boiler Plate\n        Patterns</strong>这个术语概括总结Spring Cloud的基本使用模式，所以弄明白它背后的安逸对于使用Spring Cloud非常重要。</p>\n<p>很多后端开发的码友应该知道<strong>样板式代码</strong>的问题，它的英文原文就是<strong>Boilerplate Code</strong>。在很多长期维护的系统中，经过几代人的“耕耘”之后样板式代码的问题尤为明显。此外在前端开发中，\n    Boilerplate是一个著名的开源HTML模板，也指代那些以及制作好，只要修改文字内容的网站模板。所以<strong>Boiler Plate Patterns</strong>可以理解为Spring\n    Cloud为每一个微服务节点提供一种开发样板，业务开发人员按照样板结构去开发即可。一个优秀的架构师在做技术选型或编写底层框架时，时时刻刻都会考虑面向业务的开发人员会以何种方式去使用框架，有统一的样板或者模式来遵循是对于任何刚使用框架的开发者都是非常有价值的。\n</p>\n<h2 id="h2-4">Memory Footprint、TPS、QPS</h2>\n<p>评估微服务框架优劣的主要有三个指标，分别是Memory Footprint、TPS、QPS。Memory Footprint是指内存占用情况，按照蚂蚁金服那一篇Service\n    Mesh文章的介绍，一个与应用伴随的微服务节点占用内存应该控制在20M以下。按照Java的Jvm机制内存的占用并不太好评估，但是非大文件处理的应用控制在50M以内。\n    TPS（Transactions Per Second，事物处理/秒）和QPS（Queries Per Second，查询处理/秒）一般用于衡量吞吐量，通常大规模应用的TPS会要求过万。</p>\n<p>这也是Golang在高并发分布式的新环境下发展出来的优势，很多Golang节点的TPS能到十万级别，而内存占用能控制在20M以内。</p>'}});