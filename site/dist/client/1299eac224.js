webpackJsonp([12],{381:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<p><a href="https://www.chkui.com/article/spring/spring_core_bean_post_processors" title="Spring核心——IOC处理器扩展">上一篇文章</a>介绍了非侵入式的框架的概念以及IOC的功能扩展点之一——BeanPostProcessor，我们接下来的内容继续说明IoC更多的扩展方法。\n</p>\n\n<h2 id="h2-1">BeanFactoryPostProcessor</h2>\n<p>BeanFactoryPostProcessor是针对整个容器的后置处理器。他的使用也非常简单，只要向容器中添加一个继承BeanFactoryPostProcessor的Bean即可。</p>\n\n<h3 id="h3-1">如何使用</h3>\n<p>继承了BeanFactoryPostProcessor接口的类PostProcessors：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.xml.beanfactorypostprocessor;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">PostProcessors</span> <span class="code-keyword">implements</span> <span\n            class="code-title">BeanFactoryPostProcessor</span></span>{\n<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span\n            class="code-keyword">throws</span> BeansException </span>{\n         <span class="code-comment">//DO</span>\n    }\n}</code></pre>\n<p>然后再向容器中添加这个Bean就增加了一个BeanFactoryPostProcessor。</p>\n<pre><code class="xml"><span class="php"><span class="code-meta">&lt;?</span>xml version=<span\n        class="code-string">"1.0"</span> encoding=<span class="code-string">"UTF-8"</span><span\n        class="code-meta">?&gt;</span></span>\n<span class="code-comment">&lt;!-- xml.beanfactorypostprocessor --&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">beans</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"chkui.springcore.example.xml.beanfactorypostprocessor.PostProcessors"</span> /&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>BeanFactoryPostProcessor主要用于处理容器相关的内容，他被触发时机是在IoC容器加载完各种配置后，还没执行Bean的初始化之前。这个时候除了PostProcessors这个Bean，其他任何Bean都没有被创建。&nbsp;所以在BeanFactoryPostProcessor处理Bean是不合适的，Bean应该要到BeanPostProcessor中去处理，2者的区别就是前者面向容器，后者面向Bean。接下来将通过一个详细例子来说明BeanFactoryPostProcessor和BeanPostProcessor的区别以及使用方式。期间还会介绍BeanDefinitio相关的内容。</p>\n\n<h3 id="h3-2">BeanFactoryPostProcessor与BeanPostProcessor使用</h3>\n<p><span style="color:#e74c3c">（文中仅仅是示例代码，无法运行，源码在</span><a href="https://gitee.com/chkui-com/spring-core-sample"\n                                                            rel="nofollow"><span style="color:#e74c3c">https://gitee.com/chkui-com/spring-core-sample</span></a><span\n        style="color:#e74c3c">，如需下载请自行clone）</span></p>\n\n<h4 id="h4-1"><span style="color:null">建造者模式</span></h4>\n<p>下面将会通过一个例子介绍2者的使用方式和使用场景。例子使用建造者模式模拟组装一台个人电脑，分为一下3步：</p>\n<ol>\n    <li>&nbsp;容器启动之后，会将电脑的所有“配件”（Cpu、Graphics、Ram）都添加到容器中。</li>\n    <li>&nbsp;在PostProcessorS实现BeanFactoryPostProcessor接口，它的功能是向容器添加一个Pc对象。</li>\n    <li>&nbsp;在PostProcessor实现BeanPostProcessor接口。他的工作是组装电脑——每一个Bean都会检查域上的@Autowired注解，并注入对应的部件，部件也会标记自己所属的电脑。</li>\n</ol>\n<p>下面是XML配置文件，它负责将Cpu、显卡、内存等电脑常用品牌的部件放置到容器中等待组装。此外它还添加了PostProcessorS和PostProcessor两个后置处理器用于装载电脑。</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"chkui.springcore.example.xml.beanfactorypostprocessor.bean.Cpu"</span>&gt;</span>\n     \t<span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"brand"</span> <span class="hljs-attr">value</span>=<span\n                class="code-string">"Amd"</span>/&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n    \n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"chkui.springcore.example.xml.beanfactorypostprocessor.bean.Graphics"</span>&gt;</span>\n     \t<span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"brand"</span> <span class="hljs-attr">value</span>=<span class="code-string">"Nvdia"</span>/&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n    \n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"chkui.springcore.example.xml.beanfactorypostprocessor.bean.Ram"</span>&gt;</span>\n     \t<span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"brand"</span> <span class="hljs-attr">value</span>=<span class="code-string">"Kingston"</span>/&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n    \n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"chkui.springcore.example.xml.beanfactorypostprocessor.PostProcessor"</span> /&gt;</span>\n    \n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"chkui.springcore.example.xml.beanfactorypostprocessor.PostProcessors"</span> /&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>下面是一个Cpu对象的结构，他标记了品牌和所属电脑。Graphics和Ram的结构和它一模一样。</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.xml.beanfactorypostprocessor.bean;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Cpu</span> </span>{\n\t<span class="code-keyword">private</span> String brand;\n\t\n\t<span class="code-meta">@Autowired</span>\n\t<span class="code-keyword">private</span> Pc belong;\n}</code></pre>\n<p>注意这里的@Autowired注解，我们的配置文件并没有开启Spring的自动装配功能，我们将在PostProcessor实现自动装配。</p>\n<p>PostProcessorS的作用是向容器动态添加一个之前未定义的Bean——Pc。</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.xml.beanfactorypostprocessor;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">PostProcessors</span> <span class="code-keyword">implements</span> <span\n            class="code-title">BeanFactoryPostProcessor</span></span>{\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span\n            class="code-keyword">throws</span> BeansException </span>{\n\t\t<span class="code-comment">//获取容器的注册接口</span>\n\t\tBeanDefinitionRegistry registry = (BeanDefinitionRegistry)beanFactory;\n\t\t<span class="code-comment">//新建一个BeanDefinition用于动态装配Bean</span>\n\t\tGenericBeanDefinition defininition = <span class="code-keyword">new</span> GenericBeanDefinition();\n\t\t<span class="code-comment">//设置要添加的类</span>\n\t\tdefininition.setBeanClass(Pc.class);\n\t\t<span class="code-comment">//注册BeanDefinition</span>\n\t\tregistry.registerBeanDefinition(<span class="code-string">"postBean"</span>, defininition);\n\t}\n}</code></pre>\n<p>如果看过 <a href="https://www.chkui.com/article/spring/spring_core_context_and_ioc" title="Spring核心——上下文与IoC">Ioc结构介绍的这篇文章</a>，你就会知道BeanFactory经过层层派生，实际上大部分接口都在一个类实现——DefaultListableBeanFactory，它除了实现ConfigurableListableBeanFactory接口，还实现了BeanDefinitionRegistry接口。BeanDefinitionRegistry提供了BeanDefinition的管理功能。\n</p>\n\n<h4 id="h4-2">BeanDefinition与适配器模式</h4>\n<p>\n    在上面的代码中出现了BeanDefinition接口，这里就顺道说一说这个有趣的小玩意。关于他如何使用Spring的官网并没有太详细的介绍（至少我没找到），网上倒是有各路大神的博客在解读他的源码，不过代码只是表象，要理解他的整套设计思路才能提升。</p>\n<p>关于BeanDefinition的使用模式，官网将其称呼为<em>configuration metadata</em>，直译过来叫“配置元数据”。&nbsp;他的作用有点类似于<a\n        href="https://www.chkui.com/article/spring/spring_core_context_and_ioc" title="Spring核心——上下文与IoC">Context分层应用的效果（见Spring核心——上下文与IoC&nbsp;关于\n    ApplicationContext的说明）</a>，目的就是将Bean的配置和初始化工作分成2个互不干扰的部分。</p>\n<p>我们知道 Spring现在支持各种各样的方式来添加Bean，比如在XML配置文件中使用&lt;bean&gt;标签、使用@Component以及他的派生类注解、可以在@Configuration类中生成、甚至还可以通过RMI实现远程配置等等。如果所有的这些配置来源直接和IoC容器产生关系生成Bean，那么耦合度、代码复杂度会越来越高，而且以后指不定什么时候又会加入什么新的配置方式。</p>\n<p>\n    为了解决这个问题Spring的大神们引入了适配器模式——IoC容器只接受BeanDefinition接口，IoC如何初始化一个Bean是仅仅是看BeanDefinition里的信息。而各种配置方式都有自己的适配器，所有的适配器都会根据他所需要处理的内容来生成一个BeanDefinition的实现类。这样，如果新增一个新的配置方式，增加一个适配器就可以搞定。</p>\n<p><img align="left" alt="Spring核心——IOC功能扩展点" height="381"\n        src="https://static.oschina.net/uploads/img/201807/11171429_ggwk.png" width="600"></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p>所以，我们也可以利用BeanDefinitionRegistry接口向容器添加一个BeanDefinition，进而在随后的执行过程中IoC容器会根据 这个BeanDefinition创建一个对应的Bean。</p>\n\n<h4 id="h4-3">BeanPostProcessor</h4>\n<p>\n    前面已经提到，BeanFactoryPostProcessor用于处理容器级别的问题，而BeanPostProcessor用来处理每一个Bean。我们前面已经用BeanFactoryPostProcessor向容器添加了一个Pc对象的Bean，接下来我们在BeanPostProcessor中处理每一个Bean的自动注入注解。</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.xml.beanfactorypostprocessor;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">PostProcessor</span> <span class="code-keyword">implements</span> <span\n            class="code-title">BeanPostProcessor</span>, <span class="code-title">BeanFactoryAware</span> </span>{\n\t<span class="code-keyword">private</span> ConfigurableListableBeanFactory beanFactory;\n\t<span class="hljs-function"><span class="code-keyword">public</span> Object <span class="code-title">postProcessBeforeInitialization</span><span\n            class="hljs-params">(Object bean, String beanName)</span> </span>{\n        <span class="code-keyword">return</span> autowiredImplement(bean);\n    }\n\t<span class="hljs-function"><span class="code-keyword">public</span> Object <span class="code-title">postProcessAfterInitialization</span><span\n            class="hljs-params">(Object bean, String beanName)</span> </span>{\n        <span class="code-keyword">return</span> bean;\n    }\n\t\n\t<span class="code-comment">//自定义实现autowired功能</span>\n\t<span class="hljs-function"><span class="code-keyword">private</span> Object <span class="code-title">autowiredImplement</span><span\n            class="hljs-params">(<span class="code-keyword">final</span> Object bean)</span> </span>{\n\t\t<span class="code-keyword">for</span>(Field field : bean.getClass().getDeclaredFields()) {\n\t\t\tAutowired value = field.getAnnotation(Autowired.class);\n\t\t\t<span class="code-keyword">if</span>(<span class="code-keyword">null</span> != value) {\n\t\t\t\tObject obj = beanFactory.getBean(field.getType());\n\t\t\t\tfield.setAccessible(<span class="code-keyword">true</span>);\n\t\t\t\tfield.set(bean, obj);\n\t\t\t}\n\t\t}\n\t\t<span class="code-keyword">return</span> bean;\n\t}\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setBeanFactory</span><span class="hljs-params">(BeanFactory beanFactory)</span> <span\n            class="code-keyword">throws</span> BeansException </span>{\n\t\t<span class="code-keyword">this</span>.beanFactory = (ConfigurableListableBeanFactory)beanFactory;\n\t}\n}</code></pre>\n<p>这里的PostProcessor实现BeanFactoryAware接口来获取&nbsp;BeanFactory。自动注入的处理逻辑都在autowiredImplement方法中，它会扫描Bean的每一个域检查是否有@Autowired注解，如果有则根据这个域的Class类型到BeanFactory去获取对应的Bean，然后反射注入。</p>\n<p>最后我们创建一个ApplicationContext来运行他们：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">SampleApp</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n    \tApplicationContext context = <span class="code-keyword">new</span> ClassPathXmlApplicationContext(<span\n            class="code-string">"xml/beanfactorypostprocessor/config.xml"</span>);\n    \tPc pc = context.getBean(Pc.class);\n        <span class="code-comment">/**\n        Pc Info: Graphics=Nvdia, Cpu=Amd, Ram=Kingston]\n        */</span>\n        System.out.println(pc);\n    }\n}</code></pre>\n<p>本文介绍了BeanFactoryPostProcessor和BeanPostProcessor的使用方式，以及IoC容易是如何通过BeanDefinition装载各种配置的。后续还会持续介绍Spring\n    IoC容器的各种功能扩展点。</p>'},388:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h2 id="h2-1">抽象环境的概念</h2>\n<p>在介绍Spring核心模块为运行环境管理提供的功能之前，咱们先得解释清楚“运行环境”是什么。</p>\n<p>\n    码砖早年，对上下文（Context）、环境（Environment）一直都是傻傻分不清楚，感觉2者都是放了一堆参数在里面，貌似并没有多大区别。后来才慢慢摸清楚这2个词的套路。上下文（Context）是用来处理分层传递的，不清楚的可以看看<a\n        href="https://www.chkui.com/article/spring/spring_core_context_and_ioc" title="上下文与IoC">上下文与IoC</a>一文关于ApplicationContext的介绍。\n</p>\n<p>\n    而环境（Environment）是指当前运行程序之外的各种“全局变量”，这些变量反映了当前软件运行的各种外部情况。例如我们执行System.getenv()方法，就会获取到当前包括操作系统、全局路径配置、磁盘、jdk版本等等信息。这些信息实际上与当前运行的程序是无关的——无论你是否启动JVM，这些环境变量都是客观存在的。</p>\n<p>既然环境的作用是体现当前运行的各种外部情况，那么除了JVM启动时提供的固定参数，也可以指定我们需要的环境变量。例如我们最常见的环境——开发环境、测试环境、集成QA环境、仿真环境、生产环境等。</p>\n\n<h2 id="h2-2">Profile特性</h2>\n<p>对于软件开发而言经常要控制的就是当前程序是在开发环境运行还是在生产环境运行。除了后面要介绍的Spring Profile功能，还有各种各样的方法来进行控制，比如Maven的profile标签。Spring&nbsp;Profile只是一种环境控制的参考手段，他的好处是可以在代码级别去控制，具体使用什么根据项目的需要去考量。</p>\n<p>Spring的Profile特性使用起来并不复杂，而且同时支持Java注解和XML配置。我们通过几段代码来说明如何使用Profile。</p>\n\n<h3 id="h3-1">纯Java常规使用</h3>\n<p>（以下案例的可执行代码请到<a href="https://gitee.com/chkui-com/spring-core-sample" rel="nofollow">gitee</a>下载，）</p>\n<p>定义一个servuce接口和三个service的实现类：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.profile.service;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n            class="code-title">Blizzard</span> </span>{\n\t<span class="hljs-function">String <span class="code-title">getName</span><span class="hljs-params">()</span></span>;\n}</code></pre>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.profile.service.blizzard;\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">Warcraft</span> <span\n        class="code-keyword">implements</span> <span class="code-title">Blizzard</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span\n            class="code-title">getName</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"Warcraft"</span>;\n\t}\n\n}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">WorldOfWarcraft</span> <span\n        class="code-keyword">implements</span> <span class="code-title">Blizzard</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span\n            class="code-title">getName</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"World of Warcraft"</span>;\n\t}\n\n}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">Overwatch</span> <span\n        class="code-keyword">implements</span> <span class="code-title">Blizzard</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span\n            class="code-title">getName</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"Overwatch"</span>;\n\t}\n}</code></pre>\n<p>然后我们通过纯Java配置讲接口的每个实现添加到容器中：</p>\n<pre><code class="java"><span class="code-meta">@Configuration</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">EnvironmentApp</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\t<span class="code-comment">//在启动容器之前，先指定环境中的profiles参数</span>\n\t\tSystem.setProperty(<span class="code-string">"spring.profiles.active"</span>, <span\n            class="code-string">"wow"</span>);\n\t\tApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(EnvironmentApp.class);\n        <span class="code-comment">//当前的profile值是wow，所以获取的实现类是worldOfWarcraft</span>\n\t\tBlizzard blizzard = ctx.getBean(Blizzard.class);\n\t}\n\t\n\t<span class="code-meta">@Bean</span>\n\t<span class="code-meta">@Profile</span>(<span class="code-string">"war"</span>)\n\t<span class="hljs-function"><span class="code-keyword">public</span> Blizzard <span\n            class="code-title">warcraft</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> Warcraft();\n\t}\n\t\n\t<span class="code-meta">@Bean</span>\n\t<span class="code-meta">@Profile</span>(<span class="code-string">"wow"</span>)\n\t<span class="hljs-function"><span class="code-keyword">public</span> Blizzard <span class="code-title">worldOfWarcraft</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> WorldOfWarcraft();\n\t}\n\t\n\t<span class="code-meta">@Bean</span>\n\t<span class="code-meta">@Profile</span>(<span class="code-string">"default"</span>)\n\t<span class="hljs-function"><span class="code-keyword">public</span> Blizzard <span\n            class="code-title">overwatch</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> Overwatch();\n\t}\n}</code></pre>\n<p>@Configuration类中每一个@Bean注解之后都有一个@Profile注解。@Profile中的字符串就标记了当前适配的环境变量，他配合<em>System.setProperty("spring.profiles.active",\n    "wow");</em>这一行一起使用。当设定环境参数为wow时，标记了@Profile("wow")的方法会被启用，对应的Bean会添加到容器中。而其他标记的Bean不会被添加，当没有适配到任何Profile值时，@Profile("default")标记的Bean会被启用。\n</p>\n<p>Spring Profile的功能就是根据在环境中指定参数的方法来控制@Bean的创建。</p>\n\n<h2 id="h2-3">在@Configuration上配置Profile</h2>\n<p>@Profile注解除了在@Bean方法上使用，也可以用于@Configuration类上。这样使用可以一次性控制多个Bean的加载。例如下面的例子：</p>\n<pre><code class="java"><span class="code-meta">@Configuration</span>\n<span class="code-meta">@Profile</span>(<span class="code-string">"cast"</span>)\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">CastConfig</span> </span>{\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> Castlevania <span class="code-title">castlevania</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> Castlevania();\n\t}\n}\n\n<span class="code-meta">@Configuration</span>\n<span class="code-meta">@Profile</span>(<span class="code-string">"pes"</span>)\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">PESConfig</span> </span>{\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> ProEvolutionSoccer <span class="code-title">proEvolutionSoccer</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> ProEvolutionSoccer();\n\t}\n}</code></pre>\n<p>\n    这样可以控制整个@Configuration类中的Bean是否加载。这个时候如果在@Configuration类上还标注了@Import注解，那么被@Import引入的类中的@Bean也不会添加到IoC容器中，那么这对统一配置环境是很有好处的。</p>\n<p>需要注意的是，如果这个时候又在@Bean之上添加了@Profile注解，那么Spring最终会根据@Bean之上的标签来执行。例如：</p>\n<pre><code class="java"><span class="code-meta">@Configuration</span>\n<span class="code-meta">@Profile</span>(<span class="code-string">"cast"</span>)\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">CastConfig</span> </span>{\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> Castlevania <span class="code-title">castlevania</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> Castlevania();\n\t}\n\t<span class="code-meta">@Bean</span>\n    <span class="code-meta">@Profile</span>(<span class="code-string">"pes"</span>)\n\t<span class="hljs-function"><span class="code-keyword">public</span> ProEvolutionSoccer <span class="code-title">proEvolutionSoccer</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> ProEvolutionSoccer();\n\t}\n}</code></pre>\n<p>当环境中的profile值包含"pes"时候，@Profile("pes")标注的这个Bean就会添加到IoC容器中。</p>\n\n<h2 id="h2-4">Profile的XML配置</h2>\n<p>Profile特性也可以在XML配置。不过只能在&lt;beans&gt;标签上进行：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span> <span\n        class="hljs-attr">...</span> &gt;</span>\n\t<span class="code-tag">&lt;<span class="code-name">beans</span> <span class="hljs-attr">profile</span>=<span\n            class="code-string">"ff"</span>&gt;</span>\n\t\t<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n                class="code-string">"chkui.springcore.example.hybrid.profile.service.squareenix.FinalFantasy"</span> /&gt;</span>\n\t<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span>\n\t<span class="code-tag">&lt;<span class="code-name">beans</span> <span class="hljs-attr">profile</span>=<span\n            class="code-string">"dog"</span>&gt;</span>\n\t\t<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n                class="code-string">"chkui.springcore.example.hybrid.profile.service.squareenix.SleepingDogs"</span> /&gt;</span>\n\t<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>配置之后，&lt;beans&gt;中的多个&lt;bean&gt;都会被Profile控制。</p>\n\n<h2 id="h2-5">环境变量的设置</h2>\n<p>Profile的环境变量可以包含多个值。例如：</p>\n<pre><code class="java">System.setProperty(<span class="code-string">"spring.profiles.active"</span>, <span\n        class="code-string">"wow,pes"</span>);</code></pre>\n<p>这样环境中就包含了2个Profile的值。对用的@Profile或profile配置就会被启用。</p>\n<p>除了例子中给出的System::setProperty方法，Spring还提供了多种方法来设置Profile的环境变量。</p>\n\n<h4 id="h4-1"><strong>直接在Jvm启动参数中设置</strong></h4>\n<pre><code class="bash">-Dspring.profiles.active=<span class="code-string">"wow,pes"</span></code></pre>\n\n<h4 id="h4-2">使用EnvironmentCapable接口来设置</h4>\n<p>\n    ConfigurableApplicationContext继承了ConfigurableEnvironment接口我们可以通过ConfigurableEnvironment::getEnvironment方法获取到当前Spring中的环境对象——org.springframework.core.env.Environment，然后使用他来设置环境变量：</p>\n<pre><code class="java">ConfigurableApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(EnvironmentApp.class);\nConfigurableEnvironment env = ctx.getEnvironment();\n<span class="code-comment">//通过setActiveProfiles来设置。</span>\nenv.setActiveProfiles(<span class="code-string">"wow"</span>,<span class="code-string">"pes"</span>,<span\n            class="code-string">"ff"</span>);\n<span class="code-comment">//必须重建容器</span>\nctx.refresh();</code></pre>\n<p>\n    需要注意的是，在继承关系中ConfigurableApplicationContext之后才实现ConfigurableEnvironment，如果这里使用ApplicationContext::getEnvironment方法得到的是Environment，它不提供set相关的方法。所以上面的例子使用了ConfigurableApplicationContext。由于ApplicationContext的所有实现类都实现了Configurable的功能，我们也可以像下面这样进行转型：</p>\n<pre><code class="java">ApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(EnvironmentApp.class);\nEnvironment _e =ctx.getEnvironment();\nConfigurableEnvironment env = ConfigurableEnvironment.class.cast(_e);</code></pre>\n\n<h2 id="h2-6">@Profile的实现</h2>\n<p>Profile特性的实现也不复杂，其实就是实现了Conditional功能（Conditional功能见<a\n        href="https://www.chkui.com/article/spring/spring_core_configuration_annotation_and_xml" title="@Configuration与混合使用">@Configuration与混合使用</a>一文中关于Conditionally的介绍）。\n</p>\n<p>首先@Profile注解继承实现了@Conditional：</p>\n<pre><code class="java"><span class="code-meta">@Target</span>({ElementType.TYPE, ElementType.METHOD})\n<span class="code-meta">@Retention</span>(RetentionPolicy.RUNTIME)\n<span class="code-meta">@Documented</span>\n<span class="code-meta">@Conditional</span>(ProfileCondition.class)\n<span class="code-keyword">public</span> <span class="code-meta">@interface</span> Profile {}</code></pre>\n<p>然后他的处理类实现了Condition接口：</p>\n<pre><code class="java"><span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">ProfileCondition</span> <span\n        class="code-keyword">implements</span> <span class="code-title">Condition</span> </span>{\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">boolean</span> <span\n            class="code-title">matches</span><span class="hljs-params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>{\n\t\tMultiValueMap&lt;String, Object&gt; attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());\n\t\t<span class="code-keyword">if</span> (attrs != <span class="code-keyword">null</span>) {\n\t\t\t<span class="code-keyword">for</span> (Object value : attrs.get(<span class="code-string">"value"</span>)) {\n\t\t\t\t<span class="code-keyword">if</span> (context.getEnvironment().acceptsProfiles((String[]) value)) {\n\t\t\t\t\t<span class="code-keyword">return</span> <span class="code-keyword">true</span>;\n\t\t\t\t}\n\t\t\t}\n\t\t\t<span class="code-keyword">return</span> <span class="code-keyword">false</span>;\n\t\t}\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">true</span>;\n\t}\n\n}</code></pre>\n<p>处理过程也很简单，实际上就检查@Profile注解中的值，如果和环境中的一致则添加。</p>'},405:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<p>前序文章陆续介绍了<a href="https://www.chkui.com/article/spring/spring_batch_introduction">批处理的基本概念</a>，<a\n        href="https://www.chkui.com/article/spring/spring_batch_job">Job使用</a>、<a\n        href="https://www.chkui.com/article/spring/spring_batch_step">Step控制</a>、<a\n        href="https://www.chkui.com/article/spring/spring_batch_item_and_code_case">Item的结构</a>以及<a\n        href="https://www.chkui.com/article/spring/spring_batch_flat_file_read_and_write">扁平文件的读写</a>。本文将接着前面的内容说明数据库如何进行批处理读写。\n</p>\n<h2 id="h2-1">数据读取</h2>\n<p>数据库是绝大部分系统要用到的数据存储工具，因此针对数据库执行批量数据处理任务也是很常见的需求。数据的批量处理与常规业务开发不同，如果一次性读取百万条，对于任何系统而言肯定都是不可取的。为了解决这个问题Spring\n    Batch提供了2套数据读取方案：</p>\n<ul>\n    <li>基于游标读取数据</li>\n    <li>基于分页读取数据</li>\n</ul>\n<h2 id="h2-2">游标读取数据</h2>\n<p>对于有经验大数据工程师而言数据库游标的操作应该是非常熟悉的，因为这是从数据库读取<em>数据流</em>标准方法，而且在Java中也封装了<code>ResultSet</code>这种面向游标操作的数据结构。</p>\n<p><code>ResultSet</code>一直都会指向<em>结果集</em>中的某一行数据，使用<code>next</code>方法可以让游标跳转到下一行数据。Spring Batch同样使用这个特性来控制数据的读取：</p>\n<ol>\n    <li>在初始化时打开游标。</li>\n    <li>每一次调用<code>ItemReader::read</code>方法就从<code>ResultSet</code>获取一行数据并执行<code>next</code>。</li>\n    <li>返回可用于数据处理的映射结构（map、dict）。</li>\n</ol>\n<p>\n    在一切都执行完毕之后，框架会使用回调过程调用<code>ResultSet::close</code>来关闭游标。由于所有的业务过程都绑定在一个事物之上，所以知道到<code>Step</code>执行完毕或异常退出调用执行<code>close</code>。下图展示了数据读取的过程：\n</p>\n<p><img src="https://docs.spring.io/spring-batch/4.2.x/reference/html/images/cursorExample.png"\n        alt="Spring Batch(6)——数据库批数据读写 " class="zoom-in-cursor"></p>\n<p>SQL语句的查询结果称为<em>数据集</em>（对于大部分数据库而言，其SQL执行结果会产生临时的表空间索引来存放数据集）。游标开始会停滞在ID=2的位置，一次<code>ItemReader</code>执行完毕后会产生对应的实体<code>FOO2</code>，然后游标下移直到最后的ID=6。最后关闭游标。\n</p>\n<h3 id="h3-1">JdbcCursorItemReader</h3>\n<p><code>JdbcCursorItemReader</code>是使用游标读取数据集的<code>ItemReader</code>实现类之一。它使用<code>JdbcTemplate</code>中的<code>DataSource</code>控制<code>ResultSet</code>,其过程是将<code>ResultSet</code>的每行数据转换为所需要的实体类。\n</p>\n<p><code>JdbcCursorItemReader</code>的执行过程有三步：</p>\n<ol>\n    <li>通过<code>DataSource</code>创建<code>JdbcTemplate</code>。</li>\n    <li>设定数据集的SQL语句。</li>\n    <li>创建<code>ResultSet</code>到实体类的映射。\n        大致如下：\n    </li>\n</ol>\n<pre><code class="Java"><span class="code-comment">//随风溜达的向日葵 chkui.com</span>\nJdbcCursorItemReader itemReader = <span class="code-keyword">new</span> JdbcCursorItemReader();\nitemReader.setDataSource(dataSource);\nitemReader.setSql(<span class="code-string">"SELECT ID, NAME, CREDIT from CUSTOMER"</span>);\nitemReader.setRowMapper(<span class="code-keyword">new</span> CustomerCreditRowMapper());\n</code></pre>\n<p>除了上面的代码，<code>JdbcCursorItemReader</code>还有其他属性：</p>\n<table>\n    <thead>\n    <tr>\n        <th>属性名称</th>\n        <th>说明</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n        <td>ignoreWarnings</td>\n        <td>标记当执行SQL语句出现警告时，是输出日志还是抛出异常，默认为true——输出日志</td>\n    </tr>\n    <tr>\n        <td>fetchSize</td>\n        <td>预通知JDBC驱动全量数据的个数</td>\n    </tr>\n    <tr>\n        <td>maxRows</td>\n        <td>设置ResultSet从数据库中一次读取记录的上限</td>\n    </tr>\n    <tr>\n        <td>queryTimeout</td>\n        <td>设置执行SQL语句的等待超时时间，单位秒。当超过这个时间会抛出<em>DataAccessException</em></td>\n    </tr>\n    <tr>\n        <td>verifyCursorPosition</td>\n        <td>\n            对游标位置进行校验。由于在<em>RowMapper::mapRow</em>方法中<em>ResultSet</em>是直接暴露给使用者的，因此有可能在业务代码层面调用了<em>ResultSet::next</em>方法。将这个属性设置为<em>true</em>,在框架中会有一个位置计数器与ResultSet保持一致，当执行完<em>Reader</em>后位置不一致会抛出异常。\n        </td>\n    </tr>\n    <tr>\n        <td>saveState</td>\n        <td>标记读取的状态是否被存放到<em>ExecutionContext</em>中。默认为<em>true</em></td>\n    </tr>\n    <tr>\n        <td>driverSupportsAbsolute</td>\n        <td>告诉框架是指直接使用<em>ResultSet::absolute</em>方法来指定游标位置，使用这个属性需要数据库驱动支持。建议在支持absolute特性的数据库上开启这个特性，能够明显的提升性能。默认为<em>false</em>\n        </td>\n    </tr>\n    <tr>\n        <td>setUseSharedExtendedConnection</td>\n        <td>\n            标记读取数据的游标是否与<em>Step</em>其他过程绑定成同一个事物。默认为<em>false</em>,表示读取数据的游标是单独建立连接的，具有自身独立的事物。如果设定为<em>true</em>需要用<em>ExtendedConnectionDataSourceProxy</em>包装<em>DataSource</em>用于管理事物过程。此时游标的创建标记为\'READ_ONLY\'、\'HOLD_CURSORS_OVER_COMMIT\'。需要注意的是该属性需要数据库支持3.0以上的JDBC驱动。\n        </td>\n    </tr>\n    </tbody>\n</table>\n<h4 id="h4-1">可执行源码</h4>\n<p>源码在下列地址的<em>items</em>子项目：</p>\n<ul>\n    <li>Gitee：<a\n            href="https://gitee.com/chkui-com/spring-batch-sample">https://gitee.com/chkui-com/spring-batch-sample</a>\n    </li>\n    <li>Github：<a href="https://github.com/chkui/spring-batch-sample">https://github.com/chkui/spring-batch-sample</a>\n    </li>\n</ul>\n<p>执行<code>JdbcCursorItemReader</code>的代码在<code>org.chenkui.spring.batch.sample.items.JdbcReader</code>。启动位置是<code>org.chenkui.spring.batch.sample.database.cursor.JdbcCurosrApplication</code>。\n</p>\n<p>在运行代码之前请先在数据库中执行以下DDL语句，并添加部分测试数据。</p>\n<pre><code class="SQL"><span class="code-keyword">CREATE</span> <span class="code-keyword">TABLE</span> <span\n        class="code-string">`tmp_test_weather`</span> (\n  <span class="code-string">`id`</span> <span class="code-built_in">int</span>(<span\n            class="hljs-number">10</span>) <span class="code-keyword">unsigned</span> <span\n            class="code-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT <span\n            class="code-keyword">COMMENT</span> <span class="code-string">\'主键\'</span>,\n  <span class="code-string">`siteid`</span> <span class="code-built_in">varchar</span>(<span\n            class="hljs-number">64</span>) <span class="code-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span\n            class="code-keyword">COMMENT</span> <span class="code-string">\'业务主键\'</span>,\n  <span class="code-string">`month`</span> <span class="code-built_in">varchar</span>(<span\n            class="hljs-number">64</span>) <span class="code-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span\n            class="code-keyword">COMMENT</span> <span class="code-string">\'日期\'</span>,\n  <span class="code-string">`type`</span> <span class="code-built_in">varchar</span>(<span class="hljs-number">64</span>) <span\n            class="code-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span\n            class="code-keyword">COMMENT</span> <span class="code-string">\'气象类型\'</span>,\n  <span class="code-string">`value`</span> <span class="code-built_in">int</span>(<span\n            class="hljs-number">11</span>) <span class="code-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span\n            class="code-keyword">COMMENT</span> <span class="code-string">\'值\'</span>,\n  <span class="code-string">`ext`</span> <span class="code-built_in">varchar</span>(<span class="hljs-number">255</span>) <span\n            class="code-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="code-keyword">COMMENT</span> <span\n            class="code-string">\'扩展数据\'</span>,\n  PRIMARY <span class="code-keyword">KEY</span> (<span class="code-string">`id`</span>)\n) ;\n</code></pre>\n<p>运行代码：</p>\n<pre><code class="Java"><span class="code-comment">//随风溜达的向日葵 chkui.com</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">JdbcReader</span> </span>{\n\n    <span class="code-meta">@Bean</span>\n    <span class="hljs-function"><span class="code-keyword">public</span> RowMapper&lt;WeatherEntity&gt; <span\n            class="code-title">weatherEntityRowMapper</span><span class="hljs-params">()</span> </span>{\n\n        <span class="code-keyword">return</span> <span class="code-keyword">new</span> RowMapper&lt;WeatherEntity&gt;() {\n            <span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">final</span> String SITEID_COLUMN = <span class="code-string">"siteId"</span>; <span\n            class="code-comment">// 设置映射字段</span>\n            <span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">final</span> String MONTH_COLUMN = <span class="code-string">"month"</span>;\n            <span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">final</span> String TYPE_COLUMN = <span class="code-string">"type"</span>;\n            <span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">final</span> String VALUE_COLUMN = <span class="code-string">"value"</span>;\n            <span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">final</span> String EXT_COLUMN = <span class="code-string">"ext"</span>;\n\n            <span class="code-meta">@Override</span>\n            <span class="code-comment">// 数据转换</span>\n            <span class="hljs-function"><span class="code-keyword">public</span> WeatherEntity <span class="code-title">mapRow</span><span\n                    class="hljs-params">(ResultSet resultSet, <span class="code-keyword">int</span> rowNum)</span> <span\n                    class="code-keyword">throws</span> SQLException </span>{\n                WeatherEntity weatherEntity = <span class="code-keyword">new</span> WeatherEntity();\n                weatherEntity.setSiteId(resultSet.getString(SITEID_COLUMN));\n                weatherEntity.setMonth(resultSet.getString(MONTH_COLUMN));\n                weatherEntity.setType(WeatherEntity.Type.valueOf(resultSet.getString(TYPE_COLUMN)));\n                weatherEntity.setValue(resultSet.getInt(VALUE_COLUMN));\n                weatherEntity.setExt(resultSet.getString(EXT_COLUMN));\n                <span class="code-keyword">return</span> weatherEntity;\n            }\n        };\n    }\n\n    <span class="code-meta">@Bean</span>\n    <span class="hljs-function"><span class="code-keyword">public</span> ItemReader&lt;WeatherEntity&gt; <span\n            class="code-title">jdbcCursorItemReader</span><span class="hljs-params">(\n        @Qualifier(<span class="code-string">"weatherEntityRowMapper"</span>)</span> RowMapper&lt;WeatherEntity&gt; rowMapper, DataSource datasource) </span>{\n        JdbcCursorItemReader&lt;WeatherEntity&gt; itemReader = <span class="code-keyword">new</span> JdbcCursorItemReader&lt;&gt;();\n        itemReader.setDataSource(datasource); <span class="code-comment">//设置DataSource</span>\n        <span class="code-comment">//设置读取的SQL</span>\n        itemReader.setSql(<span\n            class="code-string">"SELECT siteId, month, type, value, ext from TMP_TEST_WEATHER"</span>);\n        itemReader.setRowMapper(rowMapper); <span class="code-comment">//设置转换</span>\n        <span class="code-keyword">return</span> itemReader;\n    }\n}\n</code></pre>\n<h3 id="h3-2">HibernateCursorItemReader</h3>\n<p>在Java体系中数据库操作常见的规范有<code>JPA</code>或<code>ORM</code>，Spring Batch提供了<code>HibernateCursorItemReader</code>来实现<code>HibernateTemplate</code>,它可以通过<em>Hibernate</em>框架进行游标的控制。\n</p>\n<p><strong>需要注意的是</strong>：使用<em>Hibernate</em>框架来处理批量数据到目前为止一直都有争议，核心原因是<em>Hibernate</em>最初是为在线联机事物型系统开发的。不过这并不意味着不能使用它来处理批数据，解决此问题就是让<em>Hibernate</em>使用<code>StatelessSession</code>用来保持游标，而不是<code>standard\n    session</code>一次读写，这将导致<em>Hibernate</em>的缓存机制和数据脏读检查失效，进而影响批处理的过程。关于<em>Hibernate</em>的状态控制机制请阅读官方文档。</p>\n<p><code>HibernateCursorItemReader</code>使用过程与<code>JdbcCursorItemReader</code>没多大差异都是逐条读取数据然后控制状态链接关闭。只不过他提供了<em>Hibernate</em>所使用的<em>HSQL</em>方案。\n</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> ItemReader&lt;WeatherEntity&gt; <span\n        class="code-title">hibernateCursorItemReader</span><span\n        class="hljs-params">(SessionFactory sessionFactory)</span> </span>{\n    HibernateCursorItemReader&lt;WeatherEntity&gt; itemReader = <span class="code-keyword">new</span> HibernateCursorItemReader&lt;&gt;();\n    itemReader.setName(<span class="code-string">"hibernateCursorItemReader"</span>);\n    itemReader.setQueryString(<span class="code-string">"from WeatherEntity tmp_test_weather"</span>);\n    itemReader.setSessionFactory(sessionFactory);\n    <span class="code-keyword">return</span> itemReader;\n}\n</code></pre>\n<p>或</p>\n<pre><code class="Java"><span class="hljs-function"><span class="code-keyword">public</span> ItemReader&lt;WeatherEntity&gt; <span\n        class="code-title">hibernateCursorItemReader</span><span\n        class="hljs-params">(SessionFactory sessionFactory)</span> </span>{\n    <span class="code-keyword">return</span> <span class="code-keyword">new</span> HibernateCursorItemReaderBuilder&lt;CustomerCredit&gt;()\n            .name(<span class="code-string">"creditReader"</span>)\n            .sessionFactory(sessionFactory)\n            .queryString(<span class="code-string">"from CustomerCredit"</span>)\n            .build();\n}\n</code></pre>\n<p>如果没有特别的需要，不推荐使用<em>Hibernate</em>。</p>\n<h3 id="h3-3">StoredProcedureItemReader</h3>\n<p>存储过程是在同一个数据库中处理大量数据的常用方法。<code>StoredProcedureItemReader</code>的执行过程和<code>JdbcCursorItemReader</code>一致，但是底层逻辑是先执行存储过程，然后返回存储过程执行结果游标。不同的数据库存储过程游标返回会有一些差异：\n</p>\n<ol>\n    <li>作为一个<code>ResultSet</code>返回。（SQL Server, Sybase, DB2, Derby以及MySQL）</li>\n    <li>参数返回一个 <code>ref-cursor</code>实例。比如Oracle、PostgreSQL数据库，这类数据库存储过程是不会直接return任何内容的，需要从传参获取。</li>\n    <li>返回存储过程调用后的返回值。</li>\n</ol>\n<p>针对以上3个类型，配置上有一些差异：</p>\n<pre><code class="Java"><span class="code-comment">//随风溜达的向日葵 chkui.com</span>\n<span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> StoredProcedureItemReader <span class="code-title">reader</span><span\n        class="hljs-params">(DataSource dataSource)</span> </span>{\n    StoredProcedureItemReader reader = <span class="code-keyword">new</span> StoredProcedureItemReader();\n\n    reader.setDataSource(dataSource);\n    reader.setProcedureName(<span class="code-string">"sp_processor_weather"</span>);\n    reader.setRowMapper(<span class="code-keyword">new</span> weatherEntityRowMapper());\n\t\n    reader.setRefCursorPosition(<span class="hljs-number">1</span>);<span class="code-comment">//第二种类型需要指定ref-cursor的参数位置</span>\n\n    reader.setFunction(<span class="code-keyword">true</span>);<span\n            class="code-comment">//第三种类型需要明确的告知reader通过返回获取</span>\n\n    <span class="code-keyword">return</span> reader;\n}\n</code></pre>\n<p>使用存储过程处理数据的好处是可以实现针对库内的数据进行合并、分割、排序等处理。如果数据在同一个数据库，性能也明显好于通过Java处理。</p>\n<h2 id="h2-3">分页读取数据</h2>\n<p>相对于游标，还有一个办法是进行分页查询。分页查询意味着再进行批处理的过程中同一个SQL会多次执行。在联机型事物系统中分页查询常用于列表功能，每一次查询需要指定开始位置和结束位置。</p>\n<h3 id="h3-4">JdbcPagingItemReader</h3>\n<p>分页查询的默认实现类是<code>JdbcPagingItemReader</code>，它的核心功能是用分页器<code>PagingQueryProvider</code>进行分页控制。由于不同的数据库分页方法差别很大，所以针对不同的数据库有不同的实现类。框架提供了<code>SqlPagingQueryProviderFactoryBean</code>用于检查当前数据库并自动注入对应的<code>PagingQueryProvider</code>。\n</p>\n<p><code>JdbcPagingItemReader</code>会从数据库中一次性读取一整页的数据，但是调用<code>Reader</code>的时候还是会一行一行的返回数据。框架会自行根据运行情况确定什么时候需要执行下一个分页的查询。\n</p>\n<h4 id="h4-2">分页读取数据执行源码</h4>\n<ul>\n    <li>Gitee：<a\n            href="https://gitee.com/chkui-com/spring-batch-sample">https://gitee.com/chkui-com/spring-batch-sample</a>\n    </li>\n    <li>Github：<a href="https://github.com/chkui/spring-batch-sample">https://github.com/chkui/spring-batch-sample</a>\n    </li>\n</ul>\n<p>执行<code>JdbcPagingItemReader</code>的代码在<code>org.chenkui.spring.batch.sample.items.pageReader</code>。启动位置是<code>org.chenkui.spring.batch.sample.database.paging.JdbcPagingApplication</code>：\n</p>\n<pre><code class="Java"><span class="code-comment">//随风溜达的向日葵 chkui.com</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">pageReader</span> </span>{\n    <span class="code-keyword">final</span> <span class="code-keyword">private</span> <span\n            class="code-keyword">boolean</span> wrapperBuilder = <span class="code-keyword">false</span>;\n    <span class="code-meta">@Bean</span>\n    <span class="code-comment">//设置 queryProvider</span>\n    <span class="hljs-function"><span class="code-keyword">public</span> SqlPagingQueryProviderFactoryBean <span\n            class="code-title">queryProvider</span><span class="hljs-params">(DataSource dataSource)</span> </span>{\n        SqlPagingQueryProviderFactoryBean provider = <span class="code-keyword">new</span> SqlPagingQueryProviderFactoryBean();\n\n        provider.setDataSource(dataSource);\n        provider.setSelectClause(<span class="code-string">"select id, siteid, month, type, value, ext"</span>);\n        provider.setFromClause(<span class="code-string">"from tmp_test_weather"</span>);\n        provider.setWhereClause(<span class="code-string">"where id&gt;:start"</span>);\n        provider.setSortKey(<span class="code-string">"id"</span>);\n\n        <span class="code-keyword">return</span> provider;\n    }\n\n    <span class="code-meta">@Bean</span>\n    <span class="hljs-function"><span class="code-keyword">public</span> ItemReader&lt;WeatherEntity&gt; <span\n            class="code-title">jdbcPagingItemReader</span><span class="hljs-params">(DataSource dataSource,\n            PagingQueryProvider queryProvider,\n            RowMapper&lt;WeatherEntity&gt; rowMapper)</span> </span>{\n\n        Map&lt;String, Object&gt; parameterValues = <span class="code-keyword">new</span> HashMap&lt;&gt;();\n        parameterValues.put(<span class="code-string">"start"</span>, <span class="code-string">"1"</span>);\n        JdbcPagingItemReader&lt;WeatherEntity&gt; itemReader;\n        <span class="code-keyword">if</span> (wrapperBuilder) {\n            itemReader = <span class="code-keyword">new</span> JdbcPagingItemReaderBuilder&lt;WeatherEntity&gt;()\n                    .name(<span class="code-string">"creditReader"</span>)\n                    .dataSource(dataSource)\n                    .queryProvider(queryProvider)\n                    .parameterValues(parameterValues)\n                    .rowMapper(rowMapper)\n                    .pageSize(<span class="hljs-number">1000</span>)\n                    .build();\n        } <span class="code-keyword">else</span> {\n            itemReader = <span class="code-keyword">new</span> JdbcPagingItemReader&lt;&gt;();\n            itemReader.setName(<span class="code-string">"weatherEntityJdbcPagingItemReader"</span>);\n            itemReader.setDataSource(dataSource);\n            itemReader.setQueryProvider(queryProvider);\n            itemReader.setParameterValues(parameterValues);\n            itemReader.setRowMapper(rowMapper);\n            itemReader.setPageSize(<span class="hljs-number">1000</span>);\n        }\n        <span class="code-keyword">return</span> itemReader;\n    }\n}\n</code></pre>\n<h2 id="h2-4">数据写入</h2>\n<p>Spring Batch为不同类型的文件的写入提供了多个实现类，但并没有为数据库的写入提供任何实现类，而是交由开发者自己去实现接口。理由是：</p>\n<ol>\n    <li>\n        <p>数据库的写入与文件写入有巨大的差别。对于一个<code>Step</code>而言，在写入一份文件时需要保持对文件的打开状态从而能够高效的向队尾添加数据。如果每次都重新打开文件，从开始位置移动到队尾会耗费大量的时间（很多文件流无法在open时就知道长度）。当整个<code>Step</code>结束时才能关闭文件的打开状态，框架提供的文件读写类都实现了这个控制过程。\n        </p>\n    </li>\n    <li>\n        <p>另外无论使用何种方式将数据写入文件都是"逐行进行"的（流数据写入、字符串逐行写入）。因此当数据写入与整个<code>Step</code>绑定为事物时还需要实现一个控制过程是：在写入数据的过程中出现异常时要擦除本次事物已经写入的数据，这样才能和整个<code>Step</code>的状态保持一致。框架中的类同样实现了这个过程。\n        </p>\n    </li>\n    <li>\n        <p>但是向数据库写入数据并不需要类似于文件的<em>尾部写入控制</em>，因为数据库的各种链接池本身就保证了链接-&gt;写入-&gt;释放的高效执行，也不存在向队尾添加数据的问题。而且几乎所有的数据库驱动都提供了事物能力，在任何时候出现异常都会自动回退，不存在擦除数据的问题。\n        </p>\n    </li>\n</ol>\n<p>因此，对于数据库的写入操作只要按照常规的批量数据写入的方式即可，开发者使用任何工具都可以完成这个过程。</p>\n<h3 id="h3-5">写入数据一个简单的实现</h3>\n<p>实现数据写入方法很多，这和常规的联机事务系统没任何区别。下面直接用<code>JdbcTemplate</code>实现了一个简单的数据库写入过程。</p>\n<p>执行数据库写入的核心代码在<code>org.chenkui.spring.batch.sample.items.JdbcWriter</code>。启动位置是<code>org.chenkui.spring.batch.sample.database.output.JdbcWriterApplication</code>。\n</p>\n<pre><code class="Java"><span class="code-comment">//随风溜达的向日葵 chkui.com</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">JdbcWriter</span> </span>{\n\n    <span class="code-meta">@Bean</span>\n    <span class="hljs-function"><span class="code-keyword">public</span> ItemWriter&lt;WeatherEntity&gt; <span\n            class="code-title">jdbcBatchWriter</span><span class="hljs-params">(JdbcTemplate template)</span> </span>{\n\n        <span class="code-keyword">return</span> <span class="code-keyword">new</span> ItemWriter&lt;WeatherEntity&gt;() {\n            <span class="code-keyword">final</span> <span class="code-keyword">private</span> <span\n            class="code-keyword">static</span> String INSERt_SQL =\n                      <span class="code-string">"INSERT INTO tmp_test_weather(siteid, month, type, value, ext) VALUES(?,?,?,?,?)"</span>;\n            <span class="code-meta">@Override</span>\n            <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n                    class="code-title">write</span><span\n                    class="hljs-params">(List&lt;? extends WeatherEntity&gt; items)</span> <span class="code-keyword">throws</span> Exception </span>{\n                List&lt;Object[]&gt; batchArgs = <span class="code-keyword">new</span> ArrayList&lt;&gt;();\n                <span class="code-keyword">for</span> (WeatherEntity entity : items) {\n                    Object[] objects = <span class="code-keyword">new</span> Object[<span class="hljs-number">5</span>];\n                    objects[<span class="hljs-number">0</span>] = entity.getSiteId();\n                    objects[<span class="hljs-number">1</span>] = entity.getMonth();\n                    objects[<span class="hljs-number">2</span>] = entity.getType().name();\n                    objects[<span class="hljs-number">3</span>] = entity.getValue();\n                    objects[<span class="hljs-number">4</span>] = entity.getExt();\n                    batchArgs.add(objects);\n                }\n                template.batchUpdate(INSERt_SQL, batchArgs);\n            }\n        };\n    }\n}\n</code></pre>\n<h2 id="h2-5">组合使用案例</h2>\n<p>下面是一些组合使用过程，简单实现了文件到数据库、数据库到文件的过程。文件读写的过程已经在<a\n        href="https://www.chkui.com/article/spring/spring_batch_flat_file_read_and_write">文件读写</a>中介绍过，这里会重复使用之前介绍的文件读写的功能。\n</p>\n<p>下面的案例是将<code>data.csv</code>中的数据写入到数据库，然后再将数据写入到<code>out-data.csv</code>。案例组合使用已有的<code>item</code>完成任务：<code>flatFileReader</code>、<code>jdbcBatchWriter</code>、<code>jdbcCursorItemReader</code>、<code>simpleProcessor</code>、<code>flatFileWriter</code>。这种<code>Reader</code>、<code>Processor</code>、<code>Writer</code>组合的方式也是完成一个批处理工程的常见开发方式。\n</p>\n<p>案例的运行代码在<code>org.chenkui.spring.batch.sample.database.complex</code>包中，使用了2个<code>Step</code>来完成任务，一个将数据读取到数据库，一个将数据进行过滤，然后再写入到文件：\n</p>\n<pre><code class="Java"><span class="code-comment">//随风溜达的向日葵 chkui.com</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">FileComplexProcessConfig</span> </span>{\n    <span class="code-meta">@Bean</span>\n    <span class="code-comment">// 配置Step1</span>\n    <span class="hljs-function"><span class="code-keyword">public</span> Step <span\n            class="code-title">file2DatabaseStep</span><span class="hljs-params">(StepBuilderFactory builder,\n            @Qualifier(<span class="code-string">"flatFileReader"</span>)</span> ItemReader&lt;WeatherEntity&gt; reader,\n            @<span class="code-title">Qualifier</span><span class="hljs-params">(<span class="code-string">"jdbcBatchWriter"</span>)</span> ItemWriter&lt;WeatherEntity&gt; writer) </span>{\n        <span class="code-keyword">return</span> builder.get(<span class="code-string">"file2DatabaseStep"</span>) <span\n            class="code-comment">// 创建</span>\n                .&lt;WeatherEntity, WeatherEntity&gt;chunk(<span class="hljs-number">50</span>) <span\n            class="code-comment">// 分片</span>\n                .reader(reader) <span class="code-comment">// 读取</span>\n                .writer(writer) <span class="code-comment">// 写入</span>\n                .faultTolerant() <span class="code-comment">// 开启容错处理</span>\n                .skipLimit(<span class="hljs-number">20</span>) <span class="code-comment">// 跳过设置</span>\n                .skip(Exception.class) <span class="code-comment">// 跳过异常</span>\n                .build();\n    }\n\n    <span class="code-meta">@Bean</span>\n    <span class="code-comment">// 配置Step2</span>\n    <span class="hljs-function"><span class="code-keyword">public</span> Step <span\n            class="code-title">database2FileStep</span><span class="hljs-params">(StepBuilderFactory builder,\n            @Qualifier(<span class="code-string">"jdbcCursorItemReader"</span>)</span> ItemReader&lt;WeatherEntity&gt; reader,\n            @<span class="code-title">Qualifier</span><span class="hljs-params">(<span class="code-string">"simpleProcessor"</span>)</span> ItemProcessor&lt;WeatherEntity, MaxTemperatureEntiry&gt; processor,\n            @<span class="code-title">Qualifier</span><span class="hljs-params">(<span class="code-string">"flatFileWriter"</span>)</span> ItemWriter&lt;MaxTemperatureEntiry&gt; writer) </span>{\n        <span class="code-keyword">return</span> builder.get(<span class="code-string">"database2FileStep"</span>) <span\n            class="code-comment">// 创建</span>\n                .&lt;WeatherEntity, MaxTemperatureEntiry&gt;chunk(<span class="hljs-number">50</span>) <span\n            class="code-comment">// 分片</span>\n                .reader(reader) <span class="code-comment">// 读取</span>\n                .processor(processor) <span class="code-comment">//</span>\n                .writer(writer) <span class="code-comment">// 写入</span>\n                .faultTolerant() <span class="code-comment">// 开启容错处理</span>\n                .skipLimit(<span class="hljs-number">20</span>) <span class="code-comment">// 跳过设置</span>\n                .skip(Exception.class) <span class="code-comment">// 跳过异常</span>\n                .build();\n    }\n\n    <span class="code-meta">@Bean</span>\n    <span class="hljs-function"><span class="code-keyword">public</span> Job <span\n            class="code-title">file2DatabaseJob</span><span class="hljs-params">(@Qualifier(<span class="code-string">"file2DatabaseStep"</span>)</span> Step step2Database,\n            @<span class="code-title">Qualifier</span><span class="hljs-params">(<span class="code-string">"database2FileStep"</span>)</span> Step step2File, JobBuilderFactory builder) </span>{\n        <span class="code-keyword">return</span> builder.get(<span class="code-string">"File2Database"</span>).start(step2Database).next(step2File).build();\n    }\n}\n</code></pre>'}});