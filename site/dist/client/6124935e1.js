webpackJsonp([6],{343:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h2 id="h2-1">一切从元编程开始</h2>\n<p>一个健壮的系统都要对外部提交的数据进行完整性、合法性的校验。即使开发一个不面对最终用户的工具包，也需要对传入的数据进行缜密的校验来防止引发底层难以追踪的问题。各路大神当然也会注意到这个问题，所以在“元编程”（见<a\n        href="https://www.chkui.com/article/spring/spring_core_jsr250_and_resource" title="JSR250与资源控制">JSR250与资源控制</a>）提出之后相续提交了<em>JSR-303、JSR-349以及JSR-380</em>来完善使用注解进行数据校验的机制，这三个JSR也被称为<em>Bean\n    Validation 1.0、Bean Validation 1.1和Bean Validation 2.0</em>，后文统称为<em>Bean Validation。</em></p>\n<p>先看一个不使用<em>Bean Validation</em>校验数据的代码：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">StandardValidation</span> </span>{\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tSystem.out.println(validationWithoutAnnotation(<span class="code-string">" "</span>, -<span class="hljs-number">1</span>));\n\t}\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> String <span\n            class="code-title">validationWithoutAnnotation</span><span class="hljs-params">(String inputString, Integer inputInt)</span> </span>{\n\t\tString error = <span class="code-keyword">null</span>;\n\t\t<span class="code-keyword">if</span> (<span class="code-keyword">null</span> == inputString) {\n\t\t\terror = <span class="code-string">"inputString不能为null"</span>;\n\t\t} <span class="code-keyword">else</span> <span class="code-keyword">if</span> (<span\n            class="code-keyword">null</span> == inputInt) {\n\t\t\terror = <span class="code-string">"inputInt不能为null"</span>;\n\t\t} <span class="code-keyword">else</span> <span class="code-keyword">if</span> (<span\n            class="hljs-number">1</span> &gt; inputInt.compareTo(<span class="hljs-number">0</span>)) {\n\t\t\terror = <span class="code-string">"inputInt必须大于0"</span>;\n\t\t} <span class="code-keyword">else</span> <span class="code-keyword">if</span> (inputString.isEmpty() || inputString.trim().isEmpty()) {\n\t\t\terror = <span class="code-string">"inputString不能为空字符串"</span>;\n\t\t} <span class="code-keyword">else</span> {\n\t\t\t<span class="code-comment">// DO</span>\n\t\t}\n\t\t<span class="code-keyword">return</span> error;\n\t}\n}\n</code></pre>\n<p>相信很多码友多少都写过类似的代码。使用<em>IF—ELSE</em>是否优雅这种高端问题暂且不谈，但是大量的<em>IF—</em><em>ELSE</em>会导致业务内容越来越多的嵌套在代码中。针对这些问题<em>Bean\n    Validation</em>为数据校验提供了更加规范化、通用化、复用程度更高的校验方法。</p>\n<p>\n    数据校验的原理并不复杂，主要是用注解（Annotation）在域或setter方法上声明JavaBean中数据的准则。Java的数据校验代码主要在javax.validation包中，包括注解、校验器以及校验器工厂，接下来通过例子说明。（例子可执行代码在本人的<a\n        href="https://gitee.com/chkui-com/spring-core-sample" rel="nofollow">gitee</a>库，本文代码在chkui.springcore.example.javabase.validation包）\n</p>\n\n<h2 id="h2-2">标准数据校验</h2>\n<p><a href="https://jcp.org/aboutJava/communityprocess/final/jsr303/index.html"\n      rel="nofollow">JSR提交的Javax.validation定义</a>中已经为数据校验定义了很多方法和注解，但是需要清晰的是JSR仅仅制定了一个规范，具体的功能是由各种框架实现的。本文的例子引入了<a\n        href="http://beanvalidation.org" rel="nofollow">Hibernate Validator 6.0.12.Final</a>包，他与Spring\n    Validator一样，都是根据JSR规范实现校验功能。</p>\n<p>数据校验是围绕一个实体类展开的，下面的代码声明了一个实体类，通过注解标注每个域上的赋值规则：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.validation.entity;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Game</span> </span>{\n\t<span class="code-meta">@NotNull</span> <span class="code-comment">//非空</span>\n\t<span class="code-meta">@Length</span>(min=<span class="hljs-number">0</span>, max=<span\n            class="hljs-number">5</span>) <span class="code-comment">//字符串长度小于5，这个是一个Hibernate Validator增加的注解</span>\n\t<span class="code-keyword">private</span> String name;\n\t\n\t<span class="code-meta">@NotNull</span>\n\t<span class="code-keyword">private</span> String description;\n\t\n\t<span class="code-meta">@NotNull</span>\n\t<span class="code-meta">@Min</span>(<span class="hljs-number">0</span>) <span\n            class="code-comment">//最小值&gt;=0</span>\n\t<span class="code-meta">@Max</span>(<span class="hljs-number">10</span>) <span\n            class="code-comment">//最大值&lt;=10</span>\n\t<span class="code-keyword">private</span> <span class="code-keyword">int</span> currentVersion; \n    <span class="code-comment">//getter and setter…………</span>\n}</code></pre>\n<p>使用校验器对其进行校验：</p>\n<pre><code class="java"><span class="code-keyword">public</span> StandardValidation {\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">validate</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-comment">//引入校验工具</span>\n\t\tValidatorFactory factory = Validation.buildDefaultValidatorFactory();\n        <span class="code-comment">//获取校验器</span>\n\t\tValidator validator = factory.getValidator();\n\t\tGame wow = <span class="code-keyword">new</span> Game();\n        <span class="code-comment">//执行校验</span>\n\t\tSet&lt;ConstraintViolation&lt;Game&gt;&gt; violationSet = validator.validate(wow);\n\t\tviolationSet.forEach(violat -&gt; {\n\t\t\tviolat.getPropertyPath();<span class="code-comment">//校验错误的域</span>\n            violat.getMessage());<span class="code-comment">//校验错误的信息</span>\n\t\t});\n        <span class="code-comment">//设置值之后再次进行校验</span>\n\t\twow.setName(<span class="code-string">"World Of Warcraft"</span>);\n\t\twow.setDescription(<span class="code-string">"由著名游戏公司暴雪娱乐所制作的第一款网络游戏，属于大型多人在线角色扮演游戏。"</span>);\n\t\twow.setCurrentVersion(<span class="hljs-number">8</span>);\n\t\tviolationSet = validator.validate(wow);\n\t\tviolationSet.forEach(violat -&gt; {});\n\t}\n}</code></pre>\n<p>执行完毕之后violationSet中就是校验的结果。如果校验通过那么返回的Set长度为0。</p>\n<p><em>Bean Validation</em>已经为常规的校验功能预设了很多注解，详见<a href="https://beanvalidation.org/2.0/spec/#builtinconstraints"\n                                                  rel="nofollow">关于所有注解的介绍</a>。</p>\n\n<h2 id="h2-3">自定义校验规则</h2>\n<p>虽然在<em>javax.validation.constraints</em>已经定义了很多用于校验的注解，但是肯定无法满足复杂多样的业务需求。所以<em>Bean Validation</em>也支持自定义校验规则。在JSR的文档中对数据域的一个校验被称为<em><strong>Constraint</strong></em>（约束），一个<em><strong>Constraint</strong></em>由一个<em><strong>Annotation</strong></em>（注解）绑定1~n个<strong><em>Validator</em></strong>（校验器）组成。&nbsp;因此可以通过新增<em><strong>Annotation</strong></em>和<strong><em>Validator</em></strong>来定义新的校验方式（或者说是定义新的<em><strong>Constraint</strong></em>）。\n</p>\n\n<h3 id="h3-1">组合注解校验</h3>\n<p>可以通过组合已有的注解来实现新的数据校验规则。例如下面的例子。</p>\n<p>定义新的校验注解：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.validation.annotation;\n<span class="code-meta">@Min</span>(<span class="hljs-number">1</span>)<span class="code-comment">//最小值&gt;=1</span>\n<span class="code-meta">@Max</span>(<span class="hljs-number">300</span>)<span class="code-comment">//最大值&lt;=300</span>\n<span class="code-meta">@Constraint</span>(validatedBy = {}) <span class="code-comment">//不制定校验器</span>\n<span class="code-meta">@Documented</span>\n<span class="code-meta">@Target</span>({ ElementType.ANNOTATION_TYPE, ElementType.METHOD, ElementType.FIELD })\n<span class="code-meta">@Retention</span>(RetentionPolicy.RUNTIME)\n<span class="code-keyword">public</span> <span class="code-meta">@interface</span> Price {\n\t<span class="hljs-function">String <span class="code-title">message</span><span class="hljs-params">()</span> <span\n            class="code-keyword">default</span> "定价必须在$1~$200之间"</span>;\n\tClass&lt;?&gt;[] groups() <span class="code-keyword">default</span> { };\n\tClass&lt;? extends Payload&gt;[] payload() <span class="code-keyword">default</span> { };\n}\n</code></pre>\n<p>在@Price注解中我们标记了@Min(1)和@Max(300)，之后直接在域上标记@Price就会校验对应的值是否满足这个条件：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.validation.entity;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Game</span> </span>{\n    <span class="code-meta">@Price</span>\n\t<span class="code-keyword">private</span> <span class="code-keyword">float</span> price;\n    <span class="code-comment">//Other field</span>\n    <span class="code-comment">//setter and getter</span>\n}</code></pre>\n\n<h3 id="h3-2">自定义校验器</h3>\n<p>除了组合<em>javax.validation.constraints</em>中的注解，还可以自定义校验器（<strong><em>Validator</em></strong>）进行数据校验。</p>\n<p>声明一个用于自定义校验的注解：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.validation.annotation;\n<span class="code-meta">@Constraint</span>(validatedBy = { TypeValidator.class }) <span\n            class="code-comment">//指定校验器</span>\n<span class="code-meta">@Documented</span>\n<span class="code-meta">@Target</span>({ ElementType.ANNOTATION_TYPE, ElementType.METHOD, ElementType.FIELD })\n<span class="code-meta">@Retention</span>(RetentionPolicy.RUNTIME)\n<span class="code-keyword">public</span> <span class="code-meta">@interface</span> Type {\n\t<span class="hljs-function">String <span class="code-title">message</span><span class="hljs-params">()</span> <span\n            class="code-keyword">default</span> "游戏类型错误,可选类型为RPG、ACT、SLG、ARPG"</span>;\n\tClass&lt;?&gt;[] groups() <span class="code-keyword">default</span> {};\n\tClass&lt;? extends Payload&gt;[] payload() <span class="code-keyword">default</span> {};\n}</code></pre>\n<p>注意<em>@Constraint(validatedBy = { TypeValidator.class })</em>这一行代码，他的作用就是将这个注解和校验器进行绑定，当我们执行Validator::validator方法时对应的校验器会被调用。\n</p>\n<p><em>TypeValidator</em>类：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.validation.validator;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">TypeValidator</span> <span class="code-keyword">implements</span> <span\n            class="code-title">ConstraintValidator</span>&lt;<span class="code-title">Type</span>, <span\n            class="code-title">String</span>&gt; </span>{\n\t<span class="code-keyword">private</span> <span class="code-keyword">final</span> List&lt;String&gt; TYPE = Arrays.asList(<span\n            class="code-keyword">new</span> String[]{<span class="code-string">"RPG"</span>, <span class="code-string">"ACT"</span>, <span\n            class="code-string">"SLG"</span>, <span class="code-string">"ARPG"</span>});\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">boolean</span> <span\n            class="code-title">isValid</span><span class="hljs-params">(String value, ConstraintValidatorContext context)</span> </span>{\n\t\t<span class="code-keyword">return</span> TYPE.contains(value);\n\t}\n}</code></pre>\n<p><em>TypeValidator</em>必须实现<em>ConstraintValidator</em>这个接口，并在范型中声明对应的校验注解和数据类型（<em>ConstraintValidator&lt;T,\n    E&gt;</em>，T是绑定的注解类型、E是数据类型）。<em>TypeValidator</em>中判断数值是不是"RPG", "ACT", "SLG", "ARPG"当中的一个，若不是则<em>TypeValidator::isValid</em>返回false表示校验没通过。\n</p>\n<p>在实体类的域上使用自定义的@Type注解：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">Game</span> </span>{\n\t<span class="code-meta">@NotNull</span>\n\t<span class="code-meta">@Type</span>\n\t<span class="code-keyword">private</span> String type;\n    <span class="code-comment">//Other field ......</span>\n    <span class="code-comment">//getter and setter ......</span>\n}</code></pre>\n\n<h2 id="h2-4">分组校验</h2>\n<p>对于业务来说数据录入的规则并不是一成不变的，往往需要根据某些状态来对单个或一组数据进行校验。这个时候我们可以用到分组功能——根据状态启用一组约束。</p>\n<p>观察自定义注解或<em>javax.validation.constraints</em>包中预定以的注解，都有一个<em>groups</em>参数：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="code-meta">@interface</span> Max {\n\t<span class="hljs-function">String <span class="code-title">message</span><span class="hljs-params">()</span> <span\n            class="code-keyword">default</span> "</span>{javax.validation.constraints.Max.message}<span\n            class="code-string">";\n\tClass&lt;?&gt;[] groups() default { }; //用于分组的参数\n\tClass&lt;? extends Payload&gt;[] payload() default { };\n\tlong value();\n}</span></code></pre>\n<p>如果未指定该参数，那么校验都属于<em>javax.validation.groups.Default</em>分组。</p>\n<p>先定义一个分组，用一个没有任何功能的类或者接口即可：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.validation.groups;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n            class="code-title">BetaGroup</span> </span>{}</code></pre>\n<p>然后在校验的注解上通过<em>groups</em>指定分组：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">Game</span> </span>{\n\t\n\t<span class="code-meta">@NotNull</span>\n\t<span class="code-meta">@Min</span>(<span class="hljs-number">0</span>) <span\n            class="code-comment">//最小值&gt;=0</span>\n\t<span class="code-meta">@Max</span>(<span class="hljs-number">10</span>) <span\n            class="code-comment">//最大值&lt;=10</span>\n\t<span class="code-meta">@Max</span>(value=<span class="hljs-number">0</span>, message=<span class="code-string">"未发行的游戏版本为0!"</span>, groups = BetaGroup.class)<span\n            class="code-comment">//分组校验</span>\n\t<span class="code-keyword">private</span> <span class="code-keyword">int</span> currentVersion; \n\t\n\t<span class="code-meta">@AssertTrue</span>(groups = BetaGroup.class)<span class="code-comment">//分组校验</span>\n\t<span class="code-comment">//表示是否为内侧版</span>\n\t<span class="code-keyword">private</span> <span class="code-keyword">boolean</span> beta;\n    <span class="code-comment">//Other field ......</span>\n    <span class="code-comment">//getter and setter ......</span>\n}</code></pre>\n<p>然后执行分组校验：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="code-keyword">enum</span> StandardValidation {\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">validate</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-comment">//引入校验工具</span>\n\t\tValidatorFactory factory = Validation.buildDefaultValidatorFactory();\n\t\tValidator validator = factory.getValidator();\n\n\t\tGame wow = <span class="code-keyword">new</span> Game();\n\t\twow.setName(<span class="code-string">"World Of Warcraft"</span>);\n\t\twow.setDescription(<span class="code-string">"由著名游戏公司暴雪娱乐所制作的第一款网络游戏，属于大型多人在线角色扮演游戏。"</span>);\n\t\twow.setCurrentVersion(<span class="hljs-number">8</span>);\n\t\twow.setType(<span class="code-string">"RPG"</span>);\n\t\twow.setPrice(<span class="hljs-number">401.01F</span>);\n\n        <span class="code-comment">//使用默认分组校验</span>\n\t\tviolationSet = validator.validate(wow);\n\t\t\n\t\t<span class="code-comment">//指定分组校验</span>\n\t\tviolationSet = validator.validate(wow, BetaGroup.class);\n\t}\n}</code></pre>\n<p><em>Validator::validator</em>方法未指定分组时，相当于使用<em>javax.validation.groups.Default</em>分组。而在<em>violationSet=validator.validate(wow,\n    BetaGroup.class);</em>这一行代码指定分组之后，只会执行<em>groups = BetaGroup.class</em>注解的校验。</p>\n<p>可以一次指定多个分组的校验，这样有利于处理复杂的状态：</p>\n<pre><code class="java">validator.validate(wow, Default.class, BetaGroup.class, OtherGroup.class);</code></pre>\n\n<h2 id="h2-5">校验错误级别</h2>\n<p>校验的注解中还有一个参数——<em>payload</em>，他表示“校验问题”的级别。这个参数就像使用<em>Log4j</em>输出日志会指定<em>DEBUG、INFO、WARN</em>等级别一样，在校验数据时会有对“校验问题”进行分类的需求，比如某些页面会对用户录入的数据进行“错误”或“警告”的提示。\n</p>\n<p>在使用payload时需要先声明PalyLoad接口类以标定“问题级别”：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.validation;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">PayLoadLevel</span> </span>{\n    <span class="code-comment">//警告级别</span>\n\t<span class="code-keyword">static</span> <span class="code-keyword">public</span> <span class="hljs-class"><span\n            class="code-keyword">interface</span> <span class="code-title">WARN</span> <span class="code-keyword">extends</span> <span\n            class="code-title">Payload</span> </span>{}\n    <span class="code-comment">//错误级别</span>\n\t<span class="code-keyword">static</span> <span class="code-keyword">public</span> <span class="hljs-class"><span\n            class="code-keyword">interface</span> <span class="code-title">Error</span> <span class="code-keyword">extends</span> <span\n            class="code-title">Payload</span> </span>{}\n}</code></pre>\n<p>然后在JavaBean上指定“校验问题”的级别：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">Game</span> </span>{\n    <span class="code-comment">//默认分组校验错误时，错误级别为Error</span>\n\t<span class="code-meta">@NotNull</span>(payload=PayLoadLevel.Error.class)\n\t<span class="code-meta">@Min</span>(value=<span class="hljs-number">0</span>, payload=PayLoadLevel.Error.class) \n\t<span class="code-meta">@Max</span>(value=<span class="hljs-number">10</span>, payload=PayLoadLevel.Error.class) \n    <span class="code-comment">//BetaGroup分组错误级别为WARN</span>\n\t<span class="code-meta">@Max</span>(value=<span class="hljs-number">0</span>, message=<span class="code-string">"未发行的游戏版本为0!"</span>, groups = BetaGroup.class, payload=PayLoadLevel.WARN.class)\n\t<span class="code-keyword">private</span> <span class="code-keyword">int</span> currentVersion; \n\t\n\t<span class="code-meta">@AssertTrue</span>(groups = BetaGroup.class, payload=PayLoadLevel.WARN.class)\n\t<span class="code-keyword">private</span> <span class="code-keyword">boolean</span> beta;\n    <span class="code-comment">//Other field ......</span>\n    <span class="code-comment">//getter and setter ......\t</span>\n}</code></pre>\n<p>然后在执行校验的时候使用ConstraintViolation::getConstraintDescriptor::getPayload方法获取每一个校验问题的错误级别：</p>\n<pre><code class="java">violationSet = validator.validate(wow, BetaGroup.class);\nviolationSet.forEach(violat -&gt; {\n\tviolat.getPropertyPath();<span class="code-comment">//错误域的名称</span>\n    violat.getMessage();<span class="code-comment">//错误消息</span>\n\tviolat.getConstraintDescriptor().getPayload();<span class="code-comment">//错误级别</span>\n});</code></pre>'},358:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h2 id="h2-1">为什么要用Fragments</h2>\n<p>在我们使用React开发组件的时候，每个React组件都必须返回一个根元素。例如下面这样：</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">Table</span></span></span><span class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span class="hljs-class"><span class="code-title">Component</span></span></span><span class="hljs-class"> </span></span>{\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> (\n      <span class="xml"><span class="code-tag">&lt;<span class="code-name">table</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">tr</span>&gt;</span>\n          <span class="code-tag">&lt;<span class="code-name"><span class="code-type">Columns</span></span> /&gt;</span>\n        <span class="code-tag">&lt;/<span class="code-name">tr</span>&gt;</span>\n      <span class="code-tag">&lt;/<span class="code-name">table</span>&gt;</span>\n    );\n  }\n}\n\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">Columns</span> <span class="code-keyword">extends</span> <span class="code-title">React</span>.<span class="code-title">Component</span> </span>{\n  render() {\n    <span class="code-keyword">return</span> (\n      <span class="code-tag">&lt;<span class="code-name">div</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">td</span>&gt;</span><span class="code-type">Hello</span><span class="code-tag">&lt;/<span class="code-name">td</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">td</span>&gt;</span><span class="code-type">World</span><span class="code-tag">&lt;/<span class="code-name">td</span>&gt;</span>\n      <span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span>\n    );\n  }\n}</span></code></pre>\n<p>在正常的HTML行文中，&lt;tr&gt;标签与&lt;td&gt;标签之间的&lt;div&gt;标签是不应该存在的。</p>\n<p>虽然在这个小小的例子中，我们可以将tr标签移入到Columns中去解决这个问题，但是在错综复杂的业务层级代码中，我们经常会遇到希望一个组件返回多个并列标签的情况。</p>\n<p>为了解决这个问题，React在16.x版本新推出了一个Fragments特性——组件碎片化。Fragments的使用方法非常简单，我们将Column组件稍作改造即可：</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">Columns</span></span></span><span class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span class="hljs-class"><span class="code-title">Component</span></span></span><span class="hljs-class"> </span></span>{\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> (\n      <span class="xml"><span class="code-tag">&lt;<span class="code-name"><span class="code-type">React</span>.<span class="code-type">Fragment</span></span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">td</span>&gt;</span><span class="code-type">Hello</span><span class="code-tag">&lt;/<span class="code-name">td</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">td</span>&gt;</span><span class="code-type">World</span><span class="code-tag">&lt;/<span class="code-name">td</span>&gt;</span>\n      <span class="code-tag">&lt;/<span class="code-name"><span class="code-type">React</span>.<span class="code-type">Fragment</span></span>&gt;</span>\n    );\n  }\n}</span></code></pre>\n<p>这样，在最终渲染成Dom后，并不会出现任何与HTML行文不符的标签。</p>\n\n<h2 id="h2-2">简写与注意事项</h2>\n<p>除了React.Fragment这样的写法，React还推荐使用更加明了的简短写法：</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">Columns</span></span></span><span class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span class="hljs-class"><span class="code-title">Component</span></span></span><span class="hljs-class"> </span></span>{\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> (\n      <span class="xml"><span class="code-tag">&lt;&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">td</span>&gt;</span><span class="code-type">Hello</span><span class="code-tag">&lt;/<span class="code-name">td</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">td</span>&gt;</span><span class="code-type">World</span><span class="code-tag">&lt;/<span class="code-name">td</span>&gt;</span>\n      <span class="code-tag">&lt;/&gt;</span>\n    );\n  }\n}</span></code></pre>\n<p>需要注意的是：<span style="color:#FF0000">这样的写法不支持传递任何参数，而且某些编译器或者编译工具并不支持这种写法</span>。</p>\n\n<h2 id="h2-3">在队列中使用</h2>\n<p>一个React元素除了直接写成一个组件，也可以在队列中返回。Fragment标签使用到队列中同样也要<a href="https://www.chkui.com/article/react/react_list_key_and_form" title="列表与组件的键值">使用key属性来标记队列的位置</a>：</p>\n<pre class="javascript"><code class="language-javascript"><span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">function</span></span></span><span class="hljs-function"> </span><span class="code-title"><span class="hljs-function"><span class="code-title">Glossary</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{\n  <span class="code-keyword"><span class="code-keyword">return</span></span> (\n    <span class="xml"><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">dl</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n      {props.items.map(item =&gt; (\n        </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">React.Fragment</span></span></span></span><span class="xml"><span class="code-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="code-tag"><span class="hljs-attr">key</span></span></span></span><span class="xml"><span class="code-tag">=</span></span><span class="code-string"><span class="xml"><span class="code-tag"><span class="code-string">{item.id}</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n          </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">dt</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">{item.term}</span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">dt</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n          </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">dd</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">{item.description}</span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">dd</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n        </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">React.Fragment</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n      ))}\n    </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">dl</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n  );\n}</span></span></code></pre>\n<p></p>'},388:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h2 id="h2-1">WebFLux与WebMvc的差异</h2>\n<p><em>WebFlux</em>读写<em>Cookie</em>不像<em>WebMvc</em>那么直接，最主要的原因是<em>WebMvc</em>是基于<em>Servlet</em>规范的，而<em>WebFlux</em>仅仅遵守的是<em>HTTP</em>协议。所以在使用的时候会发现<code>HttpServletRequest</code>、<code>HttpServletResponse</code>这些<em>Servlet</em>层级的接口根本就无法使用。\n</p>\n<p><em>Cookie</em>与<em>Servlet</em>并没有太直接的关系，前者是属于<em>HTTP</em>规范的而后者是一个<em>J2EE</em>的规范，在应用层面仅有的联系就是<em>Servlet</em>会读写<em>Cookie</em>中的<em>JSESSIONID</em>来标记与前端浏览器和服务端的关系。而<code>HttpServletRequest</code>、<code>HttpServletResponse</code>仅是<em>Servlet</em>为请求和响应提供<em>header</em>、<em>body</em>管理的接口。\n</p>\n<h2 id="h2-2">WebFlux的Cookie管理</h2>\n<p><em>WebFlux</em>目前并没有为写<em>Cookie</em>提供任何工具。这就需要开发者按照<em>HTTP</em>的规范来写<em>Cookie</em>。\n    在HTTP协议交互的过程中，服务端可以通过在<em>response</em>中添加<strong>Set-Cookie</strong>头来让浏览器记录<em>Cookie</em>，而浏览器则在<em>request</em>中使用<strong>Cookie</strong>头来传递cookie。\n</p>\n<h2 id="h2-3">写Cookie</h2>\n<p>写<em>cookie</em>使用<code>ResponseEntity</code>向response头中添加<strong>Set-Cookie</strong>即可。<code>CookieBuilder</code>的代码比较长，它是用于构建一个<em>cookie</em>字符串，<strong>Set-Cookie</strong>头除了设置<em>key=value</em>，还可以设置过期日期<em>expires</em>，域名<em>domain</em>，路径<em>path</em>等。\n</p>\n<pre><code class="java"><span class="code-meta">@RestController</span>\n<span class="code-meta">@RequestMapping</span>(<span class="code-string">"/cookie"</span>)\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">CookieReadAWriteController</span> </span>{\n\t<span class="code-meta">@GetMapping</span>(<span class="code-string">"/write"</span>)\n\t<span class="hljs-function"><span class="code-keyword">public</span> ResponseEntity&lt;String&gt; <span\n            class="code-title">cookieWrite</span><span class="hljs-params">()</span> </span>{\n\t\tHttpHeaders headers = <span class="code-keyword">new</span> HttpHeaders();\n\t\tString cookie = <span class="code-keyword">new</span> CookieBuilder().setKey(<span class="code-string">"cookie-text"</span>)\n\t\t\t.setValue(cookieText)\n\t\t\t.setMaxAge(<span class="hljs-number">840000</span>)\n\t\t\t.setPath(<span class="code-string">"/"</span>)\n\t\t\t.build();\n\t\theaders.add(<span class="code-string">"Set-Cookie"</span>, cookie);\n\t\t<span class="code-keyword">return</span> <span\n            class="code-keyword">new</span> ResponseEntity&lt;String&gt;(<span class="code-string">"hi,"</span> + userName, headers, HttpStatus.OK);\n\t}\n}\n\n\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">CookieBuilder</span> </span>{\n\t<span class="code-keyword">private</span> String key;\n\t<span class="code-keyword">private</span> String value;\n\t<span class="code-keyword">private</span> String expires;\n\t<span class="code-keyword">private</span> String domain;\n\t<span class="code-keyword">private</span> String path;\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> CookieBuilder <span\n            class="code-title">setKey</span><span class="hljs-params">(String key)</span> </span>{\n\t\t<span class="code-keyword">this</span>.key = key;\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>;\n\t}\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> CookieBuilder <span\n            class="code-title">setValue</span><span class="hljs-params">(String value)</span> </span>{\n\t\t<span class="code-keyword">this</span>.value = value;\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>;\n\t}\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> CookieBuilder <span class="code-title">setMaxAge</span><span\n            class="hljs-params">(<span class="code-keyword">long</span> ms)</span> </span>{\n\t\t<span class="code-comment">//cookie的过期日期为GMT格式的时间。</span>\n\t\tDate date = <span class="code-keyword">new</span> Date(<span class="code-keyword">new</span> Date().getTime() + ms);\n\t\tSimpleDateFormat sdf = <span class="code-keyword">new</span> SimpleDateFormat(<span class="code-string">"EEE d MMM yyyy HH:mm:ss \'GMT\'"</span>, Locale.US);\n\t\tsdf.setTimeZone(TimeZone.getTimeZone(<span class="code-string">"GMT"</span>));\n\t\t<span class="code-keyword">this</span>.expires = sdf.format(date);\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>;\n\t}\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> CookieBuilder <span class="code-title">setDomain</span><span\n            class="hljs-params">(String domain)</span> </span>{\n\t\t<span class="code-keyword">this</span>.domain = domain;\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>;\n\t}\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> CookieBuilder <span\n            class="code-title">setPath</span><span class="hljs-params">(String path)</span> </span>{\n\t\t<span class="code-keyword">this</span>.path = path;\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>;\n\t}\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span\n            class="code-title">build</span><span class="hljs-params">()</span> </span>{\n\t\tStringBuilder sb = <span class="code-keyword">new</span> StringBuilder();\n\t\tsb.append(<span class="code-keyword">this</span>.key);\n\t\tsb.append(<span class="code-string">"="</span>);\n\t\tsb.append(<span class="code-keyword">this</span>.value);\n\t\tsb.append(<span class="code-string">";"</span>);\n\t\t<span class="code-keyword">if</span> (<span class="code-keyword">null</span> != <span\n            class="code-keyword">this</span>.expires) {\n\t\t\tsb.append(<span class="code-string">"expires="</span>);\n\t\t\tsb.append(<span class="code-keyword">this</span>.expires);\n\t\t\tsb.append(<span class="code-string">";"</span>);\n\t\t}\n\t\t<span class="code-keyword">if</span> (<span class="code-keyword">null</span> != <span\n            class="code-keyword">this</span>.domain) {\n\t\t\tsb.append(<span class="code-string">"domain="</span>);\n\t\t\tsb.append(<span class="code-keyword">this</span>.domain);\n\t\t\tsb.append(<span class="code-string">";"</span>);\n\t\t}\n\t\t<span class="code-keyword">if</span> (<span class="code-keyword">null</span> != <span\n            class="code-keyword">this</span>.path) {\n\t\t\tsb.append(<span class="code-string">"path="</span>);\n\t\t\tsb.append(<span class="code-keyword">this</span>.path);\n\t\t\tsb.append(<span class="code-string">";"</span>);\n\t\t}\n\t\t<span class="code-keyword">return</span> sb.toString();\n\t}\n}\n</code></pre>\n<h2 id="h2-4">读cookie</h2>\n<p>获取<em>cookie</em>就比较直观，可以直接使用<code>@CookieValue</code>这个<em>Annotation</em>来获取：</p>\n<pre><code class="java"><span class="code-meta">@RestController</span>\n<span class="code-meta">@RequestMapping</span>(<span class="code-string">"/cookie"</span>)\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">CookieReadAWriteController</span> </span>{\n\t<span class="code-meta">@GetMapping</span>(<span class="code-string">"/read/annotation"</span>)\n\t<span class="code-comment">/**\n\t * <span class="hljs-doctag">@param</span> value\n\t * <span class="hljs-doctag">@return</span>\n\t */</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">cookieReadAnnotation</span><span\n            class="hljs-params">(@CookieValue(<span\n            class="code-string">"cookie-text"</span>)</span> String value) </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"当前Cookie中的内容"</span> + value;\n\t}\n}\n</code></pre>\n<p>也可以直接从<em>Request的Header</em>中获取：</p>\n<pre><code class="java"><span class="code-meta">@RestController</span>\n<span class="code-meta">@RequestMapping</span>(<span class="code-string">"/cookie"</span>)\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">CookieReadAWriteController</span> </span>{\n\t<span class="code-meta">@GetMapping</span>(<span class="code-string">"/read/annotation"</span>)\n\t<span class="code-comment">/**\n\t * <span class="hljs-doctag">@param</span> value\n\t * <span class="hljs-doctag">@return</span>\n\t */</span>\n\t<span class="code-meta">@GetMapping</span>(<span class="code-string">"/read/entity"</span>)\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">cookieReadEntity</span><span\n            class="hljs-params">(RequestEntity&lt;String&gt; entity)</span> </span>{\n\t\tHttpHeaders headers = entity.getHeaders();\n\t\tList&lt;String&gt; cookie = headers.get(<span class="code-string">"Cookie"</span>);\n\t\t<span class="code-keyword">return</span> <span class="code-string">"当前Cookie中的内容"</span> + cookie;\n\t}\n}\n</code></pre>\n<p>\n    使用<em>Annotatin</em>是直接标记<em>Cookie</em>的<em>key</em>来获取<em>value</em>。而使用<em>RequestEntity</em>需要从头中先获取<em>Cookie</em>的内容，然后再解析<em>key</em>和<em>value</em>，存在一个<em>key</em>对应多个<em>value</em>的情况需要使用<em>RequestEntity</em>。\n</p>                                    '},402:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h2 id="h2-1">概念与应用</h2>\n<p><strong>Softmax</strong>是机器学习中一个非常重要的工具，他可以兼容 logistics 算法、可以独立作为机器学习的模型进行建模训练、还可以作为深度学习的激励函数。<br>\n    <strong>softmax</strong>的作用简单的说就计算一组数值中每个值的占比，公式一般性描述为：<br> 设一共有<img alt="机器学习——softmax计算"\n                                                                         src="https://math.jianshu.com/math?formula=n">个用数值表示的分类<img\n            alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=S_k%EF%BC%8Ck%5Cin(0%2Cn%5D">，其中<img\n            alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=n">表示分类的个数。那么softmax计算公式为：<br> <img\n            alt="机器学习——softmax计算"\n            src="https://math.jianshu.com/math?formula=P(S_i)%3D%5Cfrac%7Be%5E%7Bg_i%7D%7D%7B%5Csum_k%5Ene%5E%7Bg_k%7D%7D%2Ci%E8%A1%A8%E7%A4%BAk%E4%B8%AD%E7%9A%84%E6%9F%90%E4%B8%AA%E5%88%86%E7%B1%BB%EF%BC%8Cg_i%E8%A1%A8%E7%A4%BA%E8%AF%A5%E5%88%86%E7%B1%BB%E7%9A%84%E5%80%BC"\n            class="zoom-in-cursor">。</p>\n<p>在机器学习中经常用它来解决MECE原则的分类——每一个分类相互独立，所有的分类被完全穷尽。比如男人和女人就是负责MECE原则的。</p>\n\n<h2 id="h2-2">softmax的例子</h2>\n<p>看一个例子能更好的理解<strong>softmax</strong>。<br> 设有三个数值<img alt="机器学习——softmax计算"\n                                                       src="https://math.jianshu.com/math?formula=A%3D5%2CB%3D1%2CC%3D-1">，那么他们的softmax占比为：<br>\n    <img alt="机器学习——softmax计算"\n         src="https://math.jianshu.com/math?formula=P(A)%3D%5Cfrac%7Be%5E5%7D%7Be%5E5%2Be%2Be%5E%7B-1%7D%7D"><br> <img\n            alt="机器学习——softmax计算"\n            src="https://math.jianshu.com/math?formula=P(B)%3D%5Cfrac%7Be%7D%7Be%5E5%2Be%2Be%5E%7B-1%7D%7D"><br> <img\n            alt="机器学习——softmax计算"\n            src="https://math.jianshu.com/math?formula=P(C)%3D%5Cfrac%7Be%5E%7B-1%7D%7D%7Be%5E5%2Be%2Be%5E%7B-1%7D%7D"><br>\n    计算结果为：<br> <img alt="机器学习——softmax计算"\n                    src="https://math.jianshu.com/math?formula=P(A)%3D0.9817%2CP(B)%3D0.0180%2CP(C)%3D0.0003"\n                    class="zoom-in-cursor"><br> <img alt="机器学习——softmax计算"\n                                                     src="https://math.jianshu.com/math?formula=P(A)%2BP(B)%2BP(C)%3D1"\n                                                     class="zoom-in-cursor"></p>\n\n<h2 id="h2-3">基本特性</h2>\n<p>从上面的计算结果可以看出<em>softmax</em>的一些特性：</p>\n<ol>\n    <li>归一化：最后的合计为1，每一个分类都是一个小于1的数值。</li>\n    <li>放大效果：上面的例子中单纯从数值来看，5和1的差距并不大，但是通过指数运算有明显的放大效果，5的占比能到98%以上。</li>\n    <li>散列性质，每一个比率虽然最后都会进行归一，但是他们放大之前的数值是可以相互不干扰的。</li>\n</ol>\n\n<h2 id="h2-4">softmax的损失函数</h2>\n<p>softmax的损失函数可以用交叉熵来表述，也可以用极大似然评估来描述，后续的数学推导结论会发现2个算法的结果都是一样的。</p>\n\n<h3 id="h3-1">熵与交叉熵</h3>\n\n<h4 id="h4-1">熵</h4>\n<p>这里所说的熵来源于信息论，他表示“为了确保完整的信息被描述所需要的编码长度”。看起来是一个很拗口的概念，下面看一个例子。</p>\n<p>假设26个英文字母每个字母出现概率都是相同的<img alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=p">（即<img\n        alt="机器学习——softmax计算"\n        src="https://math.jianshu.com/math?formula=%5Cfrac%7B1%7D%7B26%7D">）,那么记录26个英文字母所需要的信息量是<img\n        alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=log_x%5Cfrac%7B1%7D%7Bp%7D">，这个公式就是表述26个字符的熵。如果取<img\n        alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=x%3D2">表示用一个信息位表示2个信息（也就是我们用来衡量数据大小最小计算单位bit：0/1），那么计算出<img\n        alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=log_226%3D4.7004%5Capprox5">说明表述所有的英文字符需要5bit的信息量。\n</p>\n\n<h4 id="h4-2">交叉熵</h4>\n<p>在实际使用中大部分事物都不是均匀分布的，比如一篇英文文章中\'e\'出现出现的频率明显多于其他字符，而且有时也无法知道真实分布的情况。这时计算信息量就可以使用交叉熵，它是在非均匀分布下信息量的一种表述表示：<br> <img\n        alt="机器学习——softmax计算"\n        src="https://math.jianshu.com/math?formula=H(p%2Cg)%3D%5Csum_i%5ENp_i%5Clog_x%5Cfrac%7B1%7D%7Bq_i%7D">。这里<img\n        alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=p_j">表示每一个事物的真实概率，<img alt="机器学习——softmax计算"\n                                                                                                src="https://math.jianshu.com/math?formula=q_j">表示对应的预估概率。<br>\n    关于交叉熵的详细说明可以看<a href="https://www.chkui.com/article/tensorflow/tensorflow_get_started_of_mnist" target="_blank"\n                    rel="nofollow">本人这篇MNIST介绍的文章关于熵与交叉熵的解释说明</a>。</p>\n\n<h3 id="h3-2">极大似然评估</h3>\n<p>softmax算法可以看做是一个概率问题，设<img alt="机器学习——softmax计算"\n                              src="https://math.jianshu.com/math?formula=A_i">表示不同的分类，每个分类的概率表示为<img\n        alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=P(A_i%7Cw_%7Bij%7Dx_j)">，其中<img\n        alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=i%20%5Cin%20(0%2CN%5D">表示分类的个数。<img\n        alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=j%5Cin(0.M%5D">&nbsp;<img alt="机器学习——softmax计算"\n                                                                                                   src="https://math.jianshu.com/math?formula=x_j">表示特征数。设<img\n        alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=q_i%3DP(A_i%7Cw_%7Bij%7Dx_j))">，那么在softmax中<img\n        alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=%5Csum_i%5EN%20q_i%20%3D%201">。用<img\n        alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=p_i">表示分类的真实分布，由于事物分类遵守MECE原则，所以所有的<img\n        alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=p_i">组合在一起实际上是个由1和0组成的数组，只有一个元素为1值。可以参照logistics回归算法：<img\n        alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=P%3Dq%5Ep(1-q)%5E%7B(1-p)%7D">，softmax也可以使用类似的结构：<img\n        alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=P%3D%5Cprod_i%5EN%20q_i%5E%7Bp_i%7D">&nbsp;。用对数最大似然评估作为损失函数：<br>\n    <img alt="机器学习——softmax计算"\n         src="https://math.jianshu.com/math?formula=L%3D%5Clog%5Cprod_i%5ENq_i%5E%7Bp_i%7D%3D%5Csum_i%5ENp_i%5Clog%7Bq_i%7D"\n         class="zoom-in-cursor">，<br> 可以看出极大似然评估和交叉熵最后得到的是一模一样的表达式。<br> 将公式扩展为<img alt="机器学习——softmax计算"\n                                                                                   src="https://math.jianshu.com/math?formula=M">个样本的情况：<br>\n    <img alt="机器学习——softmax计算"\n         src="https://math.jianshu.com/math?formula=L%3D%5Cfrac%7B1%7D%7BM%7D%5Clog%5Cprod_k%5EM%5Cprod_i%5ENq_%7Bij%7D%5E%7Bp_%7Bij%7D%7D%3D%5Cfrac%7B1%7D%7BM%7D%5Csum_k%5EM%5Csum_i%5EN%20p_%7Bkj%7D%5Clog%20q_%7Bkj%7D%2C%20k%5Cin(0%2CM%5D"\n         class="zoom-in-cursor"></p>\n\n<h2 id="h2-5">损失函数的含义</h2>\n<p>前面已经提到softmax分类应该遵守MECE原则，所以一个样本属于某个分类会用<strong>“占位”</strong>的方法来标注。例如现在有三个分类，样本A属于第二个分类表示为[0,1,0]、样本B属于第三个分类表示为[0,0,1]、C属于第一个分类——[1,0,0]。每个数组可以看做是的样本分类的真实概率分布——属于某个分类该分类对应的概率就是1，其他分类概率是0。<br>\n    特征和权重参数通过<em>softmax</em>计算之后得到的是一个概率分布。假设样本A的特征通过softmax计算后分类的概率是[0.2,0.6,0.2]，这个时候对于损失函数的计算结果是：<img\n            alt="机器学习——softmax计算"\n            src="https://math.jianshu.com/math?formula=0%C3%97%5Cln%200.2%2B1%C3%97%5Cln%200.6%20%2B%200%20%C3%97%20%5Cln%200.2%20%3D%20%5Cln%200.6%20%5Capprox%20-0.51"\n            class="zoom-in-cursor">。<br> 我们放大真实分布的比重为[0.1,0.8,0.1]后，计算结果：<img alt="机器学习——softmax计算"\n                                                                              src="https://math.jianshu.com/math?formula=%5Cln%200.8%20%5Capprox%20-0.22">，放大到[0.05,0.9,0.05]得：<img\n            alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=%5Capprox%20-0.10">。所以一个很直观的感受是：损失函数是从负数无限接近0。\n</p>\n<p>下面通过大量的数据来模拟这个过程。假设所有的样本属于2个分类，样本分类的标注固定为[1,0]，随机生成100个样本模拟分类的概率为：<br> <img alt="机器学习——softmax计算"\n                                                                               src="https://math.jianshu.com/math?formula=%5Cbegin%7Bmatrix%7D%20p_1%26p_2%5C%5C%200.2%260.8%20%5C%5C%200.7%260.3%20%5C%5C%200.9%260.1%20%5C%5C%20%E2%80%A6%26%E2%80%A6%20%5Cend%7Bmatrix%7D"><br>\n    那么这100组数据和损失函数计算结果构成的关系如下图：</p>\n<p><img alt="机器学习——softmax计算"\n        src="https://upload-images.jianshu.io/upload_images/2418406-e1dfac238be8f1a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"\n        class="zoom-in-cursor"></p>\n<p>交叉熵与分类的概率的关系</p>\n<p><br> 由于所有样本的标注都是[1,0]，所以<img alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=q_1">的概率越接近1、<img\n        alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=q_2">越接近0越符合真实分布。可以看到当<img\n        alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=q_1">接近1<img alt="机器学习——softmax计算"\n                                                                                      src="https://math.jianshu.com/math?formula=q_2">接近0时，交叉熵的计算结果从负数方向接近0。可以执行<a\n        href="https://github.com/chkui/ml-math-softmax/blob/master/sample/matplot/corss_entropy_feature.py"\n        target="_blank" rel="nofollow">模拟过程的源码</a>用matplotlib看到更清晰的结果。</p>\n<p></p>\n<p>再使用一个过程来确认这个结果。<strong>softmax</strong>是体现一组数值的占比，被标记的那个分类占比越高越接近真实分布。现在假设有5000组样本，每个样本对应20个分类，每个分类的特征值在0～10之间随机产生，每个样本的标记在0~20之间随机设定。现在看看标记项的概率值与损失函数的关系：\n</p>\n<p><img alt="机器学习——softmax计算"\n        src="https://upload-images.jianshu.io/upload_images/2418406-832b3f8fdcfba154.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"\n        class="zoom-in-cursor"></p>\n<p>标注项占比与交叉熵关系趋势</p>\n<p><br> 图中<em>softmax highest</em>表示标注项的概率（占比），<em>corss entropy</em>就是损失函数的计算结果。可以看到当标记项概率越接近1，损失的计算结果越接近0。如果有兴趣可以<a\n        href="https://github.com/chkui/ml-math-softmax/blob/master/sample/matplot/corss_entropy_ratio.py"\n        target="_blank" rel="nofollow">使用生成图像的代码</a>了解分析过程。</p>\n<p></p>\n\n<h2 id="h2-6">建模</h2>\n\n<h3 id="h3-3">softmax计算</h3>\n<p>上面的内容介绍了softmax的公式以及损失函数。下面说明其如何运算。<br> 在实际应用中一个样本的特征是一个的向量：<img alt="机器学习——softmax计算"\n                                                                    src="https://math.jianshu.com/math?formula=X%3D%7Bx_1%2Cx_2%2Cx_3%2C....x_n%7D">，每一个特征在计算过程中都有一个权重，所以引入权重参数建立权重结构（直线结构）：<br>\n    <img alt="机器学习——softmax计算"\n         src="https://math.jianshu.com/math?formula=g(x)%3Dw_0%2Bw_1x_1%2Bw_2x_2%2B...%2Bw_nx_n%3Dw_jx_j">，<img\n            alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=j%5Cin%5B0%2Cn%5D%EF%BC%8Cx_0%3D1"><br>\n    所以softmax更加完整的代数表达式是：<br> <img alt="机器学习——softmax计算"\n                                   src="https://math.jianshu.com/math?formula=softmax(x)%3D%5Cfrac%7Be%5E%7Bw_%7Bij%7Dx_j%7D%7D%7B%5Csum_j%5Ene%5E%7Bw_ijx_j%7D%7D"><br>\n    其中<img alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=i">表示计算结果有多少个分类<img alt="机器学习——softmax计算"\n                                                                                                src="https://math.jianshu.com/math?formula=i%5Cin(0%2Cm)">，j表示特征的个数<img\n            alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=j%5Cin%5B0.n%5D">。<br> 有<img\n            alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=o">个样本时就扩展为一个2阶张量，那么用矩阵形式表述更加简洁：<br> <img\n            alt="机器学习——softmax计算"\n            src="https://math.jianshu.com/math?formula=softmax(X)%3D%5Cfrac%7Be%5E%7BXW%5ET%7D%7D%7Be%5E%7BXW%5ET%7DE%7D"><br>\n    用下标<img alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=_%7B(o)%7D">表示当前的特征属于第几个样本，例如<img\n            alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=x_%7B(1)3%7D">表示第1个样本的第3个特征。矩阵的计算过程如下：</p>\n\n<h4 id="h4-3">1.计算权重指数</h4>\n<p><img alt="机器学习——softmax计算"\n        src="https://math.jianshu.com/math?formula=G%3Dexp%5Cleft(%20%5Cbegin%7Bbmatrix%7D%20x_%7B(1)0%7D%26x_%7B(1)1%7D%26x_%7B(1)2%7D%26%5Ccdots%26x_%7B(1)n%7D%5C%5C%20x_%7B(2)0%7D%26x_%7B(2)1%7D%26x_%7B(2)2%7D%26%5Ccdots%26x_%7B(2)n%7D%5C%5C%20x_%7B(3)0%7D%26x_%7B(3)1%7D%26x_%7B(3)2%7D%26%5Ccdots%26x_%7B(3)n%7D%5C%5C%20%5Cvdots%26%5Cvdots%26%5Cvdots%26%5Cddots%26%5Cvdots%5C%5C%20x_%7B(o)0%7D%26x_%7B(o)1%7D%26x_%7B(o)2%7D%26%5Ccdots%26x_%7B(o)n%7D%20%5Cend%7Bbmatrix%7D%20%C3%97%20%5Cbegin%7Bbmatrix%7D%20w_%7B10%7D%26w_%7B20%7D%26w_%7B30%7D%26%5Ccdots%26w_%7Bm0%7D%5C%5C%20w_%7B11%7D%26w_%7B21%7D%26w_%7B31%7D%26%5Ccdots%26w_%7Bm1%7D%5C%5C%20w_%7B12%7D%26w_%7B22%7D%26w_%7B32%7D%26%5Ccdots%26w_%7Bm2%7D%5C%5C%20%5Cvdots%26%5Cvdots%26%5Cvdots%26%5Cddots%26%5Cvdots%5C%5C%20w_%7B1n%7D%26w_%7B2n%7D%26w_%7B3n%7D%26%5Ccdots%26w_%7Bmn%7D%5C%5C%20%5Cend%7Bbmatrix%7D%5Cright)"><br>\n    矩阵中<img alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=x_%7B(o)0%7D%20%3D%201"><br> <img\n            alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=exp()">表示矩阵每一个元素求e指数。所以得到：</p>\n<p><img alt="机器学习——softmax计算"\n        src="https://math.jianshu.com/math?formula=G%3D%20%5Cbegin%7Bbmatrix%7D%20e%5E%7B%5Csum_j%5Enw_%7B1j%7Dx_%7B(1)j%7D%7D%26e%5E%7B%5Csum_j%5Enw_%7B2j%7Dx_%7B(1)j%7D%7D%26e%5E%7B%5Csum_j%5Enw_%7B3j%7Dx_%7B(1)j%7D%7D%26%5Ccdots%26e%5E%7B%5Csum_j%5Enw_%7Bmj%7Dx_%7B(1)j%7D%7D%5C%5C%20e%5E%7B%5Csum_j%5Enw_%7B1j%7Dx_%7B(2)j%7D%7D%26e%5E%7B%5Csum_j%5Enw_%7B2j%7Dx_%7B(2)j%7D%7D%26e%5E%7B%5Csum_j%5Enw_%7B3j%7Dx_%7B(2)j%7D%7D%26%5Ccdots%26e%5E%7B%5Csum_j%5Enw_%7Bmj%7Dx_%7B(2)j%7D%7D%5C%5C%20%5Cvdots%26%5Cvdots%26%5Cvdots%26%5Cddots%26%5Cvdots%5C%5C%20e%5E%7B%5Csum_j%5Enw_%7B1j%7Dx_%7B(o)j%7D%7D%26e%5E%7B%5Csum_j%5Enw_%7B2j%7Dx_%7B(o)j%7D%7D%26e%5E%7B%5Csum_j%5Enw_%7B3j%7Dx_%7B(o)j%7D%7D%26%5Ccdots%26e%5E%7B%5Csum_j%5Enw_%7Bmj%7Dx_%7B(o)j%7D%7D%20%5Cend%7Bbmatrix%7D">\n</p>\n<p>令<img alt="机器学习——softmax计算"\n         src="https://math.jianshu.com/math?formula=c_%7Bki%7D%3Dc(w_%7Bij%7D%2Cx_%7B(k)j%7D)%3De%5E%7B%5Csum_j%5Enw_%7Bij%7Dx_%7B(k)j%7D%7D%2Ck%5Cin(0%2Co%5D">，有：\n</p>\n<p><img alt="机器学习——softmax计算"\n        src="https://math.jianshu.com/math?formula=G%3DG(x)%3D%20%5Cbegin%7Bbmatrix%7D%20c_%7B11%7D%26c_%7B12%7D%26c_%7B13%7D%26%5Ccdots%26c_%7B1m%7D%5C%5C%20c_%7B21%7D%26c_%7B22%7D%26c_%7B23%7D%26%5Ccdots%26c_%7B2m%7D%5C%5C%20%5Cvdots%26%5Cvdots%26%5Cvdots%26%5Cddots%26%5Cvdots%5C%5C%20c_%7Bo1%7D%26c_%7Bo2%7D%26c_%7Bo3%7D%26%5Ccdots%26c_%7Bom%7D%5C%5C%20%5Cend%7Bbmatrix%7D">\n</p>\n\n<h4 id="h4-4">2.计算分母</h4>\n<p>现在<img alt="机器学习——softmax计算"\n          src="https://math.jianshu.com/math?formula=Softmax%3DS(x)%3D%5Cfrac%7BG%7D%7BG%C3%97E%7D"><br> <img\n        alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=E">是一个形状为<img alt="机器学习——softmax计算"\n                                                                                       src="https://math.jianshu.com/math?formula=m%C3%971">元素全为1的矩阵：<br>\n    <img alt="机器学习——softmax计算"\n         src="https://math.jianshu.com/math?formula=E%3D%5Cbegin%7Bbmatrix%7D%201%5C%5C%201%5C%5C%20%5Ccdots%5C%5C%201%20%5Cend%7Bbmatrix%7D">\n</p>\n<p>分母:<img alt="机器学习——softmax计算"\n           src="https://math.jianshu.com/math?formula=S%3DG%C3%97E%3D%5Cbegin%7Bbmatrix%7D%20c_%7B11%7D%26c_%7B12%7D%26c_%7B13%7D%26%5Ccdots%26c_%7B1m%7D%5C%5C%20c_%7B21%7D%26c_%7B22%7D%26c_%7B23%7D%26%5Ccdots%26c_%7B2m%7D%5C%5C%20%5Cvdots%26%5Cvdots%26%5Cvdots%26%5Cddots%26%5Cvdots%5C%5C%20c_%7Bo1%7D%26c_%7Bo2%7D%26c_%7Bo3%7D%26%5Ccdots%26c_%7Bom%7D%5C%5C%20%5Cend%7Bbmatrix%7D%C3%97%5Cbegin%7Bbmatrix%7D%201%5C%5C%201%5C%5C%20%5Ccdots%5C%5C%201%20%5Cend%7Bbmatrix%7D"><br>\n    所以：<img alt="机器学习——softmax计算"\n            src="https://math.jianshu.com/math?formula=S%3D%5Cbegin%7Bbmatrix%7D%20%5Csum_i%5Emc_%7B1i%7D%5C%5C%20%5Csum_i%5Emc_%7B2i%7D%5C%5C%20%5Csum_i%5Emc_%7B3i%7D%5C%5C%20%5Ccdots%5C%5C%20%5Csum_i%5Emc_%7Boi%7D%20%5Cend%7Bbmatrix%7D%3D%5Cbegin%7Bbmatrix%7Ds_1%5C%5Cs_2%5C%5Cs_3%5C%5C%5Ccdots%5C%5Cs_o%5Cend%7Bbmatrix%7D">\n</p>\n\n<h4 id="h4-5">3.归一化</h4>\n<p>现在<img alt="机器学习——softmax计算"\n          src="https://math.jianshu.com/math?formula=Q%3Dsoftmax%3D%5Cfrac%7BG%7D%7BS%7D%3D%5Cbegin%7Bbmatrix%7D%20c_%7B11%7D%26c_%7B12%7D%26c_%7B13%7D%26%5Ccdots%26c_%7B1m%7D%5C%5C%20c_%7B21%7D%26c_%7B22%7D%26c_%7B23%7D%26%5Ccdots%26c_%7B2m%7D%5C%5C%20%5Cvdots%26%5Cvdots%26%5Cvdots%26%5Cddots%26%5Cvdots%5C%5C%20c_%7Bo1%7D%26c_%7Bo2%7D%26c_%7Bo3%7D%26%5Ccdots%26c_%7Bom%7D%5C%5C%20%5Cend%7Bbmatrix%7D%5Cdiv%5Cbegin%7Bbmatrix%7Ds_1%5C%5Cs_2%5C%5Cs_3%5C%5C%5Ccdots%5C%5Cs_o%5Cend%7Bbmatrix%7D"><br>\n    所以最终<img alt="机器学习——softmax计算"\n             src="https://math.jianshu.com/math?formula=Q%3D%5Cbegin%7Bbmatrix%7D%20%5Cfrac%7Bc_%7B11%7D%7D%7Bd_1%7D%26%5Cfrac%7Bc_%7B12%7D%7D%7Bd_1%7D%26%5Cfrac%7Bc_%7B13%7D%7D%7Bd_1%7D%26%5Ccdots%26%5Cfrac%7Bc_%7B1m%7D%7D%7Bd_1%7D%5C%5C%20%5Cfrac%7Bc_%7B21%7D%7D%7Bd_2%7D%26%5Cfrac%7Bc_%7B22%7D%7D%7Bd_2%7D%26%5Cfrac%7Bc_%7B23%7D%7D%7Bd_2%7D%26%5Ccdots%26%5Cfrac%7Bc_%7B2m%7D%7D%7Bd_2%7D%5C%5C%20%5Cvdots%26%5Cvdots%26%5Cvdots%26%5Cddots%26%5Cvdots%5C%5C%20%5Cfrac%7Bc_%7Bo1%7D%7D%7Bd_o%7D%26%5Cfrac%7Bc_%7B12%7D%7D%7Bd_o%7D%26%5Cfrac%7Bc_%7B12%7D%7D%7Bd_o%7D%26%5Ccdots%26%5Cfrac%7Bc_%7B1m%7D%7D%7Bd_o%7D%5C%5C%20%5Cend%7Bbmatrix%7D%3D%5Cbegin%7Bbmatrix%7D%20q_%7B11%7D%26q_%7B12%7D%26q_%7B13%7D%26%5Ccdots%26q_%7B1m%7D%5C%5C%20q_%7B21%7D%26q_%7B22%7D%26q_%7B23%7D%26%5Ccdots%26q_%7B2m%7D%5C%5C%20%5Cvdots%26%5Cvdots%26%5Cvdots%26%5Cddots%26%5Cvdots%5C%5C%20q_%7Bo1%7D%26s_%7Bo2%7D%26q_%7Bo3%7D%26%5Ccdots%26q_%7Bom%7D%5C%5C%20%5Cend%7Bbmatrix%7D">\n</p>\n\n<h3 id="h3-4">交叉熵（极大似然评估）计算</h3>\n<p>根据交叉熵的公式<img alt="机器学习——softmax计算"\n                src="https://math.jianshu.com/math?formula=L%3D%5Csum_i%5Emp_i%5Clog%20q_i">，这里<img\n        alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=p_i">是样本的真实分类（标签label），<img\n        alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=q_i">是softmax计算的结果。用矩阵结构表示：<br> <img\n        alt="机器学习——softmax计算"\n        src="https://math.jianshu.com/math?formula=L%3D%5Cfrac%7B1%7D%7Bo%7D%5Cleft%5BP%5Clog%5Cleft(Q%5ET%5Cright)%5Cright%5D%5ED%C3%97E">，矩阵<img\n        alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=A_%7Bm%C3%97n%7D%5ED">表示取对角线元素形成一个<img\n        alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=1%C3%97n">的矩阵。</p>\n\n<h4 id="h4-6">1.对数及矩阵乘积</h4>\n<p><img alt="机器学习——softmax计算"\n        src="https://math.jianshu.com/math?formula=%5Cleft%5BP%5Clog%5Cleft(S%5ET%5Cright)%5Cright%5D%5ED%3D%20%5Cleft%5B%5Cbegin%7Bbmatrix%7D%20p_%7B(1)1%7D%26p_%7B(1)2%7D%26p_%7B(1)3%7D%26%5Ccdots%26p_%7B(1)m%7D%5C%5C%20p_%7B(2)1%7D%26p_%7B(2)2%7D%26p_%7B(2)3%7D%26%5Ccdots%26p_%7B(2)m%7D%5C%5C%20%5Cvdots%26%5Cvdots%26%5Cvdots%26%5Cddots%26%5Cvdots%5C%5C%20p_%7B(o)1%7D%26p_%7B(o)2%7D%26p_%7B(o)3%7D%26%5Ccdots%26p_%7B(o)m%7D%5C%5C%20%5Cend%7Bbmatrix%7D%C3%97%5Clog%5Cleft(%5Cbegin%7Bbmatrix%7D%20s_%7B11%7D%26s_%7B21%7D%26%5Ccdots%26s_%7Bo1%7D%5C%5C%20s_%7B12%7D%26s_%7B22%7D%26%5Ccdots%26s_%7Bo2%7D%5C%5C%20%5Cvdots%26%5Cvdots%26%5Cddots%26%5Cvdots%5C%5C%20s_%7B1m%7D%26s_%7B2m%7D%26%5Ccdots%26s_%7Bom%7D%5C%5C%20%5Cend%7Bbmatrix%7D%5Cright)%5Cright%5D%5ED"><br>\n    对数<img alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=%5Clog()">表示对每个元素进行对数运算，他仅改变每个元素的值，对矩阵结构没任何影响，所以下面用<img\n            alt="机器学习——softmax计算"\n            src="https://math.jianshu.com/math?formula=s_%7Bom%7D%E8%A1%A8%E7%A4%BA%5Clog(s_%7Bom%7D)">继续表示：<br> <img\n            alt="机器学习——softmax计算"\n            src="https://math.jianshu.com/math?formula=%5Cleft%5BP%5Clog%5Cleft(S%5ET%5Cright)%5Cright%5D%5ED%3D%20%5Cbegin%7Bbmatrix%7D%20%5Csum_i%5Em(p_%7B(1)i%7Ds_%7B(1)i%7D)%26%20%5Csum_i%5Em(p_%7B(2)i%7Ds_%7B(2)i%7D)%26%20%5Ccdots%26%20%5Csum_i%5Em(p_%7B(o)i%7Ds_%7B(o)i%7D)%20%5Cend%7Bbmatrix%7D">\n</p>\n\n<h4 id="h4-7">2.交叉熵计算</h4>\n<p><img alt="机器学习——softmax计算"\n        src="https://math.jianshu.com/math?formula=L%3D%5Cfrac%7B1%7D%7Bo%7D%C3%97%5Cbegin%7Bbmatrix%7D%20%5Csum_i%5Em(p_%7B(1)i%7Ds_%7B(1)i%7D)%26%20%5Csum_i%5Em(p_%7B(2)i%7Ds_%7B(2)i%7D)%26%20%5Ccdots%26%20%5Csum_i%5Em(p_%7B(o)i%7Ds_%7B(o)i%7D)%20%5Cend%7Bbmatrix%7D%C3%97%5Cbegin%7Bbmatrix%7D%201%5C%5C%201%5C%5C%20%5Ccdots%5C%5C%201%20%5Cend%7Bbmatrix%7D"><br>\n    将<img alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=%5Clog">符号带入公式得到最终的损失函数矩阵计算结果：<br> <img\n            alt="机器学习——softmax计算"\n            src="https://math.jianshu.com/math?formula=L%3D%5Cfrac%7B1%7D%7Bo%7D%5Cbegin%7Bbmatrix%7D%5Csum_k%5Eo%5Csum_i%5Em%5Cleft%5Bp_%7B(o)i%7D%5Clog(s_%7B(o)i%7D)%20%5Cright%5D%5Cend%7Bbmatrix%7D"><br>\n    把矩阵符号去掉，这里的结果和前面<strong>最大似然评估</strong>推导的结果一致。</p>\n\n<h3 id="h3-5">参数优化</h3>\n<p>通过前文的介绍我们知道,损失函数的目标是获得<strong>“最大值”</strong>，这个最大值的含义是从负无穷方向接近0的一个极限过程。所以经常会看到很多文章会在指标函数前面添加一个负号，如下面这样：<br> <img\n        alt="机器学习——softmax计算"\n        src="https://math.jianshu.com/math?formula=Loss%3D-%5Cfrac%7B1%7D%7Bo%7D%5Csum%5Csum%20p%5Cln%20q"><br>\n    这样就可以把这个过程转变为求<strong>“最小值”</strong>——从正无穷方向接近0，本质并没有多大区别。</p>\n<p>既然这是一个极限过程，自然就可以用积分原理逐渐计算合理的参数。现在的目标是通过导数和找到递增量可以逐步求解<img alt="机器学习——softmax计算"\n                                                             src="https://math.jianshu.com/math?formula=w_%7Bij%7D">值：<br>\n    用<img alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=%5Cnabla_%7Bij%7D">表示<img\n            alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=w_%7Bij%7D">的偏导函数:<img\n            alt="机器学习——softmax计算"\n            src="https://math.jianshu.com/math?formula=%5Cnabla_%7Bij%7D%3D%5Cfrac%7B%5Cpartial%20L(w_%7Bij%7D)%7D%7B%5Cpartial%20w_%7Bij%7D%7D">。<img\n            alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=w_%7Bij%7D">的更新公式为：<img\n            alt="机器学习——softmax计算"\n            src="https://math.jianshu.com/math?formula=w_%7Bij%7D%3Dw_%7Bij%7D%2B%5Ceta%5Cnabla_%7Bij%7D">。<img\n            alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=%5Ceta">表示每一步更新的步长。<br>\n    如果损失函数前携带了负号，那么更新公式应该修改为<img alt="机器学习——softmax计算"\n                                 src="https://math.jianshu.com/math?formula=w_%7Bij%7D%3Dw_%7Bij%7D-%5Ceta%5Cnabla_%7Bij%7D">，即越来越小。\n</p>\n\n<h4 id="h4-8">1.求偏导函数</h4>\n<p>目的已经明确，那么接下来就是数学运算了：<br> 设softmax计算结果一共有M个分类，输入模型的一个样本一共有N个特征。<br> <img alt="机器学习——softmax计算"\n                                                                           src="https://math.jianshu.com/math?formula=g_i">表示权重计算的结果，下标<img\n        alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=i">表示所属的分类，用数组可以表示为：<br> <img\n        alt="机器学习——softmax计算"\n        src="https://math.jianshu.com/math?formula=%5Cbegin%7Bbmatrix%7D%20g_1%3D%5Csum_j%5ENw_%7B1j%7Dx_j%5C%5C%20g_2%3D%5Csum_j%5ENw_%7B2j%7Dx_j%5C%5C%20%5Cvdots%5C%5C%20g_i%3D%5Csum_j%5ENw_%7Bij%7Dx_j%5C%5C%20%5Cvdots%5C%5C%20g_M%3D%5Csum_j%5ENw_%7BMj%7Dx_j%5C%5C%20%5Cend%7Bbmatrix%7D"><br>\n    <img alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=q_i">表示每一个分类softmax计算的结果：<img\n            alt="机器学习——softmax计算"\n            src="https://math.jianshu.com/math?formula=q_i%3D%5Cfrac%7Bg_i%7D%7B%5Csum_k%5EMg_k%7D">,k表示分类迭代求和的下标：用数组表示为：<br>\n    <img alt="机器学习——softmax计算"\n         src="https://math.jianshu.com/math?formula=%5Cbegin%7Bbmatrix%7D%20q_1%3D%5Cfrac%7Be%5E%7Bg_1%7D%7D%7B%5Csum_k%5EMe%5E%7Bg_k%7D%7D%5C%5C%20q_2%3D%5Cfrac%7Be%5E%7Bg_2%7D%7D%7B%5Csum_k%5EMe%5E%7Bg_k%7D%7D%5C%5C%20%5Cvdots%5C%5C%20q_i%3D%5Cfrac%7Be%5E%7Bg_i%7D%7D%7B%5Csum_k%5EMe%5E%7Bg_k%7D%7D%5C%5C%20%5Cvdots%5C%5C%20q_M%3D%5Cfrac%7Be%5E%7Bg_M%7D%7D%7B%5Csum_k%5EMe%5E%7Bg_k%7D%7D%5C%5C%20%5Cend%7Bbmatrix%7D"><br>\n    Loss是最终的损失函数：<img alt="机器学习——softmax计算"\n                      src="https://math.jianshu.com/math?formula=Loss%3D%5Csum_k%5EM%20L_k%20%3D%20%5Csum_k%5EM%20p_k%5Cln%20q_k">。<img\n            alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=p_k">表示每一个softmax分类对应的真实概率，取值0或1。<br>\n    优化参数是不断的调优权重参数，所以把<img alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=w_%7Bij%7D">看做自变量求导：<br>\n    <img alt="机器学习——softmax计算"\n         src="https://math.jianshu.com/math?formula=%5Cnabla_%7Bij%7D%3D%5Cfrac%7B%5Cpartial%20Loss%7D%7B%5Cpartial%20w_%7Bij%7D%7D"><br>\n    按照前面给出的公式将损失函数的计算分为3步：1）计算权重模型，2）计算softmax，3）计算交叉熵。现在把求导过程分为这3步对<img alt="机器学习——softmax计算"\n                                                                         src="https://math.jianshu.com/math?formula=q_i">、<img\n            alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=g_i">以及<img alt="机器学习——softmax计算"\n                                                                                         src="https://math.jianshu.com/math?formula=w_%7Bij%7D">复合求导：<br>\n    <img alt="机器学习——softmax计算"\n         src="https://math.jianshu.com/math?formula=%5Cbegin%7Bsplit%7D%20%5Cnabla_%7Bij%7D%26%3D%5Cleft(%5Csum_k%5EM%20p_k%5Cln%20q_k%5Cright)%27%5C%5C%20%26%3D%5Csum_k%5EM%5Cfrac%7Bp_k%7D%7Bq_k%7D%5Cleft(%5Csum_k%5EM%5Cfrac%7Be%5E%7Bg_k%7D%7D%7B%5Csum_l%5EMe%5E%7Bg_l%7D%7D%20%5Cright)%27%5C%5C%20%26%3D%5Csum_k%5EM%5Cfrac%7Bp_k%7D%7Bq_k%7D%5Cfrac%7B%5Cleft(e%5E%7Bg_k%7D%5Cright)%27%5Csum_l%5EMe%5E%7Bg_l%7D%20-%20e%5E%7Bg_k%7D%5Cleft(%5Csum_l%5EMe%5E%7Bg_l%7D%5Cright)%27%7D%7B%5Cleft(%5Csum_l%5EMe%5E%7Bg_l%7D%5Cright)%5E2%7D%5C%5C%20%26%3D%5Csum_k%5EM%5Cfrac%7Bp_k%7D%7Bq_k%7D%5Cleft%5B%5Cfrac%7B%5Cleft(e%5E%7Bg_k%7D%5Cright)%27%7D%7B%5Csum_l%5EMe%5E%7Bg_l%7D%7D%20-%20%5Cfrac%7Be%5E%7Bg_k%7D%7D%7B%5Csum_l%5EMe%5E%7Bg_l%7D%7D%5Cfrac%7Be%5E%7Bg_i%7D%7D%7B%5Csum_l%5EMe%5E%7Bg_l%7D%7D%5Cleft(g_k%5Cright)%27%5Cright%5D%20%5Cend%7Bsplit%7D">\n</p>\n<p>计算到这里需要注意一个问题。因为目标是对<img alt="机器学习——softmax计算"\n                            src="https://math.jianshu.com/math?formula=w_%7Bij%7D">求导，所以在求和公式中包含<img\n        alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=w_%7Bij%7D">的项（即包含<img alt="机器学习——softmax计算"\n                                                                                                src="https://math.jianshu.com/math?formula=g_i">的项）和不包含的项求导的结果是不一样的，所以需要将<img\n        alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=g_i">项单独拿出来求导。所以有：<br> <img\n        alt="机器学习——softmax计算"\n        src="https://math.jianshu.com/math?formula=%5Cbegin%7Bsplit%7D%20%5Cnabla_%7Bij%7D%26%3D%5Cfrac%7Bp_i%7D%7Bq_i%7D%5Cleft%5B%5Cfrac%7B%5Cleft(e%5E%7Bg_i%7D%5Cright)%27%7D%7B%5Csum_l%5EMe%5E%7Bg_l%7D%7D%20-%20%5Cfrac%7Be%5E%7Bg_i%7D%7D%7B%5Csum_l%5EMe%5E%7Bg_l%7D%7D%5Cfrac%7Be%5E%7Bg_i%7D%7D%7B%5Csum_l%5EMe%5E%7Bg_l%7D%7D%5Cleft(g_k%5Cright)%27%5Cright%5D%20%2B%20%5Csum_%7Bk%20%5Cneq%20i%7D%5EM%5Cfrac%7Bp_k%7D%7Bq_k%7D%5Cleft%5B%5Cfrac%7B%5Cleft(e%5E%7Bg_k%7D%5Cright)%27%7D%7B%5Csum_l%5EMe%5E%7Bg_l%7D%7D%20-%20%5Cfrac%7Be%5E%7Bg_k%7D%7D%7B%5Csum_l%5EMe%5E%7Bg_l%7D%7D%5Cfrac%7Be%5E%7Bg_i%7D%7D%7B%5Csum_l%5EMe%5E%7Bg_l%7D%7D%5Cleft(g_k%5Cright)%27%5Cright%5D%5C%5C%20%26%3D%5Cfrac%7Bp_i%7D%7Bq_i%7D%5Cleft(q_i-q_i%5E2%5Cright)%5Cleft(g_k%5Cright)%27-%5Csum_%7Bk%20%5Cneq%20i%7D%5EM%5Cfrac%7Bp_k%7D%7Bq_k%7Dq_kq_i%5Cleft(g_k%5Cright)%27%5C%5C%20%26%3D%5Cleft%5Bp_i-%5Cleft(p_iq_i%2B%5Csum_%7Bk%5Cneq%20i%7D%5EMp_kq_i%5Cright)%5Cright%5D%5Cleft(g_k%5Cright)%27%5C%5C%20%26%3D%5Cleft(p_i-q_i%5Csum_%7Bk%7D%5EMp_k%5Cright)%5Cfrac%7B%5Cpartial%5Csum_j%5EN%20w_%7Bij%7Dx_j%7D%7B%5Cpartial%20w_%7Bij%7D%7D%5C%5C%20%26%3D%5Cleft(p_i-q_i%5Csum_%7Bk%7D%5EMp_k%5Cright)x_j%20%5Cend%7Bsplit%7D"><br>\n    <img alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=p_k">是一个结构为[0,0,0,1,0,0......]的只有一个元素是1其余元素为0的数组，所以它的合计为1，因此得：\n</p>\n<p><img alt="机器学习——softmax计算"\n        src="https://math.jianshu.com/math?formula=%5Cnabla_%7Bij%7D%20%3D%20%5Cleft(p_i-q_i%5Cright)x_j"></p>\n<p>虽然推导这个求偏导的过程要花费一些功夫，但是这个结果却非常简单——<strong>真实分布与预测分布的差值乘权重参数对应的特征值</strong>。如果交叉熵函数中使用了负号，那么导函数为<img\n        alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=%5Cnabla_%7Bij%7D%3D(q_i-p_i)x_j">，很多文章更喜欢用这种求最小值的方式。<br>\n    观察<img alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=%5Cnabla_%7Bij%7D">的表达式，<img\n            alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=p_i">和<img alt="机器学习——softmax计算"\n                                                                                        src="https://math.jianshu.com/math?formula=x_j">都是已知的数值，在优化的过程中只有<img\n            alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=q_i">会发生改变。所以当预测分布越接近真实分布时增量会越来越接近0。</p>\n\n<h4 id="h4-9">2.多个样本与矩阵运算</h4>\n<p>上面求导的过程并没有考虑多个样本的情况，设现在有O个样本。那么求导公式变成：<br> <img alt="机器学习——softmax计算"\n                                                   src="https://math.jianshu.com/math?formula=%5Cnabla_%7Bij%7D%3D%5Cfrac%7B1%7D%7BO%7D%5Csum_k%5EO(p_%7B(k)i%7D-q_i)x_%7B(k)j%7D">。<br>\n    因为每一个子项的求导结果都是向0接近，所以求和再平分之后也是靠近0的。<br> 现在模型参数的更新公式用矩阵表示为：<br> <img alt="机器学习——softmax计算"\n                                                                        src="https://math.jianshu.com/math?formula=W%3DW%2B%5Ceta%20D">。其中<img\n            alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=D">是<img alt="机器学习——softmax计算"\n                                                                                      src="https://math.jianshu.com/math?formula=%5Cnabla_%7Bij%7D">的矩阵形，<img\n            alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=%5Ceta">是一个常量，<img alt="机器学习——softmax计算"\n                                                                                                src="https://math.jianshu.com/math?formula=W">是<img\n            alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=w_%7Bij%7D">的矩阵形。<br>\n    设P表示样本真实分布的矩阵（即标记矩阵），Q是文章前面介绍的softmax矩阵计算的结果，X表示样本矩阵。那么D的矩阵表示为：<img alt="机器学习——softmax计算"\n                                                                        src="https://math.jianshu.com/math?formula=D%3D(P-Q)%5ETX">。\n</p>\n\n<h2 id="h2-7">计算法则总结与编码实现</h2>\n\n<h3 id="h3-6">算法总结</h3>\n<p>经过前面推导分析，softmax机器学习算法建模分为以下几项内容。</p>\n\n<h4 id="h4-10">1.定义</h4>\n<p>有<img alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=O">个样本、<img alt="机器学习——softmax计算"\n                                                                                      src="https://math.jianshu.com/math?formula=N">个特征、<img\n        alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=M">个分类，。<br> <img alt="机器学习——softmax计算"\n                                                                                           src="https://math.jianshu.com/math?formula=X">是样本（feature）矩阵，形状为<img\n        alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=(O%2CN)"><br> <img alt="机器学习——softmax计算"\n                                                                                            src="https://math.jianshu.com/math?formula=W">是权重矩阵，形状为<img\n        alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=(M%2CN)"><br> <img alt="机器学习——softmax计算"\n                                                                                            src="https://math.jianshu.com/math?formula=P">是标签（label）矩阵，形状为<img\n        alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=(O%2CM)"><br> <img alt="机器学习——softmax计算"\n                                                                                            src="https://math.jianshu.com/math?formula=Q">是softmax计算后得到的矩阵，形状为<img\n        alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=(O%2CM)"><br> <img alt="机器学习——softmax计算"\n                                                                                            src="https://math.jianshu.com/math?formula=E_1%2CE_2">是两个用于合并计算的单位矩阵，形状为(M,1)和(O,1)，<img\n        alt="机器学习——softmax计算"\n        src="https://math.jianshu.com/math?formula=E%3D%5Cbegin%7Bbmatrix%7D%201%5C%5C1%5C%5C%20%5Ccdots%20%5C%5C1%20%5Cend%7Bbmatrix%7D"><br>\n    矩阵<img alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=A%5ET">表示转置矩阵，<img alt="机器学习——softmax计算"\n                                                                                               src="https://math.jianshu.com/math?formula=A%5ED">表示取矩阵的对角线元素（类似于特征）。\n</p>\n\n<h4 id="h4-11">2.softmax计算</h4>\n<p>权重指数：<img alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=G%3De%5E%7BXW%5ET%7D"><br> 归一化：<img\n        alt="机器学习——softmax计算" src="https://math.jianshu.com/math?formula=Q%3DSoftmax%3D%5Cfrac%7BG%7D%7BG*E_1%7D"></p>\n\n<h4 id="h4-12">3.损失函数</h4>\n<p><img alt="机器学习——softmax计算"\n        src="https://math.jianshu.com/math?formula=Loss%3D%5Cfrac%7B1%7D%7Bo%7D%5Cleft%5BPlog(Q%5ET)%5Cright%5D%5ED%C3%97E">\n</p>\n\n<h4 id="h4-13">4.参数训练</h4>\n<p><img alt="机器学习——softmax计算"\n        src="https://math.jianshu.com/math?formula=W%3DW%2B%5Ceta%5Cfrac%7B%5Cleft(P-Q%5Cright)%5ET%C3%97X%7D%7BO%7D">，训练会重复这个计算，直到变化率“接近”0。\n</p>\n\n<h3 id="h3-7">编码实现</h3>\n<p>以下代码在<a href="https://github.com/chkui/ml-math-softmax" target="_blank" rel="nofollow">https://github.com/chkui/ml-math-softmax</a>。<br>\n    如下图，<code>sample.softmax_train.softmax_modual.Softmax</code>类模拟了一个softmax机器学习的过程。</p>\n<pre><code class="ruby">import numpy as np\n\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">Softmax</span>:</span>\n    <span class="hljs-function"><span class="code-keyword">def</span> <span class="code-title">__init__</span><span\n            class="hljs-params">(<span class="code-keyword">self</span>, features, labels)</span></span>:\n        <span class="code-keyword">self</span>.__features = features\n        <span class="code-keyword">self</span>.__labels = labels\n        <span class="code-keyword">self</span>.__weight = np.zeros((labels.shape[<span class="hljs-number">1</span>], features.shape[<span\n            class="hljs-number">1</span>]))\n        <span class="code-comment"># 用于 softmax 归一化计算分布的标量矩阵</span>\n        <span class="code-keyword">self</span>.__e_softmax = np.ones((labels.shape[<span class="hljs-number">1</span>], <span\n            class="hljs-number">1</span>))\n        <span class="code-comment"># 用于 损失函数计算的标量矩阵</span>\n        <span class="code-keyword">self</span>.__e_loss = np.ones((features.shape[<span\n            class="hljs-number">0</span>], <span class="hljs-number">1</span>))\n        <span class="code-comment"># flag用于标记运算符号</span>\n        <span class="code-comment"># flag如果是-1,那么损失函数就是求最小值，那么优化器求差值。</span>\n        <span class="code-comment"># flag如果是+1损失函数就是求最大值，那么优化器求和</span>\n        <span class="code-keyword">self</span>.__flag = <span class="hljs-number">1</span>\n\n    <span class="hljs-function"><span class="code-keyword">def</span> <span class="code-title">__softmax</span><span\n            class="hljs-params">(<span class="code-keyword">self</span>)</span></span>:\n        liner = <span class="code-keyword">self</span>.__features * <span class="code-keyword">self</span>.__weight.T\n        exp = np.exp(liner)\n        den = exp * <span class="code-keyword">self</span>.__e_softmax\n        q = exp / den\n        <span class="code-keyword">return</span> q\n\n    <span class="hljs-function"><span class="code-keyword">def</span> <span class="code-title">__loss</span><span\n            class="hljs-params">(<span class="code-keyword">self</span>, q)</span></span>:\n        h = <span class="code-keyword">self</span>.__labels * np.log(q.T)\n        h = h.diagonal()\n        loss = <span class="code-keyword">self</span>.__flag * h * <span\n            class="code-keyword">self</span>.__e_loss / <span class="code-keyword">self</span>.__e_loss.shape[<span\n            class="hljs-number">0</span>]\n        <span class="code-keyword">return</span> loss\n\n    <span class="hljs-function"><span class="code-keyword">def</span> <span class="code-title">__optimizer</span><span\n            class="hljs-params">(<span class="code-keyword">self</span>, q, step)</span></span>:\n        d = ((<span class="code-keyword">self</span>.__flag * <span class="code-keyword">self</span>.__labels - <span\n            class="code-keyword">self</span>.__flag * q).getT() * <span\n            class="code-keyword">self</span>.__features) / <span class="code-keyword">self</span>.__features.shape[<span\n            class="hljs-number">0</span>]\n        <span class="code-keyword">self</span>.__weight = <span class="code-keyword">self</span>.__weight + (<span\n            class="code-keyword">self</span>.__flag * step) * d\n\n    <span class="hljs-function"><span class="code-keyword">def</span> <span class="code-title">train</span><span\n            class="hljs-params">(<span class="code-keyword">self</span>, handle, repeat=<span\n            class="hljs-number">2000</span>, step=<span class="hljs-number">0</span>.<span class="hljs-number">1</span>)</span></span>:\n        <span class="code-string">""</span><span class="code-string">"\n        训练\n        :param handle: 单轮训练的回调，用于输出各项数据 (count, loss, )\n        :param repeat: 重复的轮次,每轮会执行一次存储 2000\n        :param step: 优化器步近量\n        :return:\n        "</span><span class="code-string">""</span>\n        print(<span class="code-string">"Weight shape={}"</span>.format(<span class="code-keyword">self</span>.__weight.shape))\n        count = <span class="hljs-number">0</span>\n        <span class="code-keyword">while</span> count &lt; <span class="hljs-symbol">repeat:</span>\n            q = <span class="code-keyword">self</span>.__softmax()\n            loss = <span class="code-keyword">self</span>.__loss(q)\n            <span class="code-keyword">self</span>.__optimizer(q, step)\n            count = count + <span class="hljs-number">1</span>\n            handle(count, loss)\n</code></pre>\n<p>\n    类中的<code>__softmax</code>、<code>__loss</code>、<code>__optimizer</code>方法分别对应前面介绍的三步计算（归一化，损失函数，参数优化），而在<code>train</code>方法中就是重复调用这三个方法来不断的优化权重参数。<br>\n    为了执行训练<a href="https://github.com/chkui/ml-math-softmax/blob/master/sample/softmax_train/random_data.py"\n             target="_blank"\n             rel="nofollow"><code>sample.softmax_train.random_data.RandomData</code></a>用于随机生成<em>样本特征</em>和<em>样本标签</em>数据。<br>\n    下图展示了执行5000次优化过程中<strong>Loss</strong>的变化趋势：</p>\n<p><img alt="机器学习——softmax计算"\n        src="https://upload-images.jianshu.io/upload_images/2418406-b3452c5dfefc46a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"\n        class="zoom-in-cursor"></p>\n<p>训练次数与损失函数的输出</p>\n<p><br> <strong>Count</strong>表示执行训练的次数，<strong>Loss</strong>表示损失函数的输出值，可以发现几个特点：</p>\n<p></p>\n<ol>\n    <li>在优化的过程中<em>Loss</em>是逐渐接近0的。</li>\n    <li>反复使用相同的样本（案例中随机生成了500个样本）优化器在前1000次有比较明显的效果，但是后续增长乏力。</li>\n</ol>\n<p>由于使用的是随机数据，所以收敛的效果并不太理想，但是总的趋势还是收敛。后续的博文中本人会使用MNIST之类的真实数据来测试验证softmax。</p>\n<p>Github的代码中除了<a href="https://github.com/chkui/ml-math-softmax/tree/master/sample/softmax_train" target="_blank"\n                  rel="nofollow"><code>softmax_train</code></a>用于演示训练和收敛的效果，还有<a\n        href="https://github.com/chkui/ml-math-softmax/tree/master/sample/softmax_estimator" target="_blank"\n        rel="nofollow"><code>softmax_estimator</code></a>和<a\n        href="https://github.com/chkui/ml-math-softmax/blob/master/sample/softmax_compute.py" target="_blank"\n        rel="nofollow"><code>softmax_compute</code></a>。前者提供了参数相关的磁盘操作，后者简单展示了softmax算法的编码实现，需要了解的可以到代码库中查看。</p>'}});