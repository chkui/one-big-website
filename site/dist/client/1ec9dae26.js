webpackJsonp([1],{334:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<p>JSR330是Jcp给出的官方标准反向依赖注入规范。Java大部分反向依赖注入的工具或者框架目前基本上都满足JSR330规范、例如spring、guice以及Dagger。</p>\n<p>以我们最常用的spring为例。</p>\n<p>JSR中<span style="color:#cc0000">@Inject</span>可以当做<span style="color:#cc0000">@AutoWired</span>来使用。而<span\n        style="color:#cc0000">@Named</span>可以当做<span style="color:#cc0000">@Component</span>来使用。</p>\n<p>使用JSR330首先要引入javax.inject包：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">dependency</span>&gt;</span>  \n    <span class="code-tag">&lt;<span class="code-name">groupId</span>&gt;</span>javax.inject<span class="code-tag">&lt;/<span\n            class="code-name">groupId</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">artifactId</span>&gt;</span>javax.inject<span class="code-tag">&lt;/<span\n            class="code-name">artifactId</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">version</span>&gt;</span>1<span class="code-tag">&lt;/<span\n            class="code-name">version</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">dependency</span>&gt;</span> </code></pre>\n<p>目前Maven中央仓库中就一个inject的jar。</p>\n<p>首先使用xml配置通过注解扫描添加bean。</p>\n<pre><code class="xml"><span class="php"><span class="code-meta">&lt;?</span>xml version=<span\n        class="code-string">"1.0"</span> encoding=<span class="code-string">"UTF-8"</span><span\n        class="code-meta">?&gt;</span></span>\n<span class="code-tag">&lt;<span class="code-name">beans</span> <span class="hljs-attr">xmlns</span>=<span\n        class="code-string">"http://www.springframework.org/schema/beans"</span>\n    <span class="hljs-attr">xmlns:xsi</span>=<span\n            class="code-string">"http://www.w3.org/2001/XMLSchema-instance"</span>\n    <span class="hljs-attr">xmlns:context</span>=<span class="code-string">"http://www.springframework.org/schema/context"</span>  \n    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="code-string">"http://www.springframework.org/schema/beans  \n    http://www.springframework.org/schema/beans/spring-beans-3.1.xsd  \n    http://www.springframework.org/schema/context  \n    http://www.springframework.org/schema/context/spring-context-3.1.xsd"</span>&gt;</span>  \n    <span class="code-tag">&lt;<span class="code-name">context:component-scan</span>  <span class="hljs-attr">base-package</span>=<span\n            class="code-string">"com.demo.jsr330"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span>  </code></pre>\n<p>然后像下面这个添加一个bean</p>\n<pre><code class="java"><span class="code-meta">@Named</span>  \n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">service</span> </span>{\n  <span class="hljs-function"><span class="code-keyword">public</span>  <span class="code-keyword">void</span>   <span\n          class="code-title">print</span><span class="hljs-params">()</span></span>{\n     System.out.println(<span class="code-string">"Service  print  method is invoked"</span>);  \n  }  \n}  </code></pre>\n<p>然后将这个bean注入到其他bean中去使用</p>\n<pre><code class="java"><span class="code-meta">@Named</span>  \n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Faction</span> </span>{\n  <span class="code-meta">@Inject</span>\n  Service service;\n\n  <span class="hljs-function"><span class="code-keyword">public</span>  <span class="code-keyword">void</span>  <span\n          class="code-title">show</span><span class="hljs-params">()</span></span>{\n     service.print()； \n  }  \n}  </code></pre>\n<p>JSR330还定义了<span style="color:#FF0000">@Qualifier</span>和<span style="color:#FF0000">@Provider</span>，对应到spring都给出了标准的实现。\n</p>\n<p>使用JSR330代替原注解的好处是无论使用任何反向依赖注入工具或框架，只要他是支持JSR330的，都可以平滑的切换。</p>'},343:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<h2 id="h2-1">Niubility的Nodejs &nbsp;&nbsp;</h2>\n<p>关于大名鼎鼎的Nodejs是什么就不用再介绍了，他的牛逼之处数都数不完——让javascript称霸全宇宙、将一个只用于前端的编程语言同时可以制霸前后端、让致力于前端开发的小哥又多了一项事业新增了一门手艺、亮瞎人的全异步事件驱动型架构（event-driven、non-blocking、scalability）。总的来说就是，学好Nodejs必须能够赚大钱迎娶白富美。</p>\n<p>本人一直垂涎与Nodejs的鼎鼎大名，但是由于工作繁忙，一直没时间深入亵玩。最近因为一些机缘，又要着手一些前端开发的工作才觅得一次全面接触的良机。</p>\n<p>看到这里你肯定要说，又是一个要把Nodejs吹上天的文章！NoNo，本文会一步一步的说明我是怎么学会和用上nodejs的，然后结合其我所了解的语言告诉各位我所了解的Nodejs坑和优势。</p>\n\n<h2 id="h2-2">学习基础</h2>\n<p>先说说本人开始学习使用的基础。早期在某外企开发室内3D设计软件，那段时间用已经成为古董的MFC做各种windows事件驱动开发。</p>\n<p>之后就一直在做Java生态的东西、反正就是SSH啦、MVC啦、Dao啦、Entity啦、JNDI啦、JDBC啦等等，相信每个Javaer都懂的。早些年做Java时，前端部分基本就是玩转Jsp，页面清一色的用Jsp动态生成，然后丢给浏览器。现在所属团队几乎已经放弃这种方式，都是用spring-boot等弄前后端分离了。</p>\n<p>随后有幸接到一个自己可以全权负责的全新的项目，于是带着2个人开始尝试抛弃JSP，引入了大量的ajax异步请求的客户端组装数据。那时候这样做其实蛮痛苦的，新项目根本没有真正意义的前端开发人员（都玩JSP呢），所以自己不得不去研究前端的各种前端技术。在随后的许多时光中，深入且大量的学习了前端开发的所有东西，从一穷二白只会用div画画静态页面，到后面自己封装列表、消息通知等组件，通杀jquery、angularjs，了解各种脚手架。所以学习Nodejs开发，我基本上是没有语言障碍的，只是需要跟上它的思路。</p>\n\n<h2 id="h2-3">安装Nodejs</h2>\n<p>要用一样东西之前，当然是要先安装环境。Nodejs的安装网上一搜一大把，这里就简单记录一下流程，方面以后查阅。因为本人用一台windows（windows10）办公、用一台linux（ubuntu16.04）开发，所以2个操作系统都安装了Nodejs，像OSX这样高大上的玩意，暂时没机器去弄（穷）。</p>\n\n<h3 id="h3-1">windows</h3>\n<ol>\n    <li>先去官网（https://nodejs.org或https://nodejs.org/en/download/）下载一个安装包，我下的是长期稳定版。建议下载.msi。</li>\n    <li>然后就是安装了，这没什么好说的。无非就是设定一下安装目录，然后一通Next。</li>\n    <li>安装好之后检查下环境变量，看看path下添加入了Nodejs的运行路径。cmd中输入path可以看到添加了nodejs的安装目录。然后输入node --version可以看到当前的Nodejs版本号。如下图：&nbsp;&nbsp;&nbsp;&nbsp;<img alt="安装NodeJs运行环境" height="175" src="https://file.mahoooo.com/res/file/install_nodejs_runtime_environment_1.png" width="527"></li>\n    <li>Nodejs自带npm，npm和其他未来要使用的组件都存放在“X:\\yourpath\\nodejs\\node_modules”里。所以需要在windows环境变量重增加一个NODE_PATH=X:\\yourpath\\nodejs\\node_modules的参数，保证未来新增的一些模块工具可以正常使用。右键“我的电脑”-&gt;高级系统设置-&gt;环境变量-&gt;然后新建以上参数。</li>\n    <li>再然后就是最后一步了，设置node_cache（用于npm存放一些临时文件）和node_global（全局工具文件夹），当然这里也可以不设置，他会自动放在当前用户的文件夹下，但是有强迫症的我必须要设置。在cmd中输入一下命令：</li>\n</ol>\n<pre class="sql"><code class="language-bash">npm config <span class="code-built_in"><span class="code-keyword">set</span></span> prefix <span class="code-string"><span class="code-string">\'X:\\yourpath\\nodejs\\node-global\'</span></span>\n\nnpm config <span class="code-built_in"><span class="code-keyword">set</span></span> <span class="code-keyword">cache</span> <span class="code-string"><span class="code-string">\'X:\\yourpath\\nodejs\\node_cache\'</span></span></code></pre>\n\n<h3 id="h3-2">linux</h3>\n<p>linux安装和windows安装Nodejs差不多，都是下载包、解压、开用。</p>\n<ol>\n    <li>先去官网下载一个linux版本的安装包（下首页的那个就行）。下载以后发现是 xz后缀，先得用xz命令解压成tar，再用tar完成解压。</li>\n    <li>添加Nodejs运行环境：直接把node的运行目录添加到&amp;PATH里。在profile中添加Node的运行环境： <pre class="bash"><code class="language-bash"><span class="code-comment"><span class="code-comment">#node</span></span>\n<span class="code-built_in"><span class="code-built_in">export</span></span> NODE_HOME=/yourpath/node-v4.5.0-linux-x64\n<span class="code-built_in"><span class="code-built_in">export</span></span> PATH=<span class="code-variable"><span class="code-variable">$NODE_HOME</span></span>/bin:<span class="code-variable"><span class="code-variable">$PATH</span></span></code></pre> <p>然后再任意位置测试了一下运行node命令都可以正常使用。</p> </li>\n    <li> <p>然后我们需要添加node_modules到PATH中，保证npm可以使用：</p> <pre class="bash"><code class="language-apache"><span class="code-comment">#npm</span>\n<span class="code-built_in">export</span> NODE_PATH=<span class="code-variable">$NODE_HOME</span>/node_modules\n</code></pre> <p>配置完之后，就可以使用npm命令了。（修改之后切记注销用户）</p> </li>\n</ol>\n<p>完成以上步奏之后，就可以用node和npm命令干你相干的事了。安装之前按看到很多教程说是要安装python2.2到2.7的版本。但是我解压完nodejs包后在bin下运行了node -v命令居然可以跑，我就没去管python的事，应该是我用的是打包版的原因。</p>\n\n<h3 id="h3-3">Apt安装Nodejs</h3>\n<p>1.设定Nodejs安装源：</p>\n<pre class="nginx"><code class="language-bash"><span class="code-attribute">curl</span> <span class="hljs-_">-s</span>L https://deb.nodesource.com/setup_8.x | sudo -E bash -</code></pre>\n<p>2.安装Nodejs</p>\n<pre class="actionscript"><code class="language-bash">sudo apt-<span class="code-keyword">get</span> install -y nodejs</code></pre>\n\n<h3 id="h3-4">验证安装结果</h3>\n<p>安装完成之后，我在windows和linux都测试了一下。</p>\n<p>测试nodejs：输入node打开REPL，然后使用log打印数据：</p>\n<pre class="javascript"><code class="language-bash">$ node\n&gt; <span class="code-built_in">console</span>.log(<span class="code-string"><span class="code-string">"hello nodejs!"</span></span>);\nhello nodejs!\n<span class="hljs-literal">undefined</span></code></pre>\n<p>然后用npm测试安装grunt-cli：</p>\n<pre class="groovy"><code class="language-bash">$ npm install -g grunt-cli\n<span class="hljs-regexp">/yourpath/</span>node-v4<span class="hljs-number">.5</span><span class="hljs-number">.0</span>-linux-x64<span class="hljs-regexp">/node_global/</span>bin<span class="hljs-regexp">/grunt -&gt; /</span>yourpath<span class="hljs-regexp">/node-v4.5.0-linux-x64/</span>node_global<span class="hljs-regexp">/lib/</span>node_modules<span class="hljs-regexp">/grunt-cli/</span>bin/grunt\ngrunt-cli@<span class="hljs-number">1.2</span><span class="hljs-number">.0</span> <span class="hljs-regexp">/me/</span>soft<span class="hljs-regexp">/node/</span>node-v4<span class="hljs-number">.5</span><span class="hljs-number">.0</span>-linux-x64<span class="hljs-regexp">/node_global/</span>lib<span class="hljs-regexp">/node_modules/</span>grunt-cli\n├── grunt-known-options@<span class="hljs-number">1.1</span><span class="hljs-number">.0</span>\n├── resolve@<span class="hljs-number">1.1</span><span class="hljs-number">.7</span>\n├── nopt@<span class="hljs-number">3.0</span><span class="hljs-number">.6</span> (abbrev@<span class="hljs-number">1.0</span><span class="hljs-number">.9</span>)\n└── findup-sync@<span class="hljs-number">0.3</span><span class="hljs-number">.0</span> (glob@<span class="hljs-number">5.0</span><span class="hljs-number">.15</span>)</code></pre>\n\n<h3 id="h3-5">运行一个Nodejs程序</h3>\n<p>安装好之后，node的命令行和npm的命令行就都可以使用了，随后当然就是要跑跑Nodejs了。像下面这样创建一个创建一个example.js文件，随便放在某个文件：</p>\n<pre class="javascript"><code class="language-javascript"><span class="code-keyword"><span class="code-keyword">const</span></span> http = <span class="code-built_in"><span class="code-built_in">require</span></span>(<span class="code-string"><span class="code-string">\'http\'</span></span>);\n\n<span class="code-keyword"><span class="code-keyword">const</span></span> hostname = <span class="code-string"><span class="code-string">\'127.0.0.1\'</span></span>;\n<span class="code-keyword"><span class="code-keyword">const</span></span> port = <span class="hljs-number"><span class="hljs-number">3000</span></span>;\n\n<span class="code-keyword"><span class="code-keyword">const</span></span> server = http.createServer((req, res) -&gt; {\n  res.statusCode = <span class="hljs-number"><span class="hljs-number">200</span></span>;\n  res.setHeader(<span class="code-string"><span class="code-string">\'Content-Type\'</span></span>, <span class="code-string"><span class="code-string">\'text/plain\'</span></span>);\n  res.end(<span class="code-string"><span class="code-string">\'Hello World Nodejs\\n\'</span></span>);\n});\n\nserver.listen(port, hostname, () =&gt; {\n  <span class="code-built_in"><span class="code-built_in">console</span></span>.log(<span class="code-string"><span class="code-string">`Server running at http://</span><span class="hljs-subst"><span class="code-string"><span class="hljs-subst">${hostname}</span></span></span><span class="code-string">:</span><span class="hljs-subst"><span class="code-string"><span class="hljs-subst">${port}</span></span></span><span class="code-string">/`</span></span>);\n});</code></pre>\n<p>然后在当前文件下打开一个cmd运行以下命令：</p>\n<pre class="css"><code class="language-bash"><span class="code-selector-tag">node</span> <span class="code-selector-tag">example</span><span class="code-selector-class">.js</span></code></pre>\n<p>可以看到输出：</p>\n<pre class="php"><code class="language-bash"><span class="code-variable">$node</span> example.js\n\nServer running at http:<span class="code-comment">//127.0.0.1:3000</span></code></pre>\n'},352:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<h2 id="h2-1">什么叫前后端同构？</h2>\n<p>为了解决某些问题（比如SEO、提升渲染速度等）<strong><em>react</em></strong>\n    提供了2个方法在服务端生成一个HTML文本格式的字符串。在得到了这个HTML格式的字符串之后，通常会将其组装成一个页面直接返回给用户的浏览器。</p>\n<p>到这里，服务端的活已经干完了，然后就是浏览器这边干活。</p>\n<p>浏览器拿到HTML文本后，立刻进行渲染将内容呈现给用户。然后加载页面所需的 .js 文件，然后执行\n    <em><strong>JavaScript&nbsp;</strong></em>脚本，然后开始初始化&nbsp;<em><strong>react</strong></em> 组件…………</p>\n<p>到这里问题就来了。<strong><em>react</em></strong> 初始化组件后会执行组件内所有\n    <em>render&nbsp;() </em>方法，然后生成虚拟DOM的树形结构，然后在适当的时候将虚拟dom<em>写</em>到浏览器的真实dom中。因为 <strong><em>react</em></strong>\n    总是根据虚拟dom来生成真实dom，所以最后会把服务器端渲染好的HTML全部替换掉。</p>\n<p>\n    上面这个事情说不是问题确实也不是问题，无非就是用户看到页面然后“闪现”一下。说是问题还真是个问题，产品会拿着这毛病从用户体验的角度在各种场合和你死磕半个月。磕累了你索性把服务端渲染关了，然后运营又拿着SEO的问题准备和你开始撕逼了。</p>\n<p>聪明如 Facebook 的工程师当然想到了这些问题，所以他们在<em>ReactDOMServer.renderToString(element) 方法</em>中提供了一个\n    <strong><em>checksum</em></strong> 机制。</p>\n<p>关于&nbsp;<strong><em>checksum </em></strong> <a href="https://facebook.github.io/react/docs/react-dom-server.html"\n                                                  rel="nofollow">官网</a> 并没有太多介绍，但是国内外的各路博客介绍了不少。我一直想找&nbsp;<em><strong>react</strong></em>\n    开发者关于这个机制的介绍一直没找到……。</p>\n<p><strong>前后端同构</strong>就是保证前端和后端的dom结构一致，不会发生重复渲染。<em><strong>react</strong></em>\n    使用&nbsp;<strong><em>checksum </em></strong>机制进行保障。</p>\n\n<h2 id="h2-2">什么叫React首屏渲染？</h2>\n<p>简单的说就是 <em><strong>react</strong></em> 在浏览器内存中第一次生成的虚拟 dom 树。<strong>切记是虚拟 dom ，而不是浏览器的dom</strong>。</p>\n<p>了解 <strong><em>react</em></strong> 的应该知道，所有 <em><strong>react</strong></em> 组件都有一个 <em>render()</em>\n    方法（如果使用function方式编写的组件会把function里的所有代码都塞到 <em>render()</em> 方法中去）。当<em>ReactDOM.render( element, container,\n        [callback] )</em>方法执行时，会执行以下步骤：</p>\n<ol>\n    <li>所有组件的会先进行初始化（es6执行构造函数）。</li>\n    <li>所有组件的&nbsp;<em>render</em>&nbsp;<em>()</em> 方法会被调用一次，完成这个过程后会得到一颗虚拟的 dom 树。</li>\n    <li>&nbsp;<em><strong>react</strong></em> 会将虚拟dom转换成浏览器dom，完成后调用组件的&nbsp;<em>componentDidMount()</em>&nbsp;方法告诉你已经装载到浏览器上了。\n    </li>\n</ol>\n<p>在上面这个过程成中，步骤2完成后即为完成 <em><strong>react</strong></em> 的首屏渲染。结合 <strong><em>checksum</em></strong>&nbsp;机制步骤3有可能不会执行。\n</p>\n<p>当组件状态发生变更时（ <em>setState() </em>生命周期函数被调用）或者 父组件渲染时（父组件的 <em>render()</em> 方法被调用），当前组件的 <em>render()</em>\n    方法都会被执行，都有可能会导致虚拟dom变更，但是这些变更和首屏渲染没任何关系了。</p>\n\n<h2 id="h2-3">React前后端同构首屏渲染</h2>\n<p>了解了同构和首屏渲染，就好理解如何解决首屏不重复渲染的问题了。</p>\n<p>首先服务端渲染完之后会有一个 <em><strong>checksum</strong></em> 值写在根元素的属性上：</p>\n<p><img alt="React 前后端同构防止重复渲染" height="70"\n        src="https://file.mahoooo.com/res/file/react_server_render_with_checksum_1.png" width="601"></p>\n<p>这个 <em><strong>checksum</strong></em>&nbsp;是根据服务端生成的HTML内容哈希计算得到的。</p>\n<p>然后在浏览器加载完所有的js文件之后，开始执行前面介绍的&nbsp;<em>ReactDOM.render( element, container, [callback] )</em> &nbsp;初始化渲染的三个步骤。当执行完第二步生成虚拟dom后，<strong><em>react</em></strong>\n    会根虚拟dom用相同的算法计算一个哈希值，如果和 <em><strong>checksum</strong></em> 一致则认为服务器已经完成渲染，不会再执行第三步。</p>\n<p>如果 <strong><em>checksum</em></strong> 比对不一致，在 <strong>开发环境</strong>&nbsp;和 <strong>测试环境</strong>\n    会在浏览器console中输出以下警告内容：</p>\n<p><img alt="React 前后端同构防止重复渲染" height="85"\n        src="https://file.mahoooo.com/res/file/react_server_render_with_checksum_2.png" width="790"></p>\n<p><strong>生产环境不会输出任何警告。</strong></p>\n<p>同构渲染的内容就这么多，原理其实蛮简单的，无非就是保证DOM一致。但是结合代码分片、异步加载、服务端调接口异步组装数据等等功能后，如何保证服务端和浏览器端第一次渲染的dom一致还得花不少功夫。不过原理清楚了，事情总能办成。</p>'},362:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<h2 id="h2-1">Flow</h2>\n<p>Flow是Facebook开源的静态代码检查工具，他的作用是在运行代码之前对React组件以及Jsx语法进行静态代码的检查以发现一些可能存在的问题。Flow可以用于所有前端开发的项目而不仅仅局限于React，码友们可以到\n  <a title="Flow官网" href="https://flow.org/en/docs/getting-started/" rel="nofollow">官网</a>仔细了解（友情提示：可能需要VPN，非常不稳定），本文只介绍如何配合React开发使用。</p>\n<p>Flow仅仅是一个用于检查的工具，安装使用都很方便，使用时注意以下3点即可：</p>\n<ol>\n  <li>将Flow增加到我们的项目中。</li>\n  <li>确保编译之后的代码移除了Flow相关的语法。</li>\n  <li>在需要检查的地方增加了Flow相关的类型注解。（类似与Java的Annotation机制）</li>\n</ol>\n<p>接下来我们来一一说明以上三点的具体内容。码友们边阅读边操作即可。</p>\n\n<h2 id="h2-2">将Flow增加到我们的项目中</h2>\n<p>安装最新版本的Flow：</p>\n<p>Npm：</p>\n<pre class="sql"><code class="language-bash">npm <span class="code-keyword">install</span> <span class="code-comment">--save-dev flow-bin</span></code></pre>\n<p>安装完成之后在package.json文件中增加执行脚本：</p>\n<pre class="actionscript"><code class="language-javascript">{\n  <span class="code-comment"><span class="code-comment">// ...</span></span>\n  <span class="code-string"><span class="code-string">"scripts"</span></span>: {\n    <span class="code-string"><span class="code-string">"your-script-name"</span></span>: <span class="code-string"><span class="code-string">"flow"</span></span>,\n    <span class="code-comment"><span class="code-comment">// ...</span></span>\n  },\n  <span class="code-comment"><span class="code-comment">// ...</span></span>\n}</code></pre>\n<p>然后初始化Flow：</p>\n<pre class="nginx"><code class="language-bash"><span class="code-attribute">npm</span> run flow init</code></pre>\n<p>执行完成后，Flow会在终端输出一下内容：</p>\n<pre class="css"><code class="css">&gt; <span class="code-selector-tag"><span class="code-selector-tag">yourProjectName</span></span>@<span class="code-keyword"><span class="code-keyword">1</span></span>.<span class="code-keyword"><span class="code-keyword">0</span></span>.<span class="code-keyword"><span class="code-keyword">0</span></span> flow /yourProjectPath\n&gt; flow <span class="code-string"><span class="code-string">"init"</span></span>\n</code></pre>\n<p>然后在根目录下生成一个名为&nbsp;.flowconfig 的文件，打开之后是这样的：</p>\n<pre class="json"><code class="language-bash">[ignore]\n\n[include]\n\n[libs]\n\n[lints]\n\n[options]\n\n[strict]\n</code></pre>\n<p>基本上，配置文件没有什么特殊需求是不用去配置的，Flow默认涵盖了当前目录之后的所有文件。[include]用于引入项目之外的文件。例如：</p>\n<pre class="gradle"><code class="gradle">[<span class="code-keyword"><span class="code-keyword">include</span></span>]\n\n..<span class="hljs-regexp"><span class="hljs-regexp">/otherProject/</span></span>a.js\n\n[libs]\n</code></pre>\n<p>他会将和当前项目平级的otherProject/a.js 文件纳入进来。关于配置文件请看<a title="Flow配置文件说明" href="https://flow.org/en/docs/config/" rel="nofollow">这里</a>。</p>\n\n<h2 id="h2-3">编译之后的代码移除Flow相关的语法</h2>\n<p>Flow在JavaScript语法的基础上增加了一些 注解（annotation）进行了扩展。因此浏览器无法正确的解读这些Flow相关的语法，我们必须在编译之后的代码中（最终发布的代码）将增加的Flow注解移除掉。具体方法需要看我们使用了什么样的编译工具。下面将说明一些React开发常用的编译工具</p>\n\n<h3 id="h3-1">Create React App</h3>\n<p>如果你的项目是使用<a title="Create React App" href="https://github.com/facebook/create-react-app" rel="nofollow">Create React App</a>直接创建的。那么移除Flow语法的事项就不用操心了，Create React App已经帮你搞定了这个事，直接跳过这一小节吧。</p>\n\n<h3 id="h3-2">Babel</h3>\n<p>在15.x版本之前入坑React的码友应该绝大部分都用的Babel作为语法糖编译器，那个时候毕竟Create React App完全没有成熟。如果使用Babel我们还需要安装一个Babel对于Flow的preset：</p>\n<pre class="sql"><code class="language-apache">npm <span class="code-keyword">install</span> <span class="code-comment">--save-dev babel-preset-flow</span></code></pre>\n<p>然后，我们需要在<a title="Babel配置文件" href="http://babeljs.io/docs/usage/babelrc/" rel="nofollow">项目根目录Babel的配置文件 .babelrc 中</a>添加一个Flow相关的preset：</p>\n<pre class="json"><code class="language-javascript">{\n  <span class="code-string"><span class="hljs-attr">"presets"</span></span>: [\n    <span class="code-string"><span class="code-string">"flow"</span></span>,\n    <span class="code-comment">//other config</span>\n  ]\n}</code></pre>\n\n<h3 id="h3-3">其他方式</h3>\n<p>如果你既没有使用Create React App也没使用Babel作为语法糖编译器，那么可以使用<a title="Flow语法处理工具" href="https://github.com/flowtype/flow-remove-types" rel="nofollow">&nbsp;flow-remove-types </a>这个工具在发布之前移除Flow代码。</p>\n\n<h2 id="h2-4">运行Flow</h2>\n<p>完成上述步骤之后，就可以开始运行flow了：</p>\n<pre class="nginx"><code class="language-bash"><span class="code-attribute">npm</span> run flow</code></pre>\n<p>然后会输类似一下的内容：</p>\n<pre class="css"><code class="css">&gt; <span class="code-selector-tag"><span class="code-selector-tag">yourProjectName</span></span>@<span class="code-keyword"><span class="code-keyword">1</span></span>.<span class="code-keyword"><span class="code-keyword">0</span></span>.<span class="code-keyword"><span class="code-keyword">0</span></span> flow /yourProjectPath\n&gt; flow\n\nLaunching Flow server for /yourProjectPath\nSpawned flow server (pid=<span class="hljs-number"><span class="hljs-number">10705</span></span>)\nLogs will go to /tmp/flow/zSworkzSchkuizSone-big-website.log\nMonitor logs will go to /tmp/flow/zSworkzSchkuizSone-big-website.monitor_log\nNo errors!\n</code></pre>\n<p>第一次运行会生成很多临时文件比较慢，之后会快许多。</p>\n\n<h2 id="h2-5">增加Flow注解</h2>\n<p>如果你了解C++/C#的元编程或者Java的Annotation，那么理解Flow的Annotation就会非常轻松。大概就是在文件、方法、代码块之前增加一个注解（Annotation）用来告知Flow的执行行为。</p>\n<p>首先，Flow只检查包含 // @flow 注解的文件。所以如果需要检查，我们需要这样编写我们的文件：</p>\n<pre class="scala"><code class="language-javascript"><span class="code-comment"><span class="code-comment">// @flow</span></span>\n<span class="code-keyword"><span class="code-keyword">import</span></span> <span class="code-type">React</span> <span class="code-keyword">from</span> <span class="code-string"><span class="hljs-symbol">\'reac</span>t\'</span>\n\n<span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span class="hljs-class"><span class="code-title">Component</span></span></span><span class="hljs-class"> </span></span>{\n    render(){\n        <span class="code-keyword"><span class="code-keyword">return</span></span> (<span class="xml"><span class="code-tag">&lt;<span class="code-name">div</span>&gt;</span><span class="code-type">MyComponent</span><span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>)\n    }\n}\n\n<span class="code-keyword">export</span> <span class="code-keyword"><span class="code-keyword">default</span></span> <span class="code-type">MyComponent</span></code></pre>\n<p>然后我们再运行Flow就变成这样的风格了：</p>\n<pre class="scala"><code class="language-bash">&gt; yourProjectName@<span class="hljs-number">1.0</span><span class="hljs-number">.0</span> flow /yourProjectPath\n&gt; flow\n\n<span class="code-type">Error</span> ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ dev/src/home/test.js:<span class="hljs-number">5</span>:<span class="hljs-number">21</span>\n\n<span class="code-type">Cannot</span> use property <span class="code-type">Component</span> [<span class="hljs-number">1</span>] <span class="code-keyword">with</span> less than <span class="hljs-number">1</span> <span class="code-built_in"><span class="hljs-class"><span class="code-keyword">type</span></span></span><span class="hljs-class"> <span class="code-title">argument</span>.</span>\n\n     dev/src/home/test.js\n      <span class="hljs-number">2</span>│\n      <span class="hljs-number">3</span>│ <span class="code-keyword">import</span> <span class="code-type">React</span> from <span class="code-string"><span class="hljs-symbol">\'reac</span>t\'</span>\n      <span class="hljs-number">4</span>│\n      <span class="hljs-number">5</span>│ <span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MyComponent</span> <span class="code-keyword">extends</span> <span class="code-title">React</span>.<span class="code-title">Component</span> </span>{\n      <span class="hljs-number">6</span>│     <span class="hljs-function"><span class="code-title">render</span></span>(){\n      <span class="hljs-number">7</span>│         <span class="code-built_in"><span class="code-keyword">return</span></span> (&lt;div&gt;<span class="code-type">MyComponent</span>&lt;/div&gt;)\n      <span class="hljs-number">8</span>│     }\n\n     /tmp/flow/flowlib_cc1898a/react.js\n [<span class="hljs-number">1</span>] <span class="hljs-number">26</span>│ <span class="code-built_in">declare</span> <span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">React</span></span><span class="code-variable"><span class="hljs-class"><span class="code-title">$Component</span></span></span><span class="hljs-class"><span class="code-title">&lt;Props</span>, <span class="code-title">State</span> </span>= void&gt; {</code></pre>\n<p>到这里，Flow已经算是安装成功了，接下来的事是要增加各种注解以加强类型限定或者参数检测。之后的内容将简要介绍flow的相关语法规则。</p>\n\n<h2 id="h2-6">React组件参数检查</h2>\n<p><a title="PropType参数类型检测" href="https://chkui.com/article/react/react_typechecking_with_proptypes_and_dom_element">React组件参数检查</a>介绍了React通过PropType机制限定使用者使用组件传递的参数类型以及范围，但是PropType是一种运行检测机制，在程序跑起来之后获取到具体数据才会执行检查。而Flow是静态检查，是在代码编译运行之前进行一次检查，两者相辅相成互不干扰。</p>\n\n<h3 id="h3-4">Props参数检查</h3>\n<p>承接上面 MyComponent 的例子，我们引入Flow的注解对代码进行检查：</p>\n<pre class="scala"><code class="language-javascript"><span class="code-comment"><span class="code-comment">// @flow</span></span>\n<span class="code-comment"><span class="code-comment">// flow的例子，可以看看和PropType的差异在哪</span></span>\n<span class="code-keyword"><span class="code-keyword">import</span></span> <span class="code-type">React</span> <span class="code-keyword">from</span> <span class="code-string"><span class="hljs-symbol">\'reac</span>t\'</span>\n\n<span class="hljs-class"><span class="code-keyword">type</span> <span class="code-title">Props</span> </span>= {\n    num : number,\n    text : ?string\n}\n\n<span class="code-comment"><span class="code-comment">//通过&lt;&gt;引入Flow类型检查</span></span>\n<span class="code-comment"><span class="code-comment">//可以直接写成 React.Component&lt;{num : number, text ?: string}&gt;这样的形式</span></span>\n<span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span class="hljs-class"><span class="code-title">Component</span></span></span><span class="hljs-class"><span class="code-title">&lt;</span></span><span class="code-title"><span class="hljs-class"><span class="code-title">Props</span></span></span><span class="hljs-class"><span class="code-title">&gt;</span> </span></span>{\n    render(){\n        <span class="code-keyword"><span class="code-keyword">return</span></span> (<span class="xml"><span class="code-tag">&lt;<span class="code-name">div</span>&gt;</span>{<span class="code-keyword">this</span>.props.num}\\{<span class="code-keyword">this</span>.props.text}<span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>)\n    }\n}\n\n<span class="code-keyword">export</span> <span class="code-keyword"><span class="code-keyword">default</span></span> <span class="code-type">MyComponent</span></code></pre>\n<p>然后在运行Flow，输出了No Error。</p>\n<p>然后我们使用这个组件：</p>\n<pre class="scala"><code class="language-javascript"><span class="code-comment"><span class="code-comment">// @flow</span></span>\n<span class="code-comment"><span class="code-comment">// flow的例子，可以看看和PropType的差异在哪</span></span>\n<span class="code-keyword"><span class="code-keyword">import</span></span> <span class="code-type">React</span> <span class="code-keyword">from</span> <span class="code-string"><span class="hljs-symbol">\'reac</span>t\'</span>\n\n<span class="hljs-class"><span class="code-keyword">type</span> <span class="code-title">Props</span> </span>= {\n    num : number,\n    text : ?string\n}\n\n<span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span class="hljs-class"><span class="code-title">Component</span></span></span><span class="hljs-class"><span class="code-title">&lt;</span></span><span class="code-title"><span class="hljs-class"><span class="code-title">Props</span></span></span><span class="hljs-class"><span class="code-title">&gt;</span> </span></span>{\n    render(){\n        <span class="code-keyword"><span class="code-keyword">this</span></span>.props.myValue;\n        <span class="code-keyword"><span class="code-keyword">return</span></span> (<span class="xml"><span class="code-tag">&lt;<span class="code-name">div</span>&gt;</span>{<span class="code-keyword">this</span>.props.num}\\{<span class="code-keyword">this</span>.props.text}<span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>)\n    }\n}\n\n<span class="code-comment"><span class="code-comment">//void 表示 undefined 不传递参数</span></span>\n<span class="code-comment"><span class="code-comment">//这里传递类型发生错误</span></span>\n<span class="code-keyword">const</span> <span class="code-type">UseComponent</span> = (props : <span class="code-keyword">void</span>) =&gt;(<span class="xml"><span class="code-tag">&lt;<span class="code-name"><span class="code-type">MyComponent</span></span> <span class="hljs-attr">num</span>=<span class="code-string"><span class="code-string">"2"</span></span> <span class="hljs-attr">text</span>=<span class="code-string">{<span class="hljs-number">2</span>}/</span>&gt;</span>)\n\nexport <span class="code-keyword">default</span> <span class="code-type">UseComponent</span></span></code></pre>\n<p>运行flow之后输出：</p>\n<pre class="actionscript"><code class="language-bash">Error ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ dev/src/home/test.js:<span class="hljs-number">12</span>:<span class="hljs-number">20</span>\n\nCannot <span class="code-keyword">get</span> <span class="code-keyword">this</span>.props.myValue because property myValue <span class="code-keyword">is</span> missing <span class="code-keyword"><span class="code-keyword">in</span></span> Props [<span class="hljs-number">1</span>].\n\n      <span class="hljs-number">9</span>│\n [<span class="hljs-number">1</span>] <span class="hljs-number">10</span>│ <span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MyComponent</span> <span class="code-keyword">extends</span> <span class="code-title">React</span>.<span class="code-title">Component</span>&lt;<span class="code-title">Props</span>&gt; </span>{\n     <span class="hljs-number">11</span>│     <span class="hljs-function"><span class="code-title">render</span></span>(){\n     <span class="hljs-number">12</span>│         <span class="code-keyword">this</span>.props.myValue;\n     <span class="hljs-number">13</span>│         <span class="code-built_in"><span class="code-keyword">return</span></span> (&lt;div&gt;{<span class="code-keyword">this</span>.props.num}\\{<span class="code-keyword">this</span>.props.text}&lt;/div&gt;)\n     <span class="hljs-number">14</span>│     }\n     <span class="hljs-number">15</span>│ }\n\n\nError ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ dev/src/home/test.js:<span class="hljs-number">17</span>:<span class="hljs-number">40</span>\n\nCannot create MyComponent element because:\n • string [<span class="hljs-number">1</span>] <span class="code-keyword">is</span> incompatible <span class="code-keyword">with</span> number [<span class="hljs-number">2</span>] <span class="code-keyword"><span class="code-keyword">in</span></span> property num.\n • number [<span class="hljs-number">3</span>] <span class="code-keyword">is</span> incompatible <span class="code-keyword">with</span> string [<span class="hljs-number">4</span>] <span class="code-keyword"><span class="code-keyword">in</span></span> property text.\n\n    [<span class="hljs-number">2</span>]  <span class="hljs-number">6</span>│     num : number,\n    [<span class="hljs-number">4</span>]  <span class="hljs-number">7</span>│     text : ?string\n          :\n        <span class="hljs-number">14</span>│     }\n        <span class="hljs-number">15</span>│ }\n        <span class="hljs-number">16</span>│\n [<span class="hljs-number">1</span>][<span class="hljs-number">3</span>] <span class="hljs-number">17</span>│ <span class="code-keyword">const</span> UseComponent = (props : <span class="code-keyword">void</span>) =&gt;(&lt;MyComponent num=<span class="code-string"><span class="code-string">"2"</span></span> text={<span class="hljs-number">2</span>}/&gt;)\n        <span class="hljs-number">18</span>│\n        <span class="hljs-number">19</span>│ <span class="code-built_in">export</span> <span class="code-keyword">default</span> UseComponent\n\n\n\nFound <span class="hljs-number">3</span> errors</code></pre>\n<p>输出内容可以看出一共有2个错误栏输出：</p>\n<ul>\n  <li>第一栏表示myValue并没有声明。</li>\n  <li>第二栏[1]违反了[2]的限定，[3]违反了[4]的限定。我们将组件变更为&lt;MyComponent num={2}&nbsp;text="2"/&gt;即可检查通过。</li>\n</ul>\n\n<h3 id="h3-5">增加对State的检查</h3>\n<p>React的数据通过两处控制——<a title="React 深入说明JSX语法与Props特性" href="https://www.chkui.com/article/react/react_understand_jsx_and_props">props</a> 和&nbsp;<a title="React 状态、事件与动态渲染" href="https://www.chkui.com/article/react/react_state_event_and_render">state</a>。Flow也提供了state数据的检查，我们在例子中增加state检查：</p>\n<pre class="scala"><code class="language-javascript"><span class="code-comment"><span class="code-comment">// @flow</span></span>\n<span class="code-comment"><span class="code-comment">// flow的例子，可以看看和PropType的差异在哪</span></span>\n<span class="code-keyword"><span class="code-keyword">import</span></span> <span class="code-type">React</span> <span class="code-keyword">from</span> <span class="code-string"><span class="hljs-symbol">\'reac</span>t\'</span>\n\n<span class="hljs-class"><span class="code-keyword">type</span> <span class="code-title">Props</span> </span>= {\n    num : number,\n    text : ?string\n}\n\n<span class="hljs-class"><span class="code-keyword">type</span> <span class="code-title">State</span> </span>= {\n    count: number,\n};\n\n<span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span class="hljs-class"><span class="code-title">Component</span></span></span><span class="hljs-class"><span class="code-title">&lt;</span></span><span class="code-title"><span class="hljs-class"><span class="code-title">Props</span></span></span><span class="hljs-class">, </span><span class="code-title"><span class="hljs-class"><span class="code-title">State</span></span></span><span class="hljs-class"><span class="code-title">&gt;</span> </span></span>{\n    <span class="code-keyword">constructor</span>(...props){\n        <span class="code-keyword"><span class="code-keyword">super</span></span>(...props)\n        <span class="code-keyword"><span class="code-keyword">this</span></span>.state = {count:<span class="code-string">\'<span class="hljs-number">1</span>\'</span>}\n    }\n\n    render(){\n        <span class="code-keyword"><span class="code-keyword">return</span></span> (<span class="xml"><span class="code-tag">&lt;<span class="code-name">div</span>&gt;</span>{<span class="code-keyword">this</span>.props.num}\\{<span class="code-keyword">this</span>.props.text}<span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>)\n    }\n}\n\n<span class="code-keyword">const</span> <span class="code-type">UseComponent</span> = (props : <span class="code-keyword">void</span>) =&gt;(<span class="xml"><span class="code-tag">&lt;<span class="code-name"><span class="code-type">MyComponent</span></span> <span class="hljs-attr">num</span>=<span class="code-string">{<span class="hljs-number">2</span>}</span> <span class="hljs-attr">text</span>=<span class="code-string"><span class="code-string">"2"</span></span>/&gt;</span>)\n\nexport <span class="code-keyword">default</span> <span class="code-type">UseComponent</span></span></code></pre>\n<p>此时运行Flow会输出：</p>\n<pre class="scala"><code class="language-bash"><span class="code-type">Error</span> ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ dev/src/home/test.js:<span class="hljs-number">17</span>:<span class="hljs-number">29</span>\n\n<span class="code-type">Cannot</span> assign <span class="hljs-class"><span class="code-keyword">object</span> <span class="code-title">literal</span> <span class="code-title">to</span> <span class="code-title">this</span>.<span class="code-title">state</span> <span class="code-title">because</span> <span class="code-title">string</span> [1] <span class="code-title">is</span> <span class="code-title">incompatible</span></span>\n<span class="code-keyword">with</span> number [<span class="hljs-number">2</span>] <span class="code-keyword">in</span> property count.\n\n [<span class="hljs-number">2</span>] <span class="hljs-number">11</span>│     count: number,\n     <span class="hljs-number">12</span>│ };\n     <span class="hljs-number">13</span>│\n     <span class="hljs-number">14</span>│ <span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MyComponent</span> <span class="code-keyword">extends</span> <span class="code-title">React</span>.<span class="code-title">Component&lt;Props</span>, <span class="code-title">State&gt;</span> </span>{\n     <span class="hljs-number">15</span>│     constructor(...props){\n     <span class="hljs-number">16</span>│         <span class="code-keyword">super</span>(...props)\n [<span class="hljs-number">1</span>] <span class="hljs-number">17</span>│         <span class="code-keyword">this</span>.state = {count:<span class="code-string">\'<span class="hljs-number">1</span>\'</span>}\n     <span class="hljs-number">18</span>│     }\n     <span class="hljs-number">19</span>│\n     <span class="hljs-number">20</span>│     <span class="hljs-function"><span class="code-title">render</span></span>(){\n</code></pre>\n<p>检测出state.count在构造函数中赋值的类型错误。</p>\n\n<h3 id="h3-6">组件默认值</h3>\n<p>使用Flow后一样可以使用默认值，但是必须要注意默认值的类型要和注解声明的一致：</p>\n<pre class="scala"><code class="language-javascript"><span class="code-keyword"><span class="code-keyword">import</span></span> * <span class="code-keyword">as</span> <span class="code-type">React</span> <span class="code-keyword">from</span> <span class="code-string"><span class="hljs-symbol">\'reac</span>t\'</span>;\n\n<span class="hljs-class"><span class="code-keyword">type</span> <span class="code-title">Props</span> </span>= {\n  foo: number, \n};\n\n<span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span class="hljs-class"><span class="code-title">Component</span></span></span><span class="hljs-class"><span class="code-title">&lt;</span></span><span class="code-title"><span class="hljs-class"><span class="code-title">Props</span></span></span><span class="hljs-class"><span class="code-title">&gt;</span> </span></span>{\n  <span class="code-keyword">static</span> defaultProps = {\n    foo: <span class="hljs-number"><span class="hljs-number">42</span></span>, \n  };\n}</code></pre>\n\n<h3 id="h3-7">函数类型的组件</h3>\n<p>除了使用Class关键字，使用函数同样可以构造一个React组件，配合Flow使用：</p>\n<pre class="javascript"><code class="language-javascript"><span class="code-keyword"><span class="code-keyword">import</span></span> React <span class="code-keyword"><span class="code-keyword">from</span></span> <span class="code-string"><span class="code-string">\'react\'</span></span>;\n\ntype Props = {<span class="code-comment"><span class="code-comment">//参数检查</span></span>\n  foo: number,\n  bar?: string,\n};\n\n<span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">function</span></span></span><span class="hljs-function"> </span><span class="code-title"><span class="hljs-function"><span class="code-title">MyComponent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props: Props</span></span></span><span class="hljs-function">) </span></span>{\n  <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="xml"><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">div</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">{props.bar}</span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">div</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span></span>;\n}\n\nMyComponent.defaultProps = {\n  foo: <span class="hljs-number"><span class="hljs-number">42</span></span> <span class="code-comment"><span class="code-comment">//指定默认值</span></span>\n};</code></pre>\n\n<h3 id="h3-8">React事件、子组件、高阶组件检查扩展</h3>\n<p>除了对单个组件基本的检查，Flow还提供了对React事件、refs、子组件、高阶组件、Redux。本文就不一一介绍了，有需要的码友可以按照下面的资源清单去了解相关的内容：</p>\n<ul>\n  <li><a title="Flow React事件检查" href="https://flow.org/en/docs/react/events/" rel="nofollow">React事件</a></li>\n  <li><a title="Flow Refs引入对象检查" href="https://flow.org/en/docs/react/refs/" rel="nofollow">Refs引入对象</a></li>\n  <li><a title="Flow React子组件列表检查" href="https://flow.org/en/docs/react/children/" rel="nofollow">子组件列表</a></li>\n  <li><a title="Flow React高阶组件参数检查" href="https://flow.org/en/docs/react/hoc/" rel="nofollow">高阶组件参数</a></li>\n  <li><a title="Flow ReactRedux整合参数检查" href="https://flow.org/en/docs/react/redux/" rel="nofollow">Redux整合</a></li>\n</ul>\n\n<h3 id="h3-9">类型检查扩展</h3>\n<p>Flow会检查所有的JavaScript基础类型——Boolean、String、Number、null、undefined（在Flow中用void代替）。除此之外还提供了一些操作符号，例如例子中的 text : ?string，他表示参数存在“没有值”的情况，除了传递string类型之外，还可以是null或undefined。需要特别注意的是，这里的没有值和JavaScript的表达式的“非”是两个概念，Flow的“没有值”只有null、void（undefined），而JavaScript表达式的“非”包含：null、undefined、0、false。</p>\n<p>除了前面的例子中给出的各种类型参数，Flow还有更丰富的检查功能，查看 <a title="Flow 检查参数说明" href="https://flow.org/en/docs/types/" rel="nofollow">这里</a> 以了解更多内容。</p>\n\n<h3 id="h3-10">React数据类型参考</h3>\n<p>对于Flow来说，除了常规的JavaScript数据类型之外，React也有自己特有的数据类型。比如React.Node、React.Key、React.Ref&lt;&gt;等。需要详细了解的，可以查看官网关于<a title="Flow React类型的说明" href="https://flow.org/en/docs/react/types/" rel="nofollow">React类型的说明</a>。</p>\n<p>需要特别说明的是，如果所要使用React的类型，在通过ES6引入React对象时需要使用这样的方式：</p>\n<pre class="python"><code class="language-javascript"><span class="code-keyword"><span class="code-keyword">import</span></span> * <span class="code-keyword"><span class="code-keyword">as</span></span> React <span class="code-keyword"><span class="code-keyword">from</span></span> <span class="code-string"><span class="code-string">\'react\'</span></span>\n<span class="code-comment">//替换 <span class="code-keyword">import</span> React <span class="code-keyword">from</span> <span class="code-string">\'react\'</span></span>\n\n<span class="code-comment">//或者单独引入一个类型</span>\n<span class="code-comment">//<span class="code-keyword">import</span> type {Node} <span class="code-keyword">from</span> <span class="code-string">\'react</span></span></code></pre>\n<p>两者的差异在于ES6的星号import的特性，使用*号会将一个文件中的所有 export 内容组合成一个对象返回，而不使用星号仅仅能获取到exprot default 那个原型。而引入Flow后不会修改React的默认导出类型，因为默认导出不一定是一个对象，他会通过export为React扩展更多的类型。</p>\n<p>比如我们用React.Node限制render方法的返回类型：</p>\n<pre class="scala"><code class="language-javascript"><span class="code-keyword"><span class="code-keyword">import</span></span> * <span class="code-keyword">as</span> <span class="code-type">React</span> <span class="code-keyword">from</span> <span class="code-string"><span class="hljs-symbol">\'reac</span>t\'</span>\n<span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span class="hljs-class"><span class="code-title">Component</span></span></span><span class="hljs-class"><span class="code-title">&lt;</span></span></span>{}&gt; {\n  render(): <span class="code-type">React</span>.<span class="code-type">Node</span> {\n    <span class="code-comment"><span class="code-comment">// ...</span></span>\n  }\n}</code></pre>\n\n<h2 id="h2-7">遇到的一些问题</h2>\n<p>我在使用的过程中目前遇到的问题之一是import 样式资源&nbsp;或&nbsp; 图片时报 “./xxx.scss. Required module not found” 的异常，查看官方文档了解Flow只支持.js、.jsx、.mjs、.json的文件，如果需要导入其他文件需要并支持需要扩展options。在.flowconfig添加options：</p>\n<pre class=""><code class="">[ignore]\n[<span class="code-keyword"><span class="code-keyword">include</span></span>]\n[libs]\n[lints]\n[options]\n<span class="code-keyword"><span class="code-keyword">module</span></span>.file_ext=.scss\n[strict]</code></pre>\n<p>此外，某些IDE对Flow的支持不是很好。我目前所使用的webstorm 2017.3.5相对还不错，不过切记要到File-&gt;Setting-&gt;Languages&amp;Frameworks-&gt;Javascript中将version设置为Flow。</p>\n\n<h2 id="h2-8">写在最后的使用心得</h2>\n<p>引入并按照Flow的规范去约束每一个组件会导致开发量增加不少（当然你引入不用是另外一回事，但是不用引入他做什么？）。搭建好Flow的框架仅仅是开始，之后除了团队成员要去了解flow的使用方法，早期还会遇到各种坑需要去解决。而且Flow也要比React的 <a title="React 深入说明JSX语法与Props特性" href="/article/react/react_understand_jsx_and_props">PropTypes</a>&nbsp;”重“许多。</p>\n<p>JavaScript本来是一个类型推导的原型语言，弄个Flow进来搞得越来越像Java这种强类型语言，也不知道是好是坏，而Java10又学JavaScript等加入了val这种可以类型推导的关键字....。</p>\n<p>总的来说引入规范是有成本的，具体要看团队规模以及项目大小，不是引入越多的技术栈就越有逼格。如果你独立项目的前端开发人数并不多，或者代码膨胀（代码腐烂）速度也没有让你措手不及，建议慎重引入Flow。个人觉得Flow除了开发人员自检还要整合到整个测试框架中，在集成测试或某个版本的代码发布之前进行集中检查。需要思考它在项目的开发、测试、仿真、上线迭代周期中扮演的角色，甚至整合到类似与CMMI之类的管理流程去反向量化考核代码质量。</p>'},369:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<h2 id="h2-1">JSR-175与元编程</h2>\n<p>要说明JSR-250先要解释清楚JSR-175，要解释清楚JSR就的先了解JCP是什么。网上资料很多，就不细说了，简单的说JCP（Java Community\n    Process）是管理Java生态（包括J2SE、J2EE等等）发展的合作组织。JSR（Java Specification\n    Request）就是组织内的成员针对Java的发展提出的一些需求，通过审核之后即会融入到新版本的Java功能中成为Java的一项特性或功能，不同的发行版本和虚拟机都会遵守这些约定。</p>\n<p>JSR-175的全文标题是<strong><span style="color:null">&nbsp;A Metadata Facility for the Java&nbsp;Programming Language （为Java语言提供元数据设施）</span></strong>。它明确提出了在Java平台引入“元编程”（Meta\n    Programming）的思想，要求提供对“元数据”（Meta Data）的支持。这就是我们现在大量使用的“@”注解（Annotation）功能的最早来源。JSR-175之后的JSR-181（Web服务支持）、JSR-250、<a\n            href="https://www.chkui.com/article/java/java_jsr330" title="JSR-330">JSR-330</a>都是基于“元数据”功能提出的一些更细节的实现。</p>\n<p>至于“元编程”、“元数据”是什么这里就不详细展开说明了，它的理论很早就提出了，据说最早是在Lisp这一类函数式编程语言上开始使用的。网上有很多相关的资料，简单的说它就是“对源码进行编码”，比如下面这样：</p>\n<pre><code class="java"><span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MyClass</span> </span>{\n\t<span class="code-meta">@Autowired</span>\n\t<span class="code-keyword">private</span> Interface support;\n}</code></pre>\n<p>通过@Autowired这个注解来对support这个域进行编码就可以很轻松的扩展原先类的功能。</p>\n\n<h2 id="h2-2">JSR-250的Spring实现</h2>\n<p>JSR-250主要是围绕着“资源”的使用预定义了一些注解（Annotation）,这里的“资源”可以理解为一个Class类的实例、一个JavaBean、或者一个Spring中的Bean。</p>\n<p>JSR-250相关的注解全部在 <em>javax.annotation</em> 和 <em>javax.annotation.security </em>包中，分成2个部分——资源定义和权限控制。它并没有提供具体的实现方式，仅仅是提供了指导性的文档和几个注解，由具体的框架去实现。\n</p>\n<p><em>javax.annotation</em> 中包含一下几个注解：</p>\n<ul>\n    <li>@Generated：生成资源的注解，通过该项标记产生的实例是一个资源。类似于Spring中的@Bean注解，用于生成一向资源。</li>\n    <li>@PostConstruct&nbsp;创造资源之后的回调处理，Spring已经实现了这个注解，见<a\n            href="https://www.chkui.com/article/spring/spring_core_bean_lifecycle_callback"\n            title="Bean的定义与控制">Bean的定义与控制</a> 一文的介绍。\n    </li>\n    <li>@PreDestroy&nbsp;销毁资源之前的回调处理，Spring同样实现了这个注解，见<a\n            href="https://www.chkui.com/article/spring/spring_core_bean_lifecycle_callback"\n            title="Bean的定义与控制">Bean的定义与控制</a>。\n    </li>\n    <li>@Resource&nbsp;标记使用资源的位置，Spring同样实现了这个注解的功能（后文会详细介绍）。功能上有些类似于@Autowired、@Inject，但是两者有不少的差别。</li>\n    <li>@Resources&nbsp;标记使用多项资源的位置，类似于使用@Autowired向一个列表装载数据。</li>\n</ul>\n<p>仔细看JSR-250定义的这些注解就会发现，他们都是关于“资源”的构建、销毁、使用的。Spring实现了@PostConstruct、@PreDestroy和@Resource。</p>\n<p>javax.annotation.security&nbsp;包中有以下内容：</p>\n<ul>\n    <li>@DeclareRoles&nbsp;声明角色</li>\n    <li>@DenyAll&nbsp; 拒绝所有角色</li>\n    <li>@PermitAll&nbsp; 授权所有惧色</li>\n    <li>@RolesAllowed&nbsp; 角色授权</li>\n    <li>@RunAs 运行模式</li>\n</ul>\n<p>security中的内容是在资源创建之后对<strong><em>资源的使用进行管理</em></strong>。和常规的权限控制模型一样——定义角色（@DeclareRoles&nbsp;）、确定角色对资源的控制权限（@DenyAll、@PermitAll\n    、@RolesAllowed&nbsp;）。Spring并没有实现这里的任何一个注解，在这里就不深入介绍了。这一块内容在J2EE的构建中有不少的应用。</p>\n\n<h2 id="h2-3">Spring中的@Resource</h2>\n<p>\n    在没有仔细看Spring的官方文档和JSR-250之前，我一直以为@Resource这个注解和@Autowired是2个不同的功能，更早的时候还以为是管理什么Properties资源的，很多网上的内容也写得比较模糊。虽然@Resource的实现是在\n    <em>CommonAnnotationBeanPostProcessor</em>&nbsp;而@Autowired 是在\n    AutowiredAnnotationBeanPostProcessor，但是实际上两者的功能是重叠的，或者说@Resource的提供的功能是@Autowired的子集。</p>\n<p>在Spring中使用@Resource注解时，把Bean理解为一项资源就很好理解了。下面通过一些简单的例子来介绍@Resource的使用。</p>\n<p>@Resource的功能是告诉IoC容器标记的位置需要什么样的“资源”，如下：</p>\n<pre><code class="java"><span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">Abc</span> </span>{}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">Xyz</span> </span>{}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">Implement</span> </span>{\n\t<span class="code-meta">@Resource</span>\n\t<span class="code-keyword">private</span> Abc abc;\n\t\n\t<span class="code-keyword">private</span> Xyz xyz;\n\n    <span class="code-meta">@Resource</span>\n    <span class="code-keyword">private</span> ApplicationContext context;\n\n\t<span class="code-meta">@Resource</span>(name=<span class="code-string">"b_instance"</span>)\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setInject</span><span class="hljs-params">(Xyz xyz)</span> </span>{\n\t\t<span class="code-keyword">this</span>.xyz = xyz;\n\t}\n}</code></pre>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">context:annotation-config</span>/&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n            class="code-string">"abc"</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"x.y.Abc"</span> /&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n            class="code-string">"xyz_instance"</span> <span class="hljs-attr">name</span>=<span class="code-string">"inject"</span> <span\n            class="hljs-attr">class</span>=<span class="code-string">"x.y.Xyz"</span> /&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"x.y.Implement"</span> /&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>\n    运行后，IoC会向标记了@Resource的位置注入Bean——是不是感觉和@Autowired一模一样？但是需要注意的是虽然两者最后都是注入一个Bean，但是@Resource和@Autowired的处理过程是不一样的。@Autowired如果没有提供任何参数，那么他优先按照类型注入，如果要对细节进行控制可以配合Primary和Qualifiers功能，详见<a\n        href="https://www.chkui.com/article/spring/spring_core_auto_inject_of_annotation" title="注解自动装载">注解自动装载</a>的介绍。@Resource是按照命名来注入资源的，以上面的代码为例子：\n</p>\n<ol>\n    <li>例如在setter方法上定义了name="xyz_instance"参数，那么会去IoC容器中寻找id、name等于"xyz_instance"的Bean来注入。</li>\n    <li>例如在abc这个域（成员变量）上没有定义name参数，那么会使用域的名称（这里是"abc"）去IoC中按id、name寻找Bean来注入。</li>\n    <li>如果@Resource定义在方法上，并且没有指定name参数，那么他会使用setter的名称（例子中方法名为setInject，名称就是"inject"）来寻找并注入数据。</li>\n    <li>最后，如果名称匹配不上，容器会根据标记位置的类型来注入数据，例如例如中的ApplicationContext。</li>\n</ol>\n<p>所以@Resource的装载资源过程是：1)匹配name参数；2)没有name参数时会根据setter或域的名称来匹配Bean的名称；3)还是匹配不上就根据标记位置的类型来注入数据。</p>\n<p>与@Autowired相比主要有以下几点区别：</p>\n<ol>\n    <li>控制粒度没有@Autowired细，某些参数Spring并没有实现功能。但是使用他更符合整个Java生态的规范。</li>\n    <li>如果是使用类型依赖注入数据，应优先使用@Autowired，效率会好一些。</li>\n    <li>@Resource通过名称注入与@Autowired相比省去了@Qualifiers等内容。</li>\n    <li>@Resource只能用在域和Setter方法上。</li>\n</ol>\n<p>总的来说如果是按照类型注入依赖对象，那么最终得到的结果并没有任何差异，只是执行过程上有差别。如果按Bean的名称使用，@Resource比@Autowired便捷一些，但是功能少很多。</p>\n<p>个人建议如果开发的是一个面向终端用户的应用，比如Web应用、网站什么的，直接用@Autowired就好了。如果制作的是一个给别的开发人员使用的工具，可以考虑@Resourec，他能得到更多框架的支持。</p>\n\n<h2 id="h2-4">@PostConstruct 与@PreDestroy</h2>\n<p>@PostConstruct 与@PreDestroy也是JSR-250中定义的注解，Spring都实现了他们的功能，使用方法可以查看<a\n        href="https://www.chkui.com/article/spring/spring_core_bean_lifecycle_callback" title="Bean的定义与控制">Bean的定义与控制</a>&nbsp;相关的说明和介绍。\n</p>'},387:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<p>本文将解释如何在Windows下安装TensorFlow。</p>\n\n<h2 id="h2-1">确定安装哪类TensorFlow</h2>\n<p>需要先确定哪种类型的TensorFlow：</p>\n<ul>\n    <li><strong>仅支持CUP运算版本：</strong>如果电脑的系统没有&nbsp;NVIDIA®的GPU，那么必须安装这个版本。这个版本的TensorFlow安装非常简单（安装仅需一个命令，5到10分钟），所以即使系统中有满足要求的NVIDIA®\n        GPU官方还是建议在学习阶段安装这个版本。\n    </li>\n    <li><strong>支持GPU运算的版本：</strong>TensorFlow程序在GPU下运行比在CPU下运行明显快很多。如果系统中包含&nbsp;NVIDIA®的GPU满足下一个小节所示的条件并且程序对性能要求很高，建议安装此版本。\n    </li>\n</ul>\n\n<h2 id="h2-2">运行TensorFlow所需要的GPU配置</h2>\n<p>如果在系统中安装使用GPU运行的TensorFlow，需要确保下面介绍的NVIDIA软件已经安装到系统中。</p>\n<ul>\n    <li>CUDA® Toolkit 8.0。请看 <a\n            href="http://docs.nvidia.com/cuda/cuda-installation-guide-microsoft-windows/#axzz4eDEVDKkM" rel="nofollow">NVIDIA安装cuda</a>\n        的文档，根据文档中的描述确保已经将CUDA相关的路径增加到&nbsp;<code>%PATH%</code>&nbsp;环境变量中。\n    </li>\n    <li>NVIDIA的驱动关联&nbsp;CUDA Toolkit 8.0。</li>\n    <li>cuDNN v5.1。请查看 <a href="https://developer.nvidia.com/cudnn" rel="nofollow">NVIDIA&nbsp;cudnn</a>\n        文档。需要注意的是cuDNN通常安装在与其他CUDA动态链接库（dll）不同的位置。确保已经将cuDNN的 动态链接库（dll）的地址添加到系统的&nbsp;&nbsp;<code>%PATH%</code>&nbsp;环境变量中。\n    </li>\n    <li>GPU显卡必须拥有3.0以上版本的CUDA计算能力，查看 <a href="https://developer.nvidia.com/cuda-gpus" rel="nofollow">NVIDIA显卡支持列表</a>\n        了解支持情况。\n    </li>\n</ul>\n<p>如果系统中已经安装了以前的相关包，请更新到所指定的版本。</p>\n\n<h2 id="h2-3">如何安装TensorFlow</h2>\n<p>在安装TensorFlow之前必须选定一个安装机制。目前提供2种机制：</p>\n<ul>\n    <li>"native"app</li>\n    <li>Anaconda</li>\n</ul>\n<p>\n    Native的安装（以下简称本地安装）方式会将TensorFlow直接安装在当前的系统中，不会在系统和TensorFlow之间搭建任何的虚拟环境，所以本地安装不会额外安装一个独立的容器。需要注意的是本地安装可能会干扰系统中其他基于python安装的程序。如果事先已经安装配置了满足需要的python环境，本地安装通常只需要一个命令就可以完成。使用本地安装，用户可以在系统中任何位置运行TensorFlow。</p>\n<p>在Anaconda模式下，需要使用conda创建一个虚拟环境。官方优先推荐使用&nbsp;<code>pip install</code>&nbsp;命令来安装TensorFlow，其次再考虑anaconda的&nbsp;<code>conda\n    install</code>&nbsp;命令。conda包是第三方社区提供的（非TensorFlow官方），TensorFlow团队从始至终都不会去测试在conda中运行的情况，在使用时需考虑这个风险。</p>\n\n<h3 id="h3-1">本地安装</h3>\n<p>首先，需要安装以下版本的python：</p>\n<ul>\n    <li><a href="https://www.python.org/downloads/release/python-352/" rel="nofollow">Python 3.5.x from python.org</a>\n    </li>\n</ul>\n<p>TensorFlow在windows操作系统中仅仅支持3.5.x版本的python。Python 3.5.x附带pip3软件包管理器，这是用于安装TensorFlow的程序。</p>\n<p>安装TensorFlow需要启动一个终端（terminal），然后在该终端中输入对应的pip3 install命令。安装仅支持CPU版本的TensorFlow，输入以下命令：</p>\n<pre class="lua"><code class="language-bash">C:\\&gt; pip3 install <span class="code-comment">--upgrade tensorflow</span></code></pre>\n<p>安装GPU版本的TensorFlow，使用以下命令：</p>\n<pre class="lua"><code class="language-bash">C:\\&gt; pip3 install <span\n        class="code-comment">--upgrade tensorflow-gpu</span></code></pre>\n<p>Anaconda模式安装</p>\n<p><span style="color:#FF0000">再次强调，Anaconda安装是有第三方社区提供的，非官方。</span></p>\n<p>在Anaconda环境中安装TensorFlow分为以下几个步骤：</p>\n<ol>\n    <li>按照&nbsp;<a href="https://www.continuum.io/downloads" rel="nofollow">Anaconda download site</a>&nbsp;的说明进行下载和安装操作。\n    </li>\n    <li>调用以下命令来创建一个名为tensorflow的conda环境：\n        <pre class="groovy"><code class="language-bash"><span class="code-string">C:</span>&gt; conda create -n tensorflow </code></pre>\n        <p></p></li>\n    <li><p>键入以下命令来启用conda环境：</p>\n        <pre class="yaml"><code class="language-bash"><span class="hljs-attr">C:</span>&gt; activate tensorflow\n (tensorflow)C:&gt;  <span class="code-comment"><span\n                    class="code-comment"># Your prompt should change </span></span></code></pre>\n        <p></p></li>\n    <li><p>键入以下命令在conda环境中安装TensorFlow。这里 安装CPU版本的命令：</p>\n        <pre class="groovy"><code class="language-bash">(tensorflow)<span class="code-string">C:</span>&gt; pip install --ignore-installed --upgrade <span\n                class="code-string">https:</span><span class="code-comment">//storage.googleapis.com/tensorflow/windows/cpu/tensorflow-1.0.1-cp35-cp35m-win_amd64.whl </span>\n</code></pre>\n        <p>这是GPU版本的命令：</p>\n        <pre class="groovy"><code class="language-bash">(tensorflow)<span class="code-string">C:</span>&gt; pip install --ignore-installed --upgrade <span\n                class="code-string">https:</span><span class="code-comment">//storage.googleapis.com/tensorflow/windows/gpu/tensorflow_gpu-1.0.1-cp35-cp35m-win_amd64.whl </span></code></pre>\n        <p></p></li>\n</ol>\n\n<h3 id="h3-2">验证安装&nbsp;</h3>\n<ol>\n    <li>通过以下步骤来验证TensorFlow是否安装成功：</li>\n    <li>启动一个终端（比如CMD）</li>\n    <li>如果通过Anaconda安装，先启动Anaconda环境。</li>\n    <li>在终端运行python</li>\n    <li>\n        <pre class="groovy"><code class="language-bash"><span class="code-string">C:</span>&gt; python </code></pre>\n    </li>\n    <li>在python的交互环境中输入以下脚本代码：</li>\n    <li> <pre class="python"><code class="python"><span class="code-meta"><span\n            class="code-meta">&gt;&gt;&gt; </span></span><span class="code-keyword"><span\n            class="code-keyword">import</span></span> tensorflow <span class="code-keyword"><span class="code-keyword">as</span></span> tf\n\n\n\n\nhello = tf.constant(<span class="code-string"><span class="code-string">\'Hello, TensorFlow!\'</span></span>)\nsess = tf.Session()\nprint(sess.run(hello))\n </code></pre>\n        <p>如果python输出以下内容，则表明TensorFlow已经安装成功然后就可以写TensorFlow的程序了：</p></li>\n    <li>\n        <pre class=""><code class="language-bash">Hello, TensorFlow!</code></pre>\n        <p>如果收到了一些异常信息，请继续向下看。</p></li>\n</ol>\n\n<h3 id="h3-3">常见的安装问题</h3>\n<p>TensorFlow通过Stack Overflow网站来记录错误信息以及处理方法。下面的列表包含一些跳转的到&nbsp;Stack Overflow的连接。如果在安装过程中遇到的问题没有在下面中，请到Stack\n    Overflow去搜索相关的关键字。若还是搜索不到，请直接提出新问题并标记&nbsp;<code>tensorflow</code>&nbsp;的标签。</p>\n<table>\n    <tbody>\n    <tr>\n        <th>Stack Overflow Link</th>\n        <th>Error Message</th>\n    </tr>\n    <tr>\n        <td><a href="https://stackoverflow.com/q/41007279" rel="nofollow">41007279</a></td>\n        <td>\n            [...\\stream_executor\\dso_loader.cc] Couldn\'t open CUDA library nvcuda.dll\n        </td>\n    </tr>\n    <tr>\n        <td><a href="https://stackoverflow.com/q/41007279" rel="nofollow">41007279</a></td>\n        <td>\n            [...\\stream_executor\\cuda\\cuda_dnn.cc] Unable to load cuDNN DSO\n        </td>\n    </tr>\n    <tr>\n        <td><a href="http://stackoverflow.com/q/42006320" rel="nofollow">42006320</a></td>\n        <td>\n            ImportError: Traceback (most recent call last): File "...\\tensorflow\\core\\framework\\graph_pb2.py", line 6,\n            in from google.protobuf import descriptor as _descriptor ImportError: cannot import name \'descriptor\'\n        </td>\n    </tr>\n    <tr>\n        <td><a href="https://stackoverflow.com/q/42011070" rel="nofollow">42011070</a></td>\n        <td>\n            No module named "pywrap_tensorflow"\n        </td>\n    </tr>\n    </tbody>\n</table>'}});