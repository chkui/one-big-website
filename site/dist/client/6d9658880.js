webpackJsonp([6],{346:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h3 id="h3-1">不使用ES6</h3>\n<p>通常情况下，定义一个React组件可以使用ES6规范中的class关键字：</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span\n        class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span\n        class="code-title"><span class="hljs-class"><span class="code-title">Greeting</span></span></span><span\n        class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="xml"><span class="code-tag">&lt;<span\n            class="code-name">h1</span>&gt;</span><span class="code-type">Hello</span>, {<span\n            class="code-keyword">this</span>.props.name}<span class="code-tag">&lt;/<span class="code-name">h1</span>&gt;</span></span>;\n  }\n}</code></pre>\n<p>如果不使用ES6语法，可以直接使用&nbsp;<code>React.createClass</code>&nbsp;来实现相同的功能：</p>\n<pre class="javascript"><code class="language-javascript"><span class="code-keyword"><span\n        class="code-keyword">var</span></span> Greeting = React.createClass({\n  render: <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">function</span></span></span><span\n            class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span\n            class="hljs-params"></span>) </span></span>{\n    <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="xml"><span class="code-tag"><span\n            class="xml"><span class="code-tag">&lt;</span></span><span class="code-name"><span class="xml"><span\n            class="code-tag"><span class="code-name">h1</span></span></span></span><span class="xml"><span\n            class="code-tag">&gt;</span></span></span><span class="xml">Hello, {this.props.name}</span><span\n            class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span\n            class="xml"><span class="code-tag"><span class="code-name">h1</span></span></span></span><span\n            class="xml"><span class="code-tag">&gt;</span></span></span></span>;\n  }\n});</code></pre>\n\n<h4 id="h4-1">声明Prop的检查类型以及默认Props值</h4>\n<p>在前面的博文（<a title="React prop类型检查与Dom" href="https://www.chkui.com/article/react/react_typechecking_with_proptypes_and_dom_element">React prop类型检查与Dom</a>）中介绍了如何规约Prop的参数值，给出的例子都是用ES6实现的：</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span\n        class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span\n        class="code-title"><span class="hljs-class"><span class="code-title">Greeting</span></span></span><span\n        class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  <span class="code-comment"><span class="code-comment">// ...</span></span>\n}\n\n<span class="code-type">Greeting</span>.propTypes = {\n  name: <span class="code-type">React</span>.<span class="code-type">PropTypes</span>.string\n};\n\n<span class="code-type">Greeting</span>.defaultProps = {\n  name: <span class="code-string"><span class="hljs-symbol">\'Mar</span>y\'</span>\n};</code></pre>\n<p>\n    在使用&nbsp;<code>React.createClass</code>&nbsp;时，可以通过设定传入的对象的一个属性值——&nbsp;<code>propTypes</code>&nbsp;来指定参数类型，通过&nbsp;<code>getDefaultProps()</code>&nbsp;方法来设定每个参数的默认值：\n</p>\n<pre class="actionscript"><code class="language-javascript"><span class="code-keyword"><span\n        class="code-keyword">var</span></span> Greeting = React.createClass({\n  propTypes: {\n    name: PropTypes.string\n  },\n\n  getDefaultProps: <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">function</span></span></span><span class="hljs-function"><span\n            class="hljs-params">(</span></span><span class="hljs-params"></span><span class="hljs-function"><span\n            class="hljs-params">)</span> </span></span>{\n    <span class="code-keyword"><span class="code-keyword">return</span></span> {\n      name: <span class="code-string"><span class="code-string">\'Mary\'</span></span>\n    };\n  },\n\n  <span class="code-comment"><span class="code-comment">// ...</span></span>\n\n});</code></pre>\n\n<h4 id="h4-2">设定初始化状态</h4>\n<p>在ES6的 class&nbsp;结构中，我们可以在构造函数中设定初始化状态：</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span\n        class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span\n        class="code-title"><span class="hljs-class"><span class="code-title">Counter</span></span></span><span\n        class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  <span class="code-keyword">constructor</span>(props) {\n    <span class="code-keyword"><span class="code-keyword">super</span></span>(props);\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.state = {count: props.initialCount};\n  }\n  <span class="code-comment"><span class="code-comment">// ...</span></span>\n}</code></pre>\n<p>在使用&nbsp;<code>React.createClass</code>&nbsp;时，可以为传入的对象参数添加一个&nbsp;&nbsp;<code>getInitialState</code>&nbsp;方法并返回一个初始状态值：\n</p>\n<pre class="actionscript"><code class="language-javascript"><span class="code-keyword"><span\n        class="code-keyword">var</span></span> Counter = React.createClass({\n  getInitialState: <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">function</span></span></span><span class="hljs-function"><span\n            class="hljs-params">(</span></span><span class="hljs-params"></span><span class="hljs-function"><span\n            class="hljs-params">)</span> </span></span>{\n    <span class="code-keyword"><span class="code-keyword">return</span></span> {count: <span class="code-keyword"><span\n            class="code-keyword">this</span></span>.props.initialCount};\n  },\n  <span class="code-comment"><span class="code-comment">// ...</span></span>\n});</code></pre>\n\n<h4 id="h4-3">自动绑定</h4>\n<p>当使用ES6的 <em>class </em>关键字声明一个React组件时，类中的方法遵循与常规的方法一样的定义。这就意味着在类中申明的方法在执行时并不会自动属于当前实例，必须在构造函数中显示的使用.bind(this)方法绑定到当前实例：\n</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span\n        class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span\n        class="code-title"><span class="hljs-class"><span class="code-title">SayHello</span></span></span><span\n        class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  <span class="code-keyword">constructor</span>(props) {\n    <span class="code-keyword"><span class="code-keyword">super</span></span>(props);\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.state = {message: <span\n            class="code-string"><span class="hljs-symbol">\'Hello</span>!\'</span>};\n    <span class="code-comment"><span class="code-comment">// 必须，否在在handleClick中this将指向调用对象</span></span>\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.handleClick = <span\n            class="code-keyword"><span class="code-keyword">this</span></span>.handleClick.bind(<span\n            class="code-keyword"><span class="code-keyword">this</span></span>);\n  }\n\n  handleClick() {\n    alert(<span class="code-keyword"><span class="code-keyword">this</span></span>.state.message);\n  }\n\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> (\n      <span class="xml"><span class="code-tag">&lt;<span class="code-name">button</span> <span\n              class="hljs-attr">onClick</span>=<span class="code-string">{<span class="code-keyword">this</span>.handleClick}</span>&gt;</span>\n        <span class="code-type">Say</span> hello\n      <span class="code-tag">&lt;/<span class="code-name">button</span>&gt;</span></span>\n    );\n  }\n}</code></pre>\n<p>在使用&nbsp;<code>React.createClass</code>&nbsp;时不必绑定所有的方法：</p>\n<pre class="javascript"><code class="language-javascript"><span class="code-keyword"><span\n        class="code-keyword">var</span></span> SayHello = React.createClass({\n  getInitialState: <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">function</span></span></span><span class="hljs-function">(</span><span\n            class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{\n    <span class="code-keyword"><span class="code-keyword">return</span></span> {message: <span class="code-string"><span\n            class="code-string">\'Hello!\'</span></span>};\n  },\n\n  handleClick: <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">function</span></span></span><span class="hljs-function">(</span><span\n            class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{\n    alert(<span class="code-keyword"><span class="code-keyword">this</span></span>.state.message);\n  },\n\n  render: <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">function</span></span></span><span\n            class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span\n            class="hljs-params"></span>) </span></span>{\n    <span class="code-keyword"><span class="code-keyword">return</span></span> (\n      <span class="xml"><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n              class="code-name"><span class="xml"><span class="code-tag"><span\n              class="code-name">button</span></span></span></span><span class="xml"><span\n              class="code-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="code-tag"><span\n              class="hljs-attr">onClick</span></span></span></span><span class="xml"><span\n              class="code-tag">=</span></span><span class="code-string"><span class="xml"><span class="code-tag"><span\n              class="code-string">{this.handleClick}</span></span></span></span><span class="xml"><span\n              class="code-tag">&gt;</span></span></span><span class="xml">\n        Say hello\n      </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span\n              class="xml"><span class="code-tag"><span class="code-name">button</span></span></span></span><span\n              class="xml"><span class="code-tag">&gt;</span></span></span></span>\n    );\n  }\n});</code></pre>\n<p>以上的特性意味着使用ES6编写代码每一个方法都会额外增加一些样板式代码，但是对于大型应用来说代码结构更清晰。</p>\n<p>如果十分排斥样板式代码，可以启用Babal的 类属性功能（&nbsp;<a title="Class Properties" href="https://babeljs.io/docs/plugins/transform-class-properties/"\n                                         rel="nofollow">Class Properties</a>&nbsp;），利用双箭头来创建方法：</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span\n        class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span\n        class="code-title"><span class="hljs-class"><span class="code-title">SayHello</span></span></span><span\n        class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  <span class="code-keyword">constructor</span>(props) {\n    <span class="code-keyword"><span class="code-keyword">super</span></span>(props);\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.state = {message: <span\n            class="code-string"><span class="hljs-symbol">\'Hello</span>!\'</span>};\n  }\n\n  handleClick = () =&gt; {\n    alert(<span class="code-keyword"><span class="code-keyword">this</span></span>.state.message);\n  }\n\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> (\n      <span class="xml"><span class="code-tag">&lt;<span class="code-name">button</span> <span\n              class="hljs-attr">onClick</span>=<span class="code-string">{<span class="code-keyword">this</span>.handleClick}</span>&gt;</span>\n        <span class="code-type">Say</span> hello\n      <span class="code-tag">&lt;/<span class="code-name">button</span>&gt;</span></span>\n    );\n  }\n}</code></pre>\n<p>需要注意的是，目前这个功能还是实验性的，双箭头的表达式很有可能会调整。该提议不一定会被委员会接纳。</p>\n<p>如果非常想要尝试这种写法，你可以有这几种实现方式：</p>\n<ol>\n    <li>在构造函数中绑定方法。</li>\n    <li>使用箭头来定义方法。</li>\n    <li>使用&nbsp;<code>React.createClass</code>&nbsp;。</li>\n</ol>\n\n<h4 id="h4-4">代码混合器</h4>\n<blockquote>\n    <p>注意：</p>\n    <p>ES6在目前的方案中并不支持代码混合功能，因此在使用ES6编写React代码时并不能实现相关功能。</p>\n    <p>官方也收到许多在使用混合器时遇到的问题，强烈建议不要在新的代码中使用混合器功能。</p>\n    <p>以下的内容仅供参考。</p>\n</blockquote>\n<p>某些时候2个不同的组件需要共享一些相同的方法或者功能。这种情况我们称为 横切关联（&nbsp;<a title="cross-cutting concerns" href="https://en.wikipedia.org/wiki/Cross-cutting_concern"\n                                                     rel="nofollow">cross-cutting concerns</a>）。&nbsp;<a title="React.createClass"\n        href="https://facebook.github.io/react/docs/top-level-api.html#react.createclass" rel="nofollow"><code>React.createClass</code></a>&nbsp;可以通过继承来实现组件间公用相同方法。\n</p>\n<p>一个通用的案例是一个组件需要定期更新自己的状态，只要使用<code>setInterval()</code>就可以实现。但是当您不再需要它来节省内存时，取消定时器是很重要的。React提供了生命周期方法来通知创建和销毁事件。下面的代码创建了一个肩带的混合器，混合器的作用是当组件被销毁之前，可以清除已有的定时器：\n</p>\n<pre class="javascript"><code class="language-javascript"><span class="code-comment"><span class="code-comment">// 定义一个混合器</span></span>\n<span class="code-keyword"><span class="code-keyword">var</span></span> SetIntervalMixin = {\n  <span class="code-comment"><span class="code-comment">//组件将要被渲染时调用</span></span>\n  componentWillMount: <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">function</span></span></span><span class="hljs-function">(</span><span\n            class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.intervals = [];\n  },\n  <span class="code-comment"><span class="code-comment">// 设置定时器方法</span></span>\n  setInterval: <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">function</span></span></span><span class="hljs-function">(</span><span\n            class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.intervals.push(setInterval.apply(<span\n            class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="code-built_in"><span\n            class="code-built_in">arguments</span></span>));\n  },\n\n  <span class="code-comment"><span class="code-comment">//组件将要被卸载时调用</span></span>\n  componentWillUnmount: <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">function</span></span></span><span class="hljs-function">(</span><span\n            class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.intervals.forEach(clearInterval);\n  }\n};\n\n<span class="code-keyword"><span class="code-keyword">var</span></span> TickTock = React.createClass({\n  mixins: [SetIntervalMixin], <span class="code-comment"><span class="code-comment">// 设定混合器</span></span>\n  getInitialState: <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">function</span></span></span><span class="hljs-function">(</span><span\n            class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{\n    <span class="code-keyword"><span class="code-keyword">return</span></span> {seconds: <span class="hljs-number"><span\n            class="hljs-number">0</span></span>};\n  },\n  componentDidMount: <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">function</span></span></span><span class="hljs-function">(</span><span\n            class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.setInterval(<span\n            class="code-keyword"><span class="code-keyword">this</span></span>.tick, <span class="hljs-number"><span\n            class="hljs-number">1000</span></span>); <span class="code-comment"><span class="code-comment">// 调用混合器中的setInterval 方法</span></span>\n  },\n  tick: <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">function</span></span></span><span\n            class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span\n            class="hljs-params"></span>) </span></span>{\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.setState({seconds: <span\n            class="code-keyword"><span class="code-keyword">this</span></span>.state.seconds + <span\n            class="hljs-number"><span class="hljs-number">1</span></span>});\n  },\n  render: <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">function</span></span></span><span\n            class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span\n            class="hljs-params"></span>) </span></span>{\n    <span class="code-keyword"><span class="code-keyword">return</span></span> (\n      <span class="xml"><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n              class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">p</span></span></span></span><span\n              class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n        React has been running for {this.state.seconds} seconds.\n      </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span\n              class="xml"><span class="code-tag"><span class="code-name">p</span></span></span></span><span class="xml"><span\n              class="code-tag">&gt;</span></span></span></span>\n    );\n  }\n});\n\nReactDOM.render(\n  <span class="xml"><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n          class="code-name"><span class="xml"><span class="code-tag"><span\n          class="code-name">TickTock</span></span></span></span><span class="xml"><span\n          class="code-tag"> /&gt;</span></span></span><span class="xml">,\n  document.getElementById(\'example\')\n);</span></span></code></pre>\n<p>如果组件使用了多个混合器并且很多混合器定义了相同的生命周期方法，比如同时定义了componentWillUnmount方法当组件卸载时注销某些资源。所有混合器的生命周期方法都会被调用，React会按照混合器设定的顺序来执行。</p>\n\n<h3 id="h3-2">不使用JSX</h3>\n<p>对于React来说JSX并不是必须要使用的表达式。当在环境中不想在家额外的编译工具时尤其适用。</p>\n<p>每一个JSX的元素都仅仅是<code>React.createElement(component, props, ...children)</code>的语法糖，所以任何使用JSX表达式实现的内容都可以直接用JavaScript来实现。\n</p>\n<p>例如下面使用JSX编码的例子：</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span\n        class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span\n        class="code-title"><span class="hljs-class"><span class="code-title">Hello</span></span></span><span\n        class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="xml"><span class="code-tag">&lt;<span\n            class="code-name">div</span>&gt;</span><span class="code-type">Hello</span> {<span\n            class="code-keyword">this</span>.props.toWhat}<span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>;\n  }\n}\n\n<span class="code-type">ReactDOM</span>.render(\n  <span class="xml"><span class="code-tag">&lt;<span class="code-name"><span class="code-type">Hello</span></span> <span\n          class="hljs-attr">toWhat</span>=<span class="code-string"><span class="code-string">"World"</span></span> /&gt;</span>,\n  document.getElementById(<span class="hljs-symbol">\'roo</span>t\')\n);</span></code></pre>\n<p>如果我们不想使用JSX，可以将其修改为：</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span\n        class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span\n        class="code-title"><span class="hljs-class"><span class="code-title">Hello</span></span></span><span\n        class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="code-type">React</span>.createElement(<span\n            class="code-string"><span class="hljs-symbol">\'di</span>v\'</span>, <span class="hljs-literal"><span\n            class="hljs-literal">null</span></span>, <span class="code-string">`<span\n            class="code-type">Hello</span> <span class="hljs-subst">${<span class="code-keyword">this</span>.props.toWhat}</span>`</span>);\n  }\n}\n\n<span class="code-type">ReactDOM</span>.render(\n  <span class="code-type">React</span>.createElement(<span class="code-type">Hello</span>, {toWhat: <span\n            class="code-string"><span class="hljs-symbol">\'Worl</span>d\'</span>}, <span class="hljs-literal"><span\n            class="hljs-literal">null</span></span>),\n  <span class="code-built_in">document</span>.getElementById(<span class="code-string"><span\n            class="hljs-symbol">\'roo</span>t\'</span>)\n);</code></pre>\n<p>如果你对JSX如何转换成JavaScript有很强的兴趣，可以打开这个在线编译器试试：<a title="the online Babel compiler"\n        href="https://babeljs.io/repl/#?babili=false&amp;evaluate=true&amp;lineWrap=false&amp;presets=es2015%2Creact%2Cstage-0&amp;code=function%20hello()%20%7B%0A%20%20return%20%3Cdiv%3EHello%20world!%3C%2Fdiv%3E%3B%0A%7D"\n        rel="nofollow">the online Babel compiler</a>。</p>\n<p>组件被编译成一段字符串、由&nbsp;<code>React.Component</code>创建的子类或者一个普通无状态的组件。</p>\n<p>如果对编码时每次都要键入长长React.createElement感到痛苦，一个常见的模式是分配一个别名：</p>\n<pre class="javascript"><code class="language-javascript"><span class="code-keyword"><span\n        class="code-keyword">const</span></span> e = React.createElement;\n\nReactDOM.render(\n  e(<span class="code-string"><span class="code-string">\'div\'</span></span>, <span class="hljs-literal"><span\n            class="hljs-literal">null</span></span>, <span class="code-string"><span\n            class="code-string">\'Hello World\'</span></span>),\n  <span class="code-built_in"><span class="code-built_in">document</span></span>.getElementById(<span\n            class="code-string"><span class="code-string">\'root\'</span></span>)\n);</code></pre>\n<p></p>'},372:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h2 id="h2-1">JSR-175与元编程</h2>\n<p>要说明JSR-250先要解释清楚JSR-175，要解释清楚JSR就的先了解JCP是什么。网上资料很多，就不细说了，简单的说JCP（Java Community\n    Process）是管理Java生态（包括J2SE、J2EE等等）发展的合作组织。JSR（Java Specification\n    Request）就是组织内的成员针对Java的发展提出的一些需求，通过审核之后即会融入到新版本的Java功能中成为Java的一项特性或功能，不同的发行版本和虚拟机都会遵守这些约定。</p>\n<p>JSR-175的全文标题是<strong><span style="color:null">&nbsp;A Metadata Facility for the Java&nbsp;Programming Language （为Java语言提供元数据设施）</span></strong>。它明确提出了在Java平台引入“元编程”（Meta\n    Programming）的思想，要求提供对“元数据”（Meta Data）的支持。这就是我们现在大量使用的“@”注解（Annotation）功能的最早来源。JSR-175之后的JSR-181（Web服务支持）、JSR-250、<a\n            href="https://www.chkui.com/article/java/java_jsr330" title="JSR-330">JSR-330</a>都是基于“元数据”功能提出的一些更细节的实现。</p>\n<p>至于“元编程”、“元数据”是什么这里就不详细展开说明了，它的理论很早就提出了，据说最早是在Lisp这一类函数式编程语言上开始使用的。网上有很多相关的资料，简单的说它就是“对源码进行编码”，比如下面这样：</p>\n<pre><code class="java"><span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MyClass</span> </span>{\n\t<span class="code-meta">@Autowired</span>\n\t<span class="code-keyword">private</span> Interface support;\n}</code></pre>\n<p>通过@Autowired这个注解来对support这个域进行编码就可以很轻松的扩展原先类的功能。</p>\n\n<h2 id="h2-2">JSR-250的Spring实现</h2>\n<p>JSR-250主要是围绕着“资源”的使用预定义了一些注解（Annotation）,这里的“资源”可以理解为一个Class类的实例、一个JavaBean、或者一个Spring中的Bean。</p>\n<p>JSR-250相关的注解全部在 <em>javax.annotation</em> 和 <em>javax.annotation.security </em>包中，分成2个部分——资源定义和权限控制。它并没有提供具体的实现方式，仅仅是提供了指导性的文档和几个注解，由具体的框架去实现。\n</p>\n<p><em>javax.annotation</em> 中包含一下几个注解：</p>\n<ul>\n    <li>@Generated：生成资源的注解，通过该项标记产生的实例是一个资源。类似于Spring中的@Bean注解，用于生成一向资源。</li>\n    <li>@PostConstruct&nbsp;创造资源之后的回调处理，Spring已经实现了这个注解，见<a\n            href="https://www.chkui.com/article/spring/spring_core_bean_lifecycle_callback"\n            title="Bean的定义与控制">Bean的定义与控制</a> 一文的介绍。\n    </li>\n    <li>@PreDestroy&nbsp;销毁资源之前的回调处理，Spring同样实现了这个注解，见<a\n            href="https://www.chkui.com/article/spring/spring_core_bean_lifecycle_callback"\n            title="Bean的定义与控制">Bean的定义与控制</a>。\n    </li>\n    <li>@Resource&nbsp;标记使用资源的位置，Spring同样实现了这个注解的功能（后文会详细介绍）。功能上有些类似于@Autowired、@Inject，但是两者有不少的差别。</li>\n    <li>@Resources&nbsp;标记使用多项资源的位置，类似于使用@Autowired向一个列表装载数据。</li>\n</ul>\n<p>仔细看JSR-250定义的这些注解就会发现，他们都是关于“资源”的构建、销毁、使用的。Spring实现了@PostConstruct、@PreDestroy和@Resource。</p>\n<p>javax.annotation.security&nbsp;包中有以下内容：</p>\n<ul>\n    <li>@DeclareRoles&nbsp;声明角色</li>\n    <li>@DenyAll&nbsp; 拒绝所有角色</li>\n    <li>@PermitAll&nbsp; 授权所有惧色</li>\n    <li>@RolesAllowed&nbsp; 角色授权</li>\n    <li>@RunAs 运行模式</li>\n</ul>\n<p>security中的内容是在资源创建之后对<strong><em>资源的使用进行管理</em></strong>。和常规的权限控制模型一样——定义角色（@DeclareRoles&nbsp;）、确定角色对资源的控制权限（@DenyAll、@PermitAll\n    、@RolesAllowed&nbsp;）。Spring并没有实现这里的任何一个注解，在这里就不深入介绍了。这一块内容在J2EE的构建中有不少的应用。</p>\n\n<h2 id="h2-3">Spring中的@Resource</h2>\n<p>\n    在没有仔细看Spring的官方文档和JSR-250之前，我一直以为@Resource这个注解和@Autowired是2个不同的功能，更早的时候还以为是管理什么Properties资源的，很多网上的内容也写得比较模糊。虽然@Resource的实现是在\n    <em>CommonAnnotationBeanPostProcessor</em>&nbsp;而@Autowired 是在\n    AutowiredAnnotationBeanPostProcessor，但是实际上两者的功能是重叠的，或者说@Resource的提供的功能是@Autowired的子集。</p>\n<p>在Spring中使用@Resource注解时，把Bean理解为一项资源就很好理解了。下面通过一些简单的例子来介绍@Resource的使用。</p>\n<p>@Resource的功能是告诉IoC容器标记的位置需要什么样的“资源”，如下：</p>\n<pre><code class="java"><span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">Abc</span> </span>{}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">Xyz</span> </span>{}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">Implement</span> </span>{\n\t<span class="code-meta">@Resource</span>\n\t<span class="code-keyword">private</span> Abc abc;\n\t\n\t<span class="code-keyword">private</span> Xyz xyz;\n\n    <span class="code-meta">@Resource</span>\n    <span class="code-keyword">private</span> ApplicationContext context;\n\n\t<span class="code-meta">@Resource</span>(name=<span class="code-string">"b_instance"</span>)\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setInject</span><span class="hljs-params">(Xyz xyz)</span> </span>{\n\t\t<span class="code-keyword">this</span>.xyz = xyz;\n\t}\n}</code></pre>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">context:annotation-config</span>/&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n            class="code-string">"abc"</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"x.y.Abc"</span> /&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n            class="code-string">"xyz_instance"</span> <span class="hljs-attr">name</span>=<span class="code-string">"inject"</span> <span\n            class="hljs-attr">class</span>=<span class="code-string">"x.y.Xyz"</span> /&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"x.y.Implement"</span> /&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>\n    运行后，IoC会向标记了@Resource的位置注入Bean——是不是感觉和@Autowired一模一样？但是需要注意的是虽然两者最后都是注入一个Bean，但是@Resource和@Autowired的处理过程是不一样的。@Autowired如果没有提供任何参数，那么他优先按照类型注入，如果要对细节进行控制可以配合Primary和Qualifiers功能，详见<a\n        href="https://www.chkui.com/article/spring/spring_core_auto_inject_of_annotation" title="注解自动装载">注解自动装载</a>的介绍。@Resource是按照命名来注入资源的，以上面的代码为例子：\n</p>\n<ol>\n    <li>例如在setter方法上定义了name="xyz_instance"参数，那么会去IoC容器中寻找id、name等于"xyz_instance"的Bean来注入。</li>\n    <li>例如在abc这个域（成员变量）上没有定义name参数，那么会使用域的名称（这里是"abc"）去IoC中按id、name寻找Bean来注入。</li>\n    <li>如果@Resource定义在方法上，并且没有指定name参数，那么他会使用setter的名称（例子中方法名为setInject，名称就是"inject"）来寻找并注入数据。</li>\n    <li>最后，如果名称匹配不上，容器会根据标记位置的类型来注入数据，例如例如中的ApplicationContext。</li>\n</ol>\n<p>所以@Resource的装载资源过程是：1)匹配name参数；2)没有name参数时会根据setter或域的名称来匹配Bean的名称；3)还是匹配不上就根据标记位置的类型来注入数据。</p>\n<p>与@Autowired相比主要有以下几点区别：</p>\n<ol>\n    <li>控制粒度没有@Autowired细，某些参数Spring并没有实现功能。但是使用他更符合整个Java生态的规范。</li>\n    <li>如果是使用类型依赖注入数据，应优先使用@Autowired，效率会好一些。</li>\n    <li>@Resource通过名称注入与@Autowired相比省去了@Qualifiers等内容。</li>\n    <li>@Resource只能用在域和Setter方法上。</li>\n</ol>\n<p>总的来说如果是按照类型注入依赖对象，那么最终得到的结果并没有任何差异，只是执行过程上有差别。如果按Bean的名称使用，@Resource比@Autowired便捷一些，但是功能少很多。</p>\n<p>个人建议如果开发的是一个面向终端用户的应用，比如Web应用、网站什么的，直接用@Autowired就好了。如果制作的是一个给别的开发人员使用的工具，可以考虑@Resourec，他能得到更多框架的支持。</p>\n\n<h2 id="h2-4">@PostConstruct 与@PreDestroy</h2>\n<p>@PostConstruct 与@PreDestroy也是JSR-250中定义的注解，Spring都实现了他们的功能，使用方法可以查看<a\n        href="https://www.chkui.com/article/spring/spring_core_bean_lifecycle_callback" title="Bean的定义与控制">Bean的定义与控制</a>&nbsp;相关的说明和介绍。\n</p>'},376:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h2 id="h2-1">抽象环境的概念</h2>\n<p>在介绍Spring核心模块为运行环境管理提供的功能之前，咱们先得解释清楚“运行环境”是什么。</p>\n<p>\n    码砖早年，对上下文（Context）、环境（Environment）一直都是傻傻分不清楚，感觉2者都是放了一堆参数在里面，貌似并没有多大区别。后来才慢慢摸清楚这2个词的套路。上下文（Context）是用来处理分层传递的，不清楚的可以看看<a\n        href="https://www.chkui.com/article/spring/spring_core_context_and_ioc" title="上下文与IoC">上下文与IoC</a>一文关于ApplicationContext的介绍。\n</p>\n<p>\n    而环境（Environment）是指当前运行程序之外的各种“全局变量”，这些变量反映了当前软件运行的各种外部情况。例如我们执行System.getenv()方法，就会获取到当前包括操作系统、全局路径配置、磁盘、jdk版本等等信息。这些信息实际上与当前运行的程序是无关的——无论你是否启动JVM，这些环境变量都是客观存在的。</p>\n<p>既然环境的作用是体现当前运行的各种外部情况，那么除了JVM启动时提供的固定参数，也可以指定我们需要的环境变量。例如我们最常见的环境——开发环境、测试环境、集成QA环境、仿真环境、生产环境等。</p>\n\n<h2 id="h2-2">Profile特性</h2>\n<p>对于软件开发而言经常要控制的就是当前程序是在开发环境运行还是在生产环境运行。除了后面要介绍的Spring Profile功能，还有各种各样的方法来进行控制，比如Maven的profile标签。Spring&nbsp;Profile只是一种环境控制的参考手段，他的好处是可以在代码级别去控制，具体使用什么根据项目的需要去考量。</p>\n<p>Spring的Profile特性使用起来并不复杂，而且同时支持Java注解和XML配置。我们通过几段代码来说明如何使用Profile。</p>\n\n<h3 id="h3-1">纯Java常规使用</h3>\n<p>（以下案例的可执行代码请到<a href="https://gitee.com/chkui-com/spring-core-sample" rel="nofollow">gitee</a>下载，）</p>\n<p>定义一个servuce接口和三个service的实现类：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.profile.service;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n            class="code-title">Blizzard</span> </span>{\n\t<span class="hljs-function">String <span class="code-title">getName</span><span class="hljs-params">()</span></span>;\n}</code></pre>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.profile.service.blizzard;\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">Warcraft</span> <span\n        class="code-keyword">implements</span> <span class="code-title">Blizzard</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span\n            class="code-title">getName</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"Warcraft"</span>;\n\t}\n\n}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">WorldOfWarcraft</span> <span\n        class="code-keyword">implements</span> <span class="code-title">Blizzard</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span\n            class="code-title">getName</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"World of Warcraft"</span>;\n\t}\n\n}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">Overwatch</span> <span\n        class="code-keyword">implements</span> <span class="code-title">Blizzard</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span\n            class="code-title">getName</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"Overwatch"</span>;\n\t}\n}</code></pre>\n<p>然后我们通过纯Java配置讲接口的每个实现添加到容器中：</p>\n<pre><code class="java"><span class="code-meta">@Configuration</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">EnvironmentApp</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\t<span class="code-comment">//在启动容器之前，先指定环境中的profiles参数</span>\n\t\tSystem.setProperty(<span class="code-string">"spring.profiles.active"</span>, <span\n            class="code-string">"wow"</span>);\n\t\tApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(EnvironmentApp.class);\n        <span class="code-comment">//当前的profile值是wow，所以获取的实现类是worldOfWarcraft</span>\n\t\tBlizzard blizzard = ctx.getBean(Blizzard.class);\n\t}\n\t\n\t<span class="code-meta">@Bean</span>\n\t<span class="code-meta">@Profile</span>(<span class="code-string">"war"</span>)\n\t<span class="hljs-function"><span class="code-keyword">public</span> Blizzard <span\n            class="code-title">warcraft</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> Warcraft();\n\t}\n\t\n\t<span class="code-meta">@Bean</span>\n\t<span class="code-meta">@Profile</span>(<span class="code-string">"wow"</span>)\n\t<span class="hljs-function"><span class="code-keyword">public</span> Blizzard <span class="code-title">worldOfWarcraft</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> WorldOfWarcraft();\n\t}\n\t\n\t<span class="code-meta">@Bean</span>\n\t<span class="code-meta">@Profile</span>(<span class="code-string">"default"</span>)\n\t<span class="hljs-function"><span class="code-keyword">public</span> Blizzard <span\n            class="code-title">overwatch</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> Overwatch();\n\t}\n}</code></pre>\n<p>@Configuration类中每一个@Bean注解之后都有一个@Profile注解。@Profile中的字符串就标记了当前适配的环境变量，他配合<em>System.setProperty("spring.profiles.active",\n    "wow");</em>这一行一起使用。当设定环境参数为wow时，标记了@Profile("wow")的方法会被启用，对应的Bean会添加到容器中。而其他标记的Bean不会被添加，当没有适配到任何Profile值时，@Profile("default")标记的Bean会被启用。\n</p>\n<p>Spring Profile的功能就是根据在环境中指定参数的方法来控制@Bean的创建。</p>\n\n<h2 id="h2-3">在@Configuration上配置Profile</h2>\n<p>@Profile注解除了在@Bean方法上使用，也可以用于@Configuration类上。这样使用可以一次性控制多个Bean的加载。例如下面的例子：</p>\n<pre><code class="java"><span class="code-meta">@Configuration</span>\n<span class="code-meta">@Profile</span>(<span class="code-string">"cast"</span>)\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">CastConfig</span> </span>{\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> Castlevania <span class="code-title">castlevania</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> Castlevania();\n\t}\n}\n\n<span class="code-meta">@Configuration</span>\n<span class="code-meta">@Profile</span>(<span class="code-string">"pes"</span>)\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">PESConfig</span> </span>{\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> ProEvolutionSoccer <span class="code-title">proEvolutionSoccer</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> ProEvolutionSoccer();\n\t}\n}</code></pre>\n<p>\n    这样可以控制整个@Configuration类中的Bean是否加载。这个时候如果在@Configuration类上还标注了@Import注解，那么被@Import引入的类中的@Bean也不会添加到IoC容器中，那么这对统一配置环境是很有好处的。</p>\n<p>需要注意的是，如果这个时候又在@Bean之上添加了@Profile注解，那么Spring最终会根据@Bean之上的标签来执行。例如：</p>\n<pre><code class="java"><span class="code-meta">@Configuration</span>\n<span class="code-meta">@Profile</span>(<span class="code-string">"cast"</span>)\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">CastConfig</span> </span>{\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> Castlevania <span class="code-title">castlevania</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> Castlevania();\n\t}\n\t<span class="code-meta">@Bean</span>\n    <span class="code-meta">@Profile</span>(<span class="code-string">"pes"</span>)\n\t<span class="hljs-function"><span class="code-keyword">public</span> ProEvolutionSoccer <span class="code-title">proEvolutionSoccer</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> ProEvolutionSoccer();\n\t}\n}</code></pre>\n<p>当环境中的profile值包含"pes"时候，@Profile("pes")标注的这个Bean就会添加到IoC容器中。</p>\n\n<h2 id="h2-4">Profile的XML配置</h2>\n<p>Profile特性也可以在XML配置。不过只能在&lt;beans&gt;标签上进行：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span> <span\n        class="hljs-attr">...</span> &gt;</span>\n\t<span class="code-tag">&lt;<span class="code-name">beans</span> <span class="hljs-attr">profile</span>=<span\n            class="code-string">"ff"</span>&gt;</span>\n\t\t<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n                class="code-string">"chkui.springcore.example.hybrid.profile.service.squareenix.FinalFantasy"</span> /&gt;</span>\n\t<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span>\n\t<span class="code-tag">&lt;<span class="code-name">beans</span> <span class="hljs-attr">profile</span>=<span\n            class="code-string">"dog"</span>&gt;</span>\n\t\t<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n                class="code-string">"chkui.springcore.example.hybrid.profile.service.squareenix.SleepingDogs"</span> /&gt;</span>\n\t<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>配置之后，&lt;beans&gt;中的多个&lt;bean&gt;都会被Profile控制。</p>\n\n<h2 id="h2-5">环境变量的设置</h2>\n<p>Profile的环境变量可以包含多个值。例如：</p>\n<pre><code class="java">System.setProperty(<span class="code-string">"spring.profiles.active"</span>, <span\n        class="code-string">"wow,pes"</span>);</code></pre>\n<p>这样环境中就包含了2个Profile的值。对用的@Profile或profile配置就会被启用。</p>\n<p>除了例子中给出的System::setProperty方法，Spring还提供了多种方法来设置Profile的环境变量。</p>\n\n<h4 id="h4-1"><strong>直接在Jvm启动参数中设置</strong></h4>\n<pre><code class="bash">-Dspring.profiles.active=<span class="code-string">"wow,pes"</span></code></pre>\n\n<h4 id="h4-2">使用EnvironmentCapable接口来设置</h4>\n<p>\n    ConfigurableApplicationContext继承了ConfigurableEnvironment接口我们可以通过ConfigurableEnvironment::getEnvironment方法获取到当前Spring中的环境对象——org.springframework.core.env.Environment，然后使用他来设置环境变量：</p>\n<pre><code class="java">ConfigurableApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(EnvironmentApp.class);\nConfigurableEnvironment env = ctx.getEnvironment();\n<span class="code-comment">//通过setActiveProfiles来设置。</span>\nenv.setActiveProfiles(<span class="code-string">"wow"</span>,<span class="code-string">"pes"</span>,<span\n            class="code-string">"ff"</span>);\n<span class="code-comment">//必须重建容器</span>\nctx.refresh();</code></pre>\n<p>\n    需要注意的是，在继承关系中ConfigurableApplicationContext之后才实现ConfigurableEnvironment，如果这里使用ApplicationContext::getEnvironment方法得到的是Environment，它不提供set相关的方法。所以上面的例子使用了ConfigurableApplicationContext。由于ApplicationContext的所有实现类都实现了Configurable的功能，我们也可以像下面这样进行转型：</p>\n<pre><code class="java">ApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(EnvironmentApp.class);\nEnvironment _e =ctx.getEnvironment();\nConfigurableEnvironment env = ConfigurableEnvironment.class.cast(_e);</code></pre>\n\n<h2 id="h2-6">@Profile的实现</h2>\n<p>Profile特性的实现也不复杂，其实就是实现了Conditional功能（Conditional功能见<a\n        href="https://www.chkui.com/article/spring/spring_core_configuration_annotation_and_xml" title="@Configuration与混合使用">@Configuration与混合使用</a>一文中关于Conditionally的介绍）。\n</p>\n<p>首先@Profile注解继承实现了@Conditional：</p>\n<pre><code class="java"><span class="code-meta">@Target</span>({ElementType.TYPE, ElementType.METHOD})\n<span class="code-meta">@Retention</span>(RetentionPolicy.RUNTIME)\n<span class="code-meta">@Documented</span>\n<span class="code-meta">@Conditional</span>(ProfileCondition.class)\n<span class="code-keyword">public</span> <span class="code-meta">@interface</span> Profile {}</code></pre>\n<p>然后他的处理类实现了Condition接口：</p>\n<pre><code class="java"><span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">ProfileCondition</span> <span\n        class="code-keyword">implements</span> <span class="code-title">Condition</span> </span>{\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">boolean</span> <span\n            class="code-title">matches</span><span class="hljs-params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>{\n\t\tMultiValueMap&lt;String, Object&gt; attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());\n\t\t<span class="code-keyword">if</span> (attrs != <span class="code-keyword">null</span>) {\n\t\t\t<span class="code-keyword">for</span> (Object value : attrs.get(<span class="code-string">"value"</span>)) {\n\t\t\t\t<span class="code-keyword">if</span> (context.getEnvironment().acceptsProfiles((String[]) value)) {\n\t\t\t\t\t<span class="code-keyword">return</span> <span class="code-keyword">true</span>;\n\t\t\t\t}\n\t\t\t}\n\t\t\t<span class="code-keyword">return</span> <span class="code-keyword">false</span>;\n\t\t}\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">true</span>;\n\t}\n\n}</code></pre>\n<p>处理过程也很简单，实际上就检查@Profile注解中的值，如果和环境中的一致则添加。</p>'},394:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<p>本文将解释如何在Windows下安装TensorFlow。</p>\n\n<h2 id="h2-1">确定安装哪类TensorFlow</h2>\n<p>需要先确定哪种类型的TensorFlow：</p>\n<ul>\n    <li><strong>仅支持CUP运算版本：</strong>如果电脑的系统没有&nbsp;NVIDIA®的GPU，那么必须安装这个版本。这个版本的TensorFlow安装非常简单（安装仅需一个命令，5到10分钟），所以即使系统中有满足要求的NVIDIA®\n        GPU官方还是建议在学习阶段安装这个版本。\n    </li>\n    <li><strong>支持GPU运算的版本：</strong>TensorFlow程序在GPU下运行比在CPU下运行明显快很多。如果系统中包含&nbsp;NVIDIA®的GPU满足下一个小节所示的条件并且程序对性能要求很高，建议安装此版本。\n    </li>\n</ul>\n\n<h2 id="h2-2">运行TensorFlow所需要的GPU配置</h2>\n<p>如果在系统中安装使用GPU运行的TensorFlow，需要确保下面介绍的NVIDIA软件已经安装到系统中。</p>\n<ul>\n    <li>CUDA® Toolkit 8.0。请看 <a\n            href="http://docs.nvidia.com/cuda/cuda-installation-guide-microsoft-windows/#axzz4eDEVDKkM" rel="nofollow">NVIDIA安装cuda</a>\n        的文档，根据文档中的描述确保已经将CUDA相关的路径增加到&nbsp;<code>%PATH%</code>&nbsp;环境变量中。\n    </li>\n    <li>NVIDIA的驱动关联&nbsp;CUDA Toolkit 8.0。</li>\n    <li>cuDNN v5.1。请查看 <a href="https://developer.nvidia.com/cudnn" rel="nofollow">NVIDIA&nbsp;cudnn</a>\n        文档。需要注意的是cuDNN通常安装在与其他CUDA动态链接库（dll）不同的位置。确保已经将cuDNN的 动态链接库（dll）的地址添加到系统的&nbsp;&nbsp;<code>%PATH%</code>&nbsp;环境变量中。\n    </li>\n    <li>GPU显卡必须拥有3.0以上版本的CUDA计算能力，查看 <a href="https://developer.nvidia.com/cuda-gpus" rel="nofollow">NVIDIA显卡支持列表</a>\n        了解支持情况。\n    </li>\n</ul>\n<p>如果系统中已经安装了以前的相关包，请更新到所指定的版本。</p>\n\n<h2 id="h2-3">如何安装TensorFlow</h2>\n<p>在安装TensorFlow之前必须选定一个安装机制。目前提供2种机制：</p>\n<ul>\n    <li>"native"app</li>\n    <li>Anaconda</li>\n</ul>\n<p>\n    Native的安装（以下简称本地安装）方式会将TensorFlow直接安装在当前的系统中，不会在系统和TensorFlow之间搭建任何的虚拟环境，所以本地安装不会额外安装一个独立的容器。需要注意的是本地安装可能会干扰系统中其他基于python安装的程序。如果事先已经安装配置了满足需要的python环境，本地安装通常只需要一个命令就可以完成。使用本地安装，用户可以在系统中任何位置运行TensorFlow。</p>\n<p>在Anaconda模式下，需要使用conda创建一个虚拟环境。官方优先推荐使用&nbsp;<code>pip install</code>&nbsp;命令来安装TensorFlow，其次再考虑anaconda的&nbsp;<code>conda\n    install</code>&nbsp;命令。conda包是第三方社区提供的（非TensorFlow官方），TensorFlow团队从始至终都不会去测试在conda中运行的情况，在使用时需考虑这个风险。</p>\n\n<h3 id="h3-1">本地安装</h3>\n<p>首先，需要安装以下版本的python：</p>\n<ul>\n    <li><a href="https://www.python.org/downloads/release/python-352/" rel="nofollow">Python 3.5.x from python.org</a>\n    </li>\n</ul>\n<p>TensorFlow在windows操作系统中仅仅支持3.5.x版本的python。Python 3.5.x附带pip3软件包管理器，这是用于安装TensorFlow的程序。</p>\n<p>安装TensorFlow需要启动一个终端（terminal），然后在该终端中输入对应的pip3 install命令。安装仅支持CPU版本的TensorFlow，输入以下命令：</p>\n<pre class="lua"><code class="language-bash">C:\\&gt; pip3 install <span class="code-comment">--upgrade tensorflow</span></code></pre>\n<p>安装GPU版本的TensorFlow，使用以下命令：</p>\n<pre class="lua"><code class="language-bash">C:\\&gt; pip3 install <span\n        class="code-comment">--upgrade tensorflow-gpu</span></code></pre>\n<p>Anaconda模式安装</p>\n<p><span style="color:#FF0000">再次强调，Anaconda安装是有第三方社区提供的，非官方。</span></p>\n<p>在Anaconda环境中安装TensorFlow分为以下几个步骤：</p>\n<ol>\n    <li>按照&nbsp;<a href="https://www.continuum.io/downloads" rel="nofollow">Anaconda download site</a>&nbsp;的说明进行下载和安装操作。\n    </li>\n    <li>调用以下命令来创建一个名为tensorflow的conda环境：\n        <pre class="groovy"><code class="language-bash"><span class="code-string">C:</span>&gt; conda create -n tensorflow </code></pre>\n        <p></p></li>\n    <li><p>键入以下命令来启用conda环境：</p>\n        <pre class="yaml"><code class="language-bash"><span class="hljs-attr">C:</span>&gt; activate tensorflow\n (tensorflow)C:&gt;  <span class="code-comment"><span\n                    class="code-comment"># Your prompt should change </span></span></code></pre>\n        <p></p></li>\n    <li><p>键入以下命令在conda环境中安装TensorFlow。这里 安装CPU版本的命令：</p>\n        <pre class="groovy"><code class="language-bash">(tensorflow)<span class="code-string">C:</span>&gt; pip install --ignore-installed --upgrade <span\n                class="code-string">https:</span><span class="code-comment">//storage.googleapis.com/tensorflow/windows/cpu/tensorflow-1.0.1-cp35-cp35m-win_amd64.whl </span>\n</code></pre>\n        <p>这是GPU版本的命令：</p>\n        <pre class="groovy"><code class="language-bash">(tensorflow)<span class="code-string">C:</span>&gt; pip install --ignore-installed --upgrade <span\n                class="code-string">https:</span><span class="code-comment">//storage.googleapis.com/tensorflow/windows/gpu/tensorflow_gpu-1.0.1-cp35-cp35m-win_amd64.whl </span></code></pre>\n        <p></p></li>\n</ol>\n\n<h3 id="h3-2">验证安装&nbsp;</h3>\n<ol>\n    <li>通过以下步骤来验证TensorFlow是否安装成功：</li>\n    <li>启动一个终端（比如CMD）</li>\n    <li>如果通过Anaconda安装，先启动Anaconda环境。</li>\n    <li>在终端运行python</li>\n    <li>\n        <pre class="groovy"><code class="language-bash"><span class="code-string">C:</span>&gt; python </code></pre>\n    </li>\n    <li>在python的交互环境中输入以下脚本代码：</li>\n    <li> <pre class="python"><code class="python"><span class="code-meta"><span\n            class="code-meta">&gt;&gt;&gt; </span></span><span class="code-keyword"><span\n            class="code-keyword">import</span></span> tensorflow <span class="code-keyword"><span class="code-keyword">as</span></span> tf\n\n\n\n\nhello = tf.constant(<span class="code-string"><span class="code-string">\'Hello, TensorFlow!\'</span></span>)\nsess = tf.Session()\nprint(sess.run(hello))\n </code></pre>\n        <p>如果python输出以下内容，则表明TensorFlow已经安装成功然后就可以写TensorFlow的程序了：</p></li>\n    <li>\n        <pre class=""><code class="language-bash">Hello, TensorFlow!</code></pre>\n        <p>如果收到了一些异常信息，请继续向下看。</p></li>\n</ol>\n\n<h3 id="h3-3">常见的安装问题</h3>\n<p>TensorFlow通过Stack Overflow网站来记录错误信息以及处理方法。下面的列表包含一些跳转的到&nbsp;Stack Overflow的连接。如果在安装过程中遇到的问题没有在下面中，请到Stack\n    Overflow去搜索相关的关键字。若还是搜索不到，请直接提出新问题并标记&nbsp;<code>tensorflow</code>&nbsp;的标签。</p>\n<table>\n    <tbody>\n    <tr>\n        <th>Stack Overflow Link</th>\n        <th>Error Message</th>\n    </tr>\n    <tr>\n        <td><a href="https://stackoverflow.com/q/41007279" rel="nofollow">41007279</a></td>\n        <td>\n            [...\\stream_executor\\dso_loader.cc] Couldn\'t open CUDA library nvcuda.dll\n        </td>\n    </tr>\n    <tr>\n        <td><a href="https://stackoverflow.com/q/41007279" rel="nofollow">41007279</a></td>\n        <td>\n            [...\\stream_executor\\cuda\\cuda_dnn.cc] Unable to load cuDNN DSO\n        </td>\n    </tr>\n    <tr>\n        <td><a href="http://stackoverflow.com/q/42006320" rel="nofollow">42006320</a></td>\n        <td>\n            ImportError: Traceback (most recent call last): File "...\\tensorflow\\core\\framework\\graph_pb2.py", line 6,\n            in from google.protobuf import descriptor as _descriptor ImportError: cannot import name \'descriptor\'\n        </td>\n    </tr>\n    <tr>\n        <td><a href="https://stackoverflow.com/q/42011070" rel="nofollow">42011070</a></td>\n        <td>\n            No module named "pywrap_tensorflow"\n        </td>\n    </tr>\n    </tbody>\n</table>'}});