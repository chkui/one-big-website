webpackJsonp([8],{388:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<p>笼统的说一个系统主要是由3个部分组成的：</p>\n<ol>\n    <li>执行程序：主要负责处理业务逻辑，对接用户操作。</li>\n    <li>内部数据：嵌套在源码中的数据，用于指导程序运行。</li>\n    <li>外部数据：业务数据，外部配置数据。</li>\n</ol>\n<p>\n    内部数据本身就是程序的一部分，在Java中这些数据通常停留在类的静态成员变量中。而外部数据往往与代码无关，所以对于程序而言要“读懂”它们需要进行一些前置处理。例如用户在前端页面提交的数据我们从RequestContext中获取的数据类型都是字符串，而我们的业务需要将字符串转换成数字、列表、对象等等，这就引入了我们接下来要介绍的内容——数据类型转换。</p>\n<p>JavaBean对于J2SE或者J2EE而言有着非常重要的意义，ORACLE为了统一各个组织对JavaBean的使用方式制定了详尽的JavaBean规范，包括<code><a\n        href="https://docs.oracle.com/javase/8/docs/api/java/beans/BeanInfo.html" target="_blank" rel="nofollow">BeanInfo</a>、<a\n        href="https://docs.oracle.com/javase/8/docs/api/java/beans/PropertyEditor.html" target="_blank" rel="nofollow">PropertyEditor</a>、</code><code><a\n        href="https://docs.oracle.com/javase/8/docs/api/java/beans/PropertyEditorSupport.html" target="_blank"\n        rel="nofollow">PropertyEditorSupport</a></code>等方面的内容。本文会涉及到JavaBean的一些规范，但是重点是介绍Spring的数据管理。</p>\n<p>（可执行代码请到本人gitee库下载，本文的代码在<em>chkui.springcore.example.hybrid.beanmanipulation</em>包）</p>\n\n<h2 id="h2-1">Properties结构转换为实体</h2>\n<p>标准资源文件*.properties是Java程序常用的数据存储文件，Spring提供了BeanWrapper接口将*.properties文件中的数据转换成一个标准的JavaBean对象。看下面的例子：</p>\n<p>有一个实体类Person：</p>\n<pre><code class="java"><span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">Person</span> </span>{\n\t<span class="code-keyword">private</span> String name;\n\t<span class="code-keyword">private</span> <span class="code-keyword">int</span> age;\n\t<span class="code-keyword">private</span> <span class="code-keyword">boolean</span> license;\n\t<span class="code-keyword">private</span> Date birtday;\n\t<span class="code-keyword">private</span> Address address;\n\t<span class="code-keyword">private</span> Map&lt;String, String&gt; otherInfo;\n\n    <span class="code-comment">// Getter &amp; Setter ......</span>\n}\n</code></pre>\n<p>然后可以通过BeanWrapper将Properties对象中的数据设置到对象中：</p>\n<pre><code class="java">   <span class="hljs-function"><span class="code-keyword">private</span> <span\n        class="code-keyword">void</span> <span class="code-title">simpleDataBind</span><span\n        class="hljs-params">()</span> </span>{\n\t\tBeanWrapper wrapper = <span class="code-keyword">new</span> BeanWrapperImpl(<span\n            class="code-keyword">new</span> Person());\n\t\t\n\t\t<span class="code-comment">//使用 BeanWrapper::setPropertyValue 接口设置数据</span>\n\t\twrapper.setPropertyValue(<span class="code-string">"name"</span>, <span class="code-string">"niubility"</span>);\n\t\twrapper.setPropertyValue(<span class="code-string">"age"</span>, <span class="hljs-number">18</span>);\n\t\twrapper.setPropertyValue(<span class="code-string">"license"</span>, <span class="code-keyword">true</span>);\n\t\tprint(wrapper.getWrappedInstance());\n\n\t\t<span class="code-comment">//使用 Properties对象设置数据，Properties实例可以来源于*.properties文件</span>\n\t\tProperties p = <span class="code-keyword">new</span> Properties();\n\t\tp.setProperty(<span class="code-string">"name"</span>, <span class="code-string">"From Properties"</span>);\n\t\tp.setProperty(<span class="code-string">"age"</span>, <span class="code-string">"25"</span>);\n\t\tp.setProperty(<span class="code-string">"license"</span>, <span class="code-string">"false"</span>);\n\t\tp.setProperty(<span class="code-string">"otherInfo[birthday]"</span>, <span\n            class="code-string">"2000-01-01"</span>);\n\t\twrapper.setPropertyValues(p);\n\t\tprint(wrapper.getWrappedInstance());\n\t}</code></pre>\n<p>这样，使用Spring的BeanWrapper接口，可以快速的将Properties数据结构转换为一个JavaBean实体。</p>\n<p>除了配置单个实体的数据，BeanWrapper还可以为嵌套结构的实体设置数据。现在增加一个实体Vehicle：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">Vehicle</span> </span>{\n\t<span class="code-keyword">private</span> String name;\n\t<span class="code-keyword">private</span> String manufacturer;\n\t<span class="code-keyword">private</span> Person person; <span class="code-comment">//Person对象</span>\n\n    <span class="code-comment">// Getter &amp; Setter ......</span>\n\n}</code></pre>\n<p>在Vehicle中有一个Person类型的成员变量（person域），我们可以利用下面具备嵌套结构的语法来设置数据：</p>\n<pre><code class="java">   <span class="hljs-function"><span\n        class="code-keyword">private</span> BeanManipulationApp <span class="code-title">nestedDataBind</span><span\n        class="hljs-params">()</span> </span>{\n\t\t<span class="code-comment">// 数据嵌套转换</span>\n\t\tBeanWrapper wrapper = <span class="code-keyword">new</span> BeanWrapperImpl(<span\n            class="code-keyword">new</span> Vehicle(<span class="code-keyword">new</span> Person()));\n\n\t\tProperties p = <span class="code-keyword">new</span> Properties();\n\t\tp.setProperty(<span class="code-string">"name"</span>, <span class="code-string">"Envision"</span>);\n\t\tp.setProperty(<span class="code-string">"manufacturer"</span>, <span class="code-string">"Buick"</span>);\n\t\t\n\t\t<span class="code-comment">//person.name表示设置person域的name变量数值</span>\n\t\tp.setProperty(<span class="code-string">"person.name"</span>, <span class="code-string">"Alice"</span>);\n\t\tp.setProperty(<span class="code-string">"person.age"</span>, <span class="code-string">"25"</span>);\n\t\tp.setProperty(<span class="code-string">"person.license"</span>, <span class="code-string">"true"</span>);\n\t\tp.setProperty(<span class="code-string">"person.otherInfo[license code]"</span>, <span class="code-string">"123456789"</span>);\n\t\twrapper.setPropertyValues(p);\n\t\tprint(wrapper.getWrappedInstance());\n\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>;\n\t}</code></pre>\n<p>在*.properties文件中，经常使用<em>path.name=param</em>的的语法来指定一个嵌套结构（比如LOG4J的配置文件），这里也使用类似的方式来指定嵌套结构。person.name在程序执行时会调用Vehicle::getPerson::setName方法来设定数据。\n</p>\n<p>除了设定单个数据BeanWrapper还提供了更丰富的方法来设置数据，以上面的Vehicle、person为例：</p>\n<table border="1" cellpadding="1" cellspacing="1" style="width:500px">\n    <tbody>\n    <tr>\n        <th>表达式</th>\n        <th>效果</th>\n    </tr>\n    </tbody>\n    <tbody>\n    <tr>\n        <td><em>p.setProperty("name", "Envision")</em></td>\n        <td>name域的数据设置为"Envision"</td>\n    </tr>\n    <tr>\n        <td><em>p.setProperty("person.name", "Alice")</em></td>\n        <td>将嵌套的person域下的name数据设置为"Alice"</td>\n    </tr>\n    <tr>\n        <td><em>p.setProperty("list[1]", "Step2")</em></td>\n        <td>list域是一个列表，将第二个数据设置为"Step2"</td>\n    </tr>\n    <tr>\n        <td><em>p.setProperty("otherInfo[birthday]", "2000-01-01")</em></td>\n        <td>otherInfo域是一个Map，将key=birthday、value="2000-01-01"的数据添加到Map中。</td>\n    </tr>\n    </tbody>\n</table>\n<p>上面这4条规则可以组合使用，比如<em>p.setProperty("person.otherInfo[license code]", "123456789")。</em></p>\n<p>关于在Java如何使用Properties有很多讨论（<a href="https://stackoverflow.com/questions/70471/no-properties-in-java" target="_blank" rel="nofollow">比如这篇stackoverflow的问答</a>），BeanWrapper不仅仅是针对资源文件，他还衍生扩展了数据类型转换等等功能。\n</p>\n\n<h2 id="h2-2">PropertyEditor转换数据</h2>\n<p>在JavaBean规范中定义了<em>java.beans.PropertyEditor，</em>他的作用简单的说就是将字符串转换为任意对象结构。</p>\n<blockquote>\n    <p>PropertyEditor最早是用来支持java.awt中的可视化接口编辑数据的（详情见<a\n            href="https://docs.oracle.com/javase/tutorial/javabeans/advanced/customization.html" target="_blank" rel="nofollow">Oracle关于IDE数据定制化的介绍</a>）。但是在Spring或其他应用场景中更多的仅仅是用来做字符串到特定数据格式的转换（毕竟java.awt应用不多），所以PropertyEditor提供的BeanWrapper::paintValue之类的支持awt的方法不用太去关心他，主要聚焦在BeanWrapper::setAsText方法上。\n    </p>\n</blockquote>\n<p>BeanWrapper继承了PropertyEditorRegistry接口用于注册PropertyEditor。BeanWrapperImpl已经预设了很多有价值的PropertyEditor，比如上面的例子的代码<em>p.setProperty("age",\n    "25");</em>，age域是一个数字整型，而Properties中的数据都是字符串，在设置数据时会自动启用CustomNumberEditor将字符串转换为数字。</p>\n<p>Spring已经提供的PropertyEditor可以看这里的<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-beans-conversion" target="_blank"\n        rel="nofollow">清单</a>。需要注意的是，这些PropertyEditor并不是每一个都默认启用，比如CustomDateEditor必须由开发者提供DateFormat才能使用，所以需要像下面这样将其添加注册到BeanWrapper中：\n</p>\n<pre><code class="java"><span class="hljs-function"><span class="code-keyword">private</span> <span\n        class="code-keyword">void</span> <span class="code-title">propertyEditor</span><span\n        class="hljs-params">()</span> </span>{\n\tBeanWrapper wrapper = <span class="code-keyword">new</span> BeanWrapperImpl(<span class="code-keyword">new</span> Person());\n\n\t<span class="code-comment">// 设定日期转换格式</span>\n\tDateFormat df = <span class="code-keyword">new</span> java.text.SimpleDateFormat(<span class="code-string">"yyyy-MM-dd"</span>);\n\t\t\n\t<span class="code-comment">// 将Editor与DateFormat进行帮顶，使用指定的格式</span>\n\tCustomDateEditor dateEditor = <span class="code-keyword">new</span> CustomDateEditor(df, <span class="code-keyword">false</span>);\n\t\t\n\t<span class="code-comment">// 注册dateEditor，将其与Date类进行绑定</span>\n\twrapper.registerCustomEditor(Date.class, dateEditor);\n\n\t<span class="code-comment">// CustomNumberEditor执行转换</span>\n\twrapper.setPropertyValue(<span class="code-string">"age"</span>, <span class="code-string">"18"</span>);\n\t<span class="code-comment">// CustomBooleanEditor执行转换</span>\n\twrapper.setPropertyValue(<span class="code-string">"license"</span>, <span class="code-string">"false"</span>);\n\t<span class="code-comment">// dateEditor执行转换</span>\n\twrapper.setPropertyValue(<span class="code-string">"birtday"</span>, <span class="code-string">"1999-01-30"</span>);\n\tprint(wrapper.getWrappedInstance());\n}</code></pre>\n<p>添加之后，设定<em>setPropertyValue("birtday", "1999-01-30")</em>时会自动使用指定的DateFormat转换日期。</p>\n\n<h2 id="h2-3">自定义PropertyEditor</h2>\n<p>除了预设的各种PropertyEditor，我们还可以开发自定义的PropertyEditor。Person中有一个类型为Address的成员变量：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">Address</span> </span>{\n\t<span class="code-keyword">private</span> String province; <span class="code-comment">//省</span>\n\t<span class="code-keyword">private</span> String city;  <span class="code-comment">//市</span>\n\t<span class="code-keyword">private</span> String district;  <span class="code-comment">//区</span>\n\n    <span class="code-comment">// Getter &amp; Setter</span>\n}</code></pre>\n<p>我们为Address实体添加一个PropertyEditor，将特定格式的字符串转换为Address结构：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">AddressEditor</span> <span class="code-keyword">extends</span> <span class="code-title">PropertyEditorSupport</span> </span>{\n\t<span class="code-keyword">private</span> String[] SPLIT_FLAG = { <span class="code-string">","</span>, <span\n            class="code-string">"-"</span>, <span class="code-string">";"</span>, <span class="code-string">":"</span> };\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setAsText</span><span class="hljs-params">(String text)</span> </span>{\n\t\t<span class="code-keyword">int</span> pos = -<span class="hljs-number">1</span>;\n\t\tAddress address = <span class="code-keyword">new</span> Address();\n\t\t<span class="code-keyword">for</span> (String flag : SPLIT_FLAG) {\n\t\t\tpos = text.indexOf(flag);\n\t\t\t<span class="code-keyword">if</span> (-<span class="hljs-number">1</span> &lt; pos) {\n\t\t\t\tString[] split = text.split(flag);\n\t\t\t\taddress.setProvince(split[<span class="hljs-number">0</span>]);\n\t\t\t\taddress.setCity(split[<span class="hljs-number">1</span>]);\n\t\t\t\taddress.setDistrict(split[<span class="hljs-number">2</span>]);\n\t\t\t\t<span class="code-keyword">break</span>;\n\t\t\t}\n\t\t}\n\t\t<span class="code-keyword">if</span> (-<span class="hljs-number">1</span> == pos) {\n\t\t\t<span class="code-keyword">throw</span> <span class="code-keyword">new</span> IllegalArgumentException(<span\n            class="code-string">"地址格式错误"</span>);\n\t\t}\n\t\tsetValue(address);<span class="code-comment">//设定Address实例</span>\n\t}\n}</code></pre>\n<p>\n    通过AddressEditor::setAsText方法，可以将输入的字符串最红转换为一个Address实例。通常情况下开发一个Editor转换器不会直接去实现PropertyEditor接口，而是继承PropertyEditorSupport。</p>\n<p>然后我们使用AddressEditor来将字符串转换为Address对象：</p>\n<pre><code class="java"><span class="hljs-function"><span class="code-keyword">private</span> BeanManipulationApp <span\n        class="code-title">propertyEditor</span><span class="hljs-params">()</span> </span>{\n\t<span class="code-comment">//使用预设转换工具和自定义转换工具</span>\n\tBeanWrapper wrapper = <span class="code-keyword">new</span> BeanWrapperImpl(<span class="code-keyword">new</span> Person());\n\n\t<span class="code-comment">// 创建AddressEditor实例</span>\n\tAddressEditor addressEditor = <span class="code-keyword">new</span> AddressEditor();\n\t\t\n\t<span class="code-comment">// 注册addressEditor，将其与Address类进行绑定</span>\n\twrapper.registerCustomEditor(Address.class, addressEditor);\n\n    <span class="code-comment">// 设置值自动进行转化</span>\n\twrapper.setPropertyValue(<span class="code-string">"address"</span>, <span class="code-string">"广东-广州-白云"</span>);\n\tprint(wrapper.getWrappedInstance());\n}</code></pre>\n<p>按照JavaBean规范，PropertyEditor和对应的JavaBean可以使用命名规则来表示绑定关系，而无需显式的调用注册方法。</p>\n<p>\n    绑定的规则是：有一个JavaBean命名为Tyre，在相同的包下（package）有一个实现了PropertyEditor接口并且命名为TyreEditor的类，那么框架认为TyreEditor就是Tyre的Editor，无需调用BeanWrapper::registerCustomEditor方法来声明Tyre和TyreEditor的绑定关系，详情请看源码中chkui.springcore.example.hybrid.beanmanipulation.bean.Tyre的使用。</p>\n\n<h2 id="h2-4">IoC与数据转换整合</h2>\n<p>对于Spring的ApplicationContext而言，BeanWrapper、PropertyEditor都是相对比较底层的功能，在使用Spring\n    Ioc容器的时候可以直接将这些功能嵌入到Bean初始化中或MVC的requestContext的数据转换中。</p>\n<p>从框架使用者的角度来看，Spring的XML配置数据或者通过MVC接口传递数据都是字符串，因此PropertyEditor在处理这些数据时有极大的用武之地。IoC容器使用<a\n        href="https://www.chkui.com/article/spring/spring_core_bean_post_processors" title="IOC处理器扩展">后置处理器</a>CustomEditorConfigurer来管理Bean初始化相关的PropertyEditor。通过CustomEditorConfigurer可以使用所有预设的Editor，还可以增加自定义的Editor，下面是使用@Configurable启用CustomEditorConfigurer的例子：\n</p>\n<pre><code class="java"><span class="code-meta">@Configurable</span>\n<span class="code-meta">@ImportResource</span>(<span\n            class="code-string">"classpath:hybrid/beanmanipulation/config.xml"</span>)\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">BeanManipulationConfig</span> </span>{\n\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function">CustomEditorConfigurer <span class="code-title">customEditorConfigurer</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-comment">// 构建CustomEditorConfigurer</span>\n\t\tCustomEditorConfigurer configurer = <span class="code-keyword">new</span> CustomEditorConfigurer();\n\t\t\n\t\tMap&lt;Class&lt;?&gt;, Class&lt;? extends PropertyEditor&gt;&gt; customEditors = <span\n            class="code-keyword">new</span> HashMap&lt;&gt;();\n\t\t\n\t\t<span class="code-comment">// 添加AddressEditor和Address的绑定</span>\n\t\tcustomEditors.put(Address.class, AddressEditor.class);\n\t\t\n\t\t<span class="code-comment">// 添加绑定列表</span>\n\t\tconfigurer.setCustomEditors(customEditors);\n\t\t\n\t\t<span class="code-comment">// 通过PropertyEditorRegistrar注册PropertyEditor</span>\n\t\tconfigurer.setPropertyEditorRegistrars(<span class="code-keyword">new</span> PropertyEditorRegistrar[] { <span\n            class="code-keyword">new</span> DateFormatRegistrar() });\n\t\t<span class="code-keyword">return</span> configurer;\n\t}\n}</code></pre>\n<p><em>CustomEditorConfigurer::setCustomEditors</em>和<em>CustomEditorConfigurer::setPropertyEditorRegistrars</em>都可以向容器中添加PropertyEditor，最主要区别在于：\n</p>\n<ol>\n    <li>前者是直接申明一对绑定关系的类对象（Class&lt;?&gt;），例如<em>customEditors.put(Address.class, AddressEditor.class);</em>\n        这行代码并没有实例化AddressEditor，而是将实例化交给后置处理器。\n    </li>\n    <li>\n        而后者是提供一个实例化的PropertyEditor，比前者更能实现更复杂的功能。比如下面的DateFormatRegistrar代码，由于需要组装DateFormat和CustomDateEditor，所以使用PropertyEditorRegistrar来实现这个过程更加合理，后置处理器会在某个时候调用这个注册方法。\n    </li>\n</ol>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">DateFormatRegistrar</span> <span class="code-keyword">implements</span> <span\n        class="code-title">PropertyEditorRegistrar</span> </span>{\n\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">registerCustomEditors</span><span\n            class="hljs-params">(PropertyEditorRegistry registry)</span> </span>{\n\t\tDateFormat df = <span class="code-keyword">new</span> java.text.SimpleDateFormat(<span class="code-string">"yyyy-MM-dd"</span>);\n\t\tCustomDateEditor editor = <span class="code-keyword">new</span> CustomDateEditor(df, <span class="code-keyword">false</span>);\n\t\tregistry.registerCustomEditor(Date.class, editor);\n\t}\n}</code></pre>\n<p>配置好CustomEditorConfigurer之后，就可以直接在配置Bean的时候直接使用预定的格式了，比如：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span>&gt;</span>\n\t<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n            class="code-string">"person"</span> <span class="hljs-attr">class</span>=<span class="code-string">"chkui.springcore.example.hybrid.beanmanipulation.bean.Person"</span>&gt;</span>\n\t\t<span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"name"</span> <span class="hljs-attr">value</span>=<span\n                class="code-string">"XML"</span> /&gt;</span>\n\t\t<span class="code-comment">&lt;!-- 使用CustomNumberEditor转换 --&gt;</span>\n\t\t<span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"age"</span> <span class="hljs-attr">value</span>=<span\n                class="code-string">"20"</span> /&gt;</span>\n\t\t<span class="code-comment">&lt;!-- 使用CustomBooleanEditor转换 --&gt;</span>\n\t\t<span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"license"</span> <span class="hljs-attr">value</span>=<span\n                class="code-string">"1"</span> /&gt;</span>\n\t\t<span class="code-comment">&lt;!-- 使用CustomDateEditor转换 --&gt;</span>\n\t\t<span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"birtday"</span> <span class="hljs-attr">value</span>=<span class="code-string">"1998-12-30"</span> /&gt;</span>\n\t\t<span class="code-comment">&lt;!-- 使用AddressEditor转换 --&gt;</span>\n\t\t<span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"address"</span> <span class="hljs-attr">value</span>=<span class="code-string">"广东,深圳,南山"</span> /&gt;</span>\n\t<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n\t\n\t<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"chkui.springcore.example.hybrid.beanmanipulation.bean.Vehicle"</span>&gt;</span>\n\t\t<span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"name"</span> <span class="hljs-attr">value</span>=<span class="code-string">"Mercedes-Benz C-Class"</span> /&gt;</span>\n\t\t<span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"manufacturer"</span> <span class="hljs-attr">value</span>=<span\n                class="code-string">"Mercedes-Benz"</span> /&gt;</span>\n\t\t<span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"person"</span> <span class="hljs-attr">ref</span>=<span class="code-string">"person"</span> /&gt;</span>\n\t<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>此外，在Spring MVC中，可以SimpleFormController::initBinder方法将外部传入的数据和某个Bean进行绑定：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="code-keyword">final</span> <span\n        class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MyController</span> <span\n        class="code-keyword">extends</span> <span class="code-title">SimpleFormController</span> </span>{\n\n    <span class="code-comment">// 通过任何方式获取PropertyEditorRegistrar</span>\n    <span class="code-meta">@Autowired</span>\n    <span class="code-keyword">private</span> MyPropertyEditorRegistrar editorRegistrar;\n\n    <span class="hljs-function"><span class="code-keyword">protected</span> <span class="code-keyword">void</span> <span\n            class="code-title">initBinder</span><span class="hljs-params">(HttpServletRequest request,\n            ServletRequestDataBinder binder)</span> <span class="code-keyword">throws</span> Exception </span>{\n        <span class="code-comment">// 将Editor与当前Controller进行绑定</span>\n        <span class="code-keyword">this</span>.editorRegistrar.registerCustomEditors(binder);\n    }\n}</code></pre>\n<p>Spring MVC并不属于Sring核心功能范畴，这里就不展开了，需要了解的话看看SimpleFormController的JavaDoc文档即可。</p>\n'},396:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<p>在前面两篇介绍Sring核心与设计模式的文章中，分别介绍了<a title="Ioc容器"\n                                   href="https://www.chkui.com/article/spring/spring_core_design_pattern_and_ioc">Ioc容器</a>和\n    <a title="Bean的依赖关系" href="https://www.chkui.com/article/spring/spring_core_design_pattern_and_ioc">Bean的依赖关系</a>。如果阅读过前2文就会知道，Spring的整个运转机制就是围绕着IoC容器以及Bean展开的。IoC就是一个篮子，所有的Bean都向里面扔。除了提供篮子功能创建并存放Bean之外，IoC还要负责管理Bean与Bean之间的关系——依赖注入。之前也提到Bean是Spring核心容器的最小工作单元，Spring一些更高级的功能（例如切面、代理）都是在Bean的基础上实现。\n</p>\n<p>除了管理Bean与Bean之间的关系，IoC还提供了对Bean自身进行控制的各项功能，本文将介绍Bean的<strong>生命周期功能</strong>以及<strong>状态定义功能。</strong></p>\n\n<h2 id="h2-1">前置依赖</h2>\n<p>\n    Bean与Bean之间存在依赖关系，可以是强依赖（通过XML和注解直接声明依赖）、也可以是弱依赖（ApplicationContextAware等方式获取）。当一个Bean需要另外一个Bean完成初始化后自身才能工作时，例如一个Bean依赖DataSoruce，但是DataSource的初始化需要较长时间。这个时候用<em>depends-on</em>声明前置依赖即可：\n</p>\n<pre><code class="xml"><span class="code-comment">&lt;!-- 依赖多个Bean使用,号分割 --&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"beanOne"</span> <span class="hljs-attr">class</span>=<span class="code-string">"ExampleBean"</span> <span\n        class="hljs-attr">depends-on</span>=<span class="code-string">"manager,accountDao"</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"manager"</span> <span class="hljs-attr">ref</span>=<span\n            class="code-string">"manager"</span> /&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"manager"</span> <span class="hljs-attr">class</span>=<span class="code-string">"ManagerBean"</span> /&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"accountDao"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.jdbc.JdbcAccountDao"</span> /&gt;</span></code></pre>\n\n<h2 id="h2-2">延迟加载</h2>\n<p>通常情况下，所有的&nbsp;<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-singleton"\n        rel="nofollow">singleton</a>&nbsp;类型的Bean都会在容器创建后进行初始化，简单的说就是启动Jvm就开始创建（实际上是创建ApplicationContext的某个实现类实例之后）。</p>\n<p>IoC支持所有的&nbsp;<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-singleton"\n        rel="nofollow">singleton</a>&nbsp;Bean在使用时再加载，这样做的好处是可以大大节省初始化的时间。<span style="color:#e74c3c">但是如果你的应用对启动时间的长短并不敏感，建议让所有的&nbsp;</span><a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-singleton"\n        rel="nofollow"><span style="color:#e74c3c">singleton</span></a><span style="color:#e74c3c">&nbsp;都启动时加载。这样可以在启动时就发现一些问题，而不是在运行很久直到使用时才由用户去触发这个问题</span>。或者可以根据场景来使用决定是否延迟，例如开发时使用延迟加载，而在集成测试或上生产时关闭。\n</p>\n<p>可以设置全局延迟加载，也可以设置某个Bean延迟加载：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span> <span class="hljs-attr">default-lazy-init</span>=<span\n        class="code-string">"true"</span>&gt;</span>\n    <span class="code-comment">&lt;!-- 所有的Bean知道使用的时候才会进行加载... --&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<pre><code class="xml"><span class="code-comment">&lt;!-- 只有lazy类延迟加载 --&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"lazy"</span> <span class="hljs-attr">class</span>=<span class="code-string">"com.foo.ExpensiveToCreateBean"</span> <span\n        class="hljs-attr">lazy-init</span>=<span class="code-string">"true"</span>/&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">name</span>=<span\n        class="code-string">"not.lazy"</span> <span class="hljs-attr">class</span>=<span class="code-string">"com.foo.AnotherBean"</span>/&gt;</span></code></pre>\n<p>需要注意的是，在设置某个单独的Bean延迟加载时，如果有某个没有延迟加载的Bean要依赖他，那实际上也会在初始化的时候就加载。</p>\n<p>还要强调一下，这里的“加载”仅仅是为了表示一个类被Ioc创造并放置容器中，和classLoad方法将class文件中的字节码加载到方法区的加载是两个概念。</p>\n<p>延迟加载在设计模式上是单例模式一种延伸，通常也被称为懒汉模式。单例通常有双重锁+volatile、静态类和枚举三种方式实现。在<a\n        href="http://www.baidu.com/link?url=kGkdnL7l_ll3LfLYL8dxNgxmZdGW-wKRbUh6i8wRu2CERbWLWDBkpLtu38Jg9qTx0-KOIOBr6FXsjRwJigZmxa"\n        target="_blank" rel="nofollow">Effective&nbsp;<em>Java</em></a>一书中对三种模式都有深入的解析。而对于Spring容器而言，枚举的方式肯定不好用了，静态类由于属于自身代码级别应该也不会用，所以双重锁的实现方式较为可信。不过我没去看过源码，仅属于猜测。\n</p>\n\n<h2 id="h2-3">生命周期方法</h2>\n<p>一个Bean的创建、使用再到最后销毁称为"Bean的生命周期"。Spring框架为Bean的生命周期各个阶段提供了多种回掉方法来处理各种状态或者数据。</p>\n\n<h3 id="h3-1">初始化方法</h3>\n<p>\n    当一个Bean完成初始化并注入各项参数之后，初始化回掉方法会被调用，简单的说就是完成创建之后会被调用。实现初始化回调方法有2个路径：1.继承org.springframework.beans.factory.InitializingBean接口，然后实现\n    afterPropertiesSet方法。2.在Bean的XML配置上使用init-method属性来制定要调用的初始化：</p>\n<p>继承实现：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.A"</span> /&gt;</span></code></pre>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">A</span> <span class="code-keyword">implements</span> <span class="code-title">InitializingBean</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">afterPropertiesSet</span><span class="hljs-params">()</span></span>{\n        <span class="code-comment">// init</span>\n    }\n}</code></pre>\n<p>配置实现：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span\n        class="code-string">"x.y.A"</span> <span class="hljs-attr">init-method</span>=<span\n        class="code-string">"init"</span> /&gt;</span></code></pre>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">A</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">init</span><span class="hljs-params">()</span></span>{}\n}</code></pre>\n<p>2种方法都等效，实际使用是我们应该使用哪一种方法呢？</p>\n<p>InitializingBean是Spring早期实现的一个生命周期回调方法。但是在JCP推出JSR-250和<a title="JSR-330"\n                                                             href="https://www.chkui.com/article/java/java_jsr330"\n>JSR-330</a>规范之后，Spring的大神们开始意识到基于元编程思想和配置手段来实现非侵入式框架（Not\n    Coupled）才是正道。所以现在都是推荐使用配置文件和JSR-250的@PostConstruct（关于各种Annotation的使用请关注后续的文章）。现在依然保留InitializingBean应该是考虑到兼容问题。</p>\n\n<h3 id="h3-2">销毁方法</h3>\n<p>与创建方法相对应的是销毁方法。当一个类将要被销毁之前，对应的销毁回调方法会被调用。销毁方法也有一个继承实现和配置+注解实现：</p>\n<p>继承实现：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.A"</span> /&gt;</span></code></pre>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">A</span> <span class="code-keyword">implements</span> <span class="code-title">DisposableBean</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">destroy</span><span class="hljs-params">()</span></span>{\n        <span class="code-comment">// 销毁资源</span>\n    }\n}</code></pre>\n<p>配置实现：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span\n        class="code-string">"x.y.A"</span> <span class="hljs-attr">destroy-method</span>=<span class="code-string">"cleanUp"</span> /&gt;</span></code></pre>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">A</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">cleanUp</span><span class="hljs-params">()</span></span>{\n        <span class="code-comment">// 销毁资源</span>\n    }\n}</code></pre>\n<p>依然建议销毁手段也使用配置或@PreDestroy来设定销毁方法。</p>\n\n<h3 id="h3-3">全局配置初始化与销毁方法</h3>\n<p>IoC容器还提供了全局配置初始化与销毁方法的配置：</p>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">A</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">init</span><span class="hljs-params">()</span></span>{\n        <span class="code-comment">// 初始化资源</span>\n    }\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">destroy</span><span class="hljs-params">()</span></span>{\n        <span class="code-comment">// 销毁资源</span>\n    }\n}</code></pre>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span> <span class="hljs-attr">default-init-method</span>=<span\n        class="code-string">"init"</span> <span class="hljs-attr">default-destroy-method</span>=<span\n        class="code-string">"destroy"</span>&gt;</span>\n     <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n             class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span\n             class="code-string">"x.y.A"</span>/&gt;</span>\n     <span class="code-comment">&lt;!-- bean configuration --&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>通过在&lt;beans&gt;标签上使用<em>default-init-method</em>和<em>default-destroy-method</em>&nbsp;属性参数，可以为容器中所有的Bean统一指定初始化和销毁的生命周期方法。\n</p>\n<p>如果在&lt;beans&gt;上设定2个默认的生命周期方法，同时在&lt;bean&gt;上也指定了<em>init-method</em>或<em>destroy-method，</em>回调方法会以&lt;bean&gt;上的配置为准。这样就保证全局配置与单独配置可以共存。\n</p>\n<p>使用初始化或销毁2个生命周期方法注意的要点：</p>\n<ol>\n    <li>\n        初始化和销毁都提供了3种手段：XML配置、注解、以及实现接口。系统的各个部分会交由不同的团队开发，不遵循统一的规范，建议使用满足JSR规范的注解——@PostConstruct、@PreDestroy。如果是统一的团队，准训一致的规范，建议使用&lt;beans&gt;的属性统一名称使用全局配置。\n    </li>\n    <li>如果Bean设计到代理模式时（例如使用了AOP），那么生命周期方法被调用时，有可能代理类还没有被创建出来。因为生命周期方法是实体类完成对应工作之后就会被调用，而与代理类无关。</li>\n</ol>'},397:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<p>前面3篇分别介绍了<a href="https://www.chkui.com/article/spring/spring_core_design_pattern_and_ioc" title="IoC容器与Bean的关系">IoC容器与Bean的关系</a>、<a\n        href="https://www.chkui.com/article/spring/spring_core_dependency_injection_of_bean" title="Bean与Bean之间的关系">Bean与Bean之间的关系</a>以及<a\n        href="https://www.chkui.com/article/spring/spring_core_bean_lifecycle_callback" title="Bean自身的控制和管理">Bean自身的控制和管理</a>。在了解Spinrg核心模式时，一定要谨记他的基本工作元素就是IoC容器和Bean，所有的功能是围绕着这2者展开的。要实现的内容无非就是通过设计模式来解决<strong>IoC与Bean的关系</strong>、<strong>Bean与Bean的关系</strong>、<strong>IoC与IoC的关系，</strong>以及对Ioc和Bean的控制<strong>。</strong>\n</p>\n\n<h2 id="h2-1">IoC控制入口</h2>\n<p>看完整个<em>Spring Core</em>的<em>API\n    Doc</em>，你也不会发现任何一个名为<em>IoC</em>的类或者接口。唯一一个提到<em>IoC</em>这个词的是<strong>spring-beans</strong>工程下关于<em>org.springframework.beans.factory</em>这个包的介绍——"<em>The\n    core package implementing Spring\'s lightweight Inversion of Control (IoC)\n    container.</em>"。实际上<em>Spring</em>核心框架将对<em>IoC</em>容器的控制都交给了<em>BeanFactory</em>和<em>ApplicationContext</em>两个接口。\n</p>\n<p>这个2个接口有什么关系吗？一个叫<em>Factory</em>，一个叫<em>Context</em>，概念上完全是两码事，前者是创建模式的FLAG，后者是行为模式的FLAG。并且在工程结构上，一个属于spring-beans，另外一个属于spring-context。不过仔细看会发现<em>ApplicationContext</em>继承自<em>BeanFactory</em>的派生接口<em>（</em>\n    ListableBeanFactory、HierarchicalBeanFactory <em>）。</em>要想理解他们的关系和作用，还得一个一个来说。</p>\n\n<h2 id="h2-2">factory包中的接口</h2>\n<p>\n    在Spring核心工程中，BeanFactory及其派生被定义为“Ioc容器的轻量级实现”。这也是Spring最基础的IoC容器和Bean的管理接口。factory包中主要涉及5个接口BeanFactory、ListableBeanFactory、HierarchicalBeanFactory、ConfigurableBeanFactory和ConfigurableListableBeanFactory<strong>。</strong>初来咋到看到这5个接口八成懵逼，少数牛逼的码友估计能从名字猜测出他们的功能。其实他们有很清晰的层次结构，一层继承一层，一层扩展一层的功能。\n</p>\n<p style="text-align:center"><img alt="Spring核心——上下文与IoC" height="300"\n                                  src="https://oscimg.oschina.net/oscnet/c5634f6073bb56eae08c276f589ba14dcbb.jpg"\n                                  width="469"></p>\n<p style="text-align:center">（图片来源于他人博客，如有侵权请告知)</p>\n<p><strong>BeanFactory</strong>是IoC容器最基本的功能，他就是前面文章中一直提到的IoC设计模式的具体实现——处理IoC与Bean，Bean与Bean的关系。可以理解BeanFactory自身就是一个IoC容器，然后提供了getter、is、contains接口来获取和判断Bean的状态。对于单例或多例，BeanFactory只提供了BeanFactory::isSingleton和BeanFactory::isPrototype2个方法，这也是为什么我在<a\n        href="https://www.chkui.com/article/spring/spring_core_design_pattern_and_ioc">设计模式与IoC</a>一文中会说从设计模式的角度来说，Bean除了工厂方法外，只涉及<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-singleton"\n        rel="nofollow">singleton</a>和<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-prototype"\n        rel="nofollow">prototype</a>2个创建模式。</p>\n<p><strong>ListableBeanFactory</strong>继承自<strong>BeanFactory</strong>接口。看方法会发现，BeanFactory只提供单个Bean的操作，而ListableBeanFactory都是支持列表操作，比如获取Bean的总数、获取Bean的name列表、通过Bean的Type获取Bean的列表、根据注解获取Bean的列表等。从字面上的Listable也可以看出来其是在基本Factory的基础上扩展了相同类型、相同名称Bean的功能。\n</p>\n<p><strong>HierarchicalBeanFactory</strong>从字面上就应该大概知道他的作用的解决层级问题，提供子父容器的管理方法。</p>\n<p>再往下就是<strong>ConfigurableListableBeanFactory</strong>接口，这个接口提供的IoC控制功能，从子字面<strong>Configurable</strong>来看意思就是可以配置的。顶层的几个接口（<strong>BeanFactory、ListableBeanFactory</strong>）都没提供Setter或Creater的功能，而<strong>ConfigurableListableBeanFactory</strong>集成的3个接口ListableBeanFactory、AutowireCapableBeanFactor、ConfigurableBeanFactory提供了Setter、Creater的功能。实际上<strong>ConfigurableListableBeanFactory</strong>就是提供了Beans的“增改”功能，以及一些附加的依赖控制。\n</p>\n<p>网上关于<em><strong>BeanFactory</strong></em>及其派生结构介绍的资料很多，大部分都是从源码的角度详细说明他们之间的依存关系。不过从使用者的角度，实际上从总体上去了解他的组合模式思路，比你一个一个的去看源码有意义得多，更何况就算你现在看了源码，一年不碰你还能记得？总不能天天还复习吧？看源码主要是要理解作者针对实现所用设计模式。当然你要是要参加什么面试的话，还真得复习复习。记得以前我作为面试官曾叫别人当场写出ConfigurableListableBeanFactory的继承关系。现在想想当时自己有多脑残，被面试的那些小哥估计想拍我吧？开发能力的好坏是一种思维方式，而不是谁记得2个\n    new String("A")到底创建了几个String实例，或者Integer的0到128会被预设。</p>\n<p>实际上进经过多年的发展，Spring Core\n    的BeanFactory这块已经发生了多次改变。从最基础的BeanFactory到ConfigurableListableBeanFactory层层向下推进全是接口或抽象类，每一个接口都在父接口的基础上包装了的新的接口方法。通过多层继承，官方的代码中只有一个名为DefaultListableBeanFactory的类将所有的接口功能都实现了，然后XmlFactory又继承实现了资源读写的功能。XmlFactory并没有多少代码，Ioc的核心功能都在DefaultListableBeanFactory。</p>\n<p>从设计模式上来说，很难去定义这么多接口派生但是一个实现类提供所有功能的模式到底算什么。我个人认为这很像外观模式（Facade&nbsp;Pattern）和装饰模式（Decorator\n    Pattern）结合。现实中我们没也没必要像教科书似的模式来理解应用。下面解释这个思路。</p>\n<p>首先我们来看看效果。</p>\n<p>例如现在你用BeanFactory来“装载”ConfigurableListableBeanFactory的实例：</p>\n<pre><code class="java">BeanFactory ioc = <span\n        class="code-keyword">new</span> ConfigurableListableBeanFactory();</code></pre>\n<p>\n    这个时候对你来说，这个BeanFactory就是一个装饰器或外观，如果BeanFactory接口不发生改变，你所能用的功能仅仅是BeanFactory提供的几个接口方法。即使可能有人在之后的任何时间修改增加了ConfigurableListableBeanFactory的方法。此时尽管ConfigurableListableBeanFactory这个实现类的本质发生了改变，但是对于BeanFactory的使用位置来说一切照旧，他通过&nbsp;BeanFactory这个外观装饰接口看到的效果和之前一模一样。&nbsp;而扩展了接口之后的实现类，新的代码可以用新的接口。例如：</p>\n<pre><code class="java">ConfigurableListableBeanFactory ioc = <span class="code-keyword">new</span> ConfigurableListableBeanFactory();</code></pre>\n<p>然后我们还可以继续向下扩展接口和功能。</p>\n<p>如果你看过源码，你会发现spring\n    beans的BeanFactory代码最早的编写时间停留在2001年4月13号，距今已经很长的历史了。相信之后肯定不断演进扩展了大量的功能。而通过接口派生的实现外观的方式，让古老的代码和后续的新功能友好的共存。对于我们自己的设计系统或实现“代码级别的迭代”这是一个极好的例子——仅维护一个实现，通过增加外观或装饰器来演进功能，使用者一直都是看到的外观。虽然这样做似乎会违背类的单一职责的原则。</p>\n<p>在接下来介绍ApplicationContext之前先要说明，我们现在创建一个Spring应该不使用任何BeanFactory相关的接口了，关于这一点<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#context-introduction-ctx-vs-beanfactory"\n        rel="nofollow">官方文档</a>有明确的说明。除了在少数对内存大小有严苛要求的受限制的设备上进行嵌入式开发，其他时候都应该使用ApplicationContext。ApplicationContext实现了BeanFactory的所有功能，并对应用开发提供了很多有用的扩展。BeanFactory现在存在的主要作用是为一些历史第三方库提供支持，现在对于大多数使用Spring的用户来说他是一个历史性的接口。\n</p>\n\n<h2 id="h2-3">ApplicationContext</h2>\n<p>\n    不知道别人在学习编程开发的早年看到Context这个词是什么感觉，反正我是蒙逼了很久。也不知道这词最早是哪位哥翻译的，译成“上下文”?!英文里con-前缀表示聚集、集合吗，context的字面意思明明就是一堆数据的集合吧。其实码界类似让人翻译的翻译还真不少，handle=句柄（deal\n    with，处理器）、socket=套接字（就使用原意插座还好理解）。更狠的是Robustness，真不知道在哪年是哪位大爷出于什么原因把他翻成“鲁棒性”的。</p>\n<p>\n    回到正题，我真正理解Context是在开始了解设计模式之后。在设计模式中Context的概念出现在“策略模式”，该模式的标准解释是执行一个方法会根据当前的状态和对象执行不同的“策略”，“策略”因为实现类的性质不同而发生改变。实际上就是用一个Context对“策略”进行包装，而“策略”可以根据需要调整（细节请度娘）。我直接用Spring的ApplicationContext来说明。</p>\n<p style="text-align: center;"><img alt="Spring核心——上下文与IoC" height="400"\n                                    src="https://oscimg.oschina.net/oscnet/2eb09f38d1ad275a1297fd165e6bd07fb4c.jpg"\n                                    width="464"></p>\n<p style="text-align: center;">(图片来源于网络，如有侵权请告知)</p>\n<p>\n    ApplictionContext的继承思路和BeanFactory类似，就不再介绍了。在核心包中，Spring提供的ApplicationContext实现类目前有FileSystemXmlApplication和ClassPathXmlApplicationContext（Web包里还有Web环境专用的ApplicationContext）。</p>\n<p>\n    FileSystemXmlApplication和ClassPathXmlApplicationContext分别代表了2个不同的“策略”，在我们使用的时候在创建ApplicationContext时确定，并且在运行时也可以调整。</p>\n<pre><code class="java"><span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">App</span> <span class="code-keyword">implements</span> <span class="code-title">ApplicationContextAware</span></span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span\n            class="hljs-params">()</span> </span>{\n        <span class="code-comment">// 初始化为策略1</span>\n\t\tApplicationContext springContext = <span class="code-keyword">new</span> ClassPathXmlApplicationContext(<span\n            class="code-string">"myXml.xml"</span>);\n        <span class="code-comment">// 使用策略1的方法，使用者不用知道实现细节</span>\n        System.out.println(springContext.getApplicationName());\n\n        <span class="code-comment">// 修改为策略2</span>\n        springContext = <span class="code-keyword">new</span> FileSystemXmlApplicationContext(<span class="code-string">"/myProject/myXml.xml"</span>);\n        <span class="code-comment">// 使用策略2的方法，使用者不用知道实现细节</span>\n        System.out.println(springContext.getApplicationName());\n\t}\n}</code></pre>\n<p>如上面的代码，我们可以根据我们需要指定不同的“策略”。ClassPath和FIleSystem两个类功能都差不多，最大的区别就是加载文件路径的差异——一个从当前工作目录、一个从整个磁盘路径。理论上策略模式还有一个&nbsp;<em>Strategy</em>接口来包装策略，Spring直接将<em>Context</em>设定为一个接口，然后通过不同的实现类整合到了一起。从实现上来看策略模式并没有什么太神奇的东西，实际上还是一个接口多个实现类。那么看到这里你肯定已经忍不住要吼了：这到底有什么用？不就是创建一个实例给一个接口吗？\n</p>\n<p>实际上策略模式和Context是针对分层应用而设计的，很多设计模式的资料只会说模式是什么，但是不会提到模式的来源和立意。我所知道在设计模式中Context的最早概念是来源是来自这篇论文——<a\n        href="https://www.cse.wustl.edu/~schmidt/PDF/Context-Object-Pattern.pdf" rel="nofollow">Context Object A Design\n    Pattern for Efficient Information Sharing across Multiple System Layers</a>（直译为《上下文对象——多层系统的高效信息共享的设计模式》），它大致的结论是在分层应用系统中（例如MVC——view-controller-service-dao）层之间传递（共享）数据时，将相同适用范围和生命周期的所有数据组合到一个Context中去传递可以大大的提升分层之后开发效率——大概就是反正我所有东西都往里面放，你用得着就用，用不着就算，也不用来和我商量要什么了。\n</p>\n<p><span style="color:#e74c3c">所以Context实际上就是按照适用范围（Scope）而不是应用功能（functionality</span><span style="color:#e74c3c">）划分的一个数据对象。</span><span\n        > 这样在层与层之间传递数据的时候，无论有多少个接口都传递同一个的Context。</span></p>\n<p style="text-align: center;"><span><img alt="Spring核心——上下文与IoC" height="500"\n                                                             src="https://oscimg.oschina.net/oscnet/b54ba49ded2c3d92ef130edfc418a4a81ac.jpg"\n                                                             width="331"></span></p>\n<p>\n    例如Spring全局应用就是ApplicatonContext，把IoC和其他全局操作方法的丢到这个Context中。所以最后我们看到除了IoC的Bean控制接口（BeanFactory）外，他还提供资源控制接口（ResourcePatternResolver）、国际化接口（MessageSource）&nbsp;、事件发布管理接口（ApplicationEventPublisher）。这些功能并没有直接的联系，但是他们的适用范围都是Applicaton级别的，所以都被整合到了ApplicatonContext中。</p>\n<p>再例如在WebApplicationContext中，一次请求相关的所有资源以及相关的接口都会整合RequestContext中，RequestContext用于Servlet到我们自定义的Controller层传递数据。</p>\n<p>ApplicationContext继承了BeanFactory，其核心功能还是管理IoC以及Bean。前面也提到ApplicationContext还扩展了许多功能。下图来自于官方，表现了2者的功能差异。</p>\n<table>\n    <tbody>\n    <tr>\n        <th>Feature</th>\n        <th><code>BeanFactory</code></th>\n        <th><code>ApplicationContext</code></th>\n    </tr>\n    </tbody>\n    <tbody>\n    <tr>\n        <td><p>Bean 初始化与设定</p></td>\n        <td><p>Yes</p></td>\n        <td><p>Yes</p></td>\n    </tr>\n    <tr>\n        <td><code>BeanPostProcessor注册</code></td>\n        <td><p>No</p></td>\n        <td><p>Yes</p></td>\n    </tr>\n    <tr>\n        <td><code>BeanFactoryPostProcessor注册</code></td>\n        <td><p>No</p></td>\n        <td><p>Yes</p></td>\n    </tr>\n    <tr>\n        <td><p>国际化支持</p></td>\n        <td><p>No</p></td>\n        <td><p>Yes</p></td>\n    </tr>\n    <tr>\n        <td><p><span style="font-size:13px">事件发布与注册</span></p></td>\n        <td><p>No</p></td>\n        <td><p>Yes</p></td>\n    </tr>\n    </tbody>\n</table>\n<p>后续的文章会继续展开介绍这些功能以及背后设计模式的含义。</p>'}});