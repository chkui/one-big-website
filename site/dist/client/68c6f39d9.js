webpackJsonp([6],{350:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<h2 id="h2-1">Niubility的Nodejs &nbsp;&nbsp;</h2>\n<p>关于大名鼎鼎的Nodejs是什么就不用再介绍了，他的牛逼之处数都数不完——让javascript称霸全宇宙、将一个只用于前端的编程语言同时可以制霸前后端、让致力于前端开发的小哥又多了一项事业新增了一门手艺、亮瞎人的全异步事件驱动型架构（event-driven、non-blocking、scalability）。总的来说就是，学好Nodejs必须能够赚大钱迎娶白富美。</p>\n<p>本人一直垂涎与Nodejs的鼎鼎大名，但是由于工作繁忙，一直没时间深入亵玩。最近因为一些机缘，又要着手一些前端开发的工作才觅得一次全面接触的良机。</p>\n<p>看到这里你肯定要说，又是一个要把Nodejs吹上天的文章！NoNo，本文会一步一步的说明我是怎么学会和用上nodejs的，然后结合其我所了解的语言告诉各位我所了解的Nodejs坑和优势。</p>\n\n<h2 id="h2-2">学习基础</h2>\n<p>先说说本人开始学习使用的基础。早期在某外企开发室内3D设计软件，那段时间用已经成为古董的MFC做各种windows事件驱动开发。</p>\n<p>之后就一直在做Java生态的东西、反正就是SSH啦、MVC啦、Dao啦、Entity啦、JNDI啦、JDBC啦等等，相信每个Javaer都懂的。早些年做Java时，前端部分基本就是玩转Jsp，页面清一色的用Jsp动态生成，然后丢给浏览器。现在所属团队几乎已经放弃这种方式，都是用spring-boot等弄前后端分离了。</p>\n<p>随后有幸接到一个自己可以全权负责的全新的项目，于是带着2个人开始尝试抛弃JSP，引入了大量的ajax异步请求的客户端组装数据。那时候这样做其实蛮痛苦的，新项目根本没有真正意义的前端开发人员（都玩JSP呢），所以自己不得不去研究前端的各种前端技术。在随后的许多时光中，深入且大量的学习了前端开发的所有东西，从一穷二白只会用div画画静态页面，到后面自己封装列表、消息通知等组件，通杀jquery、angularjs，了解各种脚手架。所以学习Nodejs开发，我基本上是没有语言障碍的，只是需要跟上它的思路。</p>\n\n<h2 id="h2-3">安装Nodejs</h2>\n<p>要用一样东西之前，当然是要先安装环境。Nodejs的安装网上一搜一大把，这里就简单记录一下流程，方面以后查阅。因为本人用一台windows（windows10）办公、用一台linux（ubuntu16.04）开发，所以2个操作系统都安装了Nodejs，像OSX这样高大上的玩意，暂时没机器去弄（穷）。</p>\n\n<h3 id="h3-1">windows</h3>\n<ol>\n    <li>先去官网（https://nodejs.org或https://nodejs.org/en/download/）下载一个安装包，我下的是长期稳定版。建议下载.msi。</li>\n    <li>然后就是安装了，这没什么好说的。无非就是设定一下安装目录，然后一通Next。</li>\n    <li>安装好之后检查下环境变量，看看path下添加入了Nodejs的运行路径。cmd中输入path可以看到添加了nodejs的安装目录。然后输入node --version可以看到当前的Nodejs版本号。如下图：&nbsp;&nbsp;&nbsp;&nbsp;<img alt="安装NodeJs运行环境" height="175" src="https://file.mahoooo.com/res/file/install_nodejs_runtime_environment_1.png" width="527"></li>\n    <li>Nodejs自带npm，npm和其他未来要使用的组件都存放在“X:\\yourpath\\nodejs\\node_modules”里。所以需要在windows环境变量重增加一个NODE_PATH=X:\\yourpath\\nodejs\\node_modules的参数，保证未来新增的一些模块工具可以正常使用。右键“我的电脑”-&gt;高级系统设置-&gt;环境变量-&gt;然后新建以上参数。</li>\n    <li>再然后就是最后一步了，设置node_cache（用于npm存放一些临时文件）和node_global（全局工具文件夹），当然这里也可以不设置，他会自动放在当前用户的文件夹下，但是有强迫症的我必须要设置。在cmd中输入一下命令：</li>\n</ol>\n<pre class="sql"><code class="language-bash">npm config <span class="code-built_in"><span class="code-keyword">set</span></span> prefix <span class="code-string"><span class="code-string">\'X:\\yourpath\\nodejs\\node-global\'</span></span>\n\nnpm config <span class="code-built_in"><span class="code-keyword">set</span></span> <span class="code-keyword">cache</span> <span class="code-string"><span class="code-string">\'X:\\yourpath\\nodejs\\node_cache\'</span></span></code></pre>\n\n<h3 id="h3-2">linux</h3>\n<p>linux安装和windows安装Nodejs差不多，都是下载包、解压、开用。</p>\n<ol>\n    <li>先去官网下载一个linux版本的安装包（下首页的那个就行）。下载以后发现是 xz后缀，先得用xz命令解压成tar，再用tar完成解压。</li>\n    <li>添加Nodejs运行环境：直接把node的运行目录添加到&amp;PATH里。在profile中添加Node的运行环境： <pre class="bash"><code class="language-bash"><span class="code-comment"><span class="code-comment">#node</span></span>\n<span class="code-built_in"><span class="code-built_in">export</span></span> NODE_HOME=/yourpath/node-v4.5.0-linux-x64\n<span class="code-built_in"><span class="code-built_in">export</span></span> PATH=<span class="code-variable"><span class="code-variable">$NODE_HOME</span></span>/bin:<span class="code-variable"><span class="code-variable">$PATH</span></span></code></pre> <p>然后再任意位置测试了一下运行node命令都可以正常使用。</p> </li>\n    <li> <p>然后我们需要添加node_modules到PATH中，保证npm可以使用：</p> <pre class="bash"><code class="language-apache"><span class="code-comment">#npm</span>\n<span class="code-built_in">export</span> NODE_PATH=<span class="code-variable">$NODE_HOME</span>/node_modules\n</code></pre> <p>配置完之后，就可以使用npm命令了。（修改之后切记注销用户）</p> </li>\n</ol>\n<p>完成以上步奏之后，就可以用node和npm命令干你相干的事了。安装之前按看到很多教程说是要安装python2.2到2.7的版本。但是我解压完nodejs包后在bin下运行了node -v命令居然可以跑，我就没去管python的事，应该是我用的是打包版的原因。</p>\n\n<h3 id="h3-3">Apt安装Nodejs</h3>\n<p>1.设定Nodejs安装源：</p>\n<pre class="nginx"><code class="language-bash"><span class="code-attribute">curl</span> <span class="hljs-_">-s</span>L https://deb.nodesource.com/setup_8.x | sudo -E bash -</code></pre>\n<p>2.安装Nodejs</p>\n<pre class="actionscript"><code class="language-bash">sudo apt-<span class="code-keyword">get</span> install -y nodejs</code></pre>\n\n<h3 id="h3-4">验证安装结果</h3>\n<p>安装完成之后，我在windows和linux都测试了一下。</p>\n<p>测试nodejs：输入node打开REPL，然后使用log打印数据：</p>\n<pre class="javascript"><code class="language-bash">$ node\n&gt; <span class="code-built_in">console</span>.log(<span class="code-string"><span class="code-string">"hello nodejs!"</span></span>);\nhello nodejs!\n<span class="hljs-literal">undefined</span></code></pre>\n<p>然后用npm测试安装grunt-cli：</p>\n<pre class="groovy"><code class="language-bash">$ npm install -g grunt-cli\n<span class="hljs-regexp">/yourpath/</span>node-v4<span class="hljs-number">.5</span><span class="hljs-number">.0</span>-linux-x64<span class="hljs-regexp">/node_global/</span>bin<span class="hljs-regexp">/grunt -&gt; /</span>yourpath<span class="hljs-regexp">/node-v4.5.0-linux-x64/</span>node_global<span class="hljs-regexp">/lib/</span>node_modules<span class="hljs-regexp">/grunt-cli/</span>bin/grunt\ngrunt-cli@<span class="hljs-number">1.2</span><span class="hljs-number">.0</span> <span class="hljs-regexp">/me/</span>soft<span class="hljs-regexp">/node/</span>node-v4<span class="hljs-number">.5</span><span class="hljs-number">.0</span>-linux-x64<span class="hljs-regexp">/node_global/</span>lib<span class="hljs-regexp">/node_modules/</span>grunt-cli\n├── grunt-known-options@<span class="hljs-number">1.1</span><span class="hljs-number">.0</span>\n├── resolve@<span class="hljs-number">1.1</span><span class="hljs-number">.7</span>\n├── nopt@<span class="hljs-number">3.0</span><span class="hljs-number">.6</span> (abbrev@<span class="hljs-number">1.0</span><span class="hljs-number">.9</span>)\n└── findup-sync@<span class="hljs-number">0.3</span><span class="hljs-number">.0</span> (glob@<span class="hljs-number">5.0</span><span class="hljs-number">.15</span>)</code></pre>\n\n<h3 id="h3-5">运行一个Nodejs程序</h3>\n<p>安装好之后，node的命令行和npm的命令行就都可以使用了，随后当然就是要跑跑Nodejs了。像下面这样创建一个创建一个example.js文件，随便放在某个文件：</p>\n<pre class="javascript"><code class="language-javascript"><span class="code-keyword"><span class="code-keyword">const</span></span> http = <span class="code-built_in"><span class="code-built_in">require</span></span>(<span class="code-string"><span class="code-string">\'http\'</span></span>);\n\n<span class="code-keyword"><span class="code-keyword">const</span></span> hostname = <span class="code-string"><span class="code-string">\'127.0.0.1\'</span></span>;\n<span class="code-keyword"><span class="code-keyword">const</span></span> port = <span class="hljs-number"><span class="hljs-number">3000</span></span>;\n\n<span class="code-keyword"><span class="code-keyword">const</span></span> server = http.createServer((req, res) -&gt; {\n  res.statusCode = <span class="hljs-number"><span class="hljs-number">200</span></span>;\n  res.setHeader(<span class="code-string"><span class="code-string">\'Content-Type\'</span></span>, <span class="code-string"><span class="code-string">\'text/plain\'</span></span>);\n  res.end(<span class="code-string"><span class="code-string">\'Hello World Nodejs\\n\'</span></span>);\n});\n\nserver.listen(port, hostname, () =&gt; {\n  <span class="code-built_in"><span class="code-built_in">console</span></span>.log(<span class="code-string"><span class="code-string">`Server running at http://</span><span class="hljs-subst"><span class="code-string"><span class="hljs-subst">${hostname}</span></span></span><span class="code-string">:</span><span class="hljs-subst"><span class="code-string"><span class="hljs-subst">${port}</span></span></span><span class="code-string">/`</span></span>);\n});</code></pre>\n<p>然后在当前文件下打开一个cmd运行以下命令：</p>\n<pre class="css"><code class="language-bash"><span class="code-selector-tag">node</span> <span class="code-selector-tag">example</span><span class="code-selector-class">.js</span></code></pre>\n<p>可以看到输出：</p>\n<pre class="php"><code class="language-bash"><span class="code-variable">$node</span> example.js\n\nServer running at http:<span class="code-comment">//127.0.0.1:3000</span></code></pre>\n'},355:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<h2 id="h2-1">Web组件</h2>\n<p>从概念上说，React 和 <a title="Web组件" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components" rel="nofollow">Web组件</a>&nbsp;分别用于解决不同的问题。Web组件提供了强大的封装特性来支持其可重复使用性，而React提供了一系列声明性（declarative）接口保证Dom结构和数据同步。但是某些时候这2个目标是互补的。对于开发人员来说将React用于Web组件、或将Web组件用于React、或2者皆有并非难事。\n</p>\n<p>虽然大部分使用React的开发人员并不需要使用Web组件，但是在某些情况，特别是引入了某些第三方库，还是需要使用到相关机制。</p>\n\n<h3 id="h3-1">在React中使用Web组件</h3>\n<pre class="scala"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span\n        class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span\n        class="code-title"><span class="hljs-class"><span class="code-title">HelloMessage</span></span></span><span\n        class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="xml"><span class="code-tag">&lt;<span\n            class="code-name">div</span>&gt;</span><span class="code-type">Hello</span> <span class="code-tag">&lt;<span\n            class="code-name">x-search</span>&gt;</span>{<span class="code-keyword">this</span>.props.name}<span\n            class="code-tag">&lt;/<span class="code-name">x-search</span>&gt;</span>!<span class="code-tag">&lt;/<span\n            class="code-name">div</span>&gt;</span>;\n  }\n}</span></code></pre>\n<blockquote>\n    <p>Web组件常会暴露一些必要的API接口，例如一个 video Web组件可能会暴露&nbsp;&nbsp;<code>play()</code>&nbsp;和&nbsp;<code>pause()</code>&nbsp;方法。为了获取Web组件暴露的这些API接口，需要在React编码使用Refs特性来直接获取真实的Dom节点。如果引入第三方的Web组件，最好的解决方案使用一个React组件来包装引入的Web组件并最终作为一个React组件来使用。\n    </p>\n    <p>由第三方Web组件触发的事件也许并不能通过React的渲染树传递，此时需要在组件中去手工的触发事件。&nbsp;</p>\n</blockquote>\n<p>一个经常导致混乱的地方是，Web组件使用的是“class”而React使用的是“className”，例如：</p>\n<pre class="javascript"><code class="language-javascript"><span class="hljs-function"><span class="code-keyword"><span\n        class="hljs-function"><span class="code-keyword">function</span></span></span><span\n        class="hljs-function"> </span><span class="code-title"><span class="hljs-function"><span class="code-title">BrickFlipbox</span></span></span><span\n        class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span\n        class="hljs-params"></span>) </span></span>{\n  <span class="code-keyword"><span class="code-keyword">return</span></span> (\n    <span class="xml"><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span\n            class="code-name">brick-flipbox</span></span></span></span><span class="xml"><span class="code-tag"> </span></span><span\n            class="hljs-attr"><span class="xml"><span class="code-tag"><span\n            class="hljs-attr">class</span></span></span></span><span class="xml"><span\n            class="code-tag">=</span></span><span class="code-string"><span class="xml"><span class="code-tag"><span\n            class="code-string">"demo"</span></span></span></span><span class="xml"><span\n            class="code-tag">&gt;</span></span></span><span class="xml">\n      </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">div</span></span></span></span><span\n            class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">front</span><span\n            class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span\n            class="xml"><span class="code-tag"><span class="code-name">div</span></span></span></span><span class="xml"><span\n            class="code-tag">&gt;</span></span></span><span class="xml">\n      </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">div</span></span></span></span><span\n            class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">back</span><span\n            class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span\n            class="xml"><span class="code-tag"><span class="code-name">div</span></span></span></span><span class="xml"><span\n            class="code-tag">&gt;</span></span></span><span class="xml">\n    </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span\n            class="code-name">brick-flipbox</span></span></span></span><span class="xml"><span\n            class="code-tag">&gt;</span></span></span><span class="xml">\n  );\n}</span></span></code></pre>\n\n<h3 id="h3-2">在Web组件中使用React</h3>\n<pre class="javascript"><code class="language-javascript"><span class="code-keyword"><span\n        class="code-keyword">const</span></span> proto = <span class="code-built_in"><span\n        class="code-built_in">Object</span></span>.create(HTMLElement.prototype, {\n  attachedCallback: {\n    value: <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">function</span></span></span><span class="hljs-function">(</span><span\n            class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{\n      <span class="code-keyword"><span class="code-keyword">const</span></span> mountPoint = <span\n            class="code-built_in"><span class="code-built_in">document</span></span>.createElement(<span\n            class="code-string"><span class="code-string">\'span\'</span></span>);\n      <span class="code-keyword"><span class="code-keyword">this</span></span>.createShadowRoot().appendChild(mountPoint);\n\n      <span class="code-keyword"><span class="code-keyword">const</span></span> name = <span class="code-keyword"><span\n            class="code-keyword">this</span></span>.getAttribute(<span class="code-string"><span class="code-string">\'name\'</span></span>);\n      <span class="code-keyword"><span class="code-keyword">const</span></span> url = <span class="code-string"><span\n            class="code-string">\'https://www.google.com/search?q=\'</span></span> + <span class="code-built_in"><span\n            class="code-built_in">encodeURIComponent</span></span>(name);\n      ReactDOM.render(<span class="xml"><span class="code-tag"><span class="xml"><span\n            class="code-tag">&lt;</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span\n            class="code-name">a</span></span></span></span><span class="xml"><span class="code-tag"> </span></span><span\n            class="hljs-attr"><span class="xml"><span class="code-tag"><span class="hljs-attr">href</span></span></span></span><span\n            class="xml"><span class="code-tag">=</span></span><span class="code-string"><span class="xml"><span\n            class="code-tag"><span class="code-string">{url}</span></span></span></span><span class="xml"><span\n            class="code-tag">&gt;</span></span></span><span class="xml">{name}</span><span class="code-tag"><span\n            class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span class="xml"><span\n            class="code-tag"><span class="code-name">a</span></span></span></span><span class="xml"><span\n            class="code-tag">&gt;</span></span></span></span>, mountPoint);\n    }\n  }\n});\n<span class="code-built_in"><span class="code-built_in">document</span></span>.registerElement(<span\n            class="code-string"><span class="code-string">\'x-search\'</span></span>, {prototype: proto});</code></pre>\n\n<h3 id="h3-3">React整合Jquery这一类直接操作Dom的技术</h3>\n<p>\n    React在发生真实Dom渲染之前都会先产生与之对应的虚拟Dom结构，然后再“合适”的时候将虚拟Dom的内容渲染到真实Dom上，完成渲染之后componentDidMount会被调用。Jquery这一类真实Dom的操作技术投入实际使用时最好在componentDidMount中使用，然后保证这个组件不会的虚拟Dom不发生任何改变。</p>'},356:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<h2 id="h2-1">高阶组件</h2>\n<p>高阶组件（higher-order components：以下简称HOC或HOC组件）是一个React组件复用的高级技巧。HOCs本身并不是React的API接口，他是React组件之间组织方式的一种模式。</p>\n<p>具体来说，一个HOC组件是一个返回另外一个新组件的方法，如下面的代码：</p>\n<pre class="lisp"><code class="language-javascript"><span class="code-keyword">const</span> EnhancedComponent = higherOrderComponent(<span\n        class="code-name">WrappedComponent</span>)<span class="code-comment">;</span></code></pre>\n<p>常规的React组件都是将传入的props值转换成一个UI返回，而高阶组件是将一个组件转换成另外一个组件。HOCs通常以第三方React组件库的方式呈现，比如Redux的 <a\n        href="https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options"\n        rel="nofollow">connect </a>和&nbsp;Relay的&nbsp;<a\n        href="https://facebook.github.io/relay/docs/api-reference-relay.html#createcontainer-static-method"\n        rel="nofollow">createContainer</a>。</p>\n<p>本文会讨论为什么HOCs非常有用，并且介绍如何开发自定义的HOCs。</p>\n\n<h4 id="h4-1">HOCs用于组件代码共用</h4>\n<blockquote>\n    <p>在前面的文章中已经介绍了“混合器”，他也是组件代码共用的一种方式，但是到目前为止“混合器”在使用中遇到很多问题，并且官方已经不再推荐使用它。可以阅读这篇文章（<a\n            href="https://facebook.github.io/react/blog/2016/07/13/mixins-considered-harmful.html" rel="nofollow">Mixins\n        Considered Harmful</a>）了解为什么官方已经不再推荐使用“混合器”以及将代码转换成其他模式的方式。</p>\n</blockquote>\n<p>组件是React中代码重用的主要单元。但是随着应用的深入，开发者会发现一些模式对于一些传统的组件并不总是行之有效。下面这个例子，假设有一个名为&nbsp;<code>CommentList</code>&nbsp;的组件,它利用外部数据源来更新组件内的列表：\n</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span\n        class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span\n        class="code-title"><span class="hljs-class"><span class="code-title">CommentList</span></span></span><span\n        class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  <span class="code-keyword">constructor</span>() {\n    <span class="code-keyword"><span class="code-keyword">super</span></span>();\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.handleChange = <span\n            class="code-keyword"><span class="code-keyword">this</span></span>.handleChange.bind(<span\n            class="code-keyword"><span class="code-keyword">this</span></span>);\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.state = {\n      <span class="code-comment"><span class="code-comment">// "DataSource"是一个全局的数据源</span></span>\n      comments: <span class="code-type">DataSource</span>.getComments()\n    };\n  }\n\n  componentDidMount() {\n    <span class="code-comment"><span class="code-comment">// 监听数据变更</span></span>\n    <span class="code-type">DataSource</span>.addChangeListener(<span class="code-keyword"><span class="code-keyword">this</span></span>.handleChange);\n  }\n\n  componentWillUnmount() {\n    <span class="code-comment"><span class="code-comment">// 清除注册事件</span></span>\n    <span class="code-type">DataSource</span>.removeChangeListener(<span class="code-keyword"><span\n            class="code-keyword">this</span></span>.handleChange);\n  }\n\n  handleChange() {\n    <span class="code-comment"><span class="code-comment">// 当数据变更时更新组件的列表数据</span></span>\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.setState({\n      comments: <span class="code-type">DataSource</span>.getComments()\n    });\n  }\n\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> (\n      <span class="xml"><span class="code-tag">&lt;<span class="code-name">div</span>&gt;</span>\n        {<span class="code-keyword">this</span>.state.comments.map((comment) =&gt; (\n          <span class="code-tag">&lt;<span class="code-name"><span class="code-type">Comment</span></span> <span\n                  class="hljs-attr">comment</span>=<span class="code-string">{comment}</span> <span class="hljs-attr">key</span>=<span\n                  class="code-string">{comment.id}</span> /&gt;</span>\n        ))}\n      <span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span>\n    );\n  }\n}</span></code></pre>\n<p>随后，再创建一个组件来订阅监听数据的更新，也使用类似的模式：</p>\n<pre class="kotlin"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span\n        class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span\n        class="code-title"><span class="hljs-class"><span class="code-title">BlogPost</span></span></span><span\n        class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span\n        class="code-title">extends</span></span></span><span class="hljs-class"> </span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">React</span></span></span><span class="hljs-class">.</span><span\n        class="code-title"><span class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  <span class="code-keyword"><span class="code-keyword">constructor</span></span>(props) {\n    <span class="code-keyword"><span class="code-keyword">super</span></span>(props);\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.handleChange = <span\n            class="code-keyword"><span class="code-keyword">this</span></span>.handleChange.bind(<span\n            class="code-keyword"><span class="code-keyword">this</span></span>);\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.state = {\n      blogPost: DataSource.getBlogPost(props.id)\n    };\n  }\n\n  componentDidMount() {\n    DataSource.addChangeListener(<span class="code-keyword"><span class="code-keyword">this</span></span>.handleChange);\n  }\n\n  componentWillUnmount() {\n    DataSource.removeChangeListener(<span class="code-keyword"><span class="code-keyword">this</span></span>.handleChange);\n  }\n\n  handleChange() {\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.setState({\n      blogPost: DataSource.getBlogPost(<span class="code-keyword"><span class="code-keyword">this</span></span>.props.id)\n    });\n  }\n\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="xml"><span class="code-tag">&lt;<span\n            class="code-name">TextBlock</span> <span class="hljs-attr">text</span>=<span class="code-string">{<span\n            class="code-keyword">this</span>.state.blogPost}</span> /&gt;</span>;\n  }\n}</span></code></pre>\n<p><code>CommentList</code>&nbsp;和<code>BlogPost</code>&nbsp;没有任何关系，他们只是都调用了<code>DataSource</code>中不同的方法以获取特定的数据。但是实现的模式是一致的，相似点有：\n</p>\n<ol>\n    <li>在生命周期方法完成组件装载后，都增加了对&nbsp;<code>DataSource</code>&nbsp;的监听。</li>\n    <li>在监听方法中，只要数据发生变更都会调用&nbsp;<code>setState</code>&nbsp;。</li>\n    <li>在组件被卸载时，都会移除监听功能。</li>\n</ol>\n<p>可以想象在一个非常庞大的应用中，上面这种订阅&nbsp;<code>DataSource</code>&nbsp;变更并调用&nbsp;<code>setState</code>&nbsp;的模式可以在许多组件中重复使用。所以，我们可以将这一层功能抽象出来在一个地方编码实现这个处理逻辑，将它分享到许多组件中去使用，这就是HOCs。\n</p>\n<p>可以编写一个通用方法来创建类似&nbsp;<code>CommentList</code>&nbsp;和&nbsp;<code>BlogPost</code>&nbsp;组件中一致的功能——统一订阅&nbsp;<code>DataSource</code>。这个方法应该可以接受一个参数，这个参数将外部组件作为一个子组件传入到方法中，并在方法中完成子组件数据订阅的功能，例如下面的例子中的&nbsp;<code>withSubscription</code>：\n</p>\n<pre class="lisp"><code class="language-javascript"><span class="code-keyword">const</span> CommentListWithSubscription = withSubscription(\n  <span class="code-name">CommentList</span>,\n  (<span class="code-name">DataSource</span>) =&gt; DataSource.getComments()\n)<span class="code-comment">;</span>\n\n<span class="code-keyword">const</span> BlogPostWithSubscription = withSubscription(\n  <span class="code-name">BlogPost</span>,\n  (<span class="code-name">DataSource</span>, props) =&gt; DataSource.getBlogPost(<span class="code-name">props</span>.id)\n})<span class="code-comment">;</span></code></pre>\n<p><code>withSubscription</code>的第一个参数就是要被方法包装的子组件。第二个方法设定我们要获取的数据，直接指定&nbsp;<code>DataSource</code>&nbsp;并利用组件传入的\n    props。</p>\n<p>当&nbsp;<code>CommentListWithSubscription</code>&nbsp;和&nbsp;<code>BlogPostWithSubscription</code>&nbsp;被渲染时，<code>CommentList</code>&nbsp;和<code>BlogPost</code>&nbsp;将会被传入一个&nbsp;<code>data</code>&nbsp;属性值，这个值是从&nbsp;<code>DataSource</code>中检索的数据：\n</p>\n<pre class="kotlin"><code class="language-javascript"><span class="code-comment"><span class="code-comment">// 方法第一个参数传入另外一个组件</span></span>\n<span class="hljs-function"><span class="code-keyword">function</span> <span class="code-title">withSubscription</span>(<span\n        class="hljs-params">WrappedComponent, selectData</span>) </span>{\n  <span class="code-comment"><span class="code-comment">// 然后在方法体中构建另外一个组件并返回</span></span>\n  <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="hljs-class"><span\n            class="code-keyword"><span class="hljs-class"><span class="code-keyword">class</span></span></span><span\n            class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-title">extends</span></span></span><span\n            class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n            class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n            class="hljs-class"><span class="code-title">Component</span></span></span><span class="hljs-class"> </span></span>{\n    <span class="code-keyword"><span class="code-keyword">constructor</span></span>(props) {\n      <span class="code-keyword"><span class="code-keyword">super</span></span>(props);\n      <span class="code-keyword"><span class="code-keyword">this</span></span>.handleChange = <span\n            class="code-keyword"><span class="code-keyword">this</span></span>.handleChange.bind(<span\n            class="code-keyword"><span class="code-keyword">this</span></span>);\n      <span class="code-keyword"><span class="code-keyword">this</span></span>.state = {\n        <span class="code-keyword">data</span>: selectData(DataSource, props)\n      };\n    }\n\n    componentDidMount() {\n      <span class="code-comment"><span class="code-comment">// 订阅DataSource的数据</span></span>\n      DataSource.addChangeListener(<span class="code-keyword"><span class="code-keyword">this</span></span>.handleChange);\n    }\n\n    componentWillUnmount() {\n      DataSource.removeChangeListener(<span class="code-keyword"><span class="code-keyword">this</span></span>.handleChange);\n    }\n\n    handleChange() {\n      <span class="code-keyword"><span class="code-keyword">this</span></span>.setState({\n        <span class="code-keyword">data</span>: selectData(DataSource, <span class="code-keyword"><span\n            class="code-keyword">this</span></span>.props)\n      });\n    }\n\n    render() {\n      <span class="code-comment"><span class="code-comment">// 在render返回的部分对传入的组件进行包装，</span></span>\n      <span class="code-comment"><span class="code-comment">// 将变更后的数据以data属性传入包装组件，并返回根据参数渲染之后的组件</span></span>\n      <span class="code-comment"><span class="code-comment">// 如果这里利用ES6的"..."扩展属性 + assgin方法，可以组合更多的参数</span></span>\n      <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="xml"><span\n            class="code-tag">&lt;<span class="code-name">WrappedComponent</span> <span class="hljs-attr"><span\n            class="code-keyword">data</span></span>=<span class="code-string">{<span class="code-keyword">this</span>.state.<span\n            class="code-keyword">data</span>}</span> {<span class="hljs-attr">...<span class="code-keyword">this</span>.props</span>} /&gt;</span>;\n    }\n  };\n}</span></code></pre>\n<p>需要注意的，一个HOC模式的组件不会修改传入的组件，更不会使用继承的方式去复制组件原有的功能。相反地，一个HOC模式的组件是通过组合的方式将原来的组件通过“容器组件”包装起来。概括的来说，HOC是一个零副作用的纯函数。</p>\n<p>就像我们在例子中看到的，被包装的组件从容器获取所有的props属性，根据容器传入给他新属性值——&nbsp;<code>data</code>&nbsp;来渲染并输出。HOC并不关心数据是如何被子组件使用的，而与之对应的是，子组件不会去关心这些数据从何而来。\n</p>\n<p><code>withSubscription</code>&nbsp;并不是一个普通的方法，可以根据需要额外增加许多参数。例如在现在的需求是让传入到子组件的&nbsp;<code>data</code>&nbsp;属性可配置，以进一步实现子组件和包装组件相互分离，或者能够接受一个参数能够配置&nbsp;<code>shouldComponentUpdate</code>方法，或者可以配置数据源。以上这些需求都是可以实现的，因为HOC可以完全控制组件的定义。\n</p>\n\n<h4 id="h4-2">不要让源组件数据突变</h4>\n<p>在HOC编码过程中，一定不能让组件产生数据突变：</p>\n<pre class="javascript"><code class="language-javascript"><span class="hljs-function"><span class="code-keyword"><span\n        class="hljs-function"><span class="code-keyword">function</span></span></span><span\n        class="hljs-function"> </span><span class="code-title"><span class="hljs-function"><span class="code-title">logProps</span></span></span><span\n        class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">InputComponent</span></span></span><span\n        class="hljs-function">) </span></span>{\n  InputComponent.prototype.componentWillReceiveProps(nextProps) {\n    <span class="code-built_in"><span class="code-built_in">console</span></span>.log(<span class="code-string"><span\n            class="code-string">\'Current props: \'</span></span>, <span class="code-keyword"><span class="code-keyword">this</span></span>.props);\n    <span class="code-built_in"><span class="code-built_in">console</span></span>.log(<span class="code-string"><span\n            class="code-string">\'Next props: \'</span></span>, nextProps);\n  }\n  <span class="code-comment"><span class="code-comment">// 实时上，这里返回的原始input只是一个映射值，因为它已经发生了突变</span></span>\n  <span class="code-keyword"><span class="code-keyword">return</span></span> InputComponent;\n}\n\n<span class="code-comment"><span class="code-comment">// EnhancedComponent 将在收到props时记录。</span></span>\n<span class="code-keyword"><span class="code-keyword">const</span></span> EnhancedComponent = logProps(InputComponent);</code></pre>\n<p>上面的代码看似没毛病，但是存在一些隐藏的问题。</p>\n<p>首先是输入的组件不能与HOC分开使用，比如例子中的&nbsp;<code>componentWillReceiveProps</code>&nbsp;生命周期方法被增强组件覆盖，那么必须保证原始组件中&nbsp;<code>componentWillReceiveProps</code>&nbsp;不包含任何实现代码。\n</p>\n<p>其次还存在更重要的问题是，如果还有另外一个HOC组件包装了&nbsp;<code>EnhancedComponent</code>&nbsp;并且也以突变的方式覆盖&nbsp;<code>componentWillReceiveProps</code>&nbsp;方法，此时第一个HOC的功能将会被覆盖，组件之间并没有完全意义上实现隔离。\n</p>\n<p>用数据突变的方式去实现HOCs是一种不完备的抽象，开发人员在使用这些HOCs时候必须知道某些实现细节，以避免与其他HOC组件或在自身的编码中与之产生冲突。</p>\n<p>HOCs应该使用组合的方式来代替数据突变，下面的代码展示了使用容器如何包装输入组件以实现相同的功能：</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-function"><span\n        class="code-keyword">function</span> <span class="code-title">logProps</span>(<span class="hljs-params"><span\n        class="code-type">WrappedComponent</span></span>) </span>{\n  <span class="code-comment"><span class="code-comment">// 新创建一个组件</span></span>\n  <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="hljs-class"><span\n            class="code-keyword"><span class="hljs-class"><span class="code-keyword">class</span></span></span><span\n            class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n            class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n            class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n            class="hljs-class"><span class="code-title">Component</span></span></span><span class="hljs-class"> </span></span>{\n    <span class="code-comment"><span class="code-comment">//重载生命周期方法</span></span>\n    componentWillReceiveProps(nextProps) {\n      <span class="code-built_in">console</span>.log(<span class="code-string"><span class="hljs-symbol">\'Current</span> props: \'</span>, <span\n            class="code-keyword"><span class="code-keyword">this</span></span>.props);\n      <span class="code-built_in">console</span>.log(<span class="code-string"><span class="hljs-symbol">\'Next</span> props: \'</span>, nextProps);\n    }\n    render() {\n      <span class="code-comment"><span class="code-comment">// 对输入组件进行包装，利用ES6"..."扩展将参数原封不动的传入输入组件</span></span>\n      <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="xml"><span\n            class="code-tag">&lt;<span class="code-name"><span class="code-type">WrappedComponent</span></span> {<span\n            class="hljs-attr">...<span class="code-keyword">this</span>.props</span>} /&gt;</span>;\n    }\n  }\n}</span></code></pre>\n<p>这一段代码和之前的数据突变例子具备相同的功能，同时能避免上面提到的问题，而且无论是class还是function定义的组件它都适用。由于是一个纯函数，所以即使对其继续使用HOC包装也不会有任何问题。</p>\n<p>\n    在前面的介绍中，HOCs和容器组件的实现模式有相似之处。容器组件是将高级组件和底层组件整合在一起形成连接的一部分。容器会管理各种各样的内容，例如：订阅、状态，以及将属性数据传递到子组件中以实现底层组件的渲染功能。容器组件是HOCs模式实现的一部分，可以将HOCs模式看作一个参数化的容器组件。</p>\n\n<h4 id="h4-3">惯例：将无关的属性值传递到包装组件中</h4>\n<p>HOCs为一个组件额外增加了一些特性，但是它不应该影响组件原有的功能。对于一个HOC组件来说，他应该和被包装的子组件有相似的输入接口、有相同的返回。</p>\n<p>HOC组件应该将那些外部传入但是与HOC组件功能无关的参数按照被包装子组件接口定义的方式传递到子组件中。所以大部分HOC组件都会像下面这个编写render方法：</p>\n<pre class="javascript"><code class="language-javascript">render() {\n  <span class="code-comment"><span class="code-comment">// 过滤掉在当前HOC组件中不需要传递的额外参数</span></span>\n  <span class="code-keyword"><span class="code-keyword">const</span></span> { extraProp, ...passThroughProps } = <span\n            class="code-keyword"><span class="code-keyword">this</span></span>.props;\n\n  <span class="code-comment"><span class="code-comment">// 需要注入到包装组件中的参数</span></span>\n  <span class="code-keyword"><span class="code-keyword">const</span></span> injectedProp = someStateOrInstanceMethod;\n\n  <span class="code-comment"><span class="code-comment">// Pass props to wrapped component</span></span>\n  <span class="code-keyword"><span class="code-keyword">return</span></span> (\n    <span class="xml"><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span\n            class="code-name">WrappedComponent</span></span></span></span><span class="xml"><span class="code-tag">\n      </span></span><span class="hljs-attr"><span class="xml"><span class="code-tag"><span class="hljs-attr">injectedProp</span></span></span></span><span\n            class="xml"><span class="code-tag">=</span></span><span class="code-string"><span class="xml"><span\n            class="code-tag"><span class="code-string">{injectedProp}</span></span></span></span><span class="xml"><span\n            class="code-tag">\n      {</span></span><span class="hljs-attr"><span class="xml"><span class="code-tag"><span class="hljs-attr">...passThroughProps</span></span></span></span><span\n            class="xml"><span class="code-tag">}\n    /&gt;</span></span></span><span class="xml">\n  );\n}</span></span></code></pre>\n<p>这个惯例能确保HOC具备不错的复用能力。</p>\n\n<h4 id="h4-4">惯例：最大化组合性</h4>\n<p>并不是所有HOC组件都是一样的。某些时候，它们仅仅需求接受一个参数，例如：</p>\n<pre class="lisp"><code class="language-javascript"><span class="code-keyword">const</span> NavbarWithRouter = withRouter(<span\n        class="code-name">Navbar</span>)<span class="code-comment">;</span></code></pre>\n<p>通常情况下，HOC组件会接受额外的参数，下面的例子中一个配置对象 config 用于指定组件的数据依赖：</p>\n<pre class="actionscript"><code class="language-javascript"><span class="code-keyword"><span\n        class="code-keyword">const</span></span> CommentWithRelay = Relay.createContainer(Comment, config);</code></pre>\n<p>最通用的的HOC组件声明方式是这样的：</p>\n<pre class="actionscript"><code class="language-javascript"><span class="code-comment"><span class="code-comment">// React Redux\'s `connect`</span></span>\n<span class="code-keyword"><span class="code-keyword">const</span></span> ConnectedComment = connect(commentSelector, commentActions)(Comment);</code></pre>\n<p>看到这里可能还有点懵逼，但是把它拆开来看就明白了：</p>\n<pre class="actionscript"><code class="language-javascript"><span class="code-comment"><span class="code-comment">// connect是一个返回另外一个方法的方法</span></span>\n<span class="code-keyword"><span class="code-keyword">const</span></span> enhance = connect(commentListSelector, commentListActions);\n<span class="code-comment"><span\n        class="code-comment">// connect返回的方法是一个HOC组件，这个HOC组件会返回一个与Redux store相互关联的组件</span></span>\n<span class="code-keyword"><span\n        class="code-keyword">const</span></span> ConnectedComment = enhance(CommentList);</code></pre>\n<p>换一种说法,&nbsp;<code>connect</code>&nbsp;是一个高阶方法，它返回一个高阶组件！</p>\n<p>这个结构看起来令人困惑或者没有必要，但是他有一个非常有用的特性。由&nbsp;<code>connect</code>&nbsp;返回的只有一个参数的HOC组件拥有一个特殊的结构&nbsp;<code>Component =&gt;\n    Component</code>——输入一个组件输出一个组件，这种结构非常有利于组件之间重复组成组合关系，看下面这个例子：</p>\n<pre class="actionscript"><code class="language-javascript"><span class="code-comment"><span class="code-comment">// 例子用于实现这个过程</span></span>\n<span class="code-comment"><span class="code-comment">// const EnhancedComponent = connect(commentSelector)(withRouter(WrappedComponent))</span></span>\n\n<span class="code-comment"><span class="code-comment">// 有一个已定义的compose(f, g, h)方法，这个方法的执行效果就是不断的包装组件</span></span>\n<span class="code-comment"><span class="code-comment">// 效果等同于 (...args) =&gt; f(g(h(...args)))</span></span>\n<span class="code-keyword"><span class="code-keyword">const</span></span> enhance = compose(\n  <span class="code-comment"><span class="code-comment">// 2个参数都是一个HOC组件</span></span>\n  connect(commentSelector),\n  withRouter\n)\n<span class="code-keyword"><span class="code-keyword">const</span></span> EnhancedComponent = enhance(WrappedComponent)</code></pre>\n<p>有很多第三方库都提供了类似于compose的方法。只要我们编写的HOC组件都使用这个模式，可以很好的延伸使用下去，而不必考虑参数模式。</p>\n\n<h4 id="h4-5">惯例：包装组件名称以便于调试</h4>\n<p>由HOCs模式创建的包装组件很难在&nbsp;<a href="https://github.com/facebook/react-devtools" rel="nofollow">React Developer Tools</a>&nbsp;等调试工具中与原组件关联起来。为了便于调试，需要选择一个用于显示的名称表明它是一个HOC组件。\n</p>\n<p>通用的实现技巧是包装被包装组件的名称。所以如果定义的高阶组件命名为&nbsp;<code>withSubscription</code>， 而被包装的组件名为&nbsp;<code>CommentList</code>，那么HOC组件的名称应该是&nbsp;<code>WithSubscription(CommentList)</code>：\n</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-function"><span\n        class="code-keyword">function</span> <span class="code-title">withSubscription</span>(<span class="hljs-params"><span\n        class="code-type">WrappedComponent</span></span>) </span>{\n  <span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span\n          class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span\n          class="hljs-class"><span class="code-title">WithSubscription</span></span></span><span\n          class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n          class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n          class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n          class="hljs-class"><span class="code-title">Component</span></span></span><span\n          class="hljs-class"> </span></span>{<span class="code-comment"><span\n            class="code-comment">/* ... */</span></span>}\n  <span class="code-type">WithSubscription</span>.displayName = <span class="code-string">`<span class="code-type">WithSubscription</span>(<span\n            class="hljs-subst">${getDisplayName(<span class="code-type">WrappedComponent</span>)}</span>)`</span>;\n  <span class="code-keyword"><span class="code-keyword">return</span></span> <span\n            class="code-type">WithSubscription</span>;\n}\n\n<span class="hljs-function"><span class="code-keyword">function</span> <span\n        class="code-title">getDisplayName</span>(<span class="hljs-params"><span\n        class="code-type">WrappedComponent</span></span>) </span>{\n  <span class="code-keyword"><span class="code-keyword">return</span></span> <span\n            class="code-type">WrappedComponent</span>.displayName || <span class="code-type">WrappedComponent</span>.name || <span\n            class="code-string"><span class="hljs-symbol">\'Componen</span>t\'</span>;\n}</code></pre>\n\n<h3 id="h3-1">HOCs的坑</h3>\n<p>对于刚使用React的开发人员来说，HOCs存在的一些隐性问题需要注意。</p>\n\n<h4 id="h4-6">不要在render方法中去编码HOCs模式的实现代码</h4>\n<p>React的对比算法（融合算法）使用组件的标记来确定子树是需要更新还是移除重建。如果组件返回的数据和之前返回的数据相同（===），React会递归的比较子树并更新有差异的部分，如果不相同，则会移除重建整个子树。</p>\n<p>通常在使用组件时，并不需要去了解这个情况。但是如果是编写HOC组件就非常重要，这就意味着开发人员不能在render方法中去编写实现HOC的代码：</p>\n<pre class="javascript"><code class="language-javascript">render() {\n  <span class="code-comment"><span class="code-comment">// 在每次渲染时，一个新的EnhancedComponent 组件都会被创建。</span></span>\n  <span class="code-comment"><span class="code-comment">// 并且每次创建的EnhancedComponent实例都不一样</span></span>\n  <span class="code-keyword"><span class="code-keyword">const</span></span> EnhancedComponent = enhance(MyComponent);\n  <span class="code-comment"><span class="code-comment">// 这样会导致这个组件的子树每次都会重建!</span></span>\n  <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="xml"><span\n            class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span class="code-name"><span\n            class="xml"><span class="code-tag"><span\n            class="code-name">EnhancedComponent</span></span></span></span><span class="xml"><span class="code-tag"> /&gt;</span></span></span><span\n            class="xml">;\n}</span></span></code></pre>\n<p>这个问题并不仅仅是和性能有关，每次重建一个组件会导致组件以及子组件已有的状态都会丢失。我们应该将HOCs模式应用于组件之外，以保证组件的实例只被创建一次，确保每次渲染时，他的标记都是一致的。</p>\n<p>在某些罕见的应用下需要动态的使用HOC组件，可以在组件的生命周期方法或其构造函数中构造HOC模式相关的代码。</p>\n\n<h4 id="h4-7">静态方法必须复制</h4>\n<p>某些时候，在React组件中顶一个静态方法非常有用。当在某个组件上使用HOC组件时，源组件会被容器组件包装起来，这就意味着新的组件并没有源组件的静态方法。</p>\n<pre class="actionscript"><code class="language-javascript"><span class="code-comment"><span class="code-comment">// 定义一个静态方法</span></span>\nWrappedComponent.staticMethod = <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">function</span></span></span><span class="hljs-function"><span\n            class="hljs-params">(</span></span><span class="hljs-params"></span><span class="hljs-function"><span\n            class="hljs-params">)</span> </span></span>{<span class="code-comment"><span\n            class="code-comment">/*...*/</span></span>}\n<span class="code-comment"><span class="code-comment">// 现在提供一个HOC模式</span></span>\n<span class="code-keyword"><span class="code-keyword">const</span></span> EnhancedComponent = enhance(WrappedComponent);\n\n<span class="code-comment"><span class="code-comment">// 增强组件并没有静态方法</span></span>\n<span class="code-keyword"><span class="code-keyword">typeof</span></span> EnhancedComponent.staticMethod === <span\n            class="code-string"><span class="code-string">\'undefined\'</span></span> <span class="code-comment"><span\n            class="code-comment">// true</span></span></code></pre>\n<p>为了解决这个问题，你必须将源组件上的静态方法拷贝到容器组件上：</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-function"><span\n        class="code-keyword">function</span> <span class="code-title">enhance</span>(<span class="hljs-params"><span\n        class="code-type">WrappedComponent</span></span>) </span>{\n  <span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span\n          class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span\n          class="hljs-class"><span class="code-title">Enhance</span></span></span><span class="hljs-class"> </span><span\n          class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n          class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n          class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n          class="hljs-class"><span class="code-title">Component</span></span></span><span\n          class="hljs-class"> </span></span>{<span class="code-comment"><span class="code-comment">/*...*/</span></span>}\n  <span class="code-comment"><span class="code-comment">// 必须知道哪些静态方法需要拷贝 :(</span></span>\n  <span class="code-type">Enhance</span>.staticMethod = <span class="code-type">WrappedComponent</span>.staticMethod;\n  <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="code-type">Enhance</span>;\n}</code></pre>\n<p>上面的例子开发人员必须提前知道哪些静态方法需要被拷贝，我们可以利用<a href="https://github.com/mridgway/hoist-non-react-statics" rel="nofollow">hoist-non-react-statics</a>这个扩展工具来自动拷贝所有非React定义的静态方法：\n</p>\n<pre class="scala"><code class="language-javascript"><span class="code-keyword"><span class="code-keyword">import</span></span> hoistNonReactStatic <span\n        class="code-keyword">from</span> <span class="code-string"><span class="hljs-symbol">\'hoist</span>-non-react-statics\'</span>;\n<span class="hljs-function"><span class="code-keyword">function</span> <span class="code-title">enhance</span>(<span\n        class="hljs-params"><span class="code-type">WrappedComponent</span></span>) </span>{\n  <span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span\n          class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span\n          class="hljs-class"><span class="code-title">Enhance</span></span></span><span class="hljs-class"> </span><span\n          class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n          class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n          class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n          class="hljs-class"><span class="code-title">Component</span></span></span><span\n          class="hljs-class"> </span></span>{<span class="code-comment"><span class="code-comment">/*...*/</span></span>}\n  hoistNonReactStatic(<span class="code-type">Enhance</span>, <span class="code-type">WrappedComponent</span>);\n  <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="code-type">Enhance</span>;\n}</code></pre>\n<p>另外一个解决方法是由底层组件的开发者去导出静态方法：</p>\n<pre class="javascript"><code class="language-javascript"><span class="code-comment"><span class="code-comment">// Instead of...</span></span>\nMyComponent.someFunction = someFunction;\n<span class="code-keyword"><span class="code-keyword">export</span></span> <span class="code-keyword"><span\n            class="code-keyword">default</span></span> MyComponent;\n\n<span class="code-comment"><span class="code-comment">// ...export the method separately...</span></span>\n<span class="code-keyword"><span class="code-keyword">export</span></span> { someFunction };\n\n<span class="code-comment"><span class="code-comment">// ...and in the consuming module, import both</span></span>\n<span class="code-keyword"><span class="code-keyword">import</span></span> MyComponent, { someFunction } <span\n            class="code-keyword"><span class="code-keyword">from</span></span> <span class="code-string"><span\n            class="code-string">\'./MyComponent.js\'</span></span>;</code></pre>\n\n<h4 id="h4-8">Refs并不会被传递</h4>\n<p>\n    在前面的惯例中介绍了将所有的props属性传递给被包装子组件的实现方法，但是需要明确的是Refs并不会被传递。这是因为Refs并不是一个真正的属性，对于React来说他是一个处理器。如果你给一个HOC组件添加一个ref，这个ref指向的是外层容器组件而非被包装的组件。</p>\n<p>\n    如果已经在编码中出现了这个问题，明智的解决方案是找到避免使用Refs特性的方法。有时候刚开始使用React开发的编程人员更喜欢使用ref胜过props。在不得不使用Refs的情况下，我们可以考虑将ref作为一个props参数的回调方法来使用：</p>\n<pre class="actionscript"><code class="language-javascript"><span class="hljs-function"><span class="code-keyword"><span\n        class="hljs-function"><span class="code-keyword">function</span></span></span><span\n        class="hljs-function"> </span><span class="code-title"><span class="hljs-function"><span class="code-title">Field</span></span></span><span\n        class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-params"><span\n        class="hljs-function"><span class="hljs-params">{ inputRef, <span class="hljs-rest_arg">...rest</span> }</span></span></span><span\n        class="hljs-function"><span class="hljs-params">)</span> </span></span>{\n  <span class="code-keyword"><span class="code-keyword">return</span></span> &lt;input ref={inputRef} {...rest} /&gt;;\n}\n\n<span class="code-comment">// HOC包装Field</span>\n<span class="code-keyword">const</span> EnhancedField = enhance(Field);\n\n<span class="code-comment">// render()</span>\n&lt;EnhancedField\n  inputRef={(inputEl) =&gt; {\n    <span class="code-comment">// 指定一个回调函数，通过这个回调将ref通过props传递到外部</span>\n    <span class="code-keyword">this</span>.inputEl = inputEl\n  }}\n/&gt;\n\n<span class="code-comment">// 然后直接使用回调</span>\n<span class="code-keyword">this</span>.inputEl.focus();</code></pre>'},380:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<h2 id="h2-1">3.0新增容器启动方法</h2>\n<p>在3.0之前的Spring核心框架中，我们启动一个Spring容器必须使用一个XML文件。而到了3.X之后的版本Spring为创建容器新增了一个入口类——<strong><em>AnnotationConfigApplicationContext</em></strong>。\n</p>\n<p>\n    AnnotationConfigApplicationContext和过去的ClassPathXmlApplicationContext、FileSystemXmlApplicationContext等方法不同的是他不用再指定任何XML配置文件，而是可以通过指定类向容器添加Bean。我们通过几个简单的例子来说明他的使用。</p>\n<p>（以下例子只用于说明问题，源码<a href="https://gitee.com/chkui-com/spring-core-sample" rel="nofollow">请到 gitee&nbsp;自行 clone</a>，本节的代码在&nbsp;chkui.springcore.example.javabase.simple\n    包中）。</p>\n\n<h3 id="h3-1">直接添加Bean</h3>\n<p>我们可以通过AnnotationConfigApplicationContext直接向容器添加指定的类作为Bean，先定义我们的class：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.simple.pureBean;\n\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">LolBean</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">toString</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"I AM LOL!"</span>;\n\t}\n}\n\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">WowBean</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">toString</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"I AM WOW!"</span>;\n\t}\n}</code></pre>\n<p>然后向容器添加这些Bean：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.simple;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">WithoutAnnotation</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(WowBean.class, LolBean.class);\n\t\tSystem.out.println(ctx.getBean(WowBean.class));\n\t\tSystem.out.println(ctx.getBean(LolBean.class));\n\t}\n}</code></pre>\n<p>这样就启动了一个Spring的容器，并且容器中包含了WowBean和LolBean这两个类的单例。</p>\n\n<h3 id="h3-2">替代&lt;beans&gt;标签</h3>\n<p>@Configuration在之前介绍Spring核心容器的文章中出现过一两次，配合各种注解的使用@Configuration可以替代&lt;beans&gt;配置中的所有功能。基本上AnnotationConfigApplicationContext和@Configuration组合使用就可以实现Spring容器纯Java启动。请看下面的例子。</p>\n<p>我们在前面例子的基础上增加几个类：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.simple.bean;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">DotaBean</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">toString</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"I AM Dota!"</span>;\n\t}\n}\n\n<span class="code-meta">@Component</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">PseBean</span> </span>{\n\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">toString</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"I AM PSE!"</span>;\n\t}\n}</code></pre>\n<p>注意DotaBean上是没有@Component注解的。然后添加@Configuration配置：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.simple.bean;\n\n<span class="code-meta">@Configuration</span>\n<span class="code-meta">@ComponentScan</span>(<span\n            class="code-string">"chkui.springcore.example.javabase.simple.bean"</span>)\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Config</span> </span>{\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> DotaBean <span\n            class="code-title">dotaBean</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> DotaBean();\n\t}\n}</code></pre>\n<p>最后运行他们：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.simple;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">WithScan</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(Config.class, WowBean.class, LolBean.class);\n\t\tSystem.out.println(ctx.getBean(Config.class));\n\t\tSystem.out.println(ctx.getBean(PseBean.class));\n\t\tSystem.out.println(ctx.getBean(WowBean.class));\n\t\tSystem.out.println(ctx.getBean(LolBean.class));\n\t\tSystem.out.println(ctx.getBean(DotaBean.class));\n\t}\n}</code></pre>\n<p>@Component已经在&nbsp;<a href="https://www.chkui.com/article/spring/spring_core_stereotype_component_and_bean_scan"\n                         title="Stereotype组件与Bean扫描">Stereotype组件与Bean扫描</a>&nbsp;这篇文章介绍过，@ComponentScan的作用等价于&lt;context:component-scan/&gt;标签，属性参数都是一一对应的，只不过前者是驼峰命名规则（camelCase）——@ComponentScan(basePackages="...")，后者是短横线命名规则（kebab-case）——&lt;context:component-scan\n    base-package="..."/&gt;。实际上使用Annotation来替换XML配置中的内容，大部分都使用这种转换方式。</p>\n<p>@Configuration和@Bean标签会在后续的内容中详细介绍。@Bean主要用于方法标记，表明这个方法返回一个要添加到容器中的Bean。</p>\n\n<h3 id="h3-3">AnnotationConfigApplicationContext的其他使用方法</h3>\n<p>除了以上常规的使用方法，AnnotationConfigApplicationContext还有其他方式向容器添加Bean。</p>\n<p>可以使用AnnotationConfigApplicationContext::register方法来添加配置和Bean：</p>\n<pre><code class="java"><span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n        class="code-keyword">void</span> <span class="code-title">main</span><span\n        class="hljs-params">(String[] args)</span> </span>{\n    AnnotationConfigApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext();\n    <span class="code-comment">//动态添加配置文件</span>\n    ctx.register(Config1.class, Config2.class);\n    <span class="code-comment">//动态添加Bean</span>\n    ctx.register(Bean1.class);\n    <span class="code-comment">//刷新</span>\n    ctx.refresh();\n}</code></pre>\n<p>\n    注意最后的refresh方法，这个方法来源于ConfigurableApplicationContext接口，然后是在AbstractApplicationContext中实现的。他的过程相当于销毁之前已经创建的资源，然后再重新创建了一个新的容器。这里的代码会执行以下几步：</p>\n<ol>\n    <li><em>new AnnotationConfigApplicationContext()</em>：创建一个新的容器，容器中没有自定义的Bean。</li>\n    <li>AnnotationConfigApplicationContext::register：向容器添加<a\n            href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/config/BeanDefinition.html"\n            rel="nofollow">BeanDefinition</a>，但是这些<a\n            href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/config/BeanDefinition.html"\n            rel="nofollow">BeanDefinition</a>并没有转化为容器中的Bean。\n    </li>\n    <li>ConfigurableApplicationContext::refresh()：纳入新添加的<a\n            href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/config/BeanDefinition.html"\n            rel="nofollow">BeanDefinition</a>重建容器。\n    </li>\n</ol>\n<p>还可以直接使用AnnotationConfigApplicationContext::scan方法扫描指定的路径：</p>\n<pre><code class="java"><span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n        class="code-keyword">void</span> <span class="code-title">main</span><span\n        class="hljs-params">(String[] args)</span> </span>{\n    AnnotationConfigApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext();\n    ctx.scan(<span class="code-string">"com.acme"</span>);\n    ctx.refresh();\n}</code></pre>\n<p>执行原理和上面介绍的一样。</p>\n<p>\n    按照以上介绍的内容。如果你的工程中需要使用AnnotationConfigApplicationContext::register、AnnotationConfigApplicationContext::scan等方法创建容器和其中Bean的依赖关系，最好是所有的Bean都在register或scan中添加。因为重建一批Bean会花费不少时间，尤其是Bean中还有销毁方法要回收资源时。</p>\n\n<h2 id="h2-2">@Bean注解</h2>\n<p>@Bean注解等价于配置文件中的&lt;bean&gt;标签，对应的参数也是将短横线命名切换为驼峰命名——&lt;bean init-method="..."&gt; =&gt;\n    @Bean(initMethod="...")。@Bean注解只能使用在方法上，方法必须是在@Configuration标记的类或者其他Bean中，两者存在的差异会在后续的文章中介绍。下面通过一个例子来说明Bean的使用。</p>\n<p>（以下例子只用于说明问题，源码<a href="https://gitee.com/chkui-com/spring-core-sample" rel="nofollow">请到 gitee&nbsp;自行 clone</a>，本节的代码在&nbsp;chkui.springcore.example.javabase.beanAnnotation\n    包中）。</p>\n<p>定义两个要添加到容器中的Bean：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.beanAnnotation.bean;\n\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">FinalFantasy</span> </span>{\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">toString</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"Final Fantasy 1~15"</span>;\n\t}\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">init</span><span class="hljs-params">()</span> </span>{\n\t\tSystem.out.println(<span class="code-string">"Final Fantasy init!"</span>);\n\t}\n\t\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">destroy</span><span class="hljs-params">()</span> </span>{\n\t\tSystem.out.println(<span class="code-string">"Final Fantasy destroy!"</span>);\n\t}\n}\n\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">DragonQuest</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">toString</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"Dragon Quest 1~11"</span>;\n\t}\n\t\n\t<span class="code-meta">@PostConstruct</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">init</span><span class="hljs-params">()</span> </span>{\n\t\tSystem.out.println(<span class="code-string">"Dragon Quest init!"</span>);\n\t}\n\t\n\t<span class="code-meta">@PreDestroy</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">destroy</span><span class="hljs-params">()</span> </span>{\n\t\tSystem.out.println(<span class="code-string">"Dragon Quest destroy!"</span>);\n\t}\n}\n</code></pre>\n<p>定义一个功能接口及其实现类：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.beanAnnotation.bean;\n\n<span class="hljs-class"><span class="code-keyword">interface</span> <span class="code-title">Support</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">void</span> <span\n            class="code-title">setFinalFantasy</span><span class="hljs-params">(FinalFantasy ff)</span></span>;\n\t<span class="hljs-function">FinalFantasy <span class="code-title">getFinalFantasy</span><span\n            class="hljs-params">()</span></span>;\n}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">SupportImpl</span> <span\n        class="code-keyword">implements</span> <span class="code-title">Support</span> </span>{\n\t<span class="code-keyword">private</span> FinalFantasy ff; \n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setFinalFantasy</span><span class="hljs-params">(FinalFantasy ff)</span> </span>{\n\t\t<span class="code-keyword">this</span>.ff = ff;\n\t}\n\t<span class="hljs-function"><span class="code-keyword">public</span> FinalFantasy <span class="code-title">getFinalFantasy</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> ff;\n\t}\n}</code></pre>\n<p>然后顶一个@Configuration类：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.beanAnnotation.bean;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">BeanAnnotationConfig</span> </span>{\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> Support <span class="code-title">support</span><span\n            class="hljs-params">(FinalFantasy ff)</span> </span>{\n\t\tSupport support = <span class="code-keyword">new</span> SupportImpl();\n\t\tsupport.setFinalFantasy(ff);\n\t\t<span class="code-keyword">return</span> support;\n\t}\n\t\n\t<span class="code-meta">@Bean</span>(initMethod=<span class="code-string">"init"</span>, destroyMethod=<span\n            class="code-string">"destroy"</span>)\n\t<span class="code-meta">@Description</span>(<span class="code-string">"Final Fantasy"</span>)\n\t<span class="hljs-function"><span class="code-keyword">public</span> FinalFantasy <span class="code-title">finalFantasy</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> FinalFantasy();\n\t}\n\t\n\t<span class="code-meta">@Bean</span>(name= {<span class="code-string">"dragon-quest"</span>, <span\n            class="code-string">"DragonQuest"</span>})\n\t<span class="hljs-function"><span class="code-keyword">public</span> DragonQuest <span class="code-title">dragonQuest</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> DragonQuest();\n\t}\n}</code></pre>\n<p>最后运行他们：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">BeanAnnotApp</span> </span>{\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(BeanAnnotationConfig.class);\n\t\tSupport support = ctx.getBean(Support.class);\n\t\tSystem.out.println(support.getFinalFantasy());\n\t\tSystem.out.println(ctx.getBean(DragonQuest.class));\n\t}\n\n}</code></pre>\n<p>在配置类BeanAnnotationConfig中，我们配置了3个Bean。这里的写在方法上的@Bean注解和写在配置文件中的&lt;bean&gt;注解一个效果：</p>\n<ul>\n    <li>\n        <strong><em>@Bean</em></strong>中的<strong><em>initMethod</em></strong>和<strong><em>destroyMethod</em></strong>对应<strong><em>&lt;bean&gt;</em></strong>标签中的<strong><em>init-method</em></strong>和<strong><em>destroy-method</em></strong>属性。\n    </li>\n    <li><strong><em>@Bean</em></strong>中的<strong><em>name</em></strong>参数只有一个值时相当于id，有多个的时候相当于设置了多个别名</li>\n    <li><strong><em>Support support(FinalFantasy ff)</em></strong>：我们可以直接在方法中暴露参数来引入其他Bean，这就类似于配置中<strong><em>ref</em></strong>的功能。\n    </li>\n    <li>如果不指定<strong><em>initMethod</em></strong>和<strong><em>destroyMethod</em></strong>，使用JSR-330的生命周期注解（@PostConstruct、@PreDestroy）同样有效\n    </li>\n</ul>\n'}});