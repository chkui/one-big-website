webpackJsonp([11],{359:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<h3 id="h3-1">性能优化</h3>\n<p>在React内部已经使用了许多巧妙的技术来最小化由于Dom变更导致UI渲染所耗费的时间。对于很多应用来说，使用React后无需太多工作就会让客户端执行性能有质的提升。然而，还是很其他更多的办法来加速React程序。</p>\n<h4 id="h4-1">使用生产模式来构建应用</h4>\n<p>如果在开发和使用的过程中感觉了React应用有明显的性能问题，请先确认是否已经构建了压缩后的生产包：</p>\n<ul>\n    <li>在单页面用中，打包之后的生产文件应该是.min.js版本。</li>\n    <li>对于Brunch（html打包工具：http://brunch.io/），打包命令需要包含-p标记。</li>\n    <li>对于Browserify（UMD规范打包工具：http://browserify.org/），打包时需要增加生产配置参数——&nbsp;<code>NODE_ENV=production</code>。</li>\n    <li>对于在创建React App时，需要执行&nbsp;<code>npm run build</code>&nbsp;命令，并按照说明操作。</li>\n    <li>对于Rollup（JavaScript代码高效压缩工具：https://rollupjs.org/），生产打包时需要在&nbsp;<a title="commonjs插件"\n            href="https://github.com/rollup/rollup-plugin-commonjs" rel="nofollow">commonjs</a>&nbsp;插件之前使用&nbsp;<a title="replace插件"\n            href="https://github.com/rollup/rollup-plugin-replace" rel="nofollow">replace</a>&nbsp;插件：\n        <pre class="javascript"><code class="language-javascript">plugins: [\n  <span class="code-built_in"><span class="code-built_in">require</span></span>(<span class="code-string"><span\n                    class="code-string">\'rollup-plugin-replace\'</span></span>)({\n    <span class="code-string"><span class="code-string">\'process.env.NODE_ENV\'</span></span>: <span\n                    class="code-built_in"><span class="code-built_in">JSON</span></span>.stringify(<span\n                    class="code-string"><span class="code-string">\'production\'</span></span>)\n  }),\n  <span class="code-built_in"><span class="code-built_in">require</span></span>(<span class="code-string"><span\n                    class="code-string">\'rollup-plugin-commonjs\'</span></span>)(),\n  <span class="code-comment"><span class="code-comment">// ...</span></span>\n]</code></pre>\n        <p>可以在这里看到 一个完整的例子：<a title="Rollup生产优化的案例" href="https://gist.github.com/Rich-Harris/cb14f4bc0670c47d00d191565be36bf0"\n                              rel="nofollow">see this gist</a>。</p></li>\n    <li><p>使用Webpack打包，需要在打生产包的配置脚本中增加以下配置和插件：</p>\n        <pre class="javascript"><code class="language-javascript"><span class="code-keyword"><span class="code-keyword">new</span></span> webpack.DefinePlugin({\n  <span class="code-string"><span class="code-string">\'process.env\'</span></span>: {\n    NODE_ENV: <span class="code-built_in"><span class="code-built_in">JSON</span></span>.stringify(<span\n                    class="code-string"><span class="code-string">\'production\'</span></span>)\n  }\n}),\n<span class="code-keyword"><span class="code-keyword">new</span></span> webpack.optimize.UglifyJsPlugin()</code></pre>\n        <p>。</p></li>\n</ul>\n<p>切记不要将开发模式的包发布到生产环境，因为开发包中额外包含了许多用于辅助的测试的信息，无论在加载还是执行时，它都比较慢。</p>\n\n<h4 id="h4-2">使用chrome分析组件的渲染时间线</h4>\n<p>在开发模式中下你可以直接在chrome的性能工具中看到组件是如何装载、更新和卸载的。例如下面的图片展示的效果：</p>\n<p style="text-align:center"><img alt="React 渲染性能优化" height="228"\n                                  src="https://file.mahoooo.com/res/file/react_optimizing_performance_1.png"\n                                  width="651"></p>\n<p>在chrome中按照以下步骤执行：</p>\n<ol>\n    <li>使用?react_perf作为url参数（例如：http://localhost:3000/?react_perf）</li>\n    <li>打开chrome的开发工具Timeline，然后点击Record（左上角的红色按钮）。</li>\n    <li>执行你要监控的操作。请不要记录超过20秒，这可能会导致chrome假死。</li>\n    <li>停止记录。</li>\n    <li>React事件将会批量记录在User Timing标签里。</li>\n</ol>\n<p>关于分析的数据，需要明确的是：渲染的时间只是一个相对的参考值，在构建成生产包之后，渲染的速度会更快。尽管如此，这些数据仍然能够帮助我们分析是否有不相关的UI被错误的更新，以及UI更新的频率和深度。</p>\n<p>目前只有Chrome、Edge和IE支持这个特性，但是官方正在使用<a title="浏览器性能优化分析工具标准" href="https://developer.mozilla.org/en-US/docs/Web/API/User_Timing_API"\n                                       rel="nofollow">User Timing API&nbsp;标准</a>&nbsp;让更多浏览器支持这个特性。</p>\n\n<h4 id="h4-3">手工避免重复渲染</h4>\n<p>\n    React构建和维护了一个内部的虚拟Dom，这个Dom和真实的UI是相互映射的关系，他包含从用户自定义组件中返回的各种React元素。这个虚拟的Dom使得React可以避免重复渲染相同的Dom节点并在访问存在的节点时直接使用React的虚拟层数据，这样设计的原因是重复渲染浏览器或web\n    view的UI比操作一个JavaScript的对象要慢许多。在React Native也采用同样的处理方式。</p>\n<p>当组件的props和state变更时，React会将最新返回的元素与之前旧的元素进行对比来确定是否真的需要重新渲染真实的Dom。当他们不相等时，React会更新真实的Dom。</p>\n<p>在某些情况下，可以在自定义组件中重载<code>shouldComponentUpdate</code>方法来加速触发渲染的比对的过程。该方法的默认实现返回参数为true，此时React将按照原来的方式进行比对和渲染：</p>\n<pre class="kotlin"><code class="language-javascript">shouldComponentUpdate(nextProps, nextState) {\n  <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="hljs-literal"><span\n            class="hljs-literal">true</span></span>;\n}</code></pre>\n<p>如果在某些情况下能够清晰的明确组件不需要重新渲染，可以在&nbsp;<code>shouldComponentUpdate</code>&nbsp;方法中返回&nbsp;false，这样会让让组件跳过整个渲染过程，包括不再调用当前组件和子组件的render()方法。\n</p>\n\n<h4 id="h4-4">shouldComponentUpdate 的执行过程</h4>\n<p>下面是一个组件结构树。图中，“SCU”表示&nbsp;<code>shouldComponentUpdate</code>&nbsp;方法返回的值（绿色true，红色fasle），“vDOMEq”表示React的匹配是否一致（绿色true，红色fasle），有颜色的红圈表示是否执行了UI重绘（绿色表示没重绘，红色表示执行重绘）。\n</p>\n<p style="text-align:center"><img alt="React 渲染性能优化" height="371"\n                                  src="https://static.oschina.net/uploads/space/2017/0406/182936_ZTAG_2649413.png"\n                                  width="555"></p>\n<p style="text-align:left">在C2组件中，<code>shouldComponentUpdate</code>&nbsp;方法返回了false，所以React不会判断是否需要重新渲染C2并且不执行render()方法，&nbsp;因此在C4和C5中不再执行<code>shouldComponentUpdate</code>&nbsp;方法。\n</p>\n<p style="text-align:left">对于C1和C3，<code>shouldComponentUpdate</code>&nbsp;都返回了true，所以React必须对着2个组件进行比对。对于C6，<code>shouldComponentUpdate</code>&nbsp;返回true，而且比对的结果是需要UI重绘，因此C6会更新他们的真实Dom。\n</p>\n<p style="text-align:left">还有一个值得关心的组件是C8，React在这个组件中执行了render()方法，但是由于虚拟Dom并没有发生变更，前后比对一致，所以并没有发生真实Dom渲染。</p>\n<p style="text-align:left">在整个过程中React仅仅变更了C6组件的UI样式，C8由于前后虚拟Dom一致因此没有真正的执行UI渲染。C2、C2的子组件以及C7没有执行render()方法。</p>\n\n<h4 id="h4-5">一个shouldComponentUpdate的例子</h4>\n<p>在例子中，当props.color和state.count发生变更时进行UI渲染，我们在&nbsp;<code>shouldComponentUpdate</code>&nbsp;方法中进行检查：</p>\n<pre class="kotlin"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span\n        class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span\n        class="code-title"><span class="hljs-class"><span class="code-title">CounterButton</span></span></span><span\n        class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span\n        class="code-title">extends</span></span></span><span class="hljs-class"> </span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">React</span></span></span><span class="hljs-class">.</span><span\n        class="code-title"><span class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  <span class="code-keyword"><span class="code-keyword">constructor</span></span>(props) {\n    <span class="code-keyword"><span class="code-keyword">super</span></span>(props);\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.state = {count: <span\n            class="hljs-number"><span class="hljs-number">1</span></span>};\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    <span class="code-comment"><span class="code-comment">//只判断props.color和nextState.count是否变更，其他情况均不渲染</span></span>\n    <span class="code-keyword"><span class="code-keyword">if</span></span> (<span class="code-keyword"><span\n            class="code-keyword">this</span></span>.props.color !== nextProps.color) {\n      <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="hljs-literal"><span\n            class="hljs-literal">true</span></span>;\n    }\n    <span class="code-keyword"><span class="code-keyword">if</span></span> (<span class="code-keyword"><span\n            class="code-keyword">this</span></span>.state.count !== nextState.count) {\n      <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="hljs-literal"><span\n            class="hljs-literal">true</span></span>;\n    }\n    <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="hljs-literal"><span\n            class="hljs-literal">false</span></span>;\n  }\n\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> (\n      <span class="xml"><span class="code-tag">&lt;<span class="code-name">button</span>\n        <span class="hljs-attr">color</span>=<span class="code-string">{<span class="code-keyword">this</span>.props.color}</span>\n        <span class="hljs-attr">onClick</span>=<span class="code-string">{()</span> =&gt;</span> <span\n              class="code-keyword">this</span>.setState(state =&gt; ({count: state.count + <span\n              class="hljs-number">1</span>}))}&gt;\n        Count: {<span class="code-keyword">this</span>.state.count}\n      <span class="code-tag">&lt;/<span class="code-name">button</span>&gt;</span></span>\n    );\n  }\n}</code></pre>\n<p>在这段代码中，<code>shouldComponentUpdate</code>&nbsp;仅仅检查&nbsp;<code>props.color</code>和&nbsp;<code>state.count</code>是否发生变更，如果他们的值没有修改，组件将不会发生任何更新。在实际使用中，组件往往比这个复杂，我们可以使用类似于“浅比较”（关于浅比较可以参看：\n    <a title="shallow compare模式" href="https://facebook.github.io/react/docs/shallow-compare.html" rel="nofollow">Shallow Compare</a>）的模式来比对所有的属性或状态是否发生变更。React提供了这个模式的一个实现组件，只要让组件继承自&nbsp;<code>React.PureComponent</code>即可。我们可以将代码进行下面的修改：\n</p>\n<pre class="scala"><code class="language-javascript"><span class="code-comment"><span class="code-comment">//继承自React.PureComponent</span></span>\n<span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span\n        class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">CounterButton</span></span></span><span\n        class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{\n  <span class="code-keyword">constructor</span>(props) {\n    <span class="code-keyword"><span class="code-keyword">super</span></span>(props);\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.state = {count: <span\n            class="hljs-number"><span class="hljs-number">1</span></span>};\n  }\n\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> (\n      <span class="xml"><span class="code-tag">&lt;<span class="code-name">button</span>\n        <span class="hljs-attr">color</span>=<span class="code-string">{<span class="code-keyword">this</span>.props.color}</span>\n        <span class="hljs-attr">onClick</span>=<span class="code-string">{()</span> =&gt;</span> <span\n              class="code-keyword">this</span>.setState(state =&gt; ({count: state.count + <span\n              class="hljs-number">1</span>}))}&gt;\n        <span class="code-type">Count</span>: {<span class="code-keyword">this</span>.state.count}\n      <span class="code-tag">&lt;/<span class="code-name">button</span>&gt;</span></span>\n    );\n  }\n}</code></pre>\n<p>在大部分情况下，只要使用&nbsp;<code>React.PureComponent</code>&nbsp;就可以代替我们自己重载&nbsp;<code>shouldComponentUpdate</code>方法，但是它仅仅适用于“浅比较”，所以这个组件不适用于props和state数据发生突变的情况。\n</p>\n<p><span style="color:#FF0000">附：数据突变（mutated）是指变量的引用没有改变（指针地址未改变），但是引用指向的数据发生了变化（指针指向的数据发生变更）。例如const x = {foo:\'foo\'}。x.foo=\'none\' 就是一个突变。</span>\n</p>\n<p>在更复杂的数据结构中还会存在一些问题。例如下面的代码，我们希望<code>ListOfWords</code>&nbsp;组件将words参数渲染成一个逗号分隔的字符串，而父组件监控点击事件，每次点击都会增加一个单词到列表中，但是下面的代码并不会正确工作：\n</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span\n        class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span\n        class="code-title"><span class="hljs-class"><span class="code-title">ListOfWords</span></span></span><span\n        class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="xml"><span class="code-tag">&lt;<span\n            class="code-name">div</span>&gt;</span>{<span class="code-keyword">this</span>.props.words.join(\',\')}<span\n            class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>;\n  }\n}\n\n<span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span\n        class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">WordAdder</span></span></span><span class="hljs-class"> </span><span\n        class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  <span class="code-keyword">constructor</span>(props) {\n    <span class="code-keyword"><span class="code-keyword">super</span></span>(props);\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.state = {\n      words: [<span class="code-string"><span class="hljs-symbol">\'markla</span>r\'</span>]\n    };\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.handleClick = <span\n            class="code-keyword"><span class="code-keyword">this</span></span>.handleClick.bind(<span\n            class="code-keyword"><span class="code-keyword">this</span></span>);\n  }\n\n  handleClick() {\n    <span class="code-comment"><span class="code-comment">// 这段内容会导致代码不按照预期工作。</span></span>\n    <span class="code-keyword">const</span> words = <span class="code-keyword"><span\n            class="code-keyword">this</span></span>.state.words;\n    words.push(<span class="code-string"><span class="hljs-symbol">\'markla</span>r\'</span>);\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.setState({words: words});\n  }\n\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> (\n      &lt;div&gt;\n        &lt;button onClick={<span class="code-keyword">this</span>.handleClick} /&gt;\n        &lt;<span class="code-type">ListOfWords</span> words={<span class="code-keyword">this</span>.state.words} /&gt;\n      &lt;/div&gt;\n    );\n  }\n}</code></pre>\n<p>导致代码无法正常工作的原因是&nbsp;<code>PureComponent</code>&nbsp;仅仅对 this.props.words的新旧值进行“浅比较”。在words值在<code>handleClick</code>中被修改之后，即使有新的单词被添加到数组中，但是this.props.words的新旧值在进行比较时是一样的（引用对象比较），因此&nbsp;<code>ListOfWords</code>&nbsp;一直不会发生渲染。\n</p>\n\n<h4 id="h4-6">非突变数据的价值</h4>\n<p>有一个简单的方法预防上面提到的问题，就是在使用prop和state时防止数据发生突变。例如下面的例如，我们用数组的concat方法来代替等号“=”，这样在concat后会产生一个新的数组赋值给this.state.words：</p>\n<pre class="less"><code class="language-javascript"><span class="code-selector-tag">handleClick</span>() {\n  <span class="code-keyword"><span class="code-selector-tag">this</span></span><span class="code-selector-class">.setState</span>(prevState =&gt; ({\n    <span class="code-attribute">words</span>: prevState.words.concat([<span class="code-string"><span\n            class="code-string">\'marklar\'</span></span>])\n  }));\n}</code></pre>\n<p>ES6支持列表扩展语法，因此我们更容易在es6中实现非突变的数据赋值，例如：</p>\n<pre class="less"><code class="language-javascript"><span class="code-selector-tag">handleClick</span>() {\n  <span class="code-keyword"><span class="code-selector-tag">this</span></span><span class="code-selector-class">.setState</span>(prevState =&gt; ({\n    <span class="code-attribute">words</span>: [...prevState.words, <span class="code-string"><span class="code-string">\'marklar\'</span></span>],\n  }));\n};</code></pre>\n<p>可以重写传统的赋值语句防止对象中的数据发生数据突变。下面的例子有一个名为&nbsp;<code>colormap</code>&nbsp;的对象，我们想在修改&nbsp;<code>colormap.right</code>&nbsp;的值时渲染组件，我们可以这样重写组件：\n</p>\n<pre class="actionscript"><code class="language-javascript"><span class="hljs-function"><span class="code-keyword"><span\n        class="hljs-function"><span class="code-keyword">function</span></span></span><span\n        class="hljs-function"> </span><span class="code-title"><span class="hljs-function"><span class="code-title">updateColorMap</span></span></span><span\n        class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-params"><span\n        class="hljs-function"><span class="hljs-params">colormap</span></span></span><span class="hljs-function"><span\n        class="hljs-params">)</span> </span></span>{\n  colormap.right = <span class="code-string"><span class="code-string">\'blue\'</span></span>; <span class="code-comment"><span\n            class="code-comment">//浅拷贝，指针地址未变，数据发生变化。</span></span>\n}</code></pre>\n<p>可以使用&nbsp;<a title="ES6 Object.assign方法" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign"\n                rel="nofollow">Object.assign</a>&nbsp;方法来防止数据突变：</p>\n<pre class="javascript"><code class="language-javascript"><span class="hljs-function"><span class="code-keyword"><span\n        class="hljs-function"><span class="code-keyword">function</span></span></span><span\n        class="hljs-function"> </span><span class="code-title"><span class="hljs-function"><span class="code-title">updateColorMap</span></span></span><span\n        class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">colormap</span></span></span><span\n        class="hljs-function">) </span></span>{\n  <span class="code-comment"><span class="code-comment">// 深拷贝，修改返回对象的地址</span></span>\n  <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="code-built_in"><span\n            class="code-built_in">Object</span></span>.assign({}, colormap, {right: <span class="code-string"><span\n            class="code-string">\'blue\'</span></span>});\n}</code></pre>\n<p>修改后&nbsp;<code>updateColorMap</code>&nbsp;方法返回一个新的实例。需要注意的是某些浏览器不支持&nbsp;<code>Object.assign</code>方法，我们需要使用polyfill（差异化抹平，比如我们引入了babel-polyfill）来解决这个问题。\n</p>\n<p>有一个新的JavaScript方案是使用 扩展传播特性（见 <a title="扩展传播性能" href="https://github.com/sebmarkbage/ecmascript-rest-spread" rel="nofollow">object\n    spread properties</a>&nbsp;）来解决数据突变问题，实现如下：</p>\n<pre class="lua"><code class="language-javascript"><span class="hljs-function"><span class="code-keyword"><span\n        class="hljs-function"><span class="code-keyword">function</span></span></span><span\n        class="hljs-function"> </span><span class="code-title"><span class="hljs-function"><span class="code-title">updateColorMap</span></span></span><span\n        class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-params"><span\n        class="hljs-function"><span class="hljs-params">colormap</span></span></span><span class="hljs-function"><span\n        class="hljs-params">)</span></span> </span>{\n  <span class="code-keyword"><span class="code-keyword">return</span></span> {...colormap, right: <span\n            class="code-string"><span class="code-string">\'blue\'</span></span>};\n}</code></pre>\n<p>如果是构建React的App应用，那么以上方法都能够很好的支持，如果是在浏览器环境使用，需要引入polyfill机制。</p>\n\n<h4 id="h4-7">使用不可变的数据结构</h4>\n<p><a title="Immutable.js Github" href="https://github.com/facebook/immutable-js" rel="nofollow">Immutable.js</a>&nbsp;是解决数据突变问题的另外一种解决方案。它提供不可变、持久化的集合。集合包含下列结构：\n</p>\n<ul>\n    <li><em>Immutable</em>：一旦数据被创建，改集合不能在任何其他地方修改。</li>\n    <li><em>Persistent</em>：可以从已有的的数据集合（例如set）来创建新的数据集合。在创建新的数据集合后，已有的数据集合依然有效。</li>\n    <li>结构分享（<em>Structural Sharing</em>）：使用和原始数据尽可能相似的结构创建新的数据集合，并将复制降至最低，尽可能的提高效率。</li>\n</ul>\n<p>数据结构不可变的特性使跟踪数据变化变得很简单。任何变更将始终导致创建一个新的对象，所以我们只需要检查引用（指针地址）是否已经被修改即可确定数据是否已经修改。例如在常规的JavaScript代码中：</p>\n<pre class="actionscript"><code class="language-javascript"><span class="code-keyword"><span\n        class="code-keyword">const</span></span> x = { foo: <span class="code-string"><span\n        class="code-string">"bar"</span></span> };\n<span class="code-keyword"><span class="code-keyword">const</span></span> y = x;\ny.foo = <span class="code-string"><span class="code-string">"baz"</span></span>;\nx === y; <span class="code-comment"><span class="code-comment">// true</span></span></code></pre>\n<p>尽管y的值已经被修改，但是它和x都是同一个引用（指向相同的地址），因此最后的比较语句会返回true。我们可以使用&nbsp;immutable.js来修改代码：</p>\n<pre class="cs"><code class="language-javascript"><span class="code-keyword"><span\n        class="code-keyword">const</span></span> SomeRecord = Immutable.Record({ foo: <span class="hljs-literal"><span\n        class="hljs-literal">null</span></span>});\n<span class="code-keyword"><span class="code-keyword">const</span></span> x = <span class="code-keyword"><span\n            class="code-keyword">new</span></span> SomeRecord({ foo: <span class="code-string"><span\n            class="code-string">\'bar\'</span></span>});\n<span class="code-keyword"><span class="code-keyword">const</span></span> y = x.<span\n            class="code-keyword">set</span>(<span class="code-string"><span\n            class="code-string">\'foo\'</span></span>, <span class="code-string"><span\n            class="code-string">\'baz\'</span></span>);\nx === y; <span class="code-comment"><span class="code-comment">// false</span></span></code></pre>\n<p>在这个例子中，由于x突变时使用了新的引用，我们可以安全的假设x已经发生改变。</p>\n<p>还有两个库可以帮我们构建不可变数据：&nbsp;<a title="seamless-immutable" href="https://github.com/rtfeldman/seamless-immutable"\n                              rel="nofollow">seamless-immutable</a>&nbsp;and&nbsp;<a title="immutability-helper"\n        href="https://github.com/kolodny/immutability-helper" rel="nofollow">immutability-helper</a>。</p>\n<p>不可变的数据结构为我们跟踪数据对象变更提供了更加简便的方式，这是我们快速实现<code>shouldComponentUpdate</code>方法的基础。使用不可变数据后，可以为React提供不错的性能提升。</p>'},383:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<h2 id="h2-1"><span style="font-family:微软雅黑,microsoft yahei">调用堆栈</span></h2>\n<p><em>&nbsp;&nbsp;&nbsp;&nbsp;io.vertx.ext.mongo.impl.MongoClientImpl；</em></p>\n<p><em>&nbsp;&nbsp;&nbsp;&nbsp;io.vertx.ext.mongo.impl.MongoHolder;</em></p>\n<p><em>&nbsp;&nbsp;&nbsp;&nbsp;io.vertx.ext.mongo.impl.config.MongoClientOptionsParser;</em></p>\n\n<h2 id="h2-2">实现过程</h2>\n<p>当调用<em>MongoClient::createShared()</em>或<em>MongoClient::createNonShared()</em>方法创建<em>mongo</em>的客户端时，最终都会调用到<em>MongoClientImpl</em>的构造函数。</p>\n<pre class="kotlin"><code class="language-java"> <span class="hljs-function"><span class="code-keyword"><span class="code-keyword">public</span></span> <span class="code-title">MongoClientImpl</span><span class="hljs-params">(Vertx vertx, JsonObject config, String dataSourceName)</span> </span>{\n    Objects.requireNonNull(vertx);\n    Objects.requireNonNull(config);\n    Objects.requireNonNull(dataSourceName);\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.vertx = vertx;\n    <span class="code-comment"><span class="code-comment">// 检查或创建新的MongHolder</span></span>\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.holder = lookupHolder(dataSourceName, config);\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.mongo = holder.mongo();\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.useObjectId = config.getBoolean(<span class="code-string"><span class="code-string">"useObjectId"</span></span>, <span class="code-keyword"><span class="hljs-literal">false</span></span>);\n  }</code></pre>\n<p>如果是通过<em>createNonShared</em>方法创建client时，这里传入的<em>dataSourceName</em>是一个UUID。当使用<em>createShared</em>创建<em>client</em>,会在<em>lookupHolder</em>方法中检查是否已经创建了同名的客户端，否则新建。</p>\n<p>下图是检查数据源的过程。会根据传入的&nbsp;<em>datasourceName </em>从 <em>vertx </em>实例的共享数据实例（<em>io.vertx.core.shareddata.SharedData</em>）中获取同名的 <em>MongoHolder </em>实例。</p>\n<pre class="cpp"><code class="language-java"> <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">private</span></span></span><span class="hljs-function"> MongoHolder </span><span class="code-title"><span class="hljs-function"><span class="code-title">lookupHolder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String datasourceName, JsonObject config)</span></span></span><span class="hljs-function"> </span></span>{\n    <span class="code-keyword">synchronized</span> (vertx) {\n      <span class="code-comment"><span class="code-comment">// 获取共享数据实例中的map</span></span>\n      LocalMap&lt;String, MongoHolder&gt; <span class="code-built_in">map</span> = vertx.sharedData().getLocalMap(DS_LOCAL_MAP_NAME);\n\n      <span class="code-comment"><span class="code-comment">// 检查datasourceName对应的MongoHolder 是否存在</span></span>\n      MongoHolder theHolder = <span class="code-built_in">map</span>.get(datasourceName);\n\n      <span class="code-comment"><span class="code-comment">// 不存在则新构建，并将构建的结果放入sharedData的map中</span></span>\n      <span class="code-keyword"><span class="code-keyword">if</span></span> (theHolder == <span class="code-keyword">null</span>) {\n        theHolder = <span class="code-keyword"><span class="code-keyword">new</span></span> MongoHolder(config, () -&gt; removeFromMap(<span class="code-built_in">map</span>, datasourceName));\n        <span class="code-built_in">map</span>.put(datasourceName, theHolder);\n      } <span class="code-keyword"><span class="code-keyword">else</span></span> {\n        <span class="code-comment"><span class="code-comment">// 递增被引用的计数</span></span>\n        theHolder.incRefCount();\n      }\n      <span class="code-keyword"><span class="code-keyword">return</span></span> theHolder;\n    }\n  }</code></pre>\n<p>如果实例不存在，则会创建新的&nbsp;<em>MongoHolder </em>实例。<span style="color:#FF8C00">个人认为这里有个很不完美的地方是为了解决懒汉模式的问题，增加了一个线程锁。在高并发请求数据库连接资源时，这里会有阻塞。因此我在自己的实现类中存储了MongoClient的实例。不过这个线程锁可以有效减少数据库连接池的爆发式增长，在数据库连接池资源较少的情况下，有不错的效果（比如我们某个项目使用了阿里云的mongDB，最低配置只有200个连接）</span>。</p>\n<p>下图是&nbsp;<em>MongoHolder </em>的构造方法。</p>\n<pre class="kotlin"><code class="language-java"><span class="hljs-function"><span class="code-keyword"><span class="code-keyword">public</span></span> <span class="code-title">MongoHolder</span><span class="hljs-params">(JsonObject config, Runnable closeRunner)</span> </span>{\n      <span class="code-keyword"><span class="code-keyword">this</span></span>.config = config;\n      <span class="code-keyword"><span class="code-keyword">this</span></span>.closeRunner = closeRunner;\n    }</code></pre>\n<p><em>&nbsp;&nbsp;&nbsp;&nbsp;MongoHolder&nbsp;</em>构造方法只是简单的设置了成员变量 <em>config&nbsp;</em>和 <em>closeRunner </em>的值。<em>closeRunner</em>当调用<em>MongoClient::close()</em>方法时，用于回调销毁<em>SharedData::localMap</em>中的对应索引数据。<em>config </em>是用户传入的配置参数，需要注意的是，<em>config </em>传递到这里一直没有被改变。</p>\n<p>创建&nbsp;<em>MongoHolder&nbsp;</em>的实例成功后，接下来会调用&nbsp;<em>MongoHolder::mongo() </em>来创建一个真正&nbsp;<em>com.mongodb.async.client.MongoClient</em> 实例。这里同样使用了懒汉模式，存在线程锁，如果MongoClient的实例存在直接返回，如果不存在，则新建一个实例。</p>\n<pre class="java"><code class="language-java"><span class="code-keyword"><span class="code-keyword">synchronized</span></span> com.mongodb.async.client.<span class="hljs-function"><span class="hljs-function">MongoClient </span><span class="code-title"><span class="hljs-function"><span class="code-title">mongo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{\n      <span class="code-keyword"><span class="code-keyword">if</span></span> (mongo == <span class="code-keyword"><span class="code-keyword">null</span></span>) {\n        <span class="code-comment"><span class="code-comment">// 解析外部传递的config</span></span>\n        MongoClientOptionsParser parser = <span class="code-keyword"><span class="code-keyword">new</span></span> MongoClientOptionsParser(config);\n\n        <span class="code-comment"><span class="code-comment">// 将解析结果用于创建新的com.mongodb.async.client.MongoClient实例</span></span>\n        mongo = MongoClients.create(parser.settings());\n        String dbName = config.getString(<span class="code-string"><span class="code-string">"db_name"</span></span>, DEFAULT_DB_NAME);\n        db = mongo.getDatabase(dbName);\n      }\n      <span class="code-keyword"><span class="code-keyword">return</span></span> mongo;\n    }</code></pre>\n<p><em>&nbsp;&nbsp;&nbsp;&nbsp;MongoClientOptionsParser 对象</em>是创建Mongo客户端的关键，他会解析用户传递的参数来创建mongDB客户端，理解他的解析方法有利于创建合适的客户端。</p>\n<p><em>&nbsp;&nbsp;&nbsp;&nbsp;MongoClientOptionsParser </em>的构造方法共有60行，这里分几段说明。为了更好的理解创建过程，建议了解下<a title="MongoDB异步Java驱动" href="http://mongodb.github.io/mongo-java-driver/3.2/driver-async" rel="nofollow">MongoDB异步Java驱动</a>。下面的构造客户端参数的第一部分。</p>\n<pre class="gradle"><code class="language-java"> <span class="hljs-function"><span class="code-keyword"><span class="code-keyword">public</span></span> <span class="code-title">MongoClientOptionsParser</span><span class="hljs-params">(JsonObject config)</span> </span>{\n    Objects.requireNonNull(config);\n    \n    <span class="code-comment"><span class="code-comment">// 创建mongoDB的构建对象</span></span>\n    MongoClientSettings.Builder <span class="code-keyword">options</span> = MongoClientSettings.builder();\n\n    <span class="code-comment"><span class="code-comment">// 注册对象数据的存储规则</span></span>\n    <span class="code-keyword">options</span>.codecRegistry(CodecRegistries.fromRegistries(commonCodecRegistry, CodecRegistries.fromCodecs(<span class="code-keyword"><span class="code-keyword">new</span></span> JsonObjectCodec(config))));\n\n    <span class="code-comment"><span class="code-comment">// 获取连接串，所有的定义参数都来自连接串</span></span>\n    String cs = config.getString(<span class="code-string"><span class="code-string">"connection_string"</span></span>);\n\n    <span class="code-comment"><span class="code-comment">// 解析连接串</span></span>\n    ConnectionString connectionString = (cs == <span class="code-keyword"><span class="code-keyword">null</span></span>) ? <span class="code-keyword"><span class="code-keyword">null</span></span> : <span class="code-keyword"><span class="code-keyword">new</span></span> ConnectionString(cs);\n\n    <span class="code-comment"><span class="code-comment">// 解析集群参数</span></span>\n    ClusterSettings clusterSettings = <span class="code-keyword"><span class="code-keyword">new</span></span> ClusterSettingsParser(connectionString, config).settings();\n    <span class="code-keyword">options</span>.clusterSettings(clusterSettings);\n\n    <span class="code-comment"><span class="code-comment">// 解析连接池参数</span></span>\n    ConnectionPoolSettings connectionPoolSettings = <span class="code-keyword"><span class="code-keyword">new</span></span> ConnectionPoolSettingsParser(connectionString, config).settings();\n    <span class="code-keyword">options</span>.connectionPoolSettings(connectionPoolSettings);\n\n    <span class="code-comment"><span class="code-comment">// some code</span></span>\n}</code></pre>\n<p>首先创建&nbsp;<em>MongoClientSettings </em>的构造对象。</p>\n<p>然后根据传递的参数构建&nbsp;<em>CodecRegistry </em>实例。<em>CodecRegistry </em>的说明见 <a title="mongDB官网CodecRegistry的API说明" href="http://api.mongodb.com/java/3.2/?com/mongodb/async/client/MongoClientSettings.html" rel="nofollow">mongDB官网CodecRegistry的API说明</a>。<em>CodecRegistry 用于指定相关的对象在mongoDB的读写实现类，</em>例如官方已经源生实现了<em>&nbsp;StringCodec、IntegerCodec</em>来处理Java的<em>String、Integer</em>对象<em>。</em></p>\n<p>这段代码的最后部分，创建一个&nbsp;<em>ConnectionString&nbsp;</em>实例来分解和存储连接串的解析结果。<em>ConnectionString </em>是&nbsp;<em>mongoDB&nbsp;</em>官方实现的解析连接串参数方法<em>。</em>可以将http协议串解析成对应的初始化参数，例如设置连接池最小连接数为20，最大连接数为200：&nbsp;<span style="color:#FF8C00"><em>mongodb://host:27017/?minPoolSize=20&amp;maxPoolSize=200 </em></span>。详细说明见&nbsp;<a title="ConnectionString API" href="http://api.mongodb.com/java/3.2/?com/mongodb/ConnectionString.html" rel="nofollow"><em>ConnectionString&nbsp;</em>的API文档</a> &nbsp;和 <a title="mongoDB官方指引手册" href="http://mongodb.github.io/mongo-java-driver/3.2/driver-async/reference/connecting/connection-settings/" rel="nofollow">mongoDB官方指引手册</a>&nbsp;。</p>\n<p>下面的代码是&nbsp;<em>ClusterSettingsParser&nbsp;</em>对传入的数据进行解析，<em>vertx-mongdb</em>解析连接参数都是采用类似的思路：优先使用mongodb源生连接串中指定的参数，如果参数不存在，则使用用户传入的参数。因此，在我们设计mongodb的连接参数时，可以在传入的JsonObject实例中统一在key="connection_string"的参数中一次性制定mongdb风格的连接字符串，还可以在这个实例中通过key值设置vertx风格的各种连接参数。如果2个参数都存在，则优先使用连接字符串。</p>\n<pre class="java"><code class="java"><span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">public</span></span></span><span class="hljs-function"> </span><span class="code-title"><span class="hljs-function"><span class="code-title">ClusterSettingsParser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ConnectionString connectionString, JsonObject config)</span></span></span><span class="hljs-function"> </span></span>{\n\n    <span class="code-comment"><span class="code-comment">// 创建mongdb集群builder方法</span></span>\n    ClusterSettings.Builder settings = ClusterSettings.builder();\n\n    <span class="code-comment"><span class="code-comment">// 优先从连接字符串中使用mongdb源生方法解析相关参数 </span></span>\n    <span class="code-keyword"><span class="code-keyword">if</span></span> (connectionString != <span class="code-keyword"><span class="code-keyword">null</span></span>) {\n      settings.applyConnectionString(connectionString);\n    } <span class="code-keyword"><span class="code-keyword">else</span></span> {\n      <span class="code-comment"><span class="code-comment">// 如果连接字符串中相关的参数不存在，则从用户传入的config中提取指定的数据</span></span>\n      <span class="code-comment"><span class="code-comment">// 设置host列表</span></span>\n      <span class="code-comment"><span class="code-comment">// 在parseHosts中优先解析config是否存在包含key=hosts的JsonArray实例，如果有则会即系多个连接服务器</span></span>\n      <span class="code-comment"><span class="code-comment">// 如果没有key=hosts，则解析host和port是否存在</span></span>\n      List&lt;ServerAddress&gt; hosts = parseHosts(config);\n      settings.hosts(hosts);\n\n      <span class="code-comment"><span class="code-comment">// 设置mongdb的运行模式和replica模式</span></span>\n      String replicaSet = config.getString(<span class="code-string"><span class="code-string">"replicaSet"</span></span>);\n      <span class="code-keyword"><span class="code-keyword">if</span></span> (hosts.size() == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; replicaSet == <span class="code-keyword"><span class="code-keyword">null</span></span>) {\n        settings.mode(ClusterConnectionMode.SINGLE);\n      } <span class="code-keyword"><span class="code-keyword">else</span></span> {\n        settings.mode(ClusterConnectionMode.MULTIPLE);\n      }\n      <span class="code-keyword"><span class="code-keyword">if</span></span> (replicaSet != <span class="code-keyword"><span class="code-keyword">null</span></span>) {\n        settings.requiredReplicaSetName(replicaSet);\n      }\n    }\n\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.settings = settings.build();\n  }</code></pre>\n<p>这里就不一一说明每一个解析方法，基本上都是一样的套路。</p>\n<p>解析完连接参数后，用这些参数直接调用<em>MongoClients::create</em>来创建mongdb的客户端实例。然后从客户端从获取mongodb的连接。</p>\n\n<h2 id="h2-3"><span style="font-family:微软雅黑,microsoft yahei">总结</span></h2>\n<p>至此，mongdb的创建过程完毕。在创建的过程中，可以实现mongdb源生的连接串，也可以使用vertx风格的JsonObject。mongdb自身已经实现了全异步接口，因此vertx-mongdb只是在此基础上进行了一层封装。下面的附表是vertx-mongdb相关的设置参数。可以在建立vertx-mongdb实例时，通过JsonObject传入。</p>\n<pre class="actionscript"><code class="actionscript">{\n  <span class="code-comment"><span class="code-comment">// 设置单个mongdb服务时使用host、port指定主机和端口</span></span>\n  <span class="code-string"><span class="code-string">"host"</span></span> : <span class="code-string"><span class="code-string">"17.0.0.1"</span></span>, <span class="code-comment"><span class="code-comment">// string --mongdb实例所在的地址</span></span>\n  <span class="code-string"><span class="code-string">"port"</span></span> : <span class="hljs-number"><span class="hljs-number">27017</span></span>,      <span class="code-comment"><span class="code-comment">// int --mongdb实例的端口号</span></span>\n\n  <span class="code-comment"><span class="code-comment">// 设置集群mongdb服务器时使用队列</span></span>\n  <span class="code-string"><span class="code-string">"hosts"</span></span> : [\n    {\n      <span class="code-string"><span class="code-string">"host"</span></span> : <span class="code-string"><span class="code-string">"cluster1"</span></span>, <span class="code-comment"><span class="code-comment">// string --集群1地址</span></span>\n      <span class="code-string"><span class="code-string">"port"</span></span> : <span class="hljs-number"><span class="hljs-number">27000</span></span>       <span class="code-comment"><span class="code-comment">// int --集群1端口号</span></span>\n    },\n    {\n      <span class="code-string"><span class="code-string">"host"</span></span> : <span class="code-string"><span class="code-string">"cluster2"</span></span>, <span class="code-comment"><span class="code-comment">// string --集群2地址</span></span>\n      <span class="code-string"><span class="code-string">"port"</span></span> : <span class="hljs-number"><span class="hljs-number">28000</span></span>       <span class="code-comment"><span class="code-comment">// int --集群2端口号</span></span>\n    },\n    ...\n  ],\n\n  <span class="code-comment"><span class="code-comment">// 数据库分布式方法</span></span>\n  <span class="code-string"><span class="code-string">"replicaSet"</span></span> :  <span class="code-string"><span class="code-string">"foo"</span></span>    <span class="code-comment"><span class="code-comment">// string</span></span>\n\n  <span class="code-comment"><span class="code-comment">// 连接池参数</span></span>\n  <span class="code-string"><span class="code-string">"maxPoolSize"</span></span> : <span class="hljs-number"><span class="hljs-number">100</span></span>,                <span class="code-comment"><span class="code-comment">// int --最大连接数</span></span>\n  <span class="code-string"><span class="code-string">"minPoolSize"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>,                <span class="code-comment"><span class="code-comment">// int --最小连接数</span></span>\n  <span class="code-string"><span class="code-string">"maxIdleTimeMS"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>,          <span class="code-comment"><span class="code-comment">// long --单个连接空闲释放时间，0时表示没有时间限制</span></span>\n  <span class="code-string"><span class="code-string">"maxLifeTimeMS"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>,         <span class="code-comment"><span class="code-comment">// long --单个连接最大存活时间，0时表示灭有时间限制</span></span>\n  <span class="code-string"><span class="code-string">"waitQueueMultiple"</span></span>  : <span class="hljs-number"><span class="hljs-number">500</span></span>,         <span class="code-comment"><span class="code-comment">// int --等待获取连接的排队队列最大数量。</span></span>\n  <span class="code-string"><span class="code-string">"waitQueueTimeoutMS"</span></span> : <span class="hljs-number"><span class="hljs-number">120000</span></span>,      <span class="code-comment"><span class="code-comment">// long --等待获取连接的最大等待时间。</span></span>\n  <span class="code-string"><span class="code-string">"maintenanceFrequencyMS"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>,   <span class="code-comment"><span class="code-comment">// long</span></span>\n  <span class="code-string"><span class="code-string">"maintenanceInitialDelayMS"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="code-comment"><span class="code-comment">// long</span></span>\n\n  <span class="code-comment"><span class="code-comment">// 账户、密码、连接信息</span></span>\n  <span class="code-string"><span class="code-string">"username"</span></span>   : <span class="code-string"><span class="code-string">"john"</span></span>,     <span class="code-comment"><span class="code-comment">// string</span></span>\n  <span class="code-string"><span class="code-string">"password"</span></span>   : <span class="code-string"><span class="code-string">"passw0rd"</span></span>, <span class="code-comment"><span class="code-comment">// string</span></span>\n  <span class="code-string"><span class="code-string">"authSource"</span></span> : <span class="code-string"><span class="code-string">"some.db"</span></span>   <span class="code-comment"><span class="code-comment">// string</span></span>\n  <span class="code-string"><span class="code-string">"authMechanism"</span></span>     : <span class="code-string"><span class="code-string">"GSSAPI"</span></span>,        <span class="code-comment"><span class="code-comment">// string --认证机制相关配置，详情见http://docs.mongodb.org/manual/core/authentication/</span></span>\n  <span class="code-string"><span class="code-string">"gssapiServiceName"</span></span> : <span class="code-string"><span class="code-string">"myservicename"</span></span>, <span class="code-comment"><span class="code-comment">// string --Kerberos单点登录相关接口API配置。</span></span>\n\n  <span class="code-comment"><span class="code-comment">// 联网相关的配置</span></span>\n  <span class="code-string"><span class="code-string">"connectTimeoutMS"</span></span> : <span class="hljs-number"><span class="hljs-number">10000</span></span> , <span class="code-comment"><span class="code-comment">// int // --连接到mongdb数据库实例返回的等待时间</span></span>\n  <span class="code-string"><span class="code-string">"socketTimeoutMS"</span></span>  : <span class="hljs-number"><span class="hljs-number">0</span></span>,    <span class="code-comment"><span class="code-comment">// int // --通过socket完成数据库相关操作的等待与返回时间，0时表示没有限制。</span></span>\n  <span class="code-string"><span class="code-string">"sendBufferSize"</span></span>    : <span class="hljs-number"><span class="hljs-number">0</span></span>,  <span class="code-comment"><span class="code-comment">// int // --设置通过socket发送数据的缓存大小,0时表示使用操作系统默认值。</span></span>\n  <span class="code-string"><span class="code-string">"receiveBufferSize"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>,  <span class="code-comment"><span class="code-comment">// int --设置通过socket获取数据的缓存大小,0时表示使用操作系统默认值。</span></span>\n  <span class="code-string"><span class="code-string">"keepAlive"</span></span> : <span class="hljs-literal"><span class="hljs-literal">false</span></span>       <span class="code-comment"><span class="code-comment">// boolean --设置是否保持数据库连接，默认为false</span></span>\n\n  <span class="code-comment"><span class="code-comment">// 设置集群之间的心跳配置</span></span>\n  <span class="code-string"><span class="code-string">"heartbeat.socket"</span></span> : {\n  <span class="code-string"><span class="code-string">"connectTimeoutMS"</span></span> : <span class="hljs-number"><span class="hljs-number">300000</span></span>, <span class="code-comment"><span class="code-comment">// int </span></span>\n  <span class="code-string"><span class="code-string">"socketTimeoutMS"</span></span>  : <span class="hljs-number"><span class="hljs-number">100000</span></span>, <span class="code-comment"><span class="code-comment">// int</span></span>\n  <span class="code-string"><span class="code-string">"sendBufferSize"</span></span>    : <span class="hljs-number"><span class="hljs-number">8192</span></span>,  <span class="code-comment"><span class="code-comment">// int</span></span>\n  <span class="code-string"><span class="code-string">"receiveBufferSize"</span></span> : <span class="hljs-number"><span class="hljs-number">8192</span></span>,  <span class="code-comment"><span class="code-comment">// int</span></span>\n  <span class="code-string"><span class="code-string">"keepAlive"</span></span> : <span class="hljs-literal"><span class="hljs-literal">true</span></span>           <span class="code-comment"><span class="code-comment">// boolean</span></span>\n  }\n\n  <span class="code-comment"><span class="code-comment">// 设置客户端和mongdb实例的心跳测试</span></span>\n  <span class="code-string"><span class="code-string">"heartbeatFrequencyMS"</span></span> :    <span class="hljs-number"><span class="hljs-number">5000</span></span> <span class="code-comment"><span class="code-comment">// long 集群监视器监控到达每个mongdb实例的心跳频率</span></span>\n  <span class="code-string"><span class="code-string">"minHeartbeatFrequencyMS"</span></span> : <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="code-comment"><span class="code-comment">// long 当前客户端到服务器的监控频率</span></span>\n}</code></pre>\n'}});