webpackJsonp([6],{347:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h2 id="h2-1">Web组件</h2>\n<p>从概念上说，React 和 <a title="Web组件" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components" rel="nofollow">Web组件</a>&nbsp;分别用于解决不同的问题。Web组件提供了强大的封装特性来支持其可重复使用性，而React提供了一系列声明性（declarative）接口保证Dom结构和数据同步。但是某些时候这2个目标是互补的。对于开发人员来说将React用于Web组件、或将Web组件用于React、或2者皆有并非难事。\n</p>\n<p>虽然大部分使用React的开发人员并不需要使用Web组件，但是在某些情况，特别是引入了某些第三方库，还是需要使用到相关机制。</p>\n\n<h3 id="h3-1">在React中使用Web组件</h3>\n<pre class="scala"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span\n        class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span\n        class="code-title"><span class="hljs-class"><span class="code-title">HelloMessage</span></span></span><span\n        class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="xml"><span class="code-tag">&lt;<span\n            class="code-name">div</span>&gt;</span><span class="code-type">Hello</span> <span class="code-tag">&lt;<span\n            class="code-name">x-search</span>&gt;</span>{<span class="code-keyword">this</span>.props.name}<span\n            class="code-tag">&lt;/<span class="code-name">x-search</span>&gt;</span>!<span class="code-tag">&lt;/<span\n            class="code-name">div</span>&gt;</span>;\n  }\n}</span></code></pre>\n<blockquote>\n    <p>Web组件常会暴露一些必要的API接口，例如一个 video Web组件可能会暴露&nbsp;&nbsp;<code>play()</code>&nbsp;和&nbsp;<code>pause()</code>&nbsp;方法。为了获取Web组件暴露的这些API接口，需要在React编码使用Refs特性来直接获取真实的Dom节点。如果引入第三方的Web组件，最好的解决方案使用一个React组件来包装引入的Web组件并最终作为一个React组件来使用。\n    </p>\n    <p>由第三方Web组件触发的事件也许并不能通过React的渲染树传递，此时需要在组件中去手工的触发事件。&nbsp;</p>\n</blockquote>\n<p>一个经常导致混乱的地方是，Web组件使用的是“class”而React使用的是“className”，例如：</p>\n<pre class="javascript"><code class="language-javascript"><span class="hljs-function"><span class="code-keyword"><span\n        class="hljs-function"><span class="code-keyword">function</span></span></span><span\n        class="hljs-function"> </span><span class="code-title"><span class="hljs-function"><span class="code-title">BrickFlipbox</span></span></span><span\n        class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span\n        class="hljs-params"></span>) </span></span>{\n  <span class="code-keyword"><span class="code-keyword">return</span></span> (\n    <span class="xml"><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span\n            class="code-name">brick-flipbox</span></span></span></span><span class="xml"><span class="code-tag"> </span></span><span\n            class="hljs-attr"><span class="xml"><span class="code-tag"><span\n            class="hljs-attr">class</span></span></span></span><span class="xml"><span\n            class="code-tag">=</span></span><span class="code-string"><span class="xml"><span class="code-tag"><span\n            class="code-string">"demo"</span></span></span></span><span class="xml"><span\n            class="code-tag">&gt;</span></span></span><span class="xml">\n      </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">div</span></span></span></span><span\n            class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">front</span><span\n            class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span\n            class="xml"><span class="code-tag"><span class="code-name">div</span></span></span></span><span class="xml"><span\n            class="code-tag">&gt;</span></span></span><span class="xml">\n      </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">div</span></span></span></span><span\n            class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">back</span><span\n            class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span\n            class="xml"><span class="code-tag"><span class="code-name">div</span></span></span></span><span class="xml"><span\n            class="code-tag">&gt;</span></span></span><span class="xml">\n    </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span\n            class="code-name">brick-flipbox</span></span></span></span><span class="xml"><span\n            class="code-tag">&gt;</span></span></span><span class="xml">\n  );\n}</span></span></code></pre>\n\n<h3 id="h3-2">在Web组件中使用React</h3>\n<pre class="javascript"><code class="language-javascript"><span class="code-keyword"><span\n        class="code-keyword">const</span></span> proto = <span class="code-built_in"><span\n        class="code-built_in">Object</span></span>.create(HTMLElement.prototype, {\n  attachedCallback: {\n    value: <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">function</span></span></span><span class="hljs-function">(</span><span\n            class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{\n      <span class="code-keyword"><span class="code-keyword">const</span></span> mountPoint = <span\n            class="code-built_in"><span class="code-built_in">document</span></span>.createElement(<span\n            class="code-string"><span class="code-string">\'span\'</span></span>);\n      <span class="code-keyword"><span class="code-keyword">this</span></span>.createShadowRoot().appendChild(mountPoint);\n\n      <span class="code-keyword"><span class="code-keyword">const</span></span> name = <span class="code-keyword"><span\n            class="code-keyword">this</span></span>.getAttribute(<span class="code-string"><span class="code-string">\'name\'</span></span>);\n      <span class="code-keyword"><span class="code-keyword">const</span></span> url = <span class="code-string"><span\n            class="code-string">\'https://www.google.com/search?q=\'</span></span> + <span class="code-built_in"><span\n            class="code-built_in">encodeURIComponent</span></span>(name);\n      ReactDOM.render(<span class="xml"><span class="code-tag"><span class="xml"><span\n            class="code-tag">&lt;</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span\n            class="code-name">a</span></span></span></span><span class="xml"><span class="code-tag"> </span></span><span\n            class="hljs-attr"><span class="xml"><span class="code-tag"><span class="hljs-attr">href</span></span></span></span><span\n            class="xml"><span class="code-tag">=</span></span><span class="code-string"><span class="xml"><span\n            class="code-tag"><span class="code-string">{url}</span></span></span></span><span class="xml"><span\n            class="code-tag">&gt;</span></span></span><span class="xml">{name}</span><span class="code-tag"><span\n            class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span class="xml"><span\n            class="code-tag"><span class="code-name">a</span></span></span></span><span class="xml"><span\n            class="code-tag">&gt;</span></span></span></span>, mountPoint);\n    }\n  }\n});\n<span class="code-built_in"><span class="code-built_in">document</span></span>.registerElement(<span\n            class="code-string"><span class="code-string">\'x-search\'</span></span>, {prototype: proto});</code></pre>\n\n<h3 id="h3-3">React整合Jquery这一类直接操作Dom的技术</h3>\n<p>\n    React在发生真实Dom渲染之前都会先产生与之对应的虚拟Dom结构，然后再“合适”的时候将虚拟Dom的内容渲染到真实Dom上，完成渲染之后componentDidMount会被调用。Jquery这一类真实Dom的操作技术投入实际使用时最好在componentDidMount中使用，然后保证这个组件不会的虚拟Dom不发生任何改变。</p>'},354:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h2 id="h2-1">React</h2>\n<p>本文记录了本人以及目前团队从无到有使用React的过程，我们将从webpack开始说起，一步一步展现React最基本的开发生态。在这里并不会介绍任何jsx或es6相关的语法，只聚焦于如何使用react生态搭建利于团队协作、有利于提升开发效率的开发环境。</p>\n\n<h2 id="h2-2">脚手架工具——webpack&nbsp;</h2>\n<p>工欲善必须利其器，想要高效的开发react，必须保证有一个高效有序的开发环境。我们使用的是Facebook开源的脚手架工具——webpack来搭建一个完全不依赖服务器的开发环境。实现高效集成、实时编辑可见、动态编译jsx和es6等强悍功能。</p>\n\n<h3 id="h3-1">添加webpack</h3>\n<p>webpack最早是Facebook的instagram团队研发出的脚手架工具，用于支持前端系统的开发。虽然webpack一直都和react嵌套在一起使用，但是他的使用场景并不局限于react，你可以把他应用于所有的前端开发场景。</p>\n<p>webpack也是依赖nodejs和npm的，在安装webpack之前务必先安装nodejs的环境，如果在此之前你还没有安装nodejs的环境，可以看这篇<a title="nodejs安装介绍" href="http://www.chkui.com/article/nodeJs/install_nodejs_runtime_environment">关于nodejs安装</a>的文章获得一些参考。</p>\n<p>可以像下面这样安装一个全局的webpack环境。</p>\n<pre class=""><code class=""><span class="code-variable"><span class="code-variable">$ </span></span>npm install webpack -g</code></pre>\n<p>或者以依赖工程的方式安装</p>\n<pre class=""><code class=""><span class="code-comment"><span class="code-comment"># 进入项目目录</span></span>\n<span class="code-comment"><span class="code-comment"># 确定已经有 package.json，没有就通过 npm init 创建</span></span>\n<span class="code-comment"><span class="code-comment"># 安装 webpack 依赖</span></span>\n<span class="code-variable"><span class="code-variable">$ </span></span>npm install webpack --save-dev</code></pre>\n\n<h3 id="h3-2">测试运行webpack</h3>\n<p>（本例子的代码存放在：<a title="React搭建开发环境示例代码" href="https://github.com/chkui/webpack-demo" rel="nofollow">https://github.com/chkui/webpack-demo</a>。下载后用 npm install 下载npm依赖即可使用。）</p>\n<p>Setp1:简单打包</p>\n<p>首先我们增加一些用于测试元素。先写一个index.html</p>\n<pre class="xml"><code class="language-html xml"><span class="code-meta"><span class="code-meta">&lt;!DOCTYPE html&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span class="code-name">html</span></span></span><span class="code-tag"> </span><span class="hljs-attr"><span class="code-tag"><span class="hljs-attr">lang</span></span></span><span class="code-tag">=</span><span class="code-string"><span class="code-tag"><span class="code-string">"en"</span></span></span><span class="code-tag">&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span class="code-name">head</span></span></span><span class="code-tag">&gt;</span></span>\n    <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span class="code-name">meta</span></span></span><span class="code-tag"> </span><span class="hljs-attr"><span class="code-tag"><span class="hljs-attr">charset</span></span></span><span class="code-tag">=</span><span class="code-string"><span class="code-tag"><span class="code-string">"UTF-8"</span></span></span><span class="code-tag">&gt;</span></span>\n    <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span class="code-name">title</span></span></span><span class="code-tag">&gt;</span></span>Title<span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span class="code-name">title</span></span></span><span class="code-tag">&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span class="code-name">head</span></span></span><span class="code-tag">&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span class="code-name">body</span></span></span><span class="code-tag">&gt;</span></span>\n    <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span class="code-name">script</span></span></span><span class="code-tag"> </span><span class="hljs-attr"><span class="code-tag"><span class="hljs-attr">src</span></span></span><span class="code-tag">=</span><span class="code-string"><span class="code-tag"><span class="code-string">"bundle.js"</span></span></span><span class="code-tag">&gt;</span></span><span class="undefined"></span><span class="code-tag"><span class="undefined"></span><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span class="code-name">script</span></span></span><span class="code-tag">&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span class="code-name">body</span></span></span><span class="code-tag">&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span class="code-name">html</span></span></span><span class="code-tag">&gt;</span></span></code></pre>\n<p>然后添加一个entry.js</p>\n<pre class="javascript"><code class="language-javascript"><span class="code-comment"><span class="code-comment">/**\n * Created by chkui on 2016/11/16.\n */</span></span>\n<span class="code-built_in"><span class="code-built_in">require</span></span>(<span class="code-string"><span class="code-string">"!style!css!./style.css"</span></span>);\n<span class="code-built_in"><span class="code-built_in">document</span></span>.write(<span class="code-string"><span class="code-string">\'&lt;h1&gt;hello webpack&lt;/h1&gt;\'</span></span>);</code></pre>\n<p>然后就可以执行打包命令了：</p>\n<pre class=""><code class="language-bash"><span class="code-variable">$ </span>webpack ./entry.js bundle.js</code></pre>\n<p>运行以后，就会发现在目录中生成了一个bundle.js文件。浏览器中打开index.html就会看到执行效果。</p>\n<p>Step2:利用webpack分析工具打包&nbsp;</p>\n<p>增加一个名为module.js的文件：</p>\n<pre class="javascript"><code class="language-javascript"><span class="code-comment"><span class="code-comment">/**\n * Created by chkui on 2016/11/16.\n */</span></span>\n<span class="code-built_in"><span class="code-built_in">module</span></span>.exports = <span class="code-string"><span class="code-string">\'It works from module.js.\'</span></span></code></pre>\n<p>在原来的entry.js增加引用：</p>\n<pre class="javascript"><code class="language-javascript"><span class="code-comment"><span class="code-comment">/**\n * Created by chkui on 2016/11/16.\n */</span></span>\n<span class="code-built_in"><span class="code-built_in">require</span></span>(<span class="code-string"><span class="code-string">"!style!css!./style.css"</span></span>);\n<span class="code-built_in"><span class="code-built_in">document</span></span>.write(<span class="code-string"><span class="code-string">\'&lt;h1&gt;hello webpack&lt;/h1&gt;\'</span></span>);\n<span class="code-comment"><span class="code-comment">//新增对module.js的引用</span></span>\n<span class="code-built_in"><span class="code-built_in">document</span></span>.write(<span class="code-built_in"><span class="code-built_in">require</span></span>(<span class="code-string"><span class="code-string">\'./module.js\'</span></span>));</code></pre>\n<p>然后同样执行webpack打包命令：</p>\n<pre class=""><code class="language-bash"><span class="code-variable">$ </span>webpack ./entry.js bundle.js</code></pre>\n<p>然后在打开index.html，会发现我们新增加的module.js的内容被正确输出。这是因为我们在页面中通过nodejs的require的方式引入的module.js，而使用webpack打包时会自动在依赖关系中引入module.js。</p>\n\n<h3 id="h3-3">加载器</h3>\n<p>webpack提供了一个非常强大的loader功能，这个功能可以用于管理各种依赖关系模块，在webpack中所有的文件都视作一个模块。</p>\n<p>首先npm导入webpack loader：</p>\n<pre class="sql"><code class="language-bash">npm <span class="code-keyword">install</span> css-loader <span class="code-keyword">style</span>-loader</code></pre>\n<p>添加一个用于测试的style.css文件：</p>\n<pre class="css"><code class="language-css"><span class="code-selector-tag"><span class="code-selector-tag">h1</span></span>{\n    <span class="code-attribute"><span class="code-attribute">color</span></span>:red;\n}</code></pre>\n<p>在entry.js中添加引用：</p>\n<pre class="javascript"><code class="language-javascript"><span class="code-comment"><span class="code-comment">/**\n * Created by chkui on 2016/11/16.\n */</span></span>\n<span class="code-built_in"><span class="code-built_in">require</span></span>(<span class="code-string"><span class="code-string">"!style!css!./style.css"</span></span>);<span class="code-comment"><span class="code-comment">//添加对css的引用</span></span>\n<span class="code-built_in"><span class="code-built_in">document</span></span>.write(<span class="code-string"><span class="code-string">\'&lt;h1&gt;hello webpack&lt;/h1&gt;\'</span></span>);\n<span class="code-built_in"><span class="code-built_in">document</span></span>.write(<span class="code-built_in"><span class="code-built_in">require</span></span>(<span class="code-string"><span class="code-string">\'./module.js\'</span></span>));</code></pre>\n<p>使用命令行打包：</p>\n<pre class=""><code class="language-bash">webpack ./entry.js bundle.js --<span class="code-keyword">module</span>-bind <span class="code-string"><span class="code-string">\'css=style!css\'</span></span></code></pre>\n<p>会发现css的样式生效了。可以将繁琐的“!style!css!./style.css”简写成"./style.css"。</p>\n\n<h3 id="h3-4">使用配置管理</h3>\n<p>细心的人会发现，我们每次使用命令行打包都带了大量的参数，这样不仅繁琐更不利于规模化使用。webpack同样可以使用标准化配置文件来替代命令行中的各种参数。</p>\n<p>webpack的配置文件是nodejs的文件，通常命名为&nbsp;<code>webpack.config.js</code>。我们在工程中增加配置文件：</p>\n<pre class="typescript"><code class="language-javascript"><span class="code-comment"><span class="code-comment">/**\n * Created by chkui on 2016/11/16.\n */</span></span>\n<span class="code-built_in"><span class="code-built_in">module</span></span>.exports = {\n    entry: <span class="code-string"><span class="code-string">\'./entry.js\'</span></span>,<span class="code-comment"><span class="code-comment">//定义要引入的js文件</span></span>\n    output: {\n        path: __dirname,\n        filename: <span class="code-string"><span class="code-string">\'bundle.js\'</span></span> <span class="code-comment"><span class="code-comment">//定义要输出的js文件</span></span>\n    },\n    <span class="code-built_in"><span class="code-keyword">module</span></span>: {\n        loaders: [<span class="code-comment"><span class="code-comment">//定义加载内容</span></span>\n            {test: <span class="hljs-regexp"><span class="hljs-regexp">/\\.css$/</span></span>, loader: <span class="code-string"><span class="code-string">\'style!css\'</span></span>}\n        ]\n    }\n}</code></pre>\n<p>现在，我们在命令行中输入webpack就可以实现和前面一样的打包。</p>\n\n<h3 id="h3-5">丰富打包输出内容</h3>\n<p>可以使用：</p>\n<pre class="lua"><code class="lua">webpack <span class="code-comment"><span class="code-comment">--progress --colors</span></span></code></pre>\n<p>命令来丰富打包输出的内容，更容易了解出现的问题。</p>\n\n<h3 id="h3-6">监听更新模式</h3>\n<p>在我们进行编码开发的时候，每次对文件的编辑我们都想立即看到编译效果，如果每次编辑都要去打包，会非常麻烦。webpack提供了一个监听模式（类似grunt的watch），用于监听每次对文件的修改，修改后会立即进行增量更新。启用监听模式：</p>\n<pre class="lua"><code class="lua">webpack <span class="code-comment"><span class="code-comment">--progress --colors --watch</span></span></code></pre>\n<p>监听模式使用的是内存增量更新。webpack会将所有需要打包的文件copy到内存，然后监控文件修改，如果文件发生了修改，会将修改的文件替换内存中的对应文件。因此开发完之后，切记进行一次手动打包才能生效。</p>\n\n<h3 id="h3-7">开发环境模式</h3>\n<p>webpack更强大的是，他整合了nodejs的express提供了一个静态服务器。（虽然没有官方正式，我觉得webstrom和微信本地开发环境都是整合的nodejs的express）</p>\n<p>使用了开发环境模式，我们所有的动态修改和操作都可以实时看到效果，并且解决了静态资源各种路径引用的问题。首先npm安装工具：</p>\n<pre class="sql"><code class="language-bash">npm <span class="code-keyword">install</span> webpack-dev-<span class="code-keyword">server</span> -g</code></pre>\n<p>然后使用命令行工具启用开发环境：</p>\n<pre class="lua"><code class="language-bash">webpack-dev-server <span class="code-comment">--progress --colors</span></code></pre>\n<p>webpack的开发环境模式很强悍，比使用--watch更犀利的地方在于可以实现编辑即可见。浏览器立即同步刷新运行。开发环境模式可以延伸到生产环境实现代码同步级别的热部署。&nbsp;</p>\n\n<h4 id="h4-1">开发环境扩展——Linux下文件变化监控个数配置</h4>\n<p>webpack在linux下监控文件的变化用到了 Inotify机制。有可能在文件比较多的时候修改、编辑文件无法触发webpack热部署。我们可以通过一下方式检测并调整监控文件个数：</p>\n<pre class="tcl"><code class="language-bash"><span class="code-comment"><span class="code-comment">#检查inotify监控文件的个数</span></span>\ncat /<span class="code-keyword">proc</span>/sys/fs/inotify/max_user_watches</code></pre>\n<p>然后可以</p>\n<pre class="bash"><code class="language-bash"><span class="code-comment"><span class="code-comment">#将同时监控的文件个数修改为18000</span></span>\n<span class="code-built_in"><span class="code-built_in">echo</span></span> fs.inotify.max_user_watches=18000 | sudo tee <span class="hljs-_"><span class="hljs-_">-a</span></span> /etc/sysctl.conf &amp;&amp; sudo sysctl -p\n</code></pre>\n<p>再次查看个数可以看到输出已经配置的参数</p>\n\n<h4 id="h4-2">开发环境扩展——webstorm的坑</h4>\n<p>由于本人的前端页面使用webstorm开发，在使用过程中发现了一个webstorm的坑。webstorm有文件缓存的功能，在编辑完毕保存之后并不会实时的更新磁盘文件，这样的就导致webpack的开发环境无法同步更新文件。以下是解决方法：</p>\n<p>1.File-&gt;settings-&gt;System Settings</p>\n<p>2.找到弹出框的Use "safe write"，将其勾选解除。</p>\n<p><img alt="React 搭建开发环境" height="507" src="https://file.mahoooo.com/res/file/react_establish_development_environment_1.png" width="1020"></p>\n\n<h3 id="h3-8">输出调试信息</h3>\n<p>webpack的配置较为复杂，一不小心就会出现错误。它提供了一个输出调试信息的参数：</p>\n<pre class="lua"><code class="language-bash">$ webpack <span class="code-comment">--display-error-details</span></code></pre>\n<p>调试运行webpack命令出错的时候使用。Webpack 中涉及路径配置最好使用绝对路径，建议通过&nbsp;<code>path.resolve(__dirname, "app/folder")</code>&nbsp;或&nbsp;<code>path.join(__dirname, "app", "folder")</code>&nbsp;的方式来配置，以兼容 Windows 环境。</p>\n\n<h3 id="h3-9">webpack插件</h3>\n<p>某些时候，webpack的常规功能无法满足我们的需求，我们可以为webpack开发插件，或者使用其他开发团队已经完成的插件。</p>\n<p>下面是一个插件的标准格式：</p>\n<pre class="javascript"><code class="language-javascript"><span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">function</span></span></span><span class="hljs-function"> </span><span class="code-title"><span class="hljs-function"><span class="code-title">MyPlugin</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options</span></span></span><span class="hljs-function">) </span></span>{\n  <span class="code-comment"><span class="code-comment">// Configure your plugin with options...</span></span>\n}\n\nMyPlugin.prototype.apply = <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">compiler</span></span></span><span class="hljs-function">) </span></span>{\n  compiler.plugin(<span class="code-string"><span class="code-string">"compile"</span></span>, <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">params</span></span></span><span class="hljs-function">) </span></span>{\n    <span class="code-built_in"><span class="code-built_in">console</span></span>.log(<span class="code-string"><span class="code-string">"The compiler is starting to compile..."</span></span>);\n  });\n\n  compiler.plugin(<span class="code-string"><span class="code-string">"compilation"</span></span>, <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">compilation</span></span></span><span class="hljs-function">) </span></span>{\n    <span class="code-built_in"><span class="code-built_in">console</span></span>.log(<span class="code-string"><span class="code-string">"The compiler is starting a new compilation..."</span></span>);\n\n    compilation.plugin(<span class="code-string"><span class="code-string">"optimize"</span></span>, <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{\n      <span class="code-built_in"><span class="code-built_in">console</span></span>.log(<span class="code-string"><span class="code-string">"The compilation is starting to optimize files..."</span></span>);\n    });\n  });\n\n  compiler.plugin(<span class="code-string"><span class="code-string">"emit"</span></span>, <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">compilation, callback</span></span></span><span class="hljs-function">) </span></span>{\n    <span class="code-built_in"><span class="code-built_in">console</span></span>.log(<span class="code-string"><span class="code-string">"The compilation is going to emit files..."</span></span>);\n    callback();\n  });\n};\n\n<span class="code-built_in"><span class="code-built_in">module</span></span>.exports = MyPlugin;</code></pre>\n<p>需要实现什么功能，可以按照这个标准去开发自己的插件。</p>\n\n<h2 id="h2-3">React开发</h2>\n<p>使用webpack搭建好开发环境后，我们就可以开始着手开发react了。开始之前，我们还是要优先完成开发环境的配置和搭建。</p>\n<p>react使用的语法是jsx，现在还新增了对es6的支持。为了可以高效开发，我们需要使用webpack的loader功能，将jsx或es6使用语法糖转义成浏览器可以识别的标准JavaScript语法。</p>\n<p>下面将继续在前文webpack的基础上继续说明如何开发react。</p>\n\n<h3 id="h3-10">安装必要的依赖工具</h3>\n<p>react的基础工具包：</p>\n<pre class="sql"><code class="language-bash">$ npm <span class="code-keyword">install</span> react <span class="code-comment">--save-dev</span></code></pre>\n<p>react的dom组件：</p>\n<pre class="sql"><code class="language-bash">$ npm <span class="code-keyword">install</span> react react-dom <span class="code-comment">--save-dev</span></code></pre>\n<p>在前面介绍webpack的时候已经介绍了加载器的概念，这里需要额外安装babel用于对react的jsx风格的编码进行解析，babel除了jsx外还可以解析es6等。安装babel：</p>\n<pre class=""><code class="language-bash"><span class="code-variable">$ </span>npm install babel-loader</code></pre>\n<p>安装babel-loader之后\\node_modules目录中会额外多安装一个babel-core，这是babel的核心包。</p>\n<p>有了babel，我们还需要安装编码转换规则，用于解析jsx、es6等等。</p>\n<pre class="sql"><code class="language-bash">$ npm <span class="code-keyword">install</span> babel-preset-es2015 babel-preset-react <span class="code-comment">--save-dev</span></code></pre>\n<p>除了babel提供的es6和jsx，webpack还可以使用各种loader来转换编码，比如coffeescript等。想要什么就去google找吧。</p>\n\n<h3 id="h3-11">完善本地开发环境命令</h3>\n<p>前面的案例使用 webpack-dev-server 来热部署本地开发环境提升开发效率。但是每次都靠长长的命令行启动和停止太过于繁琐。我们可以利用npm的package.json配置脚本运行来统一管理脚本命令：</p>\n<pre class="actionscript"><code class="language-javascript">{\n  <span class="code-string"><span class="code-string">"name"</span></span>: <span class="code-string"><span class="code-string">"demo2-react"</span></span>,\n  <span class="code-string"><span class="code-string">"version"</span></span>: <span class="code-string"><span class="code-string">"1.0.0"</span></span>,\n  <span class="code-string"><span class="code-string">"description"</span></span>: <span class="code-string"><span class="code-string">"react demo"</span></span>,\n  <span class="code-string"><span class="code-string">"main"</span></span>: <span class="code-string"><span class="code-string">"index.js"</span></span>,\n  <span class="code-string"><span class="code-string">"scripts"</span></span>:{\n    <span class="code-string"><span class="code-string">"dev"</span></span>: <span class="code-string"><span class="code-string">"webpack-dev-server --progress --colors --inline"</span></span> <span class="code-comment"><span class="code-comment">//配置运行命令</span></span>\n  },\n  <span class="code-comment"><span class="code-comment">//more</span></span>\n}</code></pre>\n<p>添加了scripts后，我们今后只需要运行</p>\n<pre class=""><code class="language-bash"><span class="code-variable">$ </span>npm run dev</code></pre>\n<p>即可使用配置好的命令行参数启动本地开发环境服务器。</p>\n\n<h3 id="h3-12">终于可以开始码农的核心工作了</h3>\n<p>（demo代码存放在：<a title="React搭建开发环境示例代码" href="https://github.com/chkui/react-demo" rel="nofollow">https://github.com/chkui/react-demo</a>。下载后用 npm install 下载npm依赖即可使用）</p>\n<p>前面准备了这么久，就是为了随后我们可以快乐的编码。首先我们按照下面这个结构创建工程结构：</p>\n<pre class="haml"><code class="haml"><span class="code-comment"><span class="code-comment">/root</span></span>\n-<span class="ruby"><span class="ruby">-</span><span class="hljs-regexp"><span class="ruby"><span class="hljs-regexp">/dev\n</span></span></span></span>-<span class="ruby"><span class="hljs-regexp"><span class="ruby"><span class="hljs-regexp">---/js</span></span></span><span class="ruby">\n</span></span>-<span class="ruby"><span class="ruby">-----</span><span class="hljs-regexp"><span class="ruby"><span class="hljs-regexp">/index\n</span></span></span></span>-<span class="ruby"><span class="hljs-regexp"><span class="ruby"><span class="hljs-regexp">-------/comps</span></span></span><span class="ruby">\n</span></span>-<span class="ruby"><span class="ruby">---------component1.jsx\n</span></span>-<span class="ruby"><span class="ruby">---------main.jsx\n</span></span>-<span class="ruby"><span class="ruby">-------index.js\n</span></span>-<span class="ruby"><span class="ruby">---</span><span class="hljs-regexp"><span class="ruby"><span class="hljs-regexp">/style\n</span></span></span></span>-<span class="ruby"><span class="hljs-regexp"><span class="ruby"><span class="hljs-regexp">-----/index</span></span></span><span class="ruby">\n</span></span>-<span class="ruby"><span class="ruby">-------index.css\n</span></span>-<span class="ruby"><span class="ruby">---index.html</span></span></code></pre>\n<p>然后根据工程的结构修改我们的webpack.config.js：</p>\n<pre class="typescript"><code class="language-javascript"><span class="code-comment"><span class="code-comment">/**\n * Created by Administrator on 2016/11/17.\n */</span></span>\n<span class="code-keyword"><span class="code-keyword">var</span></span> path = <span class="code-built_in"><span class="code-built_in">require</span></span>(<span class="code-string"><span class="code-string">\'path\'</span></span>);\n<span class="code-built_in"><span class="code-built_in">module</span></span>.exports = {\n    entry: [<span class="code-string"><span class="code-string">\'./dev/js/index/comps/main.jsx\'</span></span>],<span class="code-comment"><span class="code-comment">//定义要引入的js文件</span></span>\n    output: {\n        path: __dirname,\n        filename: <span class="code-string"><span class="code-string">\'./dev/js/index/index.js\'</span></span> <span class="code-comment"><span class="code-comment">//定义要输出的js文件</span></span>\n    },\n    <span class="code-built_in"><span class="code-keyword">module</span></span>: {\n        loaders: [{\n            test: <span class="hljs-regexp"><span class="hljs-regexp">/\\.js[x]?$/</span></span>,\n            exclude: <span class="hljs-regexp"><span class="hljs-regexp">/(node_modules|bower_components)/</span></span>,\n            loader: <span class="code-string"><span class="code-string">\'babel-loader\'</span></span>,\n            query: {\n                presets: [<span class="code-string"><span class="code-string">\'es2015\'</span></span>,<span class="code-string"><span class="code-string">\'react\'</span></span>]\n            }\n        }, {\n            test: <span class="hljs-regexp"><span class="hljs-regexp">/\\.css$/</span></span>,\n            loader: <span class="code-string"><span class="code-string">\'style!css\'</span></span>\n        }, {\n            test: <span class="hljs-regexp"><span class="hljs-regexp">/\\.(png|jpg)$/</span></span>,\n            loader: <span class="code-string"><span class="code-string">\'url?limit=25000\'</span></span> <span class="code-comment"><span class="code-comment">//只解析小于25000字节的图片</span></span>\n        }]\n    }\n};</code></pre>\n<p>和前面介绍webpack的例子相比，这里的配置文件新增了了一个babel-loader的配置。</p>\n<p>test后的正则表达式表示对所有的js或者jsx文件进行解析；</p>\n<p>exclude表示不解析npm安装目录下和bower安装目录下的文件；</p>\n<p>loader表示使用的解析工具；</p>\n<p>query表示扩展参数，这里的\'es2015\'和\'react\'表示启用babel-preset-es2015和bable-preset-react解析规则。这里需要注意的是解析的优先级的倒序的，即会先解析‘react’。</p>\n<p>然后我们添加编码内容（所有的例子都分别实现了jsx规范和es2015规范）：</p>\n<p>index.html：</p>\n<pre class="xml"><code class="language-html xml"><span class="code-meta"><span class="code-meta">&lt;!DOCTYPE html&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span class="code-name">html</span></span></span><span class="code-tag"> </span><span class="hljs-attr"><span class="code-tag"><span class="hljs-attr">lang</span></span></span><span class="code-tag">=</span><span class="code-string"><span class="code-tag"><span class="code-string">"en"</span></span></span><span class="code-tag">&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span class="code-name">head</span></span></span><span class="code-tag">&gt;</span></span>\n    <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span class="code-name">meta</span></span></span><span class="code-tag"> </span><span class="hljs-attr"><span class="code-tag"><span class="hljs-attr">charset</span></span></span><span class="code-tag">=</span><span class="code-string"><span class="code-tag"><span class="code-string">"UTF-8"</span></span></span><span class="code-tag">&gt;</span></span>\n    <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span class="code-name">title</span></span></span><span class="code-tag">&gt;</span></span>Title<span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span class="code-name">title</span></span></span><span class="code-tag">&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span class="code-name">head</span></span></span><span class="code-tag">&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span class="code-name">body</span></span></span><span class="code-tag">&gt;</span></span>\n    <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span class="code-name">div</span></span></span><span class="code-tag"> </span><span class="hljs-attr"><span class="code-tag"><span class="hljs-attr">id</span></span></span><span class="code-tag">=</span><span class="code-string"><span class="code-tag"><span class="code-string">"comp"</span></span></span><span class="code-tag">&gt;</span></span><span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span class="code-name">div</span></span></span><span class="code-tag">&gt;</span></span>\n    <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span class="code-name">script</span></span></span><span class="code-tag"> </span><span class="hljs-attr"><span class="code-tag"><span class="hljs-attr">src</span></span></span><span class="code-tag">=</span><span class="code-string"><span class="code-tag"><span class="code-string">"/dev/js/index/index.js"</span></span></span><span class="code-tag">&gt;</span></span><span class="undefined"></span><span class="code-tag"><span class="undefined"></span><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span class="code-name">script</span></span></span><span class="code-tag">&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span class="code-name">body</span></span></span><span class="code-tag">&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span class="code-name">html</span></span></span><span class="code-tag">&gt;</span></span></code></pre>\n<p>main.jsx：</p>\n<pre class="javascript"><code class="language-javascript"><span class="code-comment"><span class="code-comment">/**\n * Created by chkui on 2016/11/17.\n */</span></span>\n\n<span class="code-comment"><span class="code-comment">//jsx</span></span>\n<span class="code-comment"><span class="code-comment">/*\nvar React = require(\'react\');\nvar ReactDOM = require(\'react-dom\');\nvar Comp1 = require(\'./component1.jsx\');\nrequire(\'../../../style/index/index.css\');\n\nReactDOM.render(\n    &lt;div className="main"&gt;\n        react jsx demo:\n        &lt;Comp1 /&gt;\n    &lt;/div&gt;,\n    document.getElementById(\'comp\')\n);\n*/</span></span>\n\n<span class="code-comment"><span class="code-comment">//es2015</span></span>\n<span class="code-keyword"><span class="code-keyword">import</span></span> React <span class="code-keyword"><span class="code-keyword">from</span></span> <span class="code-string"><span class="code-string">\'react\'</span></span>;\n<span class="code-keyword"><span class="code-keyword">import</span></span> ReactDOM <span class="code-keyword"><span class="code-keyword">from</span></span> <span class="code-string"><span class="code-string">\'react-dom\'</span></span>;\n<span class="code-keyword"><span class="code-keyword">import</span></span> Comp1 <span class="code-keyword"><span class="code-keyword">from</span></span> <span class="code-string"><span class="code-string">\'./component1.jsx\'</span></span> <span class="code-comment"><span class="code-comment">/*切记，大写是变量小写是标签*/</span></span>\n<span class="code-keyword"><span class="code-keyword">import</span></span> style <span class="code-keyword"><span class="code-keyword">from</span></span> <span class="code-string"><span class="code-string">\'../../../style/index/index.css\'</span></span>\n\nReactDOM.render(\n    <span class="xml"><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">div</span></span></span></span><span class="xml"><span class="code-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="code-tag"><span class="hljs-attr">className</span></span></span></span><span class="xml"><span class="code-tag">=</span></span><span class="code-string"><span class="xml"><span class="code-tag"><span class="code-string">"main"</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n        react es2015 demo:\n        </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">Comp1</span></span></span></span><span class="xml"><span class="code-tag"> /&gt;</span></span></span><span class="xml">\n    </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">div</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span></span>\n    ,\n    <span class="code-built_in"><span class="code-built_in">document</span></span>.getElementById(<span class="code-string"><span class="code-string">\'comp\'</span></span>)\n);\n</code></pre>\n<p>component1.jsx：</p>\n<pre class="scala"><code class="language-javascript"><span class="code-comment"><span class="code-comment">/**\n * Created by Administrator on 2016/11/17.\n */</span></span>\n\n<span class="code-comment"><span class="code-comment">//jsx</span></span>\n<span class="code-comment"><span class="code-comment">/*\nvar React = require(\'react\');\nvar comp1 = React.createClass({\n    render: function () {\n        return (\n          &lt;div className = "index"&gt;\n            hello react!\n          &lt;/div&gt;\n        );\n    }\n});\nmodule.exports = comp1;\n*/</span></span>\n\n<span class="code-comment"><span class="code-comment">//es6</span></span>\n<span class="code-keyword"><span class="code-keyword">import</span></span> <span class="code-type">React</span> <span class="code-keyword">from</span> <span class="code-string"><span class="code-string">"react"</span></span>\n<span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">Comp1</span></span></span><span class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span class="hljs-class"><span class="code-title">Component</span></span></span></span>{\n    <span class="code-comment"><span class="code-comment">//构造函数</span></span>\n    <span class="code-keyword">constructor</span>(...args){\n        <span class="code-keyword"><span class="code-keyword">super</span></span>(...args);\n    }\n    <span class="code-comment"><span class="code-comment">//覆盖父类的渲染方法</span></span>\n    render() {\n        <span class="code-keyword"><span class="code-keyword">return</span></span> (\n            <span class="xml"><span class="code-tag">&lt;<span class="code-name">div</span> <span class="hljs-attr">className</span> = <span class="code-string"><span class="code-string">"index"</span></span>&gt;</span>\n                hello react!\n            <span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>\n        );\n    }\n}\n<span class="code-keyword">export</span> <span class="code-keyword"><span class="code-keyword">default</span></span> <span class="code-type">Comp1</span>;\n</code></pre>\n<p>编码完毕之后，我们使用我们设定好的脚本运行我们的本地开发环境：</p>\n<pre class=""><code class="language-bash"><span class="code-variable">$ </span>npm run dev</code></pre>\n<p>启动时，所有的文本都会被读取到内存中，我们可以根据输出来聊天到底添加了哪些依赖的文件。启动完成后，浏览器上输入&nbsp;http://localhost:8080/dev/index.html 或&nbsp;http://localhost:8080/webpack-dev-server/dev/index.html 即可看到我们用react开发的页面。此时修改js或css文件，编辑效果都会立刻呈现在浏览器上。</p>\n\n<h2 id="h2-4">React浏览器调试工具</h2>\n<p>Facebook提供了基于chrome的页面调试工具，可以看到所有react组件及其效果。</p>\n<p>工具安装：</p>\n<ol>\n    <li>首先最重要的是——翻墙-_-。不翻墙chrome的网上商店就别想了。</li>\n    <li>然后在chrome网店搜索“React Developer Tool”。</li>\n    <li>找到后添加到chrome。</li>\n</ol>\n<p>添加完成后可以发现在chrome中增加了react的图标。</p>\n<p><img alt="React 搭建开发环境" height="282" src="https://file.mahoooo.com/res/file/react_establish_development_environment_2.png" width="638"></p>\n<p>然后在demo页面按F12打开开发人员工具，会发现多了一个React栏目。选择这个栏目后，会显示出React组件的效果。</p>\n<p><img alt="React 搭建开发环境" height="198" src="https://file.mahoooo.com/res/file/react_establish_development_environment_3.png" width="693"></p>'},355:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h2 id="h2-1">在一般组件中使用Forwarding Refs</h2>\n<p>通常情况下，我们想获取一个组建或则一个HTML元素的实例通过 <a\n        href="https://www.chkui.com/article/react/react_typechecking_with_proptypes_and_dom_element" title="Ref特性">Ref特性</a>\n    就可以实现，但是某些时候我们需要在子父级组建中传递使用实例，Forwarding Refs提供了一种技术手段来满足这个要求，特别是开发一些重复使用的组建库时。比如下面的例子：</p>\n<pre><code class="javascript"><span class="hljs-function"><span class="code-keyword">function</span> <span\n        class="code-title">MyButton</span>(<span class="hljs-params">props</span>) </span>{\n  <span class="code-keyword">return</span> (\n    <span class="xml"><span class="code-tag">&lt;<span class="code-name">button</span> <span\n            class="hljs-attr">className</span>=<span class="code-string">"MyButton"</span>&gt;</span>\n      {props.children}\n    <span class="code-tag">&lt;/<span class="code-name">button</span>&gt;</span></span>\n  );\n}</code></pre>\n<p>上面的代码中MyButton组件渲染了一个HTML元素。对于使用者而言，React隐藏了将代码渲染成页面元素的过程，当其他组件使用MyButton时，并没有任何直接的方法来获取MyButton中的&lt;button&gt;元素，这样的设计方法有利于组建的分片管理，降低耦合。</p>\n<p>\n    但是像MyButton这样的组建，其实仅仅是对基本的HTML元素进行了简单的封装。某些时候，上层组建使用他时更希望将其作为一个基本的HTML元素来看待，实现某些效果需要直接操作DOM，比如focus、selection和animations效果。</p>\n<p>下面的例子将Forwarding Refs添加到MyButton组件中，以实现实例传递的效果。</p>\n<pre><code class="javascript"><span class="code-keyword">const</span> MyButton = React.forwardRef(<span\n        class="hljs-function">(<span class="hljs-params">props, ref</span>) =&gt;</span> (\n  <span class="xml"><span class="code-tag">&lt;<span class="code-name">button</span> <span class="hljs-attr">ref</span>=<span\n          class="code-string">{ref}</span> <span class="hljs-attr">className</span>=<span\n          class="code-string">"MyButton"</span>&gt;</span>\n    {props.children}\n  <span class="code-tag">&lt;/<span class="code-name">button</span>&gt;</span></span>\n));\n\n<span class="code-comment">// 通过ref可以直接操作&lt;button&gt;元素:</span>\n<span class="code-keyword">const</span> ref = React.createRef();\n<span class="xml"><span class="code-tag">&lt;<span class="code-name">MyButton</span> <span class="hljs-attr">ref</span>=<span\n        class="code-string">{ref}</span>&gt;</span>Click me!<span class="code-tag">&lt;/<span\n        class="code-name">MyButton</span>&gt;</span></span>;</code></pre>\n<p>这个时候，ref可以直接操作&lt;button&gt;元素。其实执行过程非常简单，也就下面5步：</p>\n<ol>\n    <li>通过React.createRef()方法创建一个ref实例。</li>\n    <li>和通常使用Ref一样，将其作为一个ref属性参数传递给MyButton组件。</li>\n    <li>使用React.forwardRef方法来创建一个组件，并将ref作为第二个参数传递。</li>\n    <li>将ref参数以ref属性的方式传递给&lt;button&gt;元素。</li>\n    <li>在渲染之后，可以使用ref.current来获取&lt;button&gt;元素的实例。</li>\n</ol>\n<p><span style="color:#e74c3c">需要注意的是只有使用React.forwardRef来创建一个组件时，第二个ref参数才会存在。固定的方法或者使用类来创建组件并不会接收到ref参数。Forwarding Refs特性并不仅仅局限于用在HTML DOM元素上，这种方式也实用于组件之间传递Ref。&nbsp;</span>\n</p>\n\n<h2 id="h2-2">在高阶组件中使用Forwarding Refs</h2>\n<p><a href="https://www.chkui.com/article/react/react_high_order_component" title="高阶组件">高阶组件（HOCs）</a>仅仅对一般组件的包装。一般组件被包装之后对于使用者来说并不清晰其是否是被包装过，此时使用Ref得到的是高阶组件的实例。因此Forwarding\n    Refs特性对于高阶组件来说更有价值。</p>\n<p>下面是一个高阶组件记录日志的例子：</p>\n<pre><code class="javascript"><span class="hljs-function"><span class="code-keyword">function</span> <span\n        class="code-title">logProps</span>(<span class="hljs-params">WrappedComponent</span>) </span>{\n  <span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">LogProps</span> <span\n          class="code-keyword">extends</span> <span class="code-title">React</span>.<span\n          class="code-title">Component</span> </span>{\n    componentDidUpdate(prevProps) {\n      <span class="code-built_in">console</span>.log(<span class="code-string">\'old props:\'</span>, prevProps);\n      <span class="code-built_in">console</span>.log(<span class="code-string">\'new props:\'</span>, <span\n            class="code-keyword">this</span>.props);\n    }\n\n    render() {\n      <span class="code-keyword">return</span> <span class="xml"><span class="code-tag">&lt;<span class="code-name">WrappedComponent</span> {<span\n            class="hljs-attr">...this.props</span>} /&gt;</span>;\n    }\n  }\n\n  return LogProps;\n}</span></code></pre>\n<p>logProps组件用于在每次数据更新前后记录props中的数据。我们用其包装前面的MyButton组件。</p>\n<pre><code class="javascript"><span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MyButton</span> <span\n        class="code-keyword">extends</span> <span class="code-title">React</span>.<span\n        class="code-title">Component</span> </span>{\n  focus() {\n    <span class="code-comment">// ...</span>\n  }\n\n  render() {\n    <span class="code-comment">//</span>\n  }\n}\n\n<span class="code-keyword">export</span> <span class="code-keyword">default</span> logProps(MyButton);</code></pre>\n<p>此时通过import并使用Refs实际上得到的是LogProps的实例：</p>\n<pre><code class="javascript"><span class="code-keyword">import</span> FancyButton <span\n        class="code-keyword">from</span> <span class="code-string">\'./FancyButton\'</span>;\n\n<span class="code-keyword">const</span> ref = React.createRef();\n<span class="xml"><span class="code-tag">&lt;<span class="code-name">MyButton</span>\n  <span class="hljs-attr">label</span>=<span class="code-string">"Click Me"</span>\n  <span class="hljs-attr">handleClick</span>=<span class="code-string">{handleClick}</span>\n  <span class="hljs-attr">ref</span>=<span class="code-string">{ref}</span>\n/&gt;</span>;</span></code></pre>\n<p>我们使用Forwarding Refs对高阶组件进行简单的改造即可解决这个问题：</p>\n<pre><code class="javascript"><span class="hljs-function"><span class="code-keyword">function</span> <span\n        class="code-title">logProps</span>(<span class="hljs-params">Component</span>) </span>{\n  <span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">LogProps</span> <span\n          class="code-keyword">extends</span> <span class="code-title">React</span>.<span\n          class="code-title">Component</span> </span>{\n    componentDidUpdate(prevProps) {\n      <span class="code-built_in">console</span>.log(<span class="code-string">\'old props:\'</span>, prevProps);\n      <span class="code-built_in">console</span>.log(<span class="code-string">\'new props:\'</span>, <span\n            class="code-keyword">this</span>.props);\n    }\n\n    render() {\n      <span class="code-keyword">const</span> {forwardedRef, ...rest} = <span class="code-keyword">this</span>.props;\n\n      <span class="code-comment">// 通过forwardedRef参数传递ref的值</span>\n      <span class="code-keyword">return</span> &lt;Component ref={forwardedRef} {...rest} /&gt;;\n    }\n  }\n  \n  //然后使用 React.forwardRef 来包装创建 LogProps组件的实例\n  //注意这里使用 forwardedRef 来传递 父组件的 ref\n  //\n  return React.forwardRef((props, ref) =&gt; {\n    return &lt;LogProps {...props} forwardedRef={ref} /&gt;;\n  });\n}</code></pre>\n\n<h2 id="h2-3">开发调试组件名称显示</h2>\n<p>如果我们不进行任何调整，下面的代码在调试工具中输出的组件名称为："ForwardRef(MyComonent)"：</p>\n<pre><code class="javascript"><span class="code-keyword">const</span> WrappedComponent = React.forwardRef(\n  <span class="hljs-function"><span class="code-keyword">function</span> <span\n          class="code-title">myFunction</span>(<span class="hljs-params">props, ref</span>) </span>{\n    <span class="code-keyword">return</span> <span class="xml"><span class="code-tag">&lt;<span class="code-name">LogProps</span> {<span\n            class="hljs-attr">...props</span>} <span class="hljs-attr">forwardedRef</span>=<span class="code-string">{ref}</span> /&gt;</span>;\n  }\n);</span></code></pre>\n<p>可以通过displayName来设定想要现实的名字：</p>\n<pre><code class="javascript"><span class="hljs-function"><span class="code-keyword">function</span> <span\n        class="code-title">logProps</span>(<span class="hljs-params">Component</span>) </span>{\n  <span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">LogProps</span> <span\n          class="code-keyword">extends</span> <span class="code-title">React</span>.<span\n          class="code-title">Component</span> </span>{\n    <span class="code-comment">// ...</span>\n  }\n\n  <span class="code-comment">//先定义返回的高阶组件方法</span>\n  <span class="hljs-function"><span class="code-keyword">function</span> <span\n          class="code-title">forwardRef</span>(<span class="hljs-params">props, ref</span>) </span>{\n    <span class="code-keyword">return</span> <span class="xml"><span class="code-tag">&lt;<span class="code-name">LogProps</span> {<span\n            class="hljs-attr">...props</span>} <span class="hljs-attr">forwardedRef</span>=<span class="code-string">{ref}</span> /&gt;</span>;\n  }\n\n  //然后设定这个组件的名称\n  const name = Component.displayName || Component.name;\n  forwardRef.displayName = `logProps(${name})`;\n\n  //构建组件\n  return React.forwardRef(forwardRef);\n}</span></code></pre>'},381:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<p>在<a href="https://www.chkui.com/article/spring/spring_core_string_to_entity" title="字符串到实体转换">字符串到实体转换</a>一文中介绍了Spring核心框架中使用PropertyEditor将任何字符串转换为数字、实体的方法。除了字符串到实体，Spring还提供了更加通用的功能在对象和对象之间进行数据转换。\n</p>\n\n<h2 id="h2-1">Converter&lt;S, T&gt;</h2>\n<p>Spring的类型转换的基础是Converter&lt;S, T&gt;（以下简称转换器）接口：</p>\n<pre><code class="java"><span class="code-keyword">package</span> org.springframework.core.convert.converter;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n            class="code-title">Converter</span>&lt;<span class="code-title">S</span>, <span class="code-title">T</span>&gt; </span>{\n    <span class="hljs-function">T <span class="code-title">convert</span><span\n            class="hljs-params">(S source)</span></span>;\n}</code></pre>\n<p>\n    光是看他的结构就很清晰的明白这个接口是要做什么。S表示Source（来源）、T表示Target（目标），所以这个接口的2个范型参数就是数据从S转换为T，Converter::convert方法正是输入一个“S”类型的实例，返回一个“T”类型的实例。</p>\n<p>可以通过这个接口实现规范化、可复用的类型转换功能。下面通过转换器实现字符串到PC实体类相互转换的过程。</p>\n<p>Pc实体：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">PC</span> <span class="code-keyword">extends</span> <span\n        class="code-title">Device</span> </span>{\n\tString cpu;\n\tString graphic;\n\tString ram;\n    <span class="code-comment">//Getter &amp; Setter ...</span>\n}</code></pre>\n<p>在基类Device中通过反射实现字符串到实体类的转换：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="code-keyword">abstract</span> <span\n        class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">Device</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">pares</span><span class="hljs-params">(String text)</span></span>{ <span\n            class="code-comment">//字符串转换为实体</span>\n\t\tField[] fields = <span class="code-keyword">this</span>.getClass().getDeclaredFields();\n\t\t<span class="code-keyword">for</span> (Field field : fields) {\n\t\t\t<span class="code-keyword">int</span> begIndex = text.indexOf(field.getName());\n\t\t\t<span class="code-keyword">int</span> endIndex = text.indexOf(<span class="code-string">";"</span>, begIndex);\n\t\t\tString sub = text.substring(begIndex, endIndex), value = sub.split(<span\n            class="code-string">"="</span>)[<span class="hljs-number">1</span>];\n\t\t\tfield.setAccessible(<span class="code-keyword">true</span>);\n\t\t    field.set(<span class="code-keyword">this</span>, value);\n\t\t}\n\t};\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span\n            class="code-title">value</span><span class="hljs-params">()</span></span>{ <span class="code-comment">//实体转换为字符串</span>\n\t\tField[] fields = <span class="code-keyword">this</span>.getClass().getDeclaredFields();\n\t\tStringBuilder sb = <span class="code-keyword">new</span> StringBuilder();\n\t\t<span class="code-keyword">for</span> (Field field : fields) {\n\t\t\tsb.append(field.getName());\n\t\t\tsb.append(<span class="code-string">"="</span>);\n\t\t\tsb.append(field.get(<span class="code-keyword">this</span>).toString());\n\t\t\tsb.append(<span class="code-string">";"</span>);\n\t\t}\n\t\t<span class="code-keyword">return</span> sb.toString();\n\t}\n}</code></pre>\n<p>然后声明两个转换器的实现类：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">String2PcConverter</span> <span class="code-keyword">implements</span> <span\n        class="code-title">Converter</span>&lt;<span class="code-title">String</span>, <span\n        class="code-title">PC</span>&gt; </span>{\n    <span class="code-comment">//字符串转换为PC对象</span>\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> PC <span class="code-title">convert</span><span\n            class="hljs-params">(String source)</span> </span>{\n\t\tPC pc = <span class="code-keyword">new</span> PC();\n\t\tpc.pares(source);\n\t\t<span class="code-keyword">return</span> pc;\n\t}\n}</code></pre>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">PC2StringConverter</span> <span class="code-keyword">implements</span> <span\n        class="code-title">Converter</span>&lt;<span class="code-title">PC</span>, <span\n        class="code-title">String</span>&gt;  </span>{\n    <span class="code-comment">//PC对象转换为字符串</span>\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span\n            class="code-title">convert</span><span class="hljs-params">(PC source)</span> </span>{\n\t\t<span class="code-keyword">return</span> source.value();\n\t}\n}</code></pre>\n<p>最后使用这两个转换器：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">ConversionApp</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">void</span> <span\n            class="code-title">singletonConversion</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">final</span> String text = <span class="code-string">"cpu=amd;ram=kingston;graphic=Navidia;"</span>;\n\t\tConverter&lt;String, PC&gt; string2Pc = <span class="code-keyword">new</span> String2PcConverter();\n\t\tPC pc = string2Pc.convert(text);\n\t\tConverter&lt;PC, String&gt; pc2String = <span class="code-keyword">new</span> PC2StringConverter();\n\t\tString string = pc2String.convert(pc);\n\t}\n}</code></pre>\n<p>以上就是Spring最基本的类型转换功能——围绕着转换器（<em>Converter&lt;S, T&gt;）</em>接口实现数据类型转换。看到这里可能有些码友就要问了：这到底有什么用？直接用使用Device::pares和Device::value方法不就完事了？为什么还要引入转换器兜一圈？？！\n</p>\n<p>\n    如果系统仅仅只有1个或几个类型转换确实没必要引入转换器。但是业务总是繁杂多样的，模块与模块之前也会存在数据结构的差异，因此我们需要适配器（Adapter）、外观（Facade）等模式来应对变化多端的外部输入而无需改动业务逻辑。实际上从更高的层次看，Converter接口就是Spring为类型转换提供的一个适配器。后面会看到Spring已经为程序的顺利运行提供了大量的转换器，即使在阅读本文内容之前不知道这些转换器的存在，但Spring框架时时刻刻都在使用他们。</p>\n\n<h2 id="h2-2">ConverterFactory&lt;S, R&gt;</h2>\n<p>转换器只能对单一类型进行转换，如果有大量相同类别的数据需要转换可以使用ConverterFactory（一下简称转换工厂）：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">ConverterFactory</span>&lt;<span class="code-title">S</span>, <span\n        class="code-title">R</span>&gt; </span>{\n\n    &lt;T extends R&gt; <span class="hljs-function">Converter&lt;S, T&gt; <span\n            class="code-title">getConverter</span><span class="hljs-params">(Class&lt;T&gt; targetType)</span></span>;\n}</code></pre>\n<p>ConverterFactory::getConverter是返回一个转换器，这里范型标记“T”是“R”的子类。看下面转换工厂的例子，他可以将字符串转换成Device的子类：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">String2DeviceConverterFactory</span> <span class="code-keyword">implements</span> <span\n        class="code-title">ConverterFactory</span>&lt;<span class="code-title">String</span>, <span class="code-title">Device</span>&gt; </span>{\n\t<span class="code-keyword">public</span> &lt;T extends Device&gt; <span class="hljs-function">Converter&lt;String, T&gt; <span\n            class="code-title">getConverter</span><span class="hljs-params">(Class&lt;T&gt; targetType)</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> String2DeviceConverter(targetType);\n\t}\n\n    <span class="code-comment">// Device的通用转换器</span>\n\t<span class="code-keyword">static</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">String2DeviceConverter</span>&lt;<span class="code-title">T</span> <span\n            class="code-keyword">extends</span> <span class="code-title">Device</span>&gt; <span class="code-keyword">implements</span> <span\n            class="code-title">Converter</span>&lt;<span class="code-title">String</span>, <span class="code-title">Device</span>&gt; </span>{\n\t\t<span class="code-keyword">private</span> Class&lt;? extends Device&gt; klass;\n\t\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-title">String2DeviceConverter</span><span\n                class="hljs-params">(Class&lt;? extends Device&gt; klass)</span> </span>{\n\t\t\t<span class="code-keyword">this</span>.klass = klass;\n\t\t}\n\n\t\t<span class="hljs-function"><span class="code-keyword">public</span> T <span\n                class="code-title">convert</span><span class="hljs-params">(String source)</span> </span>{\n\t\t\tDevice device = <span class="code-keyword">null</span>;\n\t\t\tdevice = klass.newInstance();\n\t\t\tdevice.pares(source);\n\t\t\t<span class="code-keyword">return</span> (T) device;\n\t\t}\n\t}\n}</code></pre>\n<p>然后可以使用这个转换工厂按照目标类型进行转换：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">ConversionApp</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">factoryConversion</span><span\n            class="hljs-params">()</span> </span>{\n\t\tString2DeviceConverterFactory factory = <span class="code-keyword">new</span> String2DeviceConverterFactory();\n\t\tConverter&lt;String, PC&gt; pcConverter = factory.getConverter(PC.class);\n\t\t<span class="code-comment">//将字符串转换为PC</span>\n\t\tPC pc = pcConverter.convert(<span class="code-string">"cpu=amd;ram=kingston;graphic=Navidia;"</span>);\n\n\t\tConverter&lt;String, Phone&gt; phoneConverter = factory.getConverter(Phone.class);\n\t\t<span class="code-comment">//将字符串转换为Phone</span>\n\t\tPhone phone = phoneConverter.convert(<span class="code-string">"name=HUAWEIP20;cpu=Kirin970;ram=64G;"</span>);\n\t}\n}</code></pre>\n<p>Phone是另外一个继承了Device的实体类：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">Phone</span> <span class="code-keyword">extends</span> <span class="code-title">Device</span> </span>{\n\tString name;\n\tString cpu;\n\tString ram;\n    <span class="code-comment">// Getter &amp; Setter</span>\n}</code></pre>\n\n<h2 id="h2-3">数据转换服务</h2>\n<p>\n    Spring已经为数据转换预设了大量的Converter，这些Converter可以通过ConversionService直接使用。ConversionService中包含了几乎所有Java常规类型的数据格式转换，看下面的案例。</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">ConversionApp</span> </span>{<span class="hljs-function">ConversionApp <span\n        class="code-title">registConversionService</span><span class="hljs-params">()</span> </span>{\n\t\tConfigurableApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(ConversionConfig.class);\n        <span class="code-comment">// 获取ConversionService</span>\n\t\tConversionService service = ctx.getBean(ConversionService.class);\n\t\t<span class="code-comment">// 字符串转换为整型</span>\n\t\t<span class="code-keyword">int</span> i = service.convert(<span class="code-string">"123456"</span>, Integer.class);\n\t\t<span class="code-comment">// 字符串转换为浮点</span>\n\t\t<span class="code-keyword">float</span> f = service.convert(<span class="code-string">"1234.56"</span>, Float.class);\n\t\t<span class="code-comment">// 源生列表转换为List</span>\n\t\tList&lt;?&gt; list = service.convert(<span class="code-keyword">new</span> <span class="code-keyword">int</span>[] { <span\n            class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span\n            class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span> }, List.class);\n\t\t<span class="code-comment">// 源生列表转换为Set</span>\n\t\tSet&lt;?&gt; set = service.convert(<span class="code-keyword">new</span> <span class="code-keyword">int</span>[] { <span\n            class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span\n            class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span> }, Set.class);\n\t\t<span class="code-comment">// 枚举转换</span>\n\t\tGender gender = service.convert(<span class="code-string">"Male"</span>, Gender.class);\n\t\t<span class="code-comment">// 使用自定义转换器</span>\n\t\tPC pc = service.convert(<span class="code-string">"cpu=amd;ram=kingston;graphic=Navidia;"</span>, PC.class);\n\t\t<span class="code-comment">// UUID转换</span>\n\t\tUUID uuid = service.convert(<span class="code-string">"f51b4b95-0925-4ad0-8c62-4daf3ea7918f"</span>, UUID.class);\n\t\t<span class="code-comment">// 字符串转换为Optional&lt;PC&gt;</span>\n\t\tOptional&lt;PC&gt; options = service.convert(<span\n            class="code-string">"cpu=amd;ram=kingston;graphic=Navidia;"</span>, Optional.class);\n\t\t<span class="code-comment">// 使用TypeDescriptor描述进行转换</span>\n\t\tString source = <span class="code-string">"123456789"</span>;\n\t\t<span class="code-keyword">int</span> result = (<span class="code-keyword">int</span>) service.convert(source, TypeDescriptor.valueOf(source.getClass()),\n\t\t\t\tTypeDescriptor.valueOf(Integer.class));\n\t\t_G.print(result);\n\t}\n\n\t<span class="code-keyword">enum</span> Gender {\n\t\tMale, Female, Other\n\t}\n}</code></pre>\n<p>\n    除了上面的转换，ConversionService还提供了其他转换器，详情请看org.springframework.core.convert.support.DefaultConversionService的JavaDoc文档。</p>\n<p>需要通过ConversionServiceFactoryBean来启用ConversionService，下面的代码是在@Configurable中向IoC容器添加ConversionServiceFactoryBean：</p>\n<pre><code class="java"><span class="code-meta">@Configurable</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">ConversionConfig</span> </span>{\n\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> ConversionServiceFactoryBean <span\n            class="code-title">ConversionServiceFactoryBean</span><span class="hljs-params">()</span> </span>{\n\t\tConversionServiceFactoryBean factoryBean = <span class="code-keyword">new</span> ConversionServiceFactoryBean();\n\t\tSet&lt;Converter&gt; converters = <span class="code-keyword">new</span> HashSet&lt;&gt;();\n\t\t<span class="code-comment">// 添加自定义转换器</span>\n\t\tconverters.add(<span class="code-keyword">new</span> String2PcConverter());\n\t\tconverters.add(<span class="code-keyword">new</span> PC2StringConverter());\n\t\tfactoryBean.setConverters(converters);\n\t\t<span class="code-keyword">return</span> factoryBean;\n\t}\n}</code></pre>\n<p>也可以通过XML文件配置来引入ConversionService：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"conversionService"</span>\n        <span class="hljs-attr">class</span>=<span class="code-string">"org.springframework.context.support.ConversionServiceFactoryBean"</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"converters"</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">set</span>&gt;</span>\n            <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n                    class="code-string">"chkui.springcore.example.javabase.conversion.support.PC2StringConverter"</span>/&gt;</span>\n            <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n                    class="code-string">"chkui.springcore.example.javabase.conversion.support.String2PcConverter"</span>/&gt;</span>\n        <span class="code-tag">&lt;/<span class="code-name">set</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">property</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span></code></pre>\n<p>ConversionService在Spring MVC中的作用很大，可以全局注册统一的类型转换器，详情请见&nbsp;<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/web.html#mvc-config-conversion"\n        rel="nofollow">Conversion and Formatting</a>。&nbsp;</p>\n                                            '}});