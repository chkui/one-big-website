webpackJsonp([0],{395:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.content='<h2 id="h2-1">批处理的核心场景</h2>\n<ul>\n    <li>从某个位置读取大量的记录，位置可以是数据库、文件或者外部推送队列（MQ）。</li>\n    <li>根据业务需要实时处理读取的数据。</li>\n    <li>将处理后的数据写入某个位置，可以是数据库、文件或者推送到队列。</li>\n</ul>\n<h2 id="h2-2">Spring Batch能解决的批处理场景</h2>\n<p>Spring Batch为批处理提供了一个轻量化的解决方案，它根据批处理的需要迭代处理各种记录，提供事物功能。但是Spring Batch仅仅适用于"脱机"场景，在处理的过程中不能和外部进行任何交互，也不允许有任何输入。</p>\n<h2 id="h2-3">Spring Batch的目标</h2>\n<ul>\n    <li>开发人员仅关注业务逻辑，底层框架的交互交由Spring Batch去处理。</li>\n    <li>能够清晰分离业务与框架，框架已经限定了批处理的业务切入点，业务开发只需关注这些切入点（Read、Process、Write）。</li>\n    <li>提供开箱即用的通用接口。</li>\n    <li>快速轻松的融入Spring 框架，基于Spring Framework能够快速扩展各种功能。</li>\n    <li>所有现有核心服务都应易于更换或扩展，而不会对基础架构层产生任何影响。</li>\n</ul>\n<h2 id="h2-4">Spring Batch结构</h2>\n<p><img src="https://docs.spring.io/spring-batch/4.2.x/reference/html/images/spring-batch-layers.png"\n        alt="Spring Batch(1)——数据批处理概念" title="Spring Batch结构" class="zoom-in-cursor"></p>\n<p>如上图，通常情况下一个独立的JVM程序就是仅仅用于处理批处理，而不要和其他功能重叠。\n    在最后一层基础设置（Infrastructure）部分主要分为3个部分。<code>JobLauncher</code>、<code>Job</code>以及<code>Step</code>。每一个<code>Step</code>又细分为<code>ItemReader</code>、<code>ItemProcessor</code>、<code>ItemWirte</code>。使用<em>Spring\n        Batch</em>主要就是知道每一个基础设置负责的内容，然后在对应的设施中实现对应的业务。</p>\n<h2 id="h2-5">Spring Batch 批处理原则与建议</h2>\n<p>当我们构建一个批处理的过程时，必须注意以下原则：</p>\n<ol>\n    <li>\n        <p>通常情况下，批处理的过程对系统和架构的设计要够要求比较高，因此尽可能的使用通用架构来处理批量数据处理，降低问题发生的可能性。Spring\n            Batch是一个是一个轻量级的框架，适用于处理一些灵活并没有到海量的数据。</p>\n    </li>\n    <li>\n        <p>批处理应该尽可能的简单，尽量避免在单个批处理中去执行过于复杂的任务。我们可以将任务分成多个批处理或者多个步骤去实现。</p>\n    </li>\n    <li>\n        <p>保证数据处理和物理数据紧密相连。笼统的说就是我们在处理数据的过程中有很多步骤，在某些步骤执行完时应该就写入数据，而不是等所有都处理完。</p>\n    </li>\n    <li>\n        <p>尽可能减少系统资源的使用、尤其是耗费大量资源的IO以及跨服务器引用，尽量分配好数据处理的批次。</p>\n    </li>\n    <li>\n        <p>定期分析系统的IO使用情况、SQL语句的执行情况等，尽可能的减少不必要的IO操作。优化的原则有：</p>\n        <ol>\n            <li>尽量在一次事物中对同一数据进行读取或写缓存。</li>\n            <li>一次事物中，尽可能在开始就读取所有需要使用的数据。</li>\n            <li>优化索引，观察SQL的执行情况，尽量使用主键索引，尽量避免全表扫描或过多的索引扫描。</li>\n            <li>SQL中的where尽可能通过主键查询。</li>\n        </ol>\n    </li>\n    <li>\n        <p>不要在批处理中对相同的数据执行2次相同的操作。</p>\n    </li>\n    <li>\n        <p>对于批处理程序而言应该在批处理启动之前就分配足够的内存，以免处理的过程中去重新申请新的内存页。</p>\n    </li>\n    <li>\n        <p>对数据的完整性应该从最差的角度来考虑，每一步的处理都应该建立完备的数据校验。</p>\n    </li>\n    <li>\n        <p>对于数据的总量我们应该有一个和数据记录在数据结构的某个字段 上。</p>\n    </li>\n    <li>\n        <p>所有的批处理系统都需要进行压力测试。</p>\n    </li>\n    <li>\n        <p>如果整个批处理的过程是基于文件系统，在处理的过程中请切记完成文件的备份以及文件内容的校验。</p>\n    </li>\n</ol>\n<h2 id="h2-6">批处理的通用策略</h2>\n<p>和软件开发的设计模式一样，批处理也有各种各样的现成模式可供参考。当一个开发（设计）人员开始执行批处理任务时，应该将业务逻辑拆分为一下的步骤或者板块分批执行：</p>\n<ol>\n    <li>\n        <p>\n            数据转换：某个（某些）批处理的外部数据可能来自不同的外部系统或者外部提供者，这些数据的结构千差万别。在统一进行批量数据处理之前需要对这些数据进行转换，合并为一个统一的结构。因此在数据开始真正的执行业务处理之前，先要使用其他的方法或者一些批处理任务将这些数据转换为统一的格式。</p>\n    </li>\n    <li>\n        <p>\n            数据校验：批处理是对大量数据进行处理，并且数据的来源千差万别，所以批处理的输入数据需要对数据的完整性性进行校验（比如校验字段数据是否缺失）。另外批处理输出的数据也需要进行合适的校验（例如处理了100条数据，校验100条数据是否校验成功）</p>\n    </li>\n    <li>\n        <p>提取数据：批处理的工作是逐条从数据库或目标文件读取记录（records）,提取时可以通过一些规则从数据源中进行数据筛选。</p>\n    </li>\n    <li>\n        <p>数据实时更新处理：根据业务要求，对实时数据进行处理。某些时候一行数据记录的处理需要绑定在一个事物之下。</p>\n    </li>\n    <li>\n        <p>输出记录到标准的文档格式：数据处理完成之后需要根据格式写入到对应的外部数据系统中。</p>\n    </li>\n</ol>\n<p>以上五个步骤是一个标准的数据批处理过程，Spring batch框架为业务实现提供了以上几个功能入口。</p>\n<h2 id="h2-7">数据额外处理</h2>\n<p>某些情况需要实现对数据进行额外处理，在进入批处理之前通过其他方式将数据进行处理。主要内容有：</p>\n<ol>\n    <li>\n        <p>排序：由于批处理是以独立的行数据（record）进行处理的，在处理的时候并不知道记录前后关系。因此如果需要对整体数据进行排序，最好事先使用其他方式完成。</p>\n    </li>\n    <li>\n        <p>分割：数据拆分也建议使用独立的任务来完成。理由类似排序，因为批处理的过程都是以行记录为基本处理单位的，无法再对分割之后的数据进行扩展处理。</p>\n    </li>\n    <li>\n        <p>合并：理由如上。</p>\n    </li>\n</ol>\n<h2 id="h2-8">常规数据源</h2>\n<p>批处理的数据源通常包括：</p>\n<ol>\n    <li>数据库驱动链接（链接到数据库）对数据进行逐条提取。</li>\n    <li>文件驱动链接，对文件数据进行提取</li>\n    <li>消息驱动链接，从MQ、kafka等消息系统提取数据。</li>\n</ol>\n<h2 id="h2-9">典型的处理过程</h2>\n<ol>\n    <li>\n        <p>在业务停止的窗口期进行批数据处理，例如银行对账、清结算都是在12点日切到黎明之间。简称为离线处理。</p>\n    </li>\n    <li>\n        <p>在线或并发批处理，但是需要对实际业务或用户的响应进行考量。</p>\n    </li>\n    <li>\n        <p>并行处理多种不同的批处理作业。</p>\n    </li>\n    <li>\n        <p>分区处理：将相同的数据分为不同的区块，然后按照相同的步骤分为许多独立的批处理任务对不同的区块进行处理。</p>\n    </li>\n    <li>\n        <p>以上处理过程进行组合。</p>\n    </li>\n</ol>\n<p>在执行2,3点批处理时需要注意事物隔离等级。</p>\n<h2 id="h2-10">Spring Batch批处理的核心概念</h2>\n<p>下图是批处理的核心流程图。\n    <img src="https://docs.spring.io/spring-batch/4.2.x/reference/html/images/spring-batch-reference-model.png"\n         alt="Spring Batch(1)——数据批处理概念" class="zoom-in-cursor"></p>\n<p>（图片来源于网络）</p>\n<p>Spring Batch同样按照批处理的标准实现了各个层级的组件。并且在框架级别保证数据的完整性和事物性。</p>\n<p>如图所示，在一个标准的批处理任务中涵盖的核心概念有<code>JobLauncher</code>、<code>Job</code>、<code>Step</code>，一个<code>Job</code>可以涵盖多个<code>Step</code>，一个<code>Job</code>对应一个启动的<code>JobLauncher</code>。一个<code>Step</code>中分为<code>ItemReader</code>、<code>ItemProcessor</code>、<code>ItemWriter</code>，根据字面意思它们分别对应数据提取、数据处理和数据写入。此外<code>JobLauncher</code>、<code>Job</code>、<code>Step</code>会产生<em>元数据</em>（Metadata），它们会被存储到<code>JobRepository</code>中。\n</p>\n<h3 id="h3-1">Job</h3>\n<p>简单的说<code>Job</code>是封装一个批处理过程的实体，与其他的Spring项目类似，<code>Job</code>可以通过XML或Java类配置，称为“Job\n    Configuration”。如下图<code>Job</code>是单个批处理的最顶层。\n    <img src="https://docs.spring.io/spring-batch/4.2.x/reference/html/images/job-heirarchy.png"\n         alt="Spring Batch(1)——数据批处理概念" class="zoom-in-cursor"></p>\n<p>为了便于理解，可以简单的将<code>Job</code>理解为是每一步（<code>Step</code>）实例的容器。他结合了多个<code>Step</code>，为它们提供统一的服务同时也为<code>Step</code>提供个性化的服务，比如步骤重启。通常情况下<code>Job的配置包含以下内容</code>：\n</p>\n<ul>\n    <li>Job的名称</li>\n    <li>定义和排序<code>Step</code>执行实例。</li>\n    <li>标记每个<code>Step</code>是否可以重启。</li>\n</ul>\n<p>Spring Batch为Job接口提供了默认的实现——<code>SimpleJob</code>，其中实现了一些标准的批处理方法。下面的代码展示了如可注入一个<code>Job</code>。</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Job <span\n        class="code-title">footballJob</span><span class="hljs-params">()</span> </span>{\n    <span class="code-keyword">return</span> <span class="code-keyword">this</span>.jobBuilderFactory.get(<span\n            class="code-string">"footballJob"</span>) <span class="code-comment">//get中命名了Job的名称</span>\n                     .start(playerLoad())  <span\n            class="code-comment">//playerLoad、gameLoad、playerSummarization都是Step</span>\n                     .next(gameLoad())\n                     .next(playerSummarization())\n                     .end()\n                     .build();\n}\n</code></pre>\n<h4 id="h4-1">JobInstance</h4>\n<p><code>JobInstance</code>是指批处理作业运行的实例。例如一个批处理必须在每天执行一次，系统在2019年5月1日执行了一次我们称之为2019-05-01的实例，类似的还会有2019-05-02、2019-05-03实例。通常情况下，一个<code>JobInstance</code>对应一个<code>JobParameters</code>，对应多个<code>JobExecution</code>。（<code>JobParameters</code>、<code>JobExecution</code>见后文）。同一个<code>JobInstance</code>具有相同的上下文（<code>ExecutionContext</code>内容见后文）。\n</p>\n<h4 id="h4-2">JobParameters</h4>\n<p>\n    前面讨论了<code>JobInstance</code>与<code>Job</code>的区别，但是具体的区别内容都是通过<code>JobParameters</code>体现的。一个<code>JobParameters</code>对象中包含了一系列Job运行相关的参数，这些参数可以用于参考或者用于实际的业务使用。对应的关系如下图：\n</p>\n<p><img src="https://docs.spring.io/spring-batch/4.2.x/reference/html/images/job-heirarchy.png"\n        alt="Spring Batch(1)——数据批处理概念" class="zoom-in-cursor"></p>\n<p>当我们执行2个不同的<code>JobInstance</code>时<code>JobParameters</code>中的属性都会有差异。可以简单的认为一个<code>JobInstance</code>的标识就是<code>Job</code>+<code>JobParameters</code>。\n</p>\n<h4 id="h4-3">JobExecution</h4>\n<p><code>JobExecution</code>可以理解为单次运行<code>Job</code>的容器。一次<code>JobInstance</code>执行的结果可能是成功、也可能是失败。但是对于Spring\n    Batch框架而言，只有返回运行成功才会视为完成一次批处理。例如2019-05-01执行了一次<code>JobInstance</code>，但是执行的过程失败，因此第二次还会有一个“相同的”的<code>JobInstance</code>被执行。\n</p>\n<p><code>Job</code>用于定义批处理如何执行，<code>JobInstance</code>纯粹的就是一个处理对象，把所有的运行内容和信息组织在一起，主要是为了当面临问题时定义正确的重启参数。而<code>JobExecution</code>是运行时的“容器”，记录动态运行时的各种属性和上线文。他包括的信息有：\n</p>\n<table>\n    <thead>\n    <tr>\n        <th>属性</th>\n        <th>说明</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n        <td>status</td>\n        <td>状态类名为<code>BatchStatus</code>，它指示了执行的状态。在执行的过程中状态为<code>BatchStatus#STARTED</code>，失败：<code>BatchStatus#FAILED</code>，完成：<code>BatchStatus#COMPLETED</code>\n        </td>\n    </tr>\n    <tr>\n        <td>startTime</td>\n        <td><code>java.util.Date</code>对象，标记批处理任务启动的系统时间，批处理任务未启动数据为空</td>\n    </tr>\n    <tr>\n        <td>endTime</td>\n        <td><code>java.util.Date</code>对象，结束时间无论是否成功都包含该数据，如未处理完为空</td>\n    </tr>\n    <tr>\n        <td>exitStatus</td>\n        <td><code>ExitStatus</code>类，记录运行结果。</td>\n    </tr>\n    <tr>\n        <td>createTime</td>\n        <td><code>java.util.Date</code>,<code>JobExecution</code>的创建时间，某些使用execution已经创建但是并未开始运行。</td>\n    </tr>\n    <tr>\n        <td>lastUpdate</td>\n        <td><code>java.util.Date</code>，最后一次更新时间</td>\n    </tr>\n    <tr>\n        <td>executionContext</td>\n        <td>批处理任务执行的所有用户数据</td>\n    </tr>\n    <tr>\n        <td>failureExceptions</td>\n        <td>记录在执行Job时的异常，对于排查问题非常有用</td>\n    </tr>\n    </tbody>\n</table>\n<p>以上这些内容Spring Batch都会通过<code>JobRepository</code>进行持久化（这些信息官方文成称之为MetaData），因此在对应的数据源中可以看到下列信息：</p>\n<p>BATCH_JOB_INSTANCE：</p>\n<table>\n    <thead>\n    <tr>\n        <th>JOB_INST_ID</th>\n        <th>JOB_NAME</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n        <td>1</td>\n        <td>EndOfDayJob</td>\n    </tr>\n    </tbody>\n</table>\n<p>BATCH_JOB_EXECUTION_PARAMS：</p>\n<table>\n    <thead>\n    <tr>\n        <th>JOB_EXECUTION_ID</th>\n        <th>TYPE_CD</th>\n        <th>KEY_NAME</th>\n        <th>DATE_VAL</th>\n        <th>IDENTIFYING</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n        <td>1</td>\n        <td>DATE</td>\n        <td>schedule.Date</td>\n        <td>2019-01-01</td>\n        <td>TRUE</td>\n    </tr>\n    </tbody>\n</table>\n<p>BATCH_JOB_EXECUTION：</p>\n<table>\n    <thead>\n    <tr>\n        <th>JOB_EXEC_ID</th>\n        <th>JOB_INST_ID</th>\n        <th>START_TIME</th>\n        <th>END_TIME</th>\n        <th>STATUS</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n        <td>1</td>\n        <td>1</td>\n        <td>2019-01-01 21:00</td>\n        <td>2017-01-01 21:30</td>\n        <td>FAILED</td>\n    </tr>\n    </tbody>\n</table>\n<p>当某个<code>Job</code>批处理任务失败之后会在对应的数据库表中路对应的状态。假设1月1号执行的任务失败，技术团队花费了大量的时间解决这个问题到了第二天21才继续执行这个任务。</p>\n<p>BATCH_JOB_INSTANCE：</p>\n<table>\n    <thead>\n    <tr>\n        <th>JOB_INST_ID</th>\n        <th>JOB_NAME</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n        <td>1</td>\n        <td>EndOfDayJob</td>\n    </tr>\n    <tr>\n        <td>2</td>\n        <td>EndOfDayJob</td>\n    </tr>\n    </tbody>\n</table>\n<p>BATCH_JOB_EXECUTION_PARAMS：</p>\n<table>\n    <thead>\n    <tr>\n        <th>JOB_EXECUTION_ID</th>\n        <th>TYPE_CD</th>\n        <th>KEY_NAME</th>\n        <th>DATE_VAL</th>\n        <th>IDENTIFYING</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n        <td>1</td>\n        <td>DATE</td>\n        <td>schedule.Date</td>\n        <td>2019-01-01</td>\n        <td>TRUE</td>\n    </tr>\n    <tr>\n        <td>2</td>\n        <td>DATE</td>\n        <td>schedule.Date</td>\n        <td>2019-01-01</td>\n        <td>TRUE</td>\n    </tr>\n    <tr>\n        <td>3</td>\n        <td>DATE</td>\n        <td>schedule.Date</td>\n        <td>2019-01-02</td>\n        <td>TRUE</td>\n    </tr>\n    </tbody>\n</table>\n<p>BATCH_JOB_EXECUTION：</p>\n<table>\n    <thead>\n    <tr>\n        <th>JOB_EXEC_ID</th>\n        <th>JOB_INST_ID</th>\n        <th>START_TIME</th>\n        <th>END_TIME</th>\n        <th>STATUS</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n        <td>1</td>\n        <td>1</td>\n        <td>2019-01-01 21:00</td>\n        <td>2017-01-01 21:30</td>\n        <td>FAILED</td>\n    </tr>\n    <tr>\n        <td>2</td>\n        <td>1</td>\n        <td>2019-01-02 21:00</td>\n        <td>2017-01-02 21:30</td>\n        <td>COMPLETED</td>\n    </tr>\n    <tr>\n        <td>3</td>\n        <td>2</td>\n        <td>2019-01-02 21:31</td>\n        <td>2017-01-02 22:29</td>\n        <td>COMPLETED</td>\n    </tr>\n    </tbody>\n</table>\n<p>从数据上看好似<code>JobInstance</code>是一个接一个顺序执行的，但是对于Spring Batch并没有进行任何控制。不同的<code>JobInstance</code>很有可能是同时在运行（相同的<code>JobInstance</code>同时运行会抛出<code>JobExecutionAlreadyRunningException</code>异常）。\n</p>\n<h3 id="h3-2">Step</h3>\n<p>\n    <code>Step</code>是批处理重复运行的最小单元，它按照顺序定义了一次执行的必要过程。因此每个<code>Job</code>可以视作由一个或多个多个<code>Step</code>组成。一个<code>Step</code>包含了所有所有进行批处理的必要信息，这些信息的内容是由开发人员决定的并没有统一的标准。一个<code>Step</code>可以很简单，也可以很复杂。他可以是复杂业务的组合，也有可能仅仅用于迁移数据。与<code>JobExecution</code>的概念类似，<code>Step</code>也有特定的<code>StepExecution</code>，关系结构如下：\n</p>\n<p><img src="https://docs.spring.io/spring-batch/4.2.x/reference/html/images/jobHeirarchyWithSteps.png"\n        alt="Spring Batch(1)——数据批处理概念" title="Step" class="zoom-in-cursor"></p>\n<h4 id="h4-4">StepExecution</h4>\n<p><code>StepExecution</code>表示单次执行Step的容器，每次<code>Step</code>执行时都会有一个新的<code>StepExecution</code>被创建。与<code>JobExecution</code>不同的是，当某个<code>Step</code>执行失败后默认并不会重新执行。<code>StepExecution</code>包含以下属性：\n</p>\n<table>\n    <thead>\n    <tr>\n        <th>属性</th>\n        <th>说明</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n        <td>status</td>\n        <td>状态类名为<code>BatchStatus</code>，它指示了执行的状态。在执行的过程中状态为<code>BatchStatus#STARTED</code>，失败：<code>BatchStatus#FAILED</code>，完成：<code>BatchStatus#COMPLETED</code>\n        </td>\n    </tr>\n    <tr>\n        <td>startTime</td>\n        <td><code>java.util.Date</code>对象，标记<code>StepExecution</code>启动的系统时间，未启动数据为空</td>\n    </tr>\n    <tr>\n        <td>endTime</td>\n        <td><code>java.util.Date</code>对象，结束时间，无论是否成功都包含该数据，如未处理完为空</td>\n    </tr>\n    <tr>\n        <td>exitStatus</td>\n        <td><code>ExitStatus</code>类，记录运行结果。</td>\n    </tr>\n    <tr>\n        <td>createTime</td>\n        <td><code>java.util.Date</code>,<code>JobExecution</code>的创建时间，某些使用execution已经创建但是并未开始运行。</td>\n    </tr>\n    <tr>\n        <td>lastUpdate</td>\n        <td><code>java.util.Date</code>，最后一次更新时间</td>\n    </tr>\n    <tr>\n        <td>executionContext</td>\n        <td>批处理任务执行的所有用户数据</td>\n    </tr>\n    <tr>\n        <td>readCount</td>\n        <td>成功读取数据的次数</td>\n    </tr>\n    <tr>\n        <td>wirteCount</td>\n        <td>成功写入数据的次数</td>\n    </tr>\n    <tr>\n        <td>commitCount</td>\n        <td>成功提交数据的次数</td>\n    </tr>\n    <tr>\n        <td>rollbackCount</td>\n        <td>回归数据的次数，有业务代码触发</td>\n    </tr>\n    <tr>\n        <td>readSkipCount</td>\n        <td>当读数据发生错误时跳过处理的次数</td>\n    </tr>\n    <tr>\n        <td>processSkipCount</td>\n        <td>当处理过程发生错误，跳过处理的次数</td>\n    </tr>\n    <tr>\n        <td>filterCount</td>\n        <td>被过滤规则拦截未处理的次数</td>\n    </tr>\n    <tr>\n        <td>writeSkipCount</td>\n        <td>写数据失败，跳过处理的次数</td>\n    </tr>\n    </tbody>\n</table>\n<h3 id="h3-3">ExecutionContext</h3>\n<p>前文已经多次提到<code>ExecutionContext</code>。可以简单的认为<code>ExecutionContext</code>提供了一个<em>Key/Value</em>机制，在<code>StepExecution</code>和<code>JobExecution</code>对象的任何位置都可以获取到<code>ExecutionContext</code>中的任何数据。最有价值的作用是记录数据的执行位置，以便发生重启时候从对应的位置继续执行：\n</p>\n<pre><code class="Java">executionContext.putLong(getKey(LINES_READ_COUNT), reader.getPosition())\n</code></pre>\n<p>比如在任务中有一个名为“loadData”的<code>Step</code>，他的作用是从文件中读取数据写入到数据库，当第一次执行失败后，数据库中有如下数据：</p>\n<p>BATCH_JOB_INSTANCE：</p>\n<table>\n    <thead>\n    <tr>\n        <th>JOB_INST_ID</th>\n        <th>JOB_NAME</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n        <td>1</td>\n        <td>EndOfDayJob</td>\n    </tr>\n    </tbody>\n</table>\n<p>BATCH_JOB_EXECUTION_PARAMS：</p>\n<table>\n    <thead>\n    <tr>\n        <th>JOB_INST_ID</th>\n        <th>TYPE_CD</th>\n        <th>KEY_NAME</th>\n        <th>DATE_VAL</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n        <td>1</td>\n        <td>DATE</td>\n        <td>schedule.Date</td>\n        <td>2019-01-01</td>\n    </tr>\n    </tbody>\n</table>\n<p>BATCH_JOB_EXECUTION：</p>\n<table>\n    <thead>\n    <tr>\n        <th>JOB_EXEC_ID</th>\n        <th>JOB_INST_ID</th>\n        <th>START_TIME</th>\n        <th>END_TIME</th>\n        <th>STATUS</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n        <td>1</td>\n        <td>1</td>\n        <td>2017-01-01 21:00</td>\n        <td>2017-01-01 21:30</td>\n        <td>FAILED</td>\n    </tr>\n    </tbody>\n</table>\n<p>BATCH_STEP_EXECUTION：</p>\n<table>\n    <thead>\n    <tr>\n        <th>STEP_EXEC_ID</th>\n        <th>JOB_EXEC_ID</th>\n        <th>STEP_NAME</th>\n        <th>START_TIME</th>\n        <th>END_TIME</th>\n        <th>STATUS</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n        <td>1</td>\n        <td>1</td>\n        <td>loadData</td>\n        <td>2017-01-01 21:00</td>\n        <td>2017-01-01 21:30</td>\n        <td>FAILED</td>\n    </tr>\n    </tbody>\n</table>\n<p>BATCH_STEP_EXECUTION_CONTEXT：\n    |STEP_EXEC_ID|SHORT_CONTEXT|\n    |---|---|\n    |1|{piece.count=40321}|</p>\n<p>\n    在上面的例子中，<code>Step</code>运行30分钟处理了40321个“pieces”，我们姑且认为“pieces”表示行间的行数（实际就是每个Step完成循环处理的个数）。这个值会在每个<code>commit</code>之前被更新记录在<code>ExecutionContext</code>中（更新需要用到<code>StepListener</code>后文会详细说明）。当我们再次重启这个<code>Job</code>时并记录在<em>BATCH_STEP_EXECUTION_CONTEXT</em>中的数据会加载到<code>ExecutionContext</code>中,这样当我们继续执行批处理任务时可以从上一次中断的位置继续处理。例如下面的代码在<code>ItemReader</code>中检查上次执行的结果，并从中断的位置继续执行：\n</p>\n<pre><code class="Java"><span class="code-keyword">if</span> (executionContext.containsKey(getKey(LINES_READ_COUNT))) {\n    log.debug(<span class="code-string">"Initializing for restart. Restart data is: "</span> + executionContext);\n\n    <span class="code-keyword">long</span> lineCount = executionContext.getLong(getKey(LINES_READ_COUNT));\n\n    LineReader reader = getReader();\n\n    Object record = <span class="code-string">""</span>;\n    <span class="code-keyword">while</span> (reader.getPosition() &lt; lineCount &amp;&amp; record != <span\n            class="code-keyword">null</span>) {\n        record = readLine();\n    }\n}\n</code></pre>\n<p><code>ExecutionContext</code>是根据<code>JobInstance</code>进行管理的，因此只要是相同的实例都会具备相同的ExecutionContext（无论是否停止）。此外通过以下方法都可以获得一个<code>ExecutionContext</code>：\n</p>\n<pre><code class="Java">ExecutionContext ecStep = stepExecution.getExecutionContext();\nExecutionContext ecJob = jobExecution.getExecutionContext();\n</code></pre>\n<p>\n    但是这2个<code>ExecutionContext</code>并不相同，前者是在一个<code>Step</code>中每次<code>Commit</code>数据之间共享，后者是在<code>Step</code>与<code>Step</code>之间共享。\n</p>\n<h3 id="h3-4">JobRepository</h3>\n<p><code>JobRepository</code>是所有前面介绍的对象实例的持久化机制。他为<code>JobLauncher</code>、<code>Job</code>、<code>Step</code>的实现提供了CRUD操作。当一个<code>Job</code>第一次被启动时，一个<code>JobExecution</code>会从数据源中获取到，同时在执行的过程中<code>StepExecution</code>、<code>JobExecution</code>的实现都会记录到数据源中。使用<code>@EnableBatchProcessing</code>注解后<code>JobRepository</code>会进行自动化配置。\n</p>\n<h3 id="h3-5">JobLauncher</h3>\n<p><code>JobLauncher</code>为<code>Job</code>的启动运行提供了一个边界的入口，在启动<code>Job</code>的同时还可以定制<code>JobParameters</code>：</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">JobLauncher</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> JobExecution <span\n            class="code-title">run</span><span class="hljs-params">(Job job, JobParameters jobParameters)</span>\n\t\t\t\t<span class="code-keyword">throws</span> JobExecutionAlreadyRunningException, JobRestartException,\n\t\t\t\t\t   JobInstanceAlreadyCompleteException, JobParametersInvalidException</span>;\n}\n</code></pre>'},397:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.content='<h3 id="h3-1">初始化Spring-boot</h3>\n\n<h4 id="h4-1">最佳的文档结构。</h4>\n<pre><code class="ruby">com\n +- example\n     +- myproject\n         +- Application.java\n         <span class="hljs-params">|\n         +- domain\n         |</span>   +- Customer.java\n         <span class="hljs-params">|   +- CustomerRepository.java\n         |</span>\n         +- service\n         <span class="hljs-params">|   +- CustomerService.java\n         |</span>\n         +- web\n             +- CustomerController.java</code></pre>\n<p>spring-boot还是建议按照标准的controller-service-dao结构分层。有一个独立的Application.java作为系统启动入口。</p>\n\n<h4 id="h4-2">引入</h4>\n<p>这里仅仅以Maven为例：</p>\n<pre><code class="xml"><span class="php"><span class="code-meta">&lt;?</span>xml version=<span\n        class="code-string">"1.0"</span> encoding=<span class="code-string">"UTF-8"</span><span\n        class="code-meta">?&gt;</span></span>\n<span class="code-tag">&lt;<span class="code-name">project</span> <span class="hljs-attr">xmlns</span>=<span\n        class="code-string">"http://maven.apache.org/POM/4.0.0"</span> <span class="hljs-attr">xmlns:xsi</span>=<span\n        class="code-string">"http://www.w3.org/2001/XMLSchema-instance"</span>\n    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="code-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">modelVersion</span>&gt;</span>4.0.0<span\n            class="code-tag">&lt;/<span class="code-name">modelVersion</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">groupId</span>&gt;</span>org.springframework<span\n            class="code-tag">&lt;/<span class="code-name">groupId</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">artifactId</span>&gt;</span>gs-spring-boot-demo<span\n            class="code-tag">&lt;/<span class="code-name">artifactId</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">version</span>&gt;</span>0.1.0<span class="code-tag">&lt;/<span\n            class="code-name">version</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">dependencies</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">dependency</span>&gt;</span>\n            <span class="code-tag">&lt;<span class="code-name">groupId</span>&gt;</span>org.springframework.boot<span\n            class="code-tag">&lt;/<span class="code-name">groupId</span>&gt;</span>\n            <span class="code-tag">&lt;<span class="code-name">artifactId</span>&gt;</span>spring-boot-starter-web<span\n            class="code-tag">&lt;/<span class="code-name">artifactId</span>&gt;</span>\n\t    \t<span class="code-tag">&lt;<span class="code-name">version</span>&gt;</span>1.5.9.RELEASE<span\n            class="code-tag">&lt;/<span class="code-name">version</span>&gt;</span>\n        <span class="code-tag">&lt;/<span class="code-name">dependency</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">dependencies</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">properties</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">java.version</span>&gt;</span>1.8<span class="code-tag">&lt;/<span\n            class="code-name">java.version</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">properties</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">project</span>&gt;</span></code></pre>\n<p>引入了&nbsp;spring-boot-starter-web，基本上开发一个web应用所需的包都会引入其中。如果需要使用JPA等等功能需要另外引入对应的<strong><em>starter</em></strong>。spring-boot用pom的方式整合了许多开箱即用的工具，官方称之为<em><strong>starter</strong></em>特性，后面会介绍什么是<em><strong>starter。</strong></em>\n</p>\n\n<h4 id="h4-3">启动</h4>\n<p>Spring boot提供了多种启动方式，最简单的方式是在main方法中调用&nbsp;SpringApplication.run 方法即可启动Spring Boot。当然，run方法必须要配合相关的注解才能实现Spring\n    Boot目标功能。关于spring boot打包以及<strong><em>jara -jar</em></strong>或者<em><strong>CLI</strong></em>启动，后续的博文会介绍。</p>\n\n<h4 id="h4-4">DEBUG模式</h4>\n<p>通常情况下，启动Spting Boot时日志输出都是生产模式（关闭DEBUG级别的日志），在启动参数中增加--debug参数即可开启调试模式的日志输出。</p>\n<p>Eclipse的设置：工程右键-&gt;Debug As-&gt;Debug Configurations-&gt;打开Arguments选项-&gt;在Program arguments中增加 --debug 参数。</p>\n<p><img height="429" src="https://file.mahoooo.com/res/file/spring_boot_features_get_started_1.png" width="879"\n        alt="Spring Boot特性入门篇"></p>\n\n<h4 id="h4-5">纯Java配置——@Configuration</h4>\n<p>\n    <em>@Configuration</em>是一个用于类的注解，他可以替换原来定义在<em>xml</em>文件中的<em>spring</em>配置。当为某一个类增加这个注解后，会将其视作一个源自配置文件的<em>Bean</em>。<br>\n    其实<em>spring</em>的<em>ioc</em>容器一直以来都没多大变化，延续基于单例的<em>IOC</em>的机制一直向下衍生功能线，不管使用什么注解，基本上所有用到的实例都是一个<em>Bean</em>，所有的<em>Bean</em>都放在同一个的<em>IOC</em>容器中（当然也可以创建多个容器，但是似乎并没什么应用需要这么特殊的实现）。<em>Spring\n    Xml</em>配置是根据<em>xml</em>的描述生成多个<em>Bean</em>，而引入<em>@Configuration</em>注解使得配置可以彻底基于<em>Java</em>代码。</p>\n\n<h4 id="h4-6">自动配置注入——@EnableAutoConfiguration&nbsp;</h4>\n<p>这个注解用于在<em>Spring</em>的<em>IOC</em>容器中启用自动推导配置功能（使用boot中定义的默认配置）。其执行过程实际就是根据<em>classpath</em>中的包来决定是否需要注入某个用于资源配置的Bean来支持其工作。比如在<em>classpath</em>中发现了<code>tomcat-embedded.jar</code>&nbsp;这个包，那么可以推定需要启用tomcat的嵌入工具，那么boot会帮助我们创建一个&nbsp;<a\n        href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/api/org/springframework/boot/context/embedded/tomcat/TomcatEmbeddedServletContainerFactory.html"\n        rel="nofollow"><code>TomcatEmbeddedServletContainerFactory</code></a>&nbsp;的实例作为Bean放置到容器中以供其使用。我们可以通过注解的&nbsp;&nbsp;<a\n        href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/api/org/springframework/boot/autoconfigure/EnableAutoConfiguration.html#exclude--"\n        rel="nofollow"><code>exclude()</code></a>&nbsp;和&nbsp;<a\n        href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/api/org/springframework/boot/autoconfigure/EnableAutoConfiguration.html#excludeName--"\n        rel="nofollow"><code>excludeName()</code></a>&nbsp;方法告知不需要自动生成某些配置。也可以通过声明&nbsp;&nbsp;<code>spring.autoconfigure.exclude</code>&nbsp;JVM参数。&nbsp;\n</p>\n<p>\n    实质上Spring-Boot-Web就是一个更加自动化的Spring-Webmvc——不用整合servlet容器并且分分钟启动。而Spring-Boot最大的亮点之一就是根据引入的包自动注入配置。如果打开--debug模式会看到很多匹配相关的内容输出。下面是自动匹配输出的一些内容，为了便于说明只选取了很小一部分，实际输出的内容比这个多得多。</p>\n<pre><code class="ruby">=========================\nAUTO-CONFIGURATION REPORT\n=========================\n\nPositive <span class="hljs-symbol">matches:</span>\n-----------------\n\n   DispatcherServletAutoConfiguration <span class="hljs-symbol">matched:</span>\n      - @ConditionalOnClass found required <span class="hljs-class"><span class="code-keyword">class</span> \'<span\n            class="code-title">org</span>.<span class="code-title">springframework</span>.<span\n            class="code-title">web</span>.<span class="code-title">servlet</span>.<span class="code-title">DispatcherServlet</span>\';</span> @ConditionalOnMissingClass did <span\n            class="code-keyword">not</span> find unwanted <span class="hljs-class"><span\n            class="code-keyword">class</span> (<span class="code-title">OnClassCondition</span>)</span>\n      - @ConditionalOnWebApplication (required) found StandardServletEnvironment (OnWebApplicationCondition)\n\n   DispatcherServletAutoConfiguration.DispatcherServletConfiguration <span class="hljs-symbol">matched:</span>\n      - @ConditionalOnClass found required <span class="hljs-class"><span class="code-keyword">class</span> \'<span\n            class="code-title">javax</span>.<span class="code-title">servlet</span>.<span class="code-title">ServletRegistration</span>\';</span> @ConditionalOnMissingClass did <span\n            class="code-keyword">not</span> find unwanted <span class="hljs-class"><span\n            class="code-keyword">class</span> (<span class="code-title">OnClassCondition</span>)</span>\n      - Default DispatcherServlet did <span class="code-keyword">not</span> find dispatcher servlet beans (DispatcherServletAutoConfiguration.DefaultDispatcherServletCondition)\n\n\nNegative <span class="hljs-symbol">matches:</span>\n-----------------\n\n   <span class="hljs-symbol">ActiveMQAutoConfiguration:</span>\n      Did <span class="code-keyword">not</span> <span class="hljs-symbol">match:</span>\n         - @ConditionalOnClass did <span class="code-keyword">not</span> find required classes <span\n            class="code-string">\'javax.jms.ConnectionFactory\'</span>, <span class="code-string">\'org.apache.activemq.ActiveMQConnectionFactory\'</span> (OnClassCondition)\n\n</code></pre>\n<p>从<em>AUTO-CONFIGURATION REPORT </em>开始就是匹配日志，<em>Positive matche</em>&nbsp;之后的表示匹配上的配置，<em>Negative matches</em>之后表示未匹配上的配置。每一项的内容都详细说明了匹配上的依赖关系和未匹配的原因。\n</p>\n\n<h4 id="h4-7">包扫描——@ComponentScan</h4>\n<p>\n    <em>@ComponentScan</em>注解用于设定<em>IOC</em>容器加载<em>Bean</em>的扫描路径，等价于<em>xml</em>配置中的<em>&lt;context:component-scan&gt;</em>元素（<em>@ComponentScan</em>属于<em>Spring\n    Framework的Context</em>模块）。在指定的路径中会将<em>@Component</em>及其子类限定的类（如<em>@Service</em>、<em>@Repository</em>、<em>@Controller</em>）作为一个<em>Bean</em>添加到<em>IOC</em>容器中。\n</p>\n<p><em>@ComponentScan</em>中包含多个参数，例如<em>basePackages</em>、<em>basePackageClasses</em>、<em>excludeFilters</em>等，都是用于定义扫描的包路径或限定名。如果没有为@ComponentScan注解设定任何参数，则会扫描当前包以及所有子孙包。\n</p>\n\n<h4 id="h4-8">Spring-boot整合——@SpringBootApplication</h4>\n<p><em>@SpringBootApplication</em>注解整合了<em>@Configuration</em>、<em>@EnableAutoConfiguration</em>、<em>@ComponentScan</em>的效果。当为一个入口类（包含启动的main方法）定义一个@SpringBootApplication注解后，意味着增加了上述三个注解的功能——1）当前类是一个资源Bean，2）启用spring\n    boot的自动推导配置（开箱即用）、3）自动扫描入口类之后的所有子包。</p>\n<p>所以下面2种写法实现的效果是几乎一致的（在<em>@SpringBootApplication</em>中对<em>@ComponentScan</em>做了参数限定，所以只能说几乎一致。）：</p>\n<pre><code class="java"><span class="code-meta">@EnableAutoConfiguration</span>\n<span class="code-meta">@ComponentScan</span>\n<span class="code-meta">@Configuration</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Demo</span></span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> <span\n            class="code-keyword">throws</span> Exception </span>{\n        SpringApplication.run(Demo.class, args);\n    }\n}</code></pre>\n<pre><code class="java"><span class="code-meta">@SpringBootApplication</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Demo</span></span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> <span\n            class="code-keyword">throws</span> Exception </span>{\n        SpringApplication.run(Demo.class, args);\n    }\n}</code></pre>\n\n<h4 id="h4-9">开箱即用——Starter</h4>\n<p>Spring Boot通过Maven的方式提供了一系列开箱即用（一站式服务）的工具，包括MQ、AOP、JPA等，文档上将这个特性命名为<em><strong>Starter。</strong></em>前面 <em><strong>引入</strong></em>\n    部分使用的&nbsp;<em>spring-boot-starter-web </em>就是一个<em><strong>Starter</strong></em>&nbsp;。<strong><em>Starter </em></strong>特性并没有什么新的技术，仅仅是通过pom文件的方式引用了一些必要的包，然后在引入之后通过<em>Spring\n        Boot</em>的自动推导配置为引入的<em>jar包</em>注入必要的配置Bean。<a\n            href="https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-build-systems.html#using-boot-starter"\n            rel="nofollow">官网的表13.1</a> 列举了所有<em>Sprint Boot</em>官方提供的<em><strong>Starter</strong></em>。</p>\n<p>当然除了官方提供的<strong><em>Starter</em></strong>我们还可以自定义。不过需要注意的是命名规则——由官方提供的<strong><em>Starter</em></strong>命名规则为<em>spring-boot-starter-*</em>，而自定义（第三方提供）的规则为<em>&nbsp;acme-spring-boot-starter-*。自定义的<strong>Starter</strong>在某些使用需要额外指定自动配置功能，详情请看\n    <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-auto-configuration.html#boot-features-custom-starter"\n       rel="nofollow">关于自定义Starter的说明</a>。</em></p>\n\n<h4 id="h4-10">逐渐替换默认配置</h4>\n<p>这也是<em>Spring Boot</em>的最佳实践之一。虽然它提供了相当丰富的默认配置，但是并不是所有的东西用默认配置就可以解决。Spring Boot建议根据需要逐渐替换工程所需的配置。例如默认情况下工程引入了 <a\n        href="http://hsqldb.org/" rel="nofollow">HSQLDB</a>&nbsp;，并且没有配置<strong><em>DataSource</em></strong>，那么我们所有的数据库操作（例如<em>JPA</em>）都会直接使用<a\n        href="http://hsqldb.org/" rel="nofollow">HSQLDB</a>内存数据库。如果我们向<em>容器</em>注入了<strong><em>DataSource</em></strong>实例，那么我们定义的配置将会替换默认配置。\n</p>\n\n<h3 id="h3-2">开发Spring-boot</h3>\n\n<h4 id="h4-11">全局定义开发环境——spring-boot-devtools</h4>\n<p><em>spring-boot-devtools</em>（以下简称<em>Devtools</em>）为开发环境提供了许多快速便捷的设置，仅需要增加一个依赖即可实现开发所需的配置，以<em>Maven</em>为例：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">dependencies</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">dependency</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">groupId</span>&gt;</span>org.springframework.boot<span\n            class="code-tag">&lt;/<span class="code-name">groupId</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">artifactId</span>&gt;</span>spring-boot-devtools<span\n            class="code-tag">&lt;/<span class="code-name">artifactId</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">optional</span>&gt;</span>true<span\n            class="code-tag">&lt;/<span class="code-name">optional</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">dependency</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">dependencies</span>&gt;</span></code></pre>\n<p>在引入他之后当前环境自动变为开发环境。需要注意的是如果运行完整打包的工程<em>Spring Boot</em>不启用任何<em>Devtools</em>相关的功能（实际上打包工具<em>spring-boot-maven-plugin</em>默认情况下不会去打包<em>Devtools</em>），为了防止<em>Devtools</em>的作用域污染子项目，我们最好增加\n    <em>Maven </em>的 <em>optional</em> 标记。</p>\n<p>下面介绍<em>Devtools</em>具体提供了什么功能。</p>\n<p><strong>1.代码修改与热部署</strong></p>\n<p><em>Devtools&nbsp;</em>的一项功能就是能够监控代码的变更，并在发现变更时“热部署”最新的代码。不过这里的热部署不是Jvm bytecode级别的热部属，也和OGSI没任何关系。</p>\n<p>根据官方的介绍是实现了两个ClassLoader——BaseClassLoader和RestartClassLoader（推断这2个ClassLoader应该破坏了双亲委派模型）。第一次启动<em>JVM</em>时所有的<em>.class</em>文件和<em>.jar</em>文件中的类都用<em>BaseClassLoader</em>加载，然后在开发的过程中凡是变更过的<em>.class</em>\n    文件都会被标记，这些被标记的<em>.class</em>之后都会使用<em>RestartClassLoader</em>加载。在初始化一个类时，被标记了用RestartClassLoader加载的Class&lt;?&gt;实例，没有被标则委派给BaseClassLoader加载，每次发起“热部署”时都会新建一个RestartClassLoader重新加载类，这样可以保证变更过的代码都是重新加载的。\n</p>\n<p>在<em>Devtools</em>进行“热部署”时会调用<a href="https://www.concretepage.com/spring/registershutdownhook_spring"\n                                   rel="nofollow">spring的上下文挂钩（spring context hook）</a>来重新部署IOC容器。如果你关闭了它——<span\n        style="color:#FF0000"><em>SpringApplication.setRegisterShutdownHook(false)</em></span>，“热部署”无法将新加载的类实例部署到<em>IOC</em>容器中导致代码替换失败。\n</p>\n<p><img height="385" src="https://file.mahoooo.com/res/file/spring_boot_features_get_started_2.png" width="807"\n        alt="Spring Boot特性入门篇"></p>\n<p>上面是开发过程中Jconsole的输出，每一次修改代码保存都会新增一些非堆（方法区）的空间，这说明重新加载了新的字节码数据并解析到非堆中。</p>\n<p><em>jvm</em>环境中classPath路径下的任何文件修改都会触发<em>Devtools&nbsp;</em>的热部署，某些时候并不需要都监控所有的路径，例如/resources、/static、/template等，我们可以通过设定<em>spring.devtools.restart.exclude</em>属性来排除热部署监控的位置。例如：\n</p>\n<pre><code class="javascript">spring.devtools.restart.exclude=<span class="code-keyword">static</span><span\n        class="code-comment">/**</span></code></pre>\n<p>此外，使用“热部署”时还需注意以下几点（个个都有可能是引发问题的坑啊）：</p>\n<ol>\n    <li>属性<em>spring.devtools.restart.additional-paths</em>属性可以用来增加监控<em>classpath</em>之外的路径。</li>\n    <li><em>Devtools</em>内嵌了<a href="http://livereload.com/extensions/" rel="nofollow">LiveReload</a>，如果不想启用它可以将<em>spring.devtools.livereload.enabled</em>属性设置为<em>fasles</em>。\n    </li>\n    <li><em>Devtools</em>会自动忽略某些包的扫描，例如<em>spring-boot、spring-boot-devtools、spring-boot-autoconfigure、spring-boot-actuator、spring-boot-starter</em>。\n    </li>\n    <li><em>Devtools</em>会修改<em>SpringContext</em>指定的<em>ResourceLoader</em>，如果自定义了一个新的<em>ResourceLoader</em>，修改后的<em>getResource</em>方法将无法生效。\n    </li>\n    <li>将<em>spring.devtools.restart.enabled</em>属性设置为<em>false</em>可以关闭<em>Devtools</em>的“热部署”功能。</li>\n    <li>\n        某些<em>IDE</em>整合了代码监控功能，可以通过<em>spring.devtools.restart.trigger-file</em>属性指定要监控的文件，只有这个文件发生变更时才会触发<em>Devtools</em>进行全局的文件变更检查。\n    </li>\n    <li>前面介绍了<em>Devtools</em>的“热部署”是通过2个<em>ClassLoader</em>（<em>BaseClassLoader、RestartClassLoader</em>）实现的，默认情况下<em>.jar</em>包中的类只会使用<em>BaseClassLoader</em>加载。我们可以通过在根目录新建一个<em>META-INF/spring-devtools.properties</em>文件，然后在其中设置restart.exclude.\n        和&nbsp;restart.include. 属性来指定被&nbsp;RestartClassLoader 加载的 .jar 类。详情见<a\n                href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#using-boot-devtools-customizing-classload"\n                rel="nofollow">官网例子</a>。\n    </li>\n</ol>\n<p><strong>2.缓存启用和停用</strong></p>\n<p>很多框架、工具都提供了缓存功能，在生产环境中对某些热数据进行适当的缓存能够有效的提高性能。但是在开发环境这些缓存反而会影响我们验证功能。所以<em>Devtools</em>全局提供了缓存管理，并默认关闭大部分工具或框架的缓存。开发人员可用通过设置运行环境properties的方式来指定缓存功能，例如：\n</p>\n<pre><code class="java">System.setProperty(<span class="code-string">"spring.thymeleaf.cache"</span>, <span\n        class="code-string">"true"</span>);</code></pre>\n<p>就可以指定启用thymeleaf模板引擎的缓存。缓存管理相关的配置请看 <a\n        href="https://github.com/spring-projects/spring-boot/blob/v1.5.9.RELEASE/spring-boot-devtools/src/main/java/org/springframework/boot/devtools/env/DevToolsPropertyDefaultsPostProcessor.java"\n        rel="nofollow">github上spring-<em>boot-devtools环境设置</em>相关的代码</a> 。</p>\n<p><strong>3.文件配置</strong></p>\n<p>除了使用参数，我们可以把<em>Devtools</em>的所有配置写到<em>$HOME</em>目录下一个"<em>.spring-boot-devtools.properties</em>"的文件中。例如：</p>\n<pre>spring.devtools.reload.trigger-file=.reloadtrigger</pre>\n<p><strong>4.远程开发</strong></p>\n<p>Devtools除了提供本机开发的增强功能之外，还增加了强大的远程开发与调试功能。</p>\n<p>首先，<a href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#using-boot-devtools-remote"\n         rel="nofollow">我们需要在打包的时候连同spring-boot-devtools一起打包并发布</a>，而<em>spring-boot-maven-plugin</em>默认不是打包<em>Devtools</em>的，所以我们需要将<em>Pom</em>文件的<em>plugins</em>配置简单修改一下：\n</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">build</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">plugins</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">plugin</span>&gt;</span>\n            <span class="code-tag">&lt;<span class="code-name">groupId</span>&gt;</span>org.springframework.boot<span\n            class="code-tag">&lt;/<span class="code-name">groupId</span>&gt;</span>\n            <span class="code-tag">&lt;<span class="code-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span\n            class="code-tag">&lt;/<span class="code-name">artifactId</span>&gt;</span>\n            <span class="code-tag">&lt;<span class="code-name">configuration</span>&gt;</span>\n                <span class="code-tag">&lt;<span class="code-name">excludeDevtools</span>&gt;</span>false<span\n            class="code-tag">&lt;/<span class="code-name">excludeDevtools</span>&gt;</span>\n            <span class="code-tag">&lt;/<span class="code-name">configuration</span>&gt;</span>\n        <span class="code-tag">&lt;/<span class="code-name">plugin</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">plugins</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">build</span>&gt;</span></code></pre>\n<p>发布之前需要设置一个属性：</p>\n<pre>spring.devtools.remote.secret=mysecret</pre>\n<p><span style="color:#FF0000">&nbsp;特别需要注意：这个属性会带来安全风险，所以仅仅用于测试和开发，切记不要用于生产运行。</span></p>\n<p>将打好的包部署到远程服务器即可，我们称之为服务端。</p>\n<p>然后，<a\n        href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#_running_the_remote_client_application"\n        rel="nofollow">要在本地开发环境配置一个客户端</a>。</p>\n<p>客户端需要配合IDE一起使用。假设你的工程名字为<em>my-app</em>在Eclipse下进行下面的配置：</p>\n<ol>\n    <li><em><strong>Run</strong></em> 菜单栏目里选择<em><strong>Run Configurations...</strong></em>。</li>\n    <li>创建一个新的&nbsp;<em><strong>Java Application</strong></em>（在<em><strong>Java\n        Application</strong></em>处右键，然后选择<em><strong>new</strong></em>）。\n    </li>\n    <li><strong><em>Project</em></strong>一栏里选择<em>my-app</em>工程。</li>\n    <li><strong><em>Main\n        Class</em></strong>一栏里使用<em>org.springframework.boot.devtools.RemoteSpringApplication</em>作为<em>main</em>方法类。\n    </li>\n    <li><em><strong>Arguments</strong></em>选项卡中，在<strong><em>Program arguments</em></strong>中添加服务端的地址（类似https://myapp.cfapps.io的格式）\n    </li>\n</ol>\n<p>最后，启用了<em>spring.devtools.remote.secret</em>之后，客户端会监控本地classpath下文件变更。一旦触发“热部署”它会先在本地完成，然后将变更的内容推送到远程服务端触发“热部署”。就像你在本地开发一样，这对开发一些回调应用和不同环境的调试带来了极大的便利。\n</p>\n<p>还有，<em>Devtools</em>在基于<em>jdwp</em>远程调式的基础上进行了扩展，提供支持<em>HTTP</em>传输远程调试信息。绝大部分情况下都能使用<em>Java</em>的远程调试能解问题，如有特殊需求（如用到<em>docker</em>等），可以看\n    <a href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#using-boot-devtools-remote-debugtunnel"\n       rel="nofollow">这里</a>。</p>'},425:function(e,t,n){function s(){}function o(e){if(!g(e))return e;var t=[];for(var n in e)a(t,n,e[n]);return t.join("&")}function a(e,t,n){if(null!=n)if(Array.isArray(n))n.forEach(function(n){a(e,t,n)});else if(g(n))for(var s in n)a(e,t+"["+s+"]",n[s]);else e.push(encodeURIComponent(t)+"="+encodeURIComponent(n));else null===n&&e.push(encodeURIComponent(t))}function r(e){for(var t,n,s={},o=e.split("&"),a=0,r=o.length;a<r;++a)t=o[a],n=t.indexOf("="),-1==n?s[decodeURIComponent(t)]="":s[decodeURIComponent(t.slice(0,n))]=decodeURIComponent(t.slice(n+1));return s}function i(e){for(var t,n,s,o,a=e.split(/\r?\n/),r={},i=0,c=a.length;i<c;++i)n=a[i],-1!==(t=n.indexOf(":"))&&(s=n.slice(0,t).toLowerCase(),o=E(n.slice(t+1)),r[s]=o);return r}function c(e){return/[\/+]json($|[^-\w])/.test(e)}function p(e){this.req=e,this.xhr=this.req.xhr,this.text="HEAD"!=this.req.method&&(""===this.xhr.responseType||"text"===this.xhr.responseType)||void 0===this.xhr.responseType?this.xhr.responseText:null,this.statusText=this.req.xhr.statusText;var t=this.xhr.status;1223===t&&(t=204),this._setStatusProperties(t),this.header=this.headers=i(this.xhr.getAllResponseHeaders()),this.header["content-type"]=this.xhr.getResponseHeader("content-type"),this._setHeaderProperties(this.header),null===this.text&&e._responseType?this.body=this.xhr.response:this.body="HEAD"!=this.req.method?this._parseBody(this.text?this.text:this.xhr.response):null}function d(e,t){var n=this;this._query=this._query||[],this.method=e,this.url=t,this.header={},this._header={},this.on("end",function(){var e=null,t=null;try{t=new p(n)}catch(t){return e=new Error("Parser is unable to parse the response"),e.parse=!0,e.original=t,n.xhr?(e.rawResponse=void 0===n.xhr.responseType?n.xhr.responseText:n.xhr.response,e.status=n.xhr.status?n.xhr.status:null,e.statusCode=e.status):(e.rawResponse=null,e.status=null),n.callback(e)}n.emit("response",t);var s;try{n._isResponseOK(t)||(s=new Error(t.statusText||"Unsuccessful HTTP response"))}catch(e){s=e}s?(s.original=e,s.response=t,s.status=t.status,n.callback(s,t)):n.callback(null,t)})}function l(e,t,n){var s=y("DELETE",e);return"function"==typeof t&&(n=t,t=null),t&&s.send(t),n&&s.end(n),s}var h;"undefined"!=typeof window?h=window:"undefined"!=typeof self?h=self:(console.warn("Using browser-only version of superagent in non-browser environment"),h=this);var u=n(509),m=n(591),g=n(475),f=n(592),b=n(590),y=t=e.exports=function(e,n){return"function"==typeof n?new t.Request("GET",e).end(n):1==arguments.length?new t.Request("GET",e):new t.Request(e,n)};t.Request=d,y.getXHR=function(){if(!(!h.XMLHttpRequest||h.location&&"file:"==h.location.protocol&&h.ActiveXObject))return new XMLHttpRequest;try{return new ActiveXObject("Microsoft.XMLHTTP")}catch(e){}try{return new ActiveXObject("Msxml2.XMLHTTP.6.0")}catch(e){}try{return new ActiveXObject("Msxml2.XMLHTTP.3.0")}catch(e){}try{return new ActiveXObject("Msxml2.XMLHTTP")}catch(e){}throw Error("Browser-only version of superagent could not find XHR")};var E="".trim?function(e){return e.trim()}:function(e){return e.replace(/(^\s*|\s*$)/g,"")};y.serializeObject=o,y.parseString=r,y.types={html:"text/html",json:"application/json",xml:"text/xml",urlencoded:"application/x-www-form-urlencoded",form:"application/x-www-form-urlencoded","form-data":"application/x-www-form-urlencoded"},y.serialize={"application/x-www-form-urlencoded":o,"application/json":JSON.stringify},y.parse={"application/x-www-form-urlencoded":r,"application/json":JSON.parse},f(p.prototype),p.prototype._parseBody=function(e){var t=y.parse[this.type];return this.req._parser?this.req._parser(this,e):(!t&&c(this.type)&&(t=y.parse["application/json"]),t&&e&&(e.length||e instanceof Object)?t(e):null)},p.prototype.toError=function(){var e=this.req,t=e.method,n=e.url,s="cannot "+t+" "+n+" ("+this.status+")",o=new Error(s);return o.status=this.status,o.method=t,o.url=n,o},y.Response=p,u(d.prototype),m(d.prototype),d.prototype.type=function(e){return this.set("Content-Type",y.types[e]||e),this},d.prototype.accept=function(e){return this.set("Accept",y.types[e]||e),this},d.prototype.auth=function(e,t,n){1===arguments.length&&(t=""),"object"==typeof t&&null!==t&&(n=t,t=""),n||(n={type:"function"==typeof btoa?"basic":"auto"});var s=function(e){if("function"==typeof btoa)return btoa(e);throw new Error("Cannot use basic auth, btoa is not a function")};return this._auth(e,t,n,s)},d.prototype.query=function(e){return"string"!=typeof e&&(e=o(e)),e&&this._query.push(e),this},d.prototype.attach=function(e,t,n){if(t){if(this._data)throw Error("superagent can't mix .send() and .attach()");this._getFormData().append(e,t,n||t.name)}return this},d.prototype._getFormData=function(){return this._formData||(this._formData=new h.FormData),this._formData},d.prototype.callback=function(e,t){if(this._shouldRetry(e,t))return this._retry();var n=this._callback;this.clearTimeout(),e&&(this._maxRetries&&(e.retries=this._retries-1),this.emit("error",e)),n(e,t)},d.prototype.crossDomainError=function(){var e=new Error("Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.");e.crossDomain=!0,e.status=this.status,e.method=this.method,e.url=this.url,this.callback(e)},d.prototype.buffer=d.prototype.ca=d.prototype.agent=function(){return console.warn("This is not supported in browser version of superagent"),this},d.prototype.pipe=d.prototype.write=function(){throw Error("Streaming is not supported in browser version of superagent")},d.prototype._isHost=function(e){return e&&"object"==typeof e&&!Array.isArray(e)&&"[object Object]"!==Object.prototype.toString.call(e)},d.prototype.end=function(e){return this._endCalled&&console.warn("Warning: .end() was called twice. This is not supported in superagent"),this._endCalled=!0,this._callback=e||s,this._finalizeQueryString(),this._end()},d.prototype._end=function(){var e=this,t=this.xhr=y.getXHR(),n=this._formData||this._data;this._setTimeouts(),t.onreadystatechange=function(){var n=t.readyState;if(n>=2&&e._responseTimeoutTimer&&clearTimeout(e._responseTimeoutTimer),4==n){var s;try{s=t.status}catch(e){s=0}if(!s){if(e.timedout||e._aborted)return;return e.crossDomainError()}e.emit("end")}};var s=function(t,n){n.total>0&&(n.percent=n.loaded/n.total*100),n.direction=t,e.emit("progress",n)};if(this.hasListeners("progress"))try{t.onprogress=s.bind(null,"download"),t.upload&&(t.upload.onprogress=s.bind(null,"upload"))}catch(e){}try{this.username&&this.password?t.open(this.method,this.url,!0,this.username,this.password):t.open(this.method,this.url,!0)}catch(e){return this.callback(e)}if(this._withCredentials&&(t.withCredentials=!0),!this._formData&&"GET"!=this.method&&"HEAD"!=this.method&&"string"!=typeof n&&!this._isHost(n)){var o=this._header["content-type"],a=this._serializer||y.serialize[o?o.split(";")[0]:""];!a&&c(o)&&(a=y.serialize["application/json"]),a&&(n=a(n))}for(var r in this.header)null!=this.header[r]&&this.header.hasOwnProperty(r)&&t.setRequestHeader(r,this.header[r]);return this._responseType&&(t.responseType=this._responseType),this.emit("request",this),t.send(void 0!==n?n:null),this},y.agent=function(){return new b},["GET","POST","OPTIONS","PATCH","PUT","DELETE"].forEach(function(e){b.prototype[e.toLowerCase()]=function(t,n){var s=new y.Request(e,t);return this._setDefaults(s),n&&s.end(n),s}}),b.prototype.del=b.prototype.delete,y.get=function(e,t,n){var s=y("GET",e);return"function"==typeof t&&(n=t,t=null),t&&s.query(t),n&&s.end(n),s},y.head=function(e,t,n){var s=y("HEAD",e);return"function"==typeof t&&(n=t,t=null),t&&s.query(t),n&&s.end(n),s},y.options=function(e,t,n){var s=y("OPTIONS",e);return"function"==typeof t&&(n=t,t=null),t&&s.send(t),n&&s.end(n),s},y.del=l,y.delete=l,y.patch=function(e,t,n){var s=y("PATCH",e);return"function"==typeof t&&(n=t,t=null),t&&s.send(t),n&&s.end(n),s},y.post=function(e,t,n){var s=y("POST",e);return"function"==typeof t&&(n=t,t=null),t&&s.send(t),n&&s.end(n),s},y.put=function(e,t,n){var s=y("PUT",e);return"function"==typeof t&&(n=t,t=null),t&&s.send(t),n&&s.end(n),s}},475:function(e,t,n){"use strict";function s(e){return null!==e&&"object"==typeof e}e.exports=s},509:function(e,t,n){function s(e){if(e)return o(e)}function o(e){for(var t in s.prototype)e[t]=s.prototype[t];return e}e.exports=s,s.prototype.on=s.prototype.addEventListener=function(e,t){return this._callbacks=this._callbacks||{},(this._callbacks["$"+e]=this._callbacks["$"+e]||[]).push(t),this},s.prototype.once=function(e,t){function n(){this.off(e,n),t.apply(this,arguments)}return n.fn=t,this.on(e,n),this},s.prototype.off=s.prototype.removeListener=s.prototype.removeAllListeners=s.prototype.removeEventListener=function(e,t){if(this._callbacks=this._callbacks||{},0==arguments.length)return this._callbacks={},this;var n=this._callbacks["$"+e];if(!n)return this;if(1==arguments.length)return delete this._callbacks["$"+e],this;for(var s,o=0;o<n.length;o++)if((s=n[o])===t||s.fn===t){n.splice(o,1);break}return this},s.prototype.emit=function(e){this._callbacks=this._callbacks||{};var t=[].slice.call(arguments,1),n=this._callbacks["$"+e];if(n){n=n.slice(0);for(var s=0,o=n.length;s<o;++s)n[s].apply(this,t)}return this},s.prototype.listeners=function(e){return this._callbacks=this._callbacks||{},this._callbacks["$"+e]||[]},s.prototype.hasListeners=function(e){return!!this.listeners(e).length}},590:function(e,t){function n(){this._defaults=[]}["use","on","once","set","query","type","accept","auth","withCredentials","sortQuery","retry","ok","redirects","timeout","buffer","serialize","parse","ca","key","pfx","cert"].forEach(function(e){n.prototype[e]=function(){return this._defaults.push({fn:e,arguments:arguments}),this}}),n.prototype._setDefaults=function(e){this._defaults.forEach(function(t){e[t.fn].apply(e,t.arguments)})},e.exports=n},591:function(e,t,n){"use strict";function s(e){if(e)return o(e)}function o(e){for(var t in s.prototype)e[t]=s.prototype[t];return e}var a=n(475);e.exports=s,s.prototype.clearTimeout=function(){return clearTimeout(this._timer),clearTimeout(this._responseTimeoutTimer),delete this._timer,delete this._responseTimeoutTimer,this},s.prototype.parse=function(e){return this._parser=e,this},s.prototype.responseType=function(e){return this._responseType=e,this},s.prototype.serialize=function(e){return this._serializer=e,this},s.prototype.timeout=function(e){if(!e||"object"!=typeof e)return this._timeout=e,this._responseTimeout=0,this;for(var t in e)switch(t){case"deadline":this._timeout=e.deadline;break;case"response":this._responseTimeout=e.response;break;default:console.warn("Unknown timeout option",t)}return this},s.prototype.retry=function(e,t){return 0!==arguments.length&&!0!==e||(e=1),e<=0&&(e=0),this._maxRetries=e,this._retries=0,this._retryCallback=t,this};var r=["ECONNRESET","ETIMEDOUT","EADDRINFO","ESOCKETTIMEDOUT"];s.prototype._shouldRetry=function(e,t){if(!this._maxRetries||this._retries++>=this._maxRetries)return!1;if(this._retryCallback)try{var n=this._retryCallback(e,t);if(!0===n)return!0;if(!1===n)return!1}catch(e){console.error(e)}if(t&&t.status&&t.status>=500&&501!=t.status)return!0;if(e){if(e.code&&~r.indexOf(e.code))return!0;if(e.timeout&&"ECONNABORTED"==e.code)return!0;if(e.crossDomain)return!0}return!1},s.prototype._retry=function(){return this.clearTimeout(),this.req&&(this.req=null,this.req=this.request()),this._aborted=!1,this.timedout=!1,this._end()},s.prototype.then=function(e,t){if(!this._fullfilledPromise){var n=this;this._endCalled&&console.warn("Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises"),this._fullfilledPromise=new Promise(function(e,t){n.end(function(n,s){n?t(n):e(s)})})}return this._fullfilledPromise.then(e,t)},s.prototype.catch=function(e){return this.then(void 0,e)},s.prototype.use=function(e){return e(this),this},s.prototype.ok=function(e){if("function"!=typeof e)throw Error("Callback required");return this._okCallback=e,this},s.prototype._isResponseOK=function(e){return!!e&&(this._okCallback?this._okCallback(e):e.status>=200&&e.status<300)},s.prototype.get=function(e){return this._header[e.toLowerCase()]},s.prototype.getHeader=s.prototype.get,s.prototype.set=function(e,t){if(a(e)){for(var n in e)this.set(n,e[n]);return this}return this._header[e.toLowerCase()]=t,this.header[e]=t,this},s.prototype.unset=function(e){return delete this._header[e.toLowerCase()],delete this.header[e],this},s.prototype.field=function(e,t){if(null===e||void 0===e)throw new Error(".field(name, val) name can not be empty");if(this._data&&console.error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()"),a(e)){for(var n in e)this.field(n,e[n]);return this}if(Array.isArray(t)){for(var s in t)this.field(e,t[s]);return this}if(null===t||void 0===t)throw new Error(".field(name, val) val can not be empty");return"boolean"==typeof t&&(t=""+t),this._getFormData().append(e,t),this},s.prototype.abort=function(){return this._aborted?this:(this._aborted=!0,this.xhr&&this.xhr.abort(),this.req&&this.req.abort(),this.clearTimeout(),this.emit("abort"),this)},s.prototype._auth=function(e,t,n,s){switch(n.type){case"basic":this.set("Authorization","Basic "+s(e+":"+t));break;case"auto":this.username=e,this.password=t;break;case"bearer":this.set("Authorization","Bearer "+e)}return this},s.prototype.withCredentials=function(e){return void 0==e&&(e=!0),this._withCredentials=e,this},s.prototype.redirects=function(e){return this._maxRedirects=e,this},s.prototype.maxResponseSize=function(e){if("number"!=typeof e)throw TypeError("Invalid argument");return this._maxResponseSize=e,this},s.prototype.toJSON=function(){return{method:this.method,url:this.url,data:this._data,headers:this._header}},s.prototype.send=function(e){var t=a(e),n=this._header["content-type"];if(this._formData&&console.error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()"),t&&!this._data)Array.isArray(e)?this._data=[]:this._isHost(e)||(this._data={});else if(e&&this._data&&this._isHost(this._data))throw Error("Can't merge these send calls");if(t&&a(this._data))for(var s in e)this._data[s]=e[s];else"string"==typeof e?(n||this.type("form"),n=this._header["content-type"],this._data="application/x-www-form-urlencoded"==n?this._data?this._data+"&"+e:e:(this._data||"")+e):this._data=e;return!t||this._isHost(e)?this:(n||this.type("json"),this)},s.prototype.sortQuery=function(e){return this._sort=void 0===e||e,this},s.prototype._finalizeQueryString=function(){var e=this._query.join("&");if(e&&(this.url+=(this.url.indexOf("?")>=0?"&":"?")+e),this._query.length=0,this._sort){var t=this.url.indexOf("?");if(t>=0){var n=this.url.substring(t+1).split("&");"function"==typeof this._sort?n.sort(this._sort):n.sort(),this.url=this.url.substring(0,t)+"?"+n.join("&")}}},s.prototype._appendQueryString=function(){console.trace("Unsupported")},s.prototype._timeoutError=function(e,t,n){if(!this._aborted){var s=new Error(e+t+"ms exceeded");s.timeout=t,s.code="ECONNABORTED",s.errno=n,this.timedout=!0,this.abort(),this.callback(s)}},s.prototype._setTimeouts=function(){var e=this;this._timeout&&!this._timer&&(this._timer=setTimeout(function(){e._timeoutError("Timeout of ",e._timeout,"ETIME")},this._timeout)),this._responseTimeout&&!this._responseTimeoutTimer&&(this._responseTimeoutTimer=setTimeout(function(){e._timeoutError("Response timeout of ",e._responseTimeout,"ETIMEDOUT")},this._responseTimeout))}},592:function(e,t,n){"use strict";function s(e){if(e)return o(e)}function o(e){for(var t in s.prototype)e[t]=s.prototype[t];return e}var a=n(593);e.exports=s,s.prototype.get=function(e){return this.header[e.toLowerCase()]},s.prototype._setHeaderProperties=function(e){var t=e["content-type"]||"";this.type=a.type(t);var n=a.params(t);for(var s in n)this[s]=n[s];this.links={};try{e.link&&(this.links=a.parseLinks(e.link))}catch(e){}},s.prototype._setStatusProperties=function(e){var t=e/100|0;this.status=this.statusCode=e,this.statusType=t,this.info=1==t,this.ok=2==t,this.redirect=3==t,this.clientError=4==t,this.serverError=5==t,this.error=(4==t||5==t)&&this.toError(),this.created=201==e,this.accepted=202==e,this.noContent=204==e,this.badRequest=400==e,this.unauthorized=401==e,this.notAcceptable=406==e,this.forbidden=403==e,this.notFound=404==e,this.unprocessableEntity=422==e}},593:function(e,t,n){"use strict";t.type=function(e){return e.split(/ *; */).shift()},t.params=function(e){return e.split(/ *; */).reduce(function(e,t){var n=t.split(/ *= */),s=n.shift(),o=n.shift();return s&&o&&(e[s]=o),e},{})},t.parseLinks=function(e){return e.split(/ *, */).reduce(function(e,t){var n=t.split(/ *; */),s=n[0].slice(1,-1);return e[n[1].split(/ *= */)[1].slice(1,-1)]=s,e},{})},t.cleanHeader=function(e,t){return delete e["content-type"],delete e["content-length"],delete e["transfer-encoding"],delete e.host,t&&(delete e.authorization,delete e.cookie),e}}});