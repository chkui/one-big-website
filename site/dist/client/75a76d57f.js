webpackJsonp([7],{339:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h2 id="h2-1">Web组件</h2>\n<p>从概念上说，React 和 <a title="Web组件" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components" rel="nofollow">Web组件</a>&nbsp;分别用于解决不同的问题。Web组件提供了强大的封装特性来支持其可重复使用性，而React提供了一系列声明性（declarative）接口保证Dom结构和数据同步。但是某些时候这2个目标是互补的。对于开发人员来说将React用于Web组件、或将Web组件用于React、或2者皆有并非难事。\n</p>\n<p>虽然大部分使用React的开发人员并不需要使用Web组件，但是在某些情况，特别是引入了某些第三方库，还是需要使用到相关机制。</p>\n\n<h3 id="h3-1">在React中使用Web组件</h3>\n<pre class="scala"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span\n        class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span\n        class="code-title"><span class="hljs-class"><span class="code-title">HelloMessage</span></span></span><span\n        class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="xml"><span class="code-tag">&lt;<span\n            class="code-name">div</span>&gt;</span><span class="code-type">Hello</span> <span class="code-tag">&lt;<span\n            class="code-name">x-search</span>&gt;</span>{<span class="code-keyword">this</span>.props.name}<span\n            class="code-tag">&lt;/<span class="code-name">x-search</span>&gt;</span>!<span class="code-tag">&lt;/<span\n            class="code-name">div</span>&gt;</span>;\n  }\n}</span></code></pre>\n<blockquote>\n    <p>Web组件常会暴露一些必要的API接口，例如一个 video Web组件可能会暴露&nbsp;&nbsp;<code>play()</code>&nbsp;和&nbsp;<code>pause()</code>&nbsp;方法。为了获取Web组件暴露的这些API接口，需要在React编码使用Refs特性来直接获取真实的Dom节点。如果引入第三方的Web组件，最好的解决方案使用一个React组件来包装引入的Web组件并最终作为一个React组件来使用。\n    </p>\n    <p>由第三方Web组件触发的事件也许并不能通过React的渲染树传递，此时需要在组件中去手工的触发事件。&nbsp;</p>\n</blockquote>\n<p>一个经常导致混乱的地方是，Web组件使用的是“class”而React使用的是“className”，例如：</p>\n<pre class="javascript"><code class="language-javascript"><span class="hljs-function"><span class="code-keyword"><span\n        class="hljs-function"><span class="code-keyword">function</span></span></span><span\n        class="hljs-function"> </span><span class="code-title"><span class="hljs-function"><span class="code-title">BrickFlipbox</span></span></span><span\n        class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span\n        class="hljs-params"></span>) </span></span>{\n  <span class="code-keyword"><span class="code-keyword">return</span></span> (\n    <span class="xml"><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span\n            class="code-name">brick-flipbox</span></span></span></span><span class="xml"><span class="code-tag"> </span></span><span\n            class="hljs-attr"><span class="xml"><span class="code-tag"><span\n            class="hljs-attr">class</span></span></span></span><span class="xml"><span\n            class="code-tag">=</span></span><span class="code-string"><span class="xml"><span class="code-tag"><span\n            class="code-string">"demo"</span></span></span></span><span class="xml"><span\n            class="code-tag">&gt;</span></span></span><span class="xml">\n      </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">div</span></span></span></span><span\n            class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">front</span><span\n            class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span\n            class="xml"><span class="code-tag"><span class="code-name">div</span></span></span></span><span class="xml"><span\n            class="code-tag">&gt;</span></span></span><span class="xml">\n      </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">div</span></span></span></span><span\n            class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">back</span><span\n            class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span\n            class="xml"><span class="code-tag"><span class="code-name">div</span></span></span></span><span class="xml"><span\n            class="code-tag">&gt;</span></span></span><span class="xml">\n    </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span\n            class="code-name">brick-flipbox</span></span></span></span><span class="xml"><span\n            class="code-tag">&gt;</span></span></span><span class="xml">\n  );\n}</span></span></code></pre>\n\n<h3 id="h3-2">在Web组件中使用React</h3>\n<pre class="javascript"><code class="language-javascript"><span class="code-keyword"><span\n        class="code-keyword">const</span></span> proto = <span class="code-built_in"><span\n        class="code-built_in">Object</span></span>.create(HTMLElement.prototype, {\n  attachedCallback: {\n    value: <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">function</span></span></span><span class="hljs-function">(</span><span\n            class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{\n      <span class="code-keyword"><span class="code-keyword">const</span></span> mountPoint = <span\n            class="code-built_in"><span class="code-built_in">document</span></span>.createElement(<span\n            class="code-string"><span class="code-string">\'span\'</span></span>);\n      <span class="code-keyword"><span class="code-keyword">this</span></span>.createShadowRoot().appendChild(mountPoint);\n\n      <span class="code-keyword"><span class="code-keyword">const</span></span> name = <span class="code-keyword"><span\n            class="code-keyword">this</span></span>.getAttribute(<span class="code-string"><span class="code-string">\'name\'</span></span>);\n      <span class="code-keyword"><span class="code-keyword">const</span></span> url = <span class="code-string"><span\n            class="code-string">\'https://www.google.com/search?q=\'</span></span> + <span class="code-built_in"><span\n            class="code-built_in">encodeURIComponent</span></span>(name);\n      ReactDOM.render(<span class="xml"><span class="code-tag"><span class="xml"><span\n            class="code-tag">&lt;</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span\n            class="code-name">a</span></span></span></span><span class="xml"><span class="code-tag"> </span></span><span\n            class="hljs-attr"><span class="xml"><span class="code-tag"><span class="hljs-attr">href</span></span></span></span><span\n            class="xml"><span class="code-tag">=</span></span><span class="code-string"><span class="xml"><span\n            class="code-tag"><span class="code-string">{url}</span></span></span></span><span class="xml"><span\n            class="code-tag">&gt;</span></span></span><span class="xml">{name}</span><span class="code-tag"><span\n            class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span class="xml"><span\n            class="code-tag"><span class="code-name">a</span></span></span></span><span class="xml"><span\n            class="code-tag">&gt;</span></span></span></span>, mountPoint);\n    }\n  }\n});\n<span class="code-built_in"><span class="code-built_in">document</span></span>.registerElement(<span\n            class="code-string"><span class="code-string">\'x-search\'</span></span>, {prototype: proto});</code></pre>\n\n<h3 id="h3-3">React整合Jquery这一类直接操作Dom的技术</h3>\n<p>\n    React在发生真实Dom渲染之前都会先产生与之对应的虚拟Dom结构，然后再“合适”的时候将虚拟Dom的内容渲染到真实Dom上，完成渲染之后componentDidMount会被调用。Jquery这一类真实Dom的操作技术投入实际使用时最好在componentDidMount中使用，然后保证这个组件不会的虚拟Dom不发生任何改变。</p>'},347:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h2 id="h2-1">在一般组件中使用Forwarding Refs</h2>\n<p>通常情况下，我们想获取一个组建或则一个HTML元素的实例通过 <a\n        href="https://www.chkui.com/article/react/react_typechecking_with_proptypes_and_dom_element" title="Ref特性">Ref特性</a>\n    就可以实现，但是某些时候我们需要在子父级组建中传递使用实例，Forwarding Refs提供了一种技术手段来满足这个要求，特别是开发一些重复使用的组建库时。比如下面的例子：</p>\n<pre><code class="javascript"><span class="hljs-function"><span class="code-keyword">function</span> <span\n        class="code-title">MyButton</span>(<span class="hljs-params">props</span>) </span>{\n  <span class="code-keyword">return</span> (\n    <span class="xml"><span class="code-tag">&lt;<span class="code-name">button</span> <span\n            class="hljs-attr">className</span>=<span class="code-string">"MyButton"</span>&gt;</span>\n      {props.children}\n    <span class="code-tag">&lt;/<span class="code-name">button</span>&gt;</span></span>\n  );\n}</code></pre>\n<p>上面的代码中MyButton组件渲染了一个HTML元素。对于使用者而言，React隐藏了将代码渲染成页面元素的过程，当其他组件使用MyButton时，并没有任何直接的方法来获取MyButton中的&lt;button&gt;元素，这样的设计方法有利于组建的分片管理，降低耦合。</p>\n<p>\n    但是像MyButton这样的组建，其实仅仅是对基本的HTML元素进行了简单的封装。某些时候，上层组建使用他时更希望将其作为一个基本的HTML元素来看待，实现某些效果需要直接操作DOM，比如focus、selection和animations效果。</p>\n<p>下面的例子将Forwarding Refs添加到MyButton组件中，以实现实例传递的效果。</p>\n<pre><code class="javascript"><span class="code-keyword">const</span> MyButton = React.forwardRef(<span\n        class="hljs-function">(<span class="hljs-params">props, ref</span>) =&gt;</span> (\n  <span class="xml"><span class="code-tag">&lt;<span class="code-name">button</span> <span class="hljs-attr">ref</span>=<span\n          class="code-string">{ref}</span> <span class="hljs-attr">className</span>=<span\n          class="code-string">"MyButton"</span>&gt;</span>\n    {props.children}\n  <span class="code-tag">&lt;/<span class="code-name">button</span>&gt;</span></span>\n));\n\n<span class="code-comment">// 通过ref可以直接操作&lt;button&gt;元素:</span>\n<span class="code-keyword">const</span> ref = React.createRef();\n<span class="xml"><span class="code-tag">&lt;<span class="code-name">MyButton</span> <span class="hljs-attr">ref</span>=<span\n        class="code-string">{ref}</span>&gt;</span>Click me!<span class="code-tag">&lt;/<span\n        class="code-name">MyButton</span>&gt;</span></span>;</code></pre>\n<p>这个时候，ref可以直接操作&lt;button&gt;元素。其实执行过程非常简单，也就下面5步：</p>\n<ol>\n    <li>通过React.createRef()方法创建一个ref实例。</li>\n    <li>和通常使用Ref一样，将其作为一个ref属性参数传递给MyButton组件。</li>\n    <li>使用React.forwardRef方法来创建一个组件，并将ref作为第二个参数传递。</li>\n    <li>将ref参数以ref属性的方式传递给&lt;button&gt;元素。</li>\n    <li>在渲染之后，可以使用ref.current来获取&lt;button&gt;元素的实例。</li>\n</ol>\n<p><span style="color:#e74c3c">需要注意的是只有使用React.forwardRef来创建一个组件时，第二个ref参数才会存在。固定的方法或者使用类来创建组件并不会接收到ref参数。Forwarding Refs特性并不仅仅局限于用在HTML DOM元素上，这种方式也实用于组件之间传递Ref。&nbsp;</span>\n</p>\n\n<h2 id="h2-2">在高阶组件中使用Forwarding Refs</h2>\n<p><a href="https://www.chkui.com/article/react/react_high_order_component" title="高阶组件">高阶组件（HOCs）</a>仅仅对一般组件的包装。一般组件被包装之后对于使用者来说并不清晰其是否是被包装过，此时使用Ref得到的是高阶组件的实例。因此Forwarding\n    Refs特性对于高阶组件来说更有价值。</p>\n<p>下面是一个高阶组件记录日志的例子：</p>\n<pre><code class="javascript"><span class="hljs-function"><span class="code-keyword">function</span> <span\n        class="code-title">logProps</span>(<span class="hljs-params">WrappedComponent</span>) </span>{\n  <span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">LogProps</span> <span\n          class="code-keyword">extends</span> <span class="code-title">React</span>.<span\n          class="code-title">Component</span> </span>{\n    componentDidUpdate(prevProps) {\n      <span class="code-built_in">console</span>.log(<span class="code-string">\'old props:\'</span>, prevProps);\n      <span class="code-built_in">console</span>.log(<span class="code-string">\'new props:\'</span>, <span\n            class="code-keyword">this</span>.props);\n    }\n\n    render() {\n      <span class="code-keyword">return</span> <span class="xml"><span class="code-tag">&lt;<span class="code-name">WrappedComponent</span> {<span\n            class="hljs-attr">...this.props</span>} /&gt;</span>;\n    }\n  }\n\n  return LogProps;\n}</span></code></pre>\n<p>logProps组件用于在每次数据更新前后记录props中的数据。我们用其包装前面的MyButton组件。</p>\n<pre><code class="javascript"><span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MyButton</span> <span\n        class="code-keyword">extends</span> <span class="code-title">React</span>.<span\n        class="code-title">Component</span> </span>{\n  focus() {\n    <span class="code-comment">// ...</span>\n  }\n\n  render() {\n    <span class="code-comment">//</span>\n  }\n}\n\n<span class="code-keyword">export</span> <span class="code-keyword">default</span> logProps(MyButton);</code></pre>\n<p>此时通过import并使用Refs实际上得到的是LogProps的实例：</p>\n<pre><code class="javascript"><span class="code-keyword">import</span> FancyButton <span\n        class="code-keyword">from</span> <span class="code-string">\'./FancyButton\'</span>;\n\n<span class="code-keyword">const</span> ref = React.createRef();\n<span class="xml"><span class="code-tag">&lt;<span class="code-name">MyButton</span>\n  <span class="hljs-attr">label</span>=<span class="code-string">"Click Me"</span>\n  <span class="hljs-attr">handleClick</span>=<span class="code-string">{handleClick}</span>\n  <span class="hljs-attr">ref</span>=<span class="code-string">{ref}</span>\n/&gt;</span>;</span></code></pre>\n<p>我们使用Forwarding Refs对高阶组件进行简单的改造即可解决这个问题：</p>\n<pre><code class="javascript"><span class="hljs-function"><span class="code-keyword">function</span> <span\n        class="code-title">logProps</span>(<span class="hljs-params">Component</span>) </span>{\n  <span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">LogProps</span> <span\n          class="code-keyword">extends</span> <span class="code-title">React</span>.<span\n          class="code-title">Component</span> </span>{\n    componentDidUpdate(prevProps) {\n      <span class="code-built_in">console</span>.log(<span class="code-string">\'old props:\'</span>, prevProps);\n      <span class="code-built_in">console</span>.log(<span class="code-string">\'new props:\'</span>, <span\n            class="code-keyword">this</span>.props);\n    }\n\n    render() {\n      <span class="code-keyword">const</span> {forwardedRef, ...rest} = <span class="code-keyword">this</span>.props;\n\n      <span class="code-comment">// 通过forwardedRef参数传递ref的值</span>\n      <span class="code-keyword">return</span> &lt;Component ref={forwardedRef} {...rest} /&gt;;\n    }\n  }\n  \n  //然后使用 React.forwardRef 来包装创建 LogProps组件的实例\n  //注意这里使用 forwardedRef 来传递 父组件的 ref\n  //\n  return React.forwardRef((props, ref) =&gt; {\n    return &lt;LogProps {...props} forwardedRef={ref} /&gt;;\n  });\n}</code></pre>\n\n<h2 id="h2-3">开发调试组件名称显示</h2>\n<p>如果我们不进行任何调整，下面的代码在调试工具中输出的组件名称为："ForwardRef(MyComonent)"：</p>\n<pre><code class="javascript"><span class="code-keyword">const</span> WrappedComponent = React.forwardRef(\n  <span class="hljs-function"><span class="code-keyword">function</span> <span\n          class="code-title">myFunction</span>(<span class="hljs-params">props, ref</span>) </span>{\n    <span class="code-keyword">return</span> <span class="xml"><span class="code-tag">&lt;<span class="code-name">LogProps</span> {<span\n            class="hljs-attr">...props</span>} <span class="hljs-attr">forwardedRef</span>=<span class="code-string">{ref}</span> /&gt;</span>;\n  }\n);</span></code></pre>\n<p>可以通过displayName来设定想要现实的名字：</p>\n<pre><code class="javascript"><span class="hljs-function"><span class="code-keyword">function</span> <span\n        class="code-title">logProps</span>(<span class="hljs-params">Component</span>) </span>{\n  <span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">LogProps</span> <span\n          class="code-keyword">extends</span> <span class="code-title">React</span>.<span\n          class="code-title">Component</span> </span>{\n    <span class="code-comment">// ...</span>\n  }\n\n  <span class="code-comment">//先定义返回的高阶组件方法</span>\n  <span class="hljs-function"><span class="code-keyword">function</span> <span\n          class="code-title">forwardRef</span>(<span class="hljs-params">props, ref</span>) </span>{\n    <span class="code-keyword">return</span> <span class="xml"><span class="code-tag">&lt;<span class="code-name">LogProps</span> {<span\n            class="hljs-attr">...props</span>} <span class="hljs-attr">forwardedRef</span>=<span class="code-string">{ref}</span> /&gt;</span>;\n  }\n\n  //然后设定这个组件的名称\n  const name = Component.displayName || Component.name;\n  forwardRef.displayName = `logProps(${name})`;\n\n  //构建组件\n  return React.forwardRef(forwardRef);\n}</span></code></pre>'},361:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<p>在<a href="https://www.chkui.com/article/spring/spring_core_auto_inject_of_annotation" title="注解自动装载">注解自动装载</a>中介绍了通过注解（Annotation）自动向Bean中注入其他Bean的方法，本篇将介绍通过注解（Annotation）向容器添加Bean的方法。\n</p>\n<p>\n    Spring的核心容器提供了@Component和@Bean注解来标记如何向IoC容器添加Bean。在核心包中@Component又派生了@Service、@Controller和@Repository这三个注解（在其他的Spring工程或包中还有更多的派生），本文主要介绍@Component及其派生注解的使用。</p>\n\n<h2 id="h2-1">一个简单的使用例子</h2>\n<p>\n    要想使用@Component等注解来向容器添加Bean，需要向IoC容器指明什么类有这个注解，所以Spring提供了一个扫描机制让使用者指定要检查的路径。配置非常简单，只要使用上下文的component-scan标签即可。我们通过下面的例子来简单说明如何配置。</p>\n<p>例子中的代码仅用于说明问题，并不能运行。源码请到<a href="https://gitee.com/chkui-com/spring-core-sample" rel="nofollow">https://gitee.com/chkui-com/spring-core-sample</a>自行clone，例子在<em>chkui.springcore.example.hybrid.component</em>包中。\n</p>\n<p>有一个接口和一个实现类作为要添加到IoC容器的Bean：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.component.bean;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n            class="code-title">NameService</span> </span>{\n\t<span class="hljs-function">String <span class="code-title">getName</span><span class="hljs-params">()</span></span>;\n}</code></pre>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.component.bean;\n\n<span class="code-meta">@Component</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">NameServiceImpl</span> <span class="code-keyword">implements</span> <span\n            class="code-title">NameService</span></span>{\n\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span\n            class="code-title">getName</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"This is My Component"</span>;\n\t}\n}</code></pre>\n<p>在实现类NameServiceImpl上使用了@Component注解。</p>\n<p>然后XML（/spring-core-sample/src/main/resources/hybrid/component）配置为：</p>\n<pre><code class="xml"><span class="php"><span class="code-meta">&lt;?</span>xml version=<span\n        class="code-string">"1.0"</span> encoding=<span class="code-string">"UTF-8"</span><span\n        class="code-meta">?&gt;</span></span>\n<span class="code-tag">&lt;<span class="code-name">beans</span> <span class="hljs-attr">xmlns</span>=<span\n        class="code-string">"http://www.springframework.org/schema/beans"</span>\n    <span class="hljs-attr">xmlns:xsi</span>=<span\n            class="code-string">"http://www.w3.org/2001/XMLSchema-instance"</span>\n    <span class="hljs-attr">xmlns:context</span>=<span class="code-string">"http://www.springframework.org/schema/context"</span>\n    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="code-string">"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span>\n    \n    <span class="code-tag">&lt;<span class="code-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span\n            class="code-string">"chkui.springcore.example.hybrid.component.bean"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>XML配置文件中没有任何&lt;bean&gt;的声明，仅仅是通过component-scan启用了路径扫描功能，base-package指定了扫描的包路径。</p>\n<p>然后我们加载这个XML运行Spring IoC容器：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.component;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">SimpleScanApp</span> </span>{\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tprint(<span class="code-keyword">new</span> ClassPathXmlApplicationContext(<span class="code-string">"hybrid/component/scanConfig.xml"</span>));\n\t}\n\t\n\t<span class="hljs-function"><span class="code-keyword">private</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">print</span><span class="hljs-params">(ApplicationContext context)</span> </span>{\n    \tNameService service = context.getBean(NameService.class);\n    \tSystem.out.println(service.getName());\n\t}\n}</code></pre>\n<p>运行之后NameServiceImpl就会作为一个Bean添加到IoC容器中。</p>\n<p>在<a href="https://www.chkui.com/article/spring/spring_core_ioc_extension_points" title="IOC功能扩展点">IOC功能扩展点</a>&nbsp;一文中已经介绍通过XML、@Component、@Bean任何一种方式去声明一个Bean都会转化为一个&nbsp;<a\n        href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/config/BeanDefinition.html"\n        rel="nofollow">BeanDefinition</a>的实现类交给BeanFactory来创建实例，所以实际上通过@Component注解和在XML文件中编写一个&lt;bean&gt;标签在结果上并没有什么区别——都是向容器添加了一个Bean实例。但是Spring偏偏提供了@Bean和@Component（以及他的派生注解）2个注解来声名Bean，这当中肯定是有一些差异的。\n</p>\n<p>@Bean在后续的文章会介绍，它就等价与在XML编写一个&lt;bean&gt;标签。而@Component以及他的派生注解除了是一个IoC容器中的Bean还有许多附加的含义。</p>\n\n<h2 id="h2-2">Stereotype与功能分层</h2>\n<p>观察@Bean和@Component两个注解的包，前者是在 <em>org.springframework.context.annotation</em> ，而后者是在&nbsp;<em>org.springframework.stereotype</em>\n    。不仅仅是@Component，他的派生注解@Service、@Controller和@Repository都在这个包中，实际上它就是在告诉使用者这些注解提供<em>stereotype</em>的特性（或者称为功能、作用）。\n</p>\n<p>那什么是<em>stereotype</em>特性呢？这很难通过Stereotype这个词的字面意思（这个词能翻译的意思很多，这里最接近的翻译应该是“旧规矩”或者“使固定”）来理解。</p>\n<p>\n    Stereotype特性最早出现在J2EE6中（忘记是哪个JSR提出的了），可以理解为围绕着“元数据”功能而发展出来的一种设计模式，虽然我很难说清楚他属于23个设计模式中的哪一个，但是这确实已经是一种约定俗成的做法，只要看到Stereotype就应该像看到“Factory——工厂模式”、“Adapter——适配器模式”、“Facade——外观模式”一样，一眼就知道他的作用。</p>\n<p>\n    Stereotype特性的目标就是为“组合模式的分层系统”按层标记一个类的功能。所谓的“组合模式的分层系统”实际上就是我们常用的Controller-Service-Dao这种分层模式，只不过有些系统可能会多几层（比如Controller和Service之间加个RPC框架什么的）。根据<a\n        href="https://docs.oracle.com/javaee/6/api/javax/enterprise/inject/Stereotype.html" rel="nofollow">Stereotype特性的Java官网原文</a>介绍，它是一个用来标记注解的注解（annotating\n    annotation）。一个注解如果被@Stereotype标记证明他提供Stereotype模式的功能，例如下面这样：</p>\n<pre><code class="java"><span class="code-meta">@Stereotype</span> \n<span class="code-meta">@Target</span>(TYPE) \n<span class="code-meta">@Retention</span>(RUNTIME) \n<span class="code-meta">@interface</span> controller {}\n\n<span class="code-meta">@Stereotype</span> \n<span class="code-meta">@Target</span>(TYPE) \n<span class="code-meta">@Retention</span>(RUNTIME) \n<span class="code-meta">@interface</span> service {}</code></pre>\n<p>然后我们在使用时可以为不同层的类打上这些标记，表示他们属于不同的分层：</p>\n<pre><code class="java"><span class="hljs-class"><span class="code-keyword">interface</span> <span class="code-title">UserService</span></span>{}\n\n<span class="code-meta">@Service</span>\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">UserServiceImpl</span> <span\n        class="code-keyword">implements</span> <span class="code-title">UserService</span></span>{\n\t\n}\n\n<span class="code-meta">@Controller</span>\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">UseController</span></span>{\n\t<span class="code-meta">@Autowired</span>\n\tUserService userService;\n\t\n}</code></pre>\n<p>\n    一个类的实例可能会被用于0到多个分层中（比如Spring的一个Bean既可以是Controller也可以是Service，只要标记对应的注解即可），但是通常情况下一个类最多只会用在一个分层中使用。简单的说Stereotype特性就是用注解来告诉框架某个类是属于系统功能中的哪一层。</p>\n<p>\n    Java的文档上要求提供Stereotype特性的注解需要用@Stereotype来标记。但是Spring的开发大神并没有理会这个事，@Component并没有使用@Stereotype来标记，但是他确实提供了Stereotype的模式。</p>\n<p>\n    在Stereotype模式下，Spring核心工程为Controller-Service-Dao的分层模型分别提供了@Controller、@Service、@Repository注解。我们按照Stereotype的模式为对应的类标记3个注解，然后在引入MVC、ORM、JPA相关的框架之后这些注解会告诉框架对应的类扮演着什么样的功能角色，框架就能很清晰的根据注解提供相关的功能服务。</p>\n<p>\n    例如引入Spring-webmvc之后，一个类如果用@Controller注解标记了之后框架就知道他们都是处理前端请求的，MVC框架就会为他提供RequestMapping之类的功能。随后我们需要将框架调整为WebFlux，基本上直接更换依赖的Jar包就可以了，因为大家都是按照一个模式来开发的。</p>\n<p><span style="color:#e74c3c">所以，如果我们的某个类是用于指定的分层功能，那么最好使用<em>org.springframework.stereotype</em>包中的注解来标记他所属的分层。如果类没有明确的功能（例如用于存储配置数据的类，或者Helper类），使用@Bean等其他方式添加到容器中更合适（@Bean会在后续的文章中介绍）。</span>\n</p>\n<p>使用Stereotype特性来标记分层，还有一个好处是即使工程的结构再复杂多样，都可以很轻松的使用注解（Annotation）来实现拦截器或者AOP功能。因为我们能够很清晰的知道每个分层的作用，开发AOP的功能就非常便利。</p>\n\n<h2 id="h2-3">扫描配置</h2>\n<p>本文开篇使用了一个简单的例子说明使用&lt;context:component-scan&gt;扫描功能来自动添加被注解标记的Bean。除了使用base-package属性还有其他的标签来控制扫描的路径。</p>\n<p>&lt;context:include-filter&gt;和&lt;context:exclude-filter&gt;标签用来指定包含和排除的过滤规则。他们提供2个参数——type和expression，用来指定过滤类型和过滤参数，例如:</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span\n            class="code-string">"org.example"</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">context:include-filter</span> <span\n                class="hljs-attr">type</span>=<span class="code-string">"regex"</span>\n                <span class="hljs-attr">expression</span>=<span\n                    class="code-string">".*Stub.*Repository"</span>/&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">context:exclude-filter</span> <span\n                class="hljs-attr">type</span>=<span class="code-string">"annotation"</span>\n                <span class="hljs-attr">expression</span>=<span class="code-string">"org.springframework.stereotype.Repository"</span>/&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">context:component-scan</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>此外还可以使用use-default-filters属性来指定是否扫描默认注解（<code>@Component</code>、<code>@Repository</code>、<code>@Service</code>、<code>@Controller、</code><code>@Configuration</code>），默认值为ture。如果设定成false，需要我们在include-filter中增加对应的annotation。\n</p>\n<p>除了使用XML配置，还可以使用@ComponentScan注解来指定扫描的路径，他提供和XML配置一样的功能。在后续的文章会介绍纯Java配置的功能。</p>\n<p>关于扫描的详细说明见<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-scanning-filters"\n        rel="nofollow">官网的过滤规则说明</a>。</p>\n\n<h2 id="h2-4">组件命名</h2>\n<p>和普通的Bean一样，我们也可以在@Component上添加注解来指定Bean在IoC容器的名称：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.component.bean;\n\n<span class="code-meta">@Service</span>(<span class="code-string">"implementNameService"</span>)\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">NameServiceImpl</span> <span class="code-keyword">implements</span> <span\n            class="code-title">NameService</span></span>{\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span\n            class="code-title">getName</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"This is My Component"</span>;\n\t}\n}</code></pre>\n<p>这样在容器中这个Bean的名称被命名为"implementNameService"。除了直接在注解上添加内容，我们还可以实现&nbsp;BeanNameGenerator 接口来实现全局的命名方法。看下面这个例子。（源码请到<a\n        href="https://gitee.com/chkui-com/spring-core-sample" rel="nofollow">https://gitee.com/chkui-com/spring-core-sample</a>自行clone，例子在<em>chkui.springcore.example.hybrid.component</em>包中。）\n</p>\n<p>首先在XML中使用 "name-generator"&nbsp;指定名称的生成器：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span> <span\n        class="hljs-attr">xmlns</span>=<span class="code-string">"http://www.springframework.org/schema/beans"</span>\n\t<span class="hljs-attr">xmlns:xsi</span>=<span\n            class="code-string">"http://www.w3.org/2001/XMLSchema-instance"</span>\n\t<span class="hljs-attr">xmlns:context</span>=<span class="code-string">"http://www.springframework.org/schema/context"</span>\n\t<span class="hljs-attr">xsi:schemaLocation</span>=<span class="code-string">"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span>\n\n\t<span class="code-tag">&lt;<span class="code-name">context:component-scan</span>\n\t\t<span class="hljs-attr">base-package</span>=<span class="code-string">"chkui.springcore.example.hybrid.component.bean"</span>\n\t\t<span class="hljs-attr">name-generator</span>=<span class="code-string">"chkui.springcore.example.hybrid.component.bean.NameGenerator"</span> /&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>然后编写我们的命名生成规则：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.component.bean;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">NameGenerator</span> <span class="code-keyword">implements</span> <span\n            class="code-title">BeanNameGenerator</span> </span>{\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">generateBeanName</span><span\n            class="hljs-params">(BeanDefinition definition, BeanDefinitionRegistry registry)</span> </span>{\n\t\tAnnotatedBeanDefinition annotdef = AnnotatedBeanDefinition.class.cast(definition);\n\t\tAnnotationMetadata meta = annotdef.getMetadata();\n\t\t<span class="code-comment">//生成规则:如果已经命名不做任何调整，如果未命名则在类名车后面增加”_NoDefinedName“字符串</span>\n\t\t<span class="code-keyword">return</span> Optional.of(meta).map(met -&gt; met.getAnnotationTypes()).map(set -&gt; set.toArray(<span\n            class="code-keyword">new</span> String[] {}))\n\t\t\t\t.map(array -&gt; array[<span class="hljs-number">0</span>]).map(name -&gt; meta.getAnnotationAttributes(name)).map(entry -&gt; entry.get(<span\n            class="code-string">"value"</span>))\n\t\t\t\t.map(obj -&gt; <span class="code-string">""</span>.equals(obj) ? <span class="code-keyword">null</span> : obj).orElse(definition.getBeanClassName() + <span\n            class="code-string">"_NoDefinedName"</span>)\n\t\t\t\t.toString();\n\t}\n}</code></pre>\n\n<h2 id="h2-5">使用索引提升启动速度</h2>\n<p>\n    通常情况下，即使是对整个classpath进行扫描并不会占用太多的时间，但是某些应用对启动时间有极高的要求，对此Spring提供了索引功能。索引功能并不复杂，就是第一次扫描之后生成一个静态文件记录所有的组件，然后下一次扫描就直接读取文件中的内容，而不去执行扫描过程。</p>\n<p>首先引入spring-context-indexer包：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">dependencies</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">dependency</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">groupId</span>&gt;</span>org.springframework<span\n            class="code-tag">&lt;/<span class="code-name">groupId</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">artifactId</span>&gt;</span>spring-context-indexer<span\n            class="code-tag">&lt;/<span class="code-name">artifactId</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">version</span>&gt;</span>5.0.7.RELEASE<span class="code-tag">&lt;/<span\n            class="code-name">version</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">optional</span>&gt;</span>true<span\n            class="code-tag">&lt;/<span class="code-name">optional</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">dependency</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">dependencies</span>&gt;</span></code></pre>\n<pre><code class="json">dependencies {\n    compileOnly(<span class="hljs-attr">"org.springframework:spring-context-indexer:5.0.7.RELEASE"</span>)\n}</code></pre>\n<p>然后在运行后会生成一个&nbsp;META-INF/spring.components\n    的文件，之后只要运行工程发现这个文件都会直接使用他。可以通过环境变量或工程根目录的spring.properties中设置spring.index.ignore=ture来禁用这个功能。</p>\n<p>这个功能如果没有什么明确的需求，慎重使用，会提高工程的管理成本。</p>'}});