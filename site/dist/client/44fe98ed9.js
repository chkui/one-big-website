webpackJsonp([4],{337:function(a,s,n){"use strict";Object.defineProperty(s,"__esModule",{value:!0});s.content='<h2 id="h2-1">一切从元编程开始</h2>\n<p>一个健壮的系统都要对外部提交的数据进行完整性、合法性的校验。即使开发一个不面对最终用户的工具包，也需要对传入的数据进行缜密的校验来防止引发底层难以追踪的问题。各路大神当然也会注意到这个问题，所以在“元编程”（见<a\n        href="https://www.chkui.com/article/spring/spring_core_jsr250_and_resource" title="JSR250与资源控制">JSR250与资源控制</a>）提出之后相续提交了<em>JSR-303、JSR-349以及JSR-380</em>来完善使用注解进行数据校验的机制，这三个JSR也被称为<em>Bean\n    Validation 1.0、Bean Validation 1.1和Bean Validation 2.0</em>，后文统称为<em>Bean Validation。</em></p>\n<p>先看一个不使用<em>Bean Validation</em>校验数据的代码：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">StandardValidation</span> </span>{\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tSystem.out.println(validationWithoutAnnotation(<span class="code-string">" "</span>, -<span class="hljs-number">1</span>));\n\t}\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> String <span\n            class="code-title">validationWithoutAnnotation</span><span class="hljs-params">(String inputString, Integer inputInt)</span> </span>{\n\t\tString error = <span class="code-keyword">null</span>;\n\t\t<span class="code-keyword">if</span> (<span class="code-keyword">null</span> == inputString) {\n\t\t\terror = <span class="code-string">"inputString不能为null"</span>;\n\t\t} <span class="code-keyword">else</span> <span class="code-keyword">if</span> (<span\n            class="code-keyword">null</span> == inputInt) {\n\t\t\terror = <span class="code-string">"inputInt不能为null"</span>;\n\t\t} <span class="code-keyword">else</span> <span class="code-keyword">if</span> (<span\n            class="hljs-number">1</span> &gt; inputInt.compareTo(<span class="hljs-number">0</span>)) {\n\t\t\terror = <span class="code-string">"inputInt必须大于0"</span>;\n\t\t} <span class="code-keyword">else</span> <span class="code-keyword">if</span> (inputString.isEmpty() || inputString.trim().isEmpty()) {\n\t\t\terror = <span class="code-string">"inputString不能为空字符串"</span>;\n\t\t} <span class="code-keyword">else</span> {\n\t\t\t<span class="code-comment">// DO</span>\n\t\t}\n\t\t<span class="code-keyword">return</span> error;\n\t}\n}\n</code></pre>\n<p>相信很多码友多少都写过类似的代码。使用<em>IF—ELSE</em>是否优雅这种高端问题暂且不谈，但是大量的<em>IF—</em><em>ELSE</em>会导致业务内容越来越多的嵌套在代码中。针对这些问题<em>Bean\n    Validation</em>为数据校验提供了更加规范化、通用化、复用程度更高的校验方法。</p>\n<p>\n    数据校验的原理并不复杂，主要是用注解（Annotation）在域或setter方法上声明JavaBean中数据的准则。Java的数据校验代码主要在javax.validation包中，包括注解、校验器以及校验器工厂，接下来通过例子说明。（例子可执行代码在本人的<a\n        href="https://gitee.com/chkui-com/spring-core-sample" rel="nofollow">gitee</a>库，本文代码在chkui.springcore.example.javabase.validation包）\n</p>\n\n<h2 id="h2-2">标准数据校验</h2>\n<p><a href="https://jcp.org/aboutJava/communityprocess/final/jsr303/index.html"\n      rel="nofollow">JSR提交的Javax.validation定义</a>中已经为数据校验定义了很多方法和注解，但是需要清晰的是JSR仅仅制定了一个规范，具体的功能是由各种框架实现的。本文的例子引入了<a\n        href="http://beanvalidation.org" rel="nofollow">Hibernate Validator 6.0.12.Final</a>包，他与Spring\n    Validator一样，都是根据JSR规范实现校验功能。</p>\n<p>数据校验是围绕一个实体类展开的，下面的代码声明了一个实体类，通过注解标注每个域上的赋值规则：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.validation.entity;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Game</span> </span>{\n\t<span class="code-meta">@NotNull</span> <span class="code-comment">//非空</span>\n\t<span class="code-meta">@Length</span>(min=<span class="hljs-number">0</span>, max=<span\n            class="hljs-number">5</span>) <span class="code-comment">//字符串长度小于5，这个是一个Hibernate Validator增加的注解</span>\n\t<span class="code-keyword">private</span> String name;\n\t\n\t<span class="code-meta">@NotNull</span>\n\t<span class="code-keyword">private</span> String description;\n\t\n\t<span class="code-meta">@NotNull</span>\n\t<span class="code-meta">@Min</span>(<span class="hljs-number">0</span>) <span\n            class="code-comment">//最小值&gt;=0</span>\n\t<span class="code-meta">@Max</span>(<span class="hljs-number">10</span>) <span\n            class="code-comment">//最大值&lt;=10</span>\n\t<span class="code-keyword">private</span> <span class="code-keyword">int</span> currentVersion; \n    <span class="code-comment">//getter and setter…………</span>\n}</code></pre>\n<p>使用校验器对其进行校验：</p>\n<pre><code class="java"><span class="code-keyword">public</span> StandardValidation {\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">validate</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-comment">//引入校验工具</span>\n\t\tValidatorFactory factory = Validation.buildDefaultValidatorFactory();\n        <span class="code-comment">//获取校验器</span>\n\t\tValidator validator = factory.getValidator();\n\t\tGame wow = <span class="code-keyword">new</span> Game();\n        <span class="code-comment">//执行校验</span>\n\t\tSet&lt;ConstraintViolation&lt;Game&gt;&gt; violationSet = validator.validate(wow);\n\t\tviolationSet.forEach(violat -&gt; {\n\t\t\tviolat.getPropertyPath();<span class="code-comment">//校验错误的域</span>\n            violat.getMessage());<span class="code-comment">//校验错误的信息</span>\n\t\t});\n        <span class="code-comment">//设置值之后再次进行校验</span>\n\t\twow.setName(<span class="code-string">"World Of Warcraft"</span>);\n\t\twow.setDescription(<span class="code-string">"由著名游戏公司暴雪娱乐所制作的第一款网络游戏，属于大型多人在线角色扮演游戏。"</span>);\n\t\twow.setCurrentVersion(<span class="hljs-number">8</span>);\n\t\tviolationSet = validator.validate(wow);\n\t\tviolationSet.forEach(violat -&gt; {});\n\t}\n}</code></pre>\n<p>执行完毕之后violationSet中就是校验的结果。如果校验通过那么返回的Set长度为0。</p>\n<p><em>Bean Validation</em>已经为常规的校验功能预设了很多注解，详见<a href="https://beanvalidation.org/2.0/spec/#builtinconstraints"\n                                                  rel="nofollow">关于所有注解的介绍</a>。</p>\n\n<h2 id="h2-3">自定义校验规则</h2>\n<p>虽然在<em>javax.validation.constraints</em>已经定义了很多用于校验的注解，但是肯定无法满足复杂多样的业务需求。所以<em>Bean Validation</em>也支持自定义校验规则。在JSR的文档中对数据域的一个校验被称为<em><strong>Constraint</strong></em>（约束），一个<em><strong>Constraint</strong></em>由一个<em><strong>Annotation</strong></em>（注解）绑定1~n个<strong><em>Validator</em></strong>（校验器）组成。&nbsp;因此可以通过新增<em><strong>Annotation</strong></em>和<strong><em>Validator</em></strong>来定义新的校验方式（或者说是定义新的<em><strong>Constraint</strong></em>）。\n</p>\n\n<h3 id="h3-1">组合注解校验</h3>\n<p>可以通过组合已有的注解来实现新的数据校验规则。例如下面的例子。</p>\n<p>定义新的校验注解：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.validation.annotation;\n<span class="code-meta">@Min</span>(<span class="hljs-number">1</span>)<span class="code-comment">//最小值&gt;=1</span>\n<span class="code-meta">@Max</span>(<span class="hljs-number">300</span>)<span class="code-comment">//最大值&lt;=300</span>\n<span class="code-meta">@Constraint</span>(validatedBy = {}) <span class="code-comment">//不制定校验器</span>\n<span class="code-meta">@Documented</span>\n<span class="code-meta">@Target</span>({ ElementType.ANNOTATION_TYPE, ElementType.METHOD, ElementType.FIELD })\n<span class="code-meta">@Retention</span>(RetentionPolicy.RUNTIME)\n<span class="code-keyword">public</span> <span class="code-meta">@interface</span> Price {\n\t<span class="hljs-function">String <span class="code-title">message</span><span class="hljs-params">()</span> <span\n            class="code-keyword">default</span> "定价必须在$1~$200之间"</span>;\n\tClass&lt;?&gt;[] groups() <span class="code-keyword">default</span> { };\n\tClass&lt;? extends Payload&gt;[] payload() <span class="code-keyword">default</span> { };\n}\n</code></pre>\n<p>在@Price注解中我们标记了@Min(1)和@Max(300)，之后直接在域上标记@Price就会校验对应的值是否满足这个条件：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.validation.entity;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Game</span> </span>{\n    <span class="code-meta">@Price</span>\n\t<span class="code-keyword">private</span> <span class="code-keyword">float</span> price;\n    <span class="code-comment">//Other field</span>\n    <span class="code-comment">//setter and getter</span>\n}</code></pre>\n\n<h3 id="h3-2">自定义校验器</h3>\n<p>除了组合<em>javax.validation.constraints</em>中的注解，还可以自定义校验器（<strong><em>Validator</em></strong>）进行数据校验。</p>\n<p>声明一个用于自定义校验的注解：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.validation.annotation;\n<span class="code-meta">@Constraint</span>(validatedBy = { TypeValidator.class }) <span\n            class="code-comment">//指定校验器</span>\n<span class="code-meta">@Documented</span>\n<span class="code-meta">@Target</span>({ ElementType.ANNOTATION_TYPE, ElementType.METHOD, ElementType.FIELD })\n<span class="code-meta">@Retention</span>(RetentionPolicy.RUNTIME)\n<span class="code-keyword">public</span> <span class="code-meta">@interface</span> Type {\n\t<span class="hljs-function">String <span class="code-title">message</span><span class="hljs-params">()</span> <span\n            class="code-keyword">default</span> "游戏类型错误,可选类型为RPG、ACT、SLG、ARPG"</span>;\n\tClass&lt;?&gt;[] groups() <span class="code-keyword">default</span> {};\n\tClass&lt;? extends Payload&gt;[] payload() <span class="code-keyword">default</span> {};\n}</code></pre>\n<p>注意<em>@Constraint(validatedBy = { TypeValidator.class })</em>这一行代码，他的作用就是将这个注解和校验器进行绑定，当我们执行Validator::validator方法时对应的校验器会被调用。\n</p>\n<p><em>TypeValidator</em>类：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.validation.validator;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">TypeValidator</span> <span class="code-keyword">implements</span> <span\n            class="code-title">ConstraintValidator</span>&lt;<span class="code-title">Type</span>, <span\n            class="code-title">String</span>&gt; </span>{\n\t<span class="code-keyword">private</span> <span class="code-keyword">final</span> List&lt;String&gt; TYPE = Arrays.asList(<span\n            class="code-keyword">new</span> String[]{<span class="code-string">"RPG"</span>, <span class="code-string">"ACT"</span>, <span\n            class="code-string">"SLG"</span>, <span class="code-string">"ARPG"</span>});\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">boolean</span> <span\n            class="code-title">isValid</span><span class="hljs-params">(String value, ConstraintValidatorContext context)</span> </span>{\n\t\t<span class="code-keyword">return</span> TYPE.contains(value);\n\t}\n}</code></pre>\n<p><em>TypeValidator</em>必须实现<em>ConstraintValidator</em>这个接口，并在范型中声明对应的校验注解和数据类型（<em>ConstraintValidator&lt;T,\n    E&gt;</em>，T是绑定的注解类型、E是数据类型）。<em>TypeValidator</em>中判断数值是不是"RPG", "ACT", "SLG", "ARPG"当中的一个，若不是则<em>TypeValidator::isValid</em>返回false表示校验没通过。\n</p>\n<p>在实体类的域上使用自定义的@Type注解：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">Game</span> </span>{\n\t<span class="code-meta">@NotNull</span>\n\t<span class="code-meta">@Type</span>\n\t<span class="code-keyword">private</span> String type;\n    <span class="code-comment">//Other field ......</span>\n    <span class="code-comment">//getter and setter ......</span>\n}</code></pre>\n\n<h2 id="h2-4">分组校验</h2>\n<p>对于业务来说数据录入的规则并不是一成不变的，往往需要根据某些状态来对单个或一组数据进行校验。这个时候我们可以用到分组功能——根据状态启用一组约束。</p>\n<p>观察自定义注解或<em>javax.validation.constraints</em>包中预定以的注解，都有一个<em>groups</em>参数：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="code-meta">@interface</span> Max {\n\t<span class="hljs-function">String <span class="code-title">message</span><span class="hljs-params">()</span> <span\n            class="code-keyword">default</span> "</span>{javax.validation.constraints.Max.message}<span\n            class="code-string">";\n\tClass&lt;?&gt;[] groups() default { }; //用于分组的参数\n\tClass&lt;? extends Payload&gt;[] payload() default { };\n\tlong value();\n}</span></code></pre>\n<p>如果未指定该参数，那么校验都属于<em>javax.validation.groups.Default</em>分组。</p>\n<p>先定义一个分组，用一个没有任何功能的类或者接口即可：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.validation.groups;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n            class="code-title">BetaGroup</span> </span>{}</code></pre>\n<p>然后在校验的注解上通过<em>groups</em>指定分组：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">Game</span> </span>{\n\t\n\t<span class="code-meta">@NotNull</span>\n\t<span class="code-meta">@Min</span>(<span class="hljs-number">0</span>) <span\n            class="code-comment">//最小值&gt;=0</span>\n\t<span class="code-meta">@Max</span>(<span class="hljs-number">10</span>) <span\n            class="code-comment">//最大值&lt;=10</span>\n\t<span class="code-meta">@Max</span>(value=<span class="hljs-number">0</span>, message=<span class="code-string">"未发行的游戏版本为0!"</span>, groups = BetaGroup.class)<span\n            class="code-comment">//分组校验</span>\n\t<span class="code-keyword">private</span> <span class="code-keyword">int</span> currentVersion; \n\t\n\t<span class="code-meta">@AssertTrue</span>(groups = BetaGroup.class)<span class="code-comment">//分组校验</span>\n\t<span class="code-comment">//表示是否为内侧版</span>\n\t<span class="code-keyword">private</span> <span class="code-keyword">boolean</span> beta;\n    <span class="code-comment">//Other field ......</span>\n    <span class="code-comment">//getter and setter ......</span>\n}</code></pre>\n<p>然后执行分组校验：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="code-keyword">enum</span> StandardValidation {\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">validate</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-comment">//引入校验工具</span>\n\t\tValidatorFactory factory = Validation.buildDefaultValidatorFactory();\n\t\tValidator validator = factory.getValidator();\n\n\t\tGame wow = <span class="code-keyword">new</span> Game();\n\t\twow.setName(<span class="code-string">"World Of Warcraft"</span>);\n\t\twow.setDescription(<span class="code-string">"由著名游戏公司暴雪娱乐所制作的第一款网络游戏，属于大型多人在线角色扮演游戏。"</span>);\n\t\twow.setCurrentVersion(<span class="hljs-number">8</span>);\n\t\twow.setType(<span class="code-string">"RPG"</span>);\n\t\twow.setPrice(<span class="hljs-number">401.01F</span>);\n\n        <span class="code-comment">//使用默认分组校验</span>\n\t\tviolationSet = validator.validate(wow);\n\t\t\n\t\t<span class="code-comment">//指定分组校验</span>\n\t\tviolationSet = validator.validate(wow, BetaGroup.class);\n\t}\n}</code></pre>\n<p><em>Validator::validator</em>方法未指定分组时，相当于使用<em>javax.validation.groups.Default</em>分组。而在<em>violationSet=validator.validate(wow,\n    BetaGroup.class);</em>这一行代码指定分组之后，只会执行<em>groups = BetaGroup.class</em>注解的校验。</p>\n<p>可以一次指定多个分组的校验，这样有利于处理复杂的状态：</p>\n<pre><code class="java">validator.validate(wow, Default.class, BetaGroup.class, OtherGroup.class);</code></pre>\n\n<h2 id="h2-5">校验错误级别</h2>\n<p>校验的注解中还有一个参数——<em>payload</em>，他表示“校验问题”的级别。这个参数就像使用<em>Log4j</em>输出日志会指定<em>DEBUG、INFO、WARN</em>等级别一样，在校验数据时会有对“校验问题”进行分类的需求，比如某些页面会对用户录入的数据进行“错误”或“警告”的提示。\n</p>\n<p>在使用payload时需要先声明PalyLoad接口类以标定“问题级别”：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.validation;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">PayLoadLevel</span> </span>{\n    <span class="code-comment">//警告级别</span>\n\t<span class="code-keyword">static</span> <span class="code-keyword">public</span> <span class="hljs-class"><span\n            class="code-keyword">interface</span> <span class="code-title">WARN</span> <span class="code-keyword">extends</span> <span\n            class="code-title">Payload</span> </span>{}\n    <span class="code-comment">//错误级别</span>\n\t<span class="code-keyword">static</span> <span class="code-keyword">public</span> <span class="hljs-class"><span\n            class="code-keyword">interface</span> <span class="code-title">Error</span> <span class="code-keyword">extends</span> <span\n            class="code-title">Payload</span> </span>{}\n}</code></pre>\n<p>然后在JavaBean上指定“校验问题”的级别：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">Game</span> </span>{\n    <span class="code-comment">//默认分组校验错误时，错误级别为Error</span>\n\t<span class="code-meta">@NotNull</span>(payload=PayLoadLevel.Error.class)\n\t<span class="code-meta">@Min</span>(value=<span class="hljs-number">0</span>, payload=PayLoadLevel.Error.class) \n\t<span class="code-meta">@Max</span>(value=<span class="hljs-number">10</span>, payload=PayLoadLevel.Error.class) \n    <span class="code-comment">//BetaGroup分组错误级别为WARN</span>\n\t<span class="code-meta">@Max</span>(value=<span class="hljs-number">0</span>, message=<span class="code-string">"未发行的游戏版本为0!"</span>, groups = BetaGroup.class, payload=PayLoadLevel.WARN.class)\n\t<span class="code-keyword">private</span> <span class="code-keyword">int</span> currentVersion; \n\t\n\t<span class="code-meta">@AssertTrue</span>(groups = BetaGroup.class, payload=PayLoadLevel.WARN.class)\n\t<span class="code-keyword">private</span> <span class="code-keyword">boolean</span> beta;\n    <span class="code-comment">//Other field ......</span>\n    <span class="code-comment">//getter and setter ......\t</span>\n}</code></pre>\n<p>然后在执行校验的时候使用ConstraintViolation::getConstraintDescriptor::getPayload方法获取每一个校验问题的错误级别：</p>\n<pre><code class="java">violationSet = validator.validate(wow, BetaGroup.class);\nviolationSet.forEach(violat -&gt; {\n\tviolat.getPropertyPath();<span class="code-comment">//错误域的名称</span>\n    violat.getMessage();<span class="code-comment">//错误消息</span>\n\tviolat.getConstraintDescriptor().getPayload();<span class="code-comment">//错误级别</span>\n});</code></pre>'},371:function(a,s,n){"use strict";Object.defineProperty(s,"__esModule",{value:!0});s.content='<h2 id="h2-1">@Configuration</h2>\n<p>在介绍Spring核心容器的系列文章中已经多次出现这个注解，从使用的角度来说可以把他理解为XML配置中的&lt;beans&gt;标签，但是两者肯定是不等价的。</p>\n<p>在&lt;beans&gt;标签中除了使用&lt;bean&gt;声名Bean以外，还有各种&lt;context&gt;标签来扩展功能，比如&lt;context:component-scan/&gt;、&lt;context:annotation-config /&gt;以及&lt;import&gt;等，这些扩展的功能并不是@Configuration注解的参数，而是通过另外一个注解来实现——@ComponentScan、@Import。</p>\n<p>@Configuration的基本使用方法已经在<a href="https://www.chkui.com/article/spring/spring_core_java_base_and_bean_annotation" title="纯Java运行与@Bean">纯Java运行与@Bean</a>的“@Bean注解”部分介绍了使用方法，本篇在此基础上进一步进行说明。</p>\n\n<h2 id="h2-2">@Configuration添加依赖</h2>\n<p>除了在<a href="https://www.chkui.com/article/spring/spring_core_java_base_and_bean_annotation" title="纯Java运行与@Bean">纯Java运行与@Bean</a>文中介绍的使用方法，我们还可以直接通过使用Java代码来添加依赖关系：</p>\n<p>(文中的代码仅用于说明问题，源码在<a href="https://gitee.com/chkui-com/spring-core-sample" rel="nofollow">gitee</a>上，如有需要请自行clone，本文的案例代码在chkui.springcore.example.javabase.configuration包中。)</p>\n<pre><code class="java"><span class="code-meta">@Configuration</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MyConfig</span> </span>{\n\n    <span class="code-meta">@Bean</span>\n    <span class="hljs-function"><span class="code-keyword">public</span> Alice <span class="code-title">alice</span><span class="hljs-params">()</span> </span>{\n        <span class="code-comment">//直接使用方法注入数据。</span>\n        <span class="code-comment">//从表面上看这里调用bob()并没有经过容器处理。而是直接使用了。</span>\n        <span class="code-keyword">return</span> <span class="code-keyword">new</span> Alice(bob());\n    }\n\n    <span class="code-meta">@Bean</span>\n    <span class="hljs-function"><span class="code-keyword">public</span> Bob <span class="code-title">bob</span><span class="hljs-params">()</span> </span>{\n        <span class="code-keyword">return</span> <span class="code-keyword">new</span> Bob();\n    }\n}</code></pre>\n<p>看到这里，思维敏捷的码友通过以下逻辑肯定就发现问题了：</p>\n<ol>\n\t<li>通过@Bean注解是向容器添加一个<a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/config/BeanDefinition.html" rel="nofollow">BeanDefinition</a>，</li>\n\t<li>在所有的<a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/config/BeanDefinition.html" rel="nofollow">BeanDefinition</a>创建之后容器开始创建Bean之前会执行预设的<a href="https://www.chkui.com/article/spring/spring_core_ioc_extension_points" title="IOC功能扩展点">后置处理器BeanFactoryPostProcessor</a>。</li>\n\t<li>最后容器根据<a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/config/BeanDefinition.html" rel="nofollow">BeanDefinition</a>的内容创建Bean。</li>\n\t<li><span style="color:#ffffff"><em><span style="background-color:#4e5f70">&nbsp;return new Alice(bob());&nbsp;</span></em></span>这段代码中<em>MyConfig::bob</em>方法的调用看起来完全和容器无关，这样就违反了依赖注入的原则！</li>\n\t<li>所以是不是Alice类中被注入的Bob实例根本就不是IoC容器中的Bob？</li>\n</ol>\n<p>首先可以很负责的告诉码友们Spring并没有限制这个方式去添加Bean，所以例子中Alice类中的Bob实例就是IoC容器中的实例。即使是这样去注入Bean同样实现了依赖注入的功能。至于怎么解决的看完本文自然就能得到答案了。</p>\n\n<h2 id="h2-3">@Component添加依赖</h2>\n<p>之前在<a href="https://www.chkui.com/article/spring/spring_core_stereotype_component_and_bean_scan" title="Stereotype组件与Bean扫描">Stereotype组件与Bean扫描</a>这篇文章已经提到过，除了在@Configuration中的方法使用@Bean，还可以在@Component及其派生类中的方法使用@Bean。例如下面的例子：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.configuration.bean;\n\n<span class="code-meta">@Component</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">BeanManager</span> </span>{\n\t\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> Cytus <span class="code-title">cytus</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> Cytus();\n\t}\n\t\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> Dva <span class="code-title">dva</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> Dva();\n\t}\n\t\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> Game <span class="code-title">game</span><span class="hljs-params">(Dva dva)</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> Game(cytus(), dva);\n\t}\n}</code></pre>\n<p>BeanManager中的三个方法都会向容器添加Bean。注意第三个方法：<em>public Game game(Dva dva)</em>。这里即采用了通过方法参数注入依赖，也像前面的例子一样直接调用了方法。但是这里与前面介绍的使用@Configuration注解不同，Game中的Cytus实例不是IoC容器中的Cytus。</p>\n<p>通过下面的例子来说明@Configuration和@Component中注入Bean的差异。（代码仅用于展示，有兴趣运行的可以下载<a href="https://gitee.com/chkui-com/spring-core-sample" rel="nofollow">gitee上的源码</a>，代码在<em>chkui.springcore.example.javabase.configuration</em> 包中）。</p>\n<pre><code class="java"><span class="code-comment">//package chkui.springcore.example.javabase.configuration;</span>\n<span class="code-comment">//使用@Configuration注解</span>\n<span class="code-meta">@Configuration</span>\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">Config</span> </span>{\n\t\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> Alice <span class="code-title">alice</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> Alice(bob());\n\t}\n\t\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> Bob <span class="code-title">bob</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> Bob();\n\t}\n}\n<span class="code-comment">//package chkui.springcore.example.javabase.configuration.bean;</span>\n<span class="code-comment">//使用@Component注解</span>\n<span class="code-meta">@Component</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">BeanManager</span> </span>{\n\t\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> Cytus <span class="code-title">cytus</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> Cytus();\n\t}\n\t\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> Dva <span class="code-title">dva</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> Dva();\n\t}\n\t\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> Game <span class="code-title">game</span><span class="hljs-params">(Dva dva)</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> Game(cytus(), dva);\n\t}\n}\n<span class="code-comment">//运行</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">ConfigurationApp</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(Config.class， BeanManager.class);\n\t\tBob bob = ctx.getBean(Bob.class);\n\t\tAlice alice = ctx.getBean(Alice.class);\n\t\tSystem.out.println(<span class="code-string">"Bob instance of IoC hash: "</span> + bob.hashCode());\n\t\tSystem.out.println(<span class="code-string">"Bob instance of Alice hash: "</span> + alice.getBob().hashCode());\n\t\tSystem.out.println(<span class="code-string">"Compare："</span> + (bob == alice.getBob()));\n\t\tSystem.out.println(<span class="code-string">"Config instance："</span> + ctx.getBean(Config.class));\n\n\t\tGame game = ctx.getBean(Game.class);\n\t\tCytus cytus = ctx.getBean(Cytus.class);\n\t\tDva dva = ctx.getBean(Dva.class);\n\t\tSystem.out.println(<span class="code-string">"IoC Cytus: "</span> + cytus.hashCode());\n\t\tSystem.out.println(<span class="code-string">"Game Cytus: "</span> + game.getCytus().hashCode());\n\t\tSystem.out.println(<span class="code-string">"IoC Dva: "</span> + dva.hashCode());\n\t\tSystem.out.println(<span class="code-string">"Game Dva: "</span> + game.getDva().hashCode());\n\t\tSystem.out.println(<span class="code-string">"Cytus："</span> + (cytus == game.getCytus()));\n\t\tSystem.out.println(<span class="code-string">"Dva："</span> + (dva == game.getDva()));\n\t\tSystem.out.println(<span class="code-string">"BeanManager Instance："</span> + ctx.getBean(BeanManager.class));\n\t}\n}</code></pre>\n<p>在最后的main方法中我们对容器中以及Alice、Game中包含的实例进行了hash以及实例对比，在我的电脑上输出结果如下：</p>\n<pre><code class="bash">1.Bob instance of IoC <span class="code-built_in">hash</span>: 1242027525\n2.Bob instance of Alice <span class="code-built_in">hash</span>: 1242027525\n3.Compare：<span class="hljs-literal">true</span>\n4.Config instance：5.chkui.springcore.example.javabase.configuration.Config$<span class="code-variable">$EnhancerBySpringCGLIB</span>$<span class="code-variable">$acdbeb32</span>@74287ea3\n6.IoC Cytus: 2104973502\n7.Game Cytus: 735937428\n8.IoC Dva: 1604247316\n9.Game Dva: 1604247316\n10.Cytus：<span class="hljs-literal">false</span>\n11.Dva：<span class="hljs-literal">true</span>\n12.BeanManager Instance：chkui.springcore.example.javabase.configuration.bean.BeanManager@68746f22</code></pre>\n<p>例子中分别在@Configuration和@Component标记的类中使用@Bean来向容器添加Bean。最后通过输出实例的hash以及地址匹配（使用“==”比对）来确定是否都是同一个单例。</p>\n<p>很明显IoC容器中的Cytus以Game中的Cytus并不是一个实例，其他都是同一个单例。仔细看看第4行和第12行的<strong><em>Config instance</em></strong>和<strong><em>BeanManager instance</em></strong>的输出内容就会得到答案。</p>\n<p>BeanManager是一个常规的类，而在JVM中运行的Config是一个通过CGLIB实现的字节码级别的代理类（<em>如果不知道CGLIB是什么就自己网上找找吧，这玩意在Java界已经红得发紫了</em>）。Spring实际上是使用CGLIB为Config类添加了一个“代理壳”，当我们在任何地方直接调用@Configuration标注的类中的的方法时，代理壳都会将其整理为一个<a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/config/BeanDefinition.html" rel="nofollow">BeanDefinition</a>的转换过程。</p>\n<p>知道两者的差异后我们选择何种方式来添加Bean就很清晰了：</p>\n<p>使用@Configuration能保证不会出现例子中Cytus这样的例外。也能清晰的明确@Configuration等价于一个&lt;beans&gt;统一管理。</p>\n<p>而在@Component或其他组建中使用@Bean好处是不会启动CGLIB这种重量级工具（不过在Spring中即使这里不使用，其他很多地方也在使用）。并且@Component及其相关的Stereotype组件自身就有摸框级别的功能，在这里使用@Bean注解能很好的表明一个Bean的从属和结构关系，但是需要注意直接调用方法的“副作用”。</p>\n<p>个人建议如果没什么特别的要求就使用@Configuration，引入CGLIB并不会影响多少性能，然而坑会少很多。在spring官网将用@Configuration创建的@Bean称呼为"Full"模式、将@Component创建的@Bean称呼为"\'lite"模式，从字面上也能略知他们的差异。</p>\n\n<h2 id="h2-4">多种方式混合使用</h2>\n<p>从XML配置到纯Java配置，Spring变得越来越简便好用，对应的功能也越来越多样化。如果对他的脉络没有清晰的认识，往往会陷入迷惑中。无论功能再复杂我们都要记住本系列文章开篇提到的IoC容器的初衷：</p>\n<p><strong><em>处理容器与Bean、Bean与Bean的关系。Bean是最小的工作单元，一切功能都是在Bean基础上扩展而来的。</em></strong></p>\n<p>所以无论是XML配置还是纯Java配置基本目标就是解决三个问题：向容器添加Bean，确定Bean的功能，确定Bean与Bean之间的依赖关系。</p>\n<p>既然XML和纯Java配置都是解决同样的问题，那么混合使用当然没问题。比如在XML中配置了&lt;context:component-scan/&gt;，那么指定路径下的@Component以及派生注解（@Service、@Comfiguration等）都会被扫描并添加到容器中成为一个Bean。然后IoC容器会根据注解的类型来确定这个Bean是什么功能。、</p>\n<p>下面是一个使用AnnotationConfigApplicationContext启动容器混合使用Java配置与XML配置的例子（源码在本人<a href="https://gitee.com/chkui-com/spring-core-sample" rel="nofollow">gitee的spring-core-sample</a>仓库中，本节的代码在包<em>chkui.springcore.example.javabase.multiconfiguration</em>中）。</p>\n<p>首先我们使用AnnotationConfigApplicationContext启动IoC容器：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.multiconfiguration;\n\n<span class="code-meta">@Configuration</span>\n<span class="code-meta">@ComponentScans</span>({ <span class="code-meta">@ComponentScan</span>(<span class="code-string">"chkui.springcore.example.javabase.multiconfiguration.config"</span>),\n\t\t<span class="code-meta">@ComponentScan</span>(<span class="code-string">"chkui.springcore.example.javabase.multiconfiguration.service"</span>) })\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MultiConfigurationApp</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(MultiConfigurationApp.class);\n\t}\n}</code></pre>\n<p>在Main方法中直接指定了当前的类，所以MultiConfigurationApp类会成为一个Bean。由于是一个Stereotype模式的@Configuration标记类（@Configuration继承自@Component，提供了配置相关的分层功能，关于Stereotype模式的内容相见<a href="https://www.chkui.com/article/spring/spring_core_stereotype_component_and_bean_scan" rel="nofollow">Stereotype组件与Bean扫描</a>），所以容器会用CGLIB来代理它实现配置相关的功能。@ComponentScans是一个辅助注解，他的作用就是整合多个@ComponentScan一起使用。</p>\n<p>在config包中有2个@Configuration类：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.multiconfiguration.config;\n\n<span class="code-meta">@Configuration</span>\n<span class="code-meta">@Import</span>({ClubConfiguration.class})\n<span class="code-meta">@ImportResource</span>(<span class="code-string">"javabase/multiconfiguration/config.xml"</span>)\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MainConfiguration</span> </span>{}</code></pre>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.multiconfiguration.config;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">ClubConfiguration</span> </span>{\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> Mil <span class="code-title">mil</span><span class="hljs-params">()</span> </span>{<span class="code-keyword">return</span> <span class="code-keyword">new</span> Mil();}\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> Mau <span class="code-title">mau</span><span class="hljs-params">()</span> </span>{<span class="code-keyword">return</span> <span class="code-keyword">new</span> Mau();}\n}</code></pre>\n<p>MainConfiguration类被标记了@Configuration注解，所以他会被扫描并添加到容器中。</p>\n<p>@Import注解的作用是引入其他类成为一个Bean，我们可以看到ClubConfiguration类并没有任何注解，但是他通过@Import注解在其他类添加到容器中。</p>\n<p>而@ImportResource等价于XML配置中的&lt;import&gt;标签，作用就是引入一个XML配置文件。对应的XML文件如下：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span> <span class="hljs-attr">...</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span class="code-string">"chkui.springcore.example.javabase.multiconfiguration.bean.Cfc"</span> /&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span class="code-string">"chkui.springcore.example.javabase.multiconfiguration.bean.Jav"</span> /&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>这样XML配置中的2个类也会被添加到容器中。案例中对应的实体类如下：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.multiconfiguration.bean;\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">Mau</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">toString</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"Manchester United[MAU]"</span>;\n\t}\n}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">Cfc</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">toString</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"Chelsea Football Club[CFC]"</span>;\n\t}\n}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">Mil</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">toString</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"A.C Milan [MIL]"</span>;\n\t}\n}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">Jav</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">toString</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"Juventus [JAV]"</span>;\n\t}\n}</code></pre>\n\n<h2 id="h2-5">Conditionally</h2>\n<p>最后在使用@Configuration时可以使用Conditionally特性来确定是否添加Bean。大致用法就是实现Condition接口，然后通过@Conditional注解和@Bean绑定在一起进行条件判断。</p>\n<p>实现Condition：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.multiconfiguration.config;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">SoySauceCondition</span> <span class="code-keyword">implements</span> <span class="code-title">Condition</span> </span>{\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">boolean</span> <span class="code-title">matches</span><span class="hljs-params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">false</span>; <span class="code-comment">//返回false则不会对应的Bean。</span>\n\t}\n}</code></pre>\n<p>然后使用@Conditional注解绑定到一个@Bean上：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.multiconfiguration.config;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">ClubConfiguration</span> </span>{\n\t<span class="code-meta">@Bean</span>\n\t<span class="code-meta">@Conditional</span>(SoySauceCondition.class)\n\t<span class="hljs-function"><span class="code-keyword">public</span> SoySauce <span class="code-title">soySauce</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> SoySauce();\n\t}\n}</code></pre>\n<p>这样，如果SoySauceCondition中的matches方法返回ture则添加SoySauce到IoC容器中，否则不会存在这个Bean。</p>'},387:function(a,s,n){"use strict";Object.defineProperty(s,"__esModule",{value:!0});s.content='<h2 id="h2-1">非侵入式框架</h2>\n<p>\n    Spring一直标注自己是一个非侵入式框架。非侵入式设计的概念并不新鲜，目标就是降低使用者和框架代码的耦合，毕竟框架的开发者和使用者几乎肯定不是同一个团队。Spring最早的非侵入式实现就是他的一系列XML配置，理想状态下Spring框架的所有的功能都应该是通过配置实现的。元编程在Java中的使用现给非侵入式的设计提供了更好的解决方案，在Java中通过注解（Annotation）即可标记某个类、方法、域的附加功能，而无需通过继承的方式来扩展原始框架没有的功能。下面通过3段代码的例子来说明侵入式与非侵入式的区别。</p>\n<p><span style="color:#e74c3c">文章中的代码仅仅用于说明原理，已经删除了一些无关代码，无法执行。可执行代码在：<a\n        href="https://github.com/chkui/spring-core-example"\n        rel="nofollow">https://github.com/chkui/spring-core-example</a>，如有需要请自行clone，仅支持gradle依赖。</span></p>\n\n<h3 id="h3-1">一个基本的容器</h3>\n<p>下面的代码是大致模仿的IoC容器创建Bean的过程。BeanFactory::createBeans方法传入Bean的类型列表，而迭代器遍历列表完成每一个类的实例创建：</p>\n<pre><code class="java"><span class="code-comment">/**框架代码*/</span>\n<span class="code-keyword">package</span> chkui.springcore.example.xml.beanpostprocessor.nopluging;\n\n<span class="code-comment">//创建Bean的工厂类,由框架开发者开发</span>\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">BeanFactory</span> </span>{\n\t<span class="code-comment">//创建一系列的Bean</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> List&lt;Object&gt; <span class="code-title">createBeans</span><span\n            class="hljs-params">(List&lt;Class&lt;?&gt;&gt; clslist)</span></span>{\n\t\t<span class="code-keyword">return</span> clslist.stream().map(cls-&gt;{\n\t\t\t<span class="code-keyword">return</span> createBean(cls);\n\t\t}).collect(Collectors.toList());\n\t}\n\t<span class="code-comment">//创建一个Bean</span>\n\t<span class="hljs-function">Object <span class="code-title">createBean</span><span class="hljs-params">(Class&lt;?&gt; cls)</span></span>{\n\t\t<span class="code-comment">//添加到容器</span>\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> BeanWrapper(cls.newInstance());\n\t}\n}\n\n<span class="code-comment">//包装代理</span>\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">BeanWrapper</span> </span>{\n\t<span class="code-keyword">private</span> Object bean;\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span\n            class="code-title">BeanWrapper</span><span class="hljs-params">(Object bean)</span> </span>{\n\t\t<span class="code-keyword">this</span>.bean = bean;\n\t}\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">toString</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"Wrapper("</span> + <span\n            class="code-keyword">this</span>.bean.toString() + <span class="code-string">")"</span>;\n\t}\n}</code></pre>\n<p>下面的代码是框架使用者的代码——将Bean1和Bean2交给BeanFactory来完成初始化：</p>\n<pre><code class="java"><span class="code-comment">/**使用端代码*/</span>\n<span class="code-keyword">package</span> chkui.springcore.example.xml.beanpostprocessor.nopluging;\n\n<span class="code-comment">//import ...</span>\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">IocExtensionSampleNoPluging</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n    \tList&lt;Class&lt;?&gt;&gt; classes = Arrays.asList(<span class="code-keyword">new</span> Class&lt;?&gt;[]{MyBean1.class, MyBean2.class});\n    \tList&lt;Object&gt; ins = <span class="code-keyword">new</span> BeanFactory().createBeans(classes);\n    \tSystem.out.println(<span class="code-string">"Result:"</span> + ins.toString());\n    }\n}\n\n<span class="code-comment">//Bean1，由使用者编码</span>\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MyBean1</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">toString</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"MyBean1 Ins"</span>;\n\t}\n}\n\n<span class="code-comment">//Bean2，使用者编码</span>\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MyBean2</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">toString</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"MyBean2 Ins"</span>;\n\t}\n}</code></pre>\n<p>classpath：chkui.springcore.example.xml.beanpostprocessor.nopluging.IocExtensionSample。<a\n        href="https://github.com/chkui/spring-core-example/blob/master/src/main/java/chkui/springcore/example/xml/beanpostprocessor/nopluging/IocExtensionSample.java"\n        rel="nofollow">源码地址</a>。</p>\n<p>某个时刻，框架的使用者有个新需求是在要在每个Bean创建的前后进行一些处理。我们可以通过继承的方式来实现功能。下面我们修改使用端代码实现这个功能。</p>\n\n<h3 id="h3-2">继承实现功能扩展</h3>\n<p>通过继承类BeanFactory，并修改createBean方法可以实现我们的需求：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.xml.beanpostprocessor.extend;\n\n<span class="code-comment">//执行</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">IocExtensionSampleNoPluging</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n    \tList&lt;Class&lt;?&gt;&gt; classes = Arrays.asList(<span class="code-keyword">new</span> Class&lt;?&gt;[]{MyBean1.class, MyBean2.class});\n    \tList&lt;Object&gt; ins = <span class="code-keyword">new</span> ModifyBeanFactory().createBeans(classes);\n    \tSystem.out.println(<span class="code-string">"Result:"</span> + ins.toString());\n    }\n}\n\n<span class="code-comment">//新建一个BeanFactory的派生类，并修改createBean的实现，添加使用者的处理逻辑</span>\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">ModifyBeanFactory</span> <span\n        class="code-keyword">extends</span> <span class="code-title">BeanFactory</span> </span>{\n\t<span class="hljs-function">Object <span class="code-title">createBean</span><span class="hljs-params">(Class&lt;?&gt; cls)</span></span>{\n\t\tObject ins = cls.newInstance();\n\t\t<span class="code-comment">//添加容器之前的处理</span>\n\t\tBeanWrapper wrapper = <span class="code-keyword">new</span> BeanWrapper(ins);\n\t\t<span class="code-comment">//添加容器之后的处理</span>\n\t\t<span class="code-keyword">return</span> wrapper;\n\t}\n}</code></pre>\n<p>classpath：chkui.springcore.example.xml.beanpostprocessor.extend.IocExtensionSample。<a\n        href="https://github.com/chkui/spring-core-example/blob/master/src/main/java/chkui/springcore/example/xml/beanpostprocessor/extend/IocExtensionSample.java"\n        rel="nofollow">源码地址</a>。</p>\n<p>这里在使用者的代码里新增了一个ModifyBeanFactory类，并重写了createBean方法。在重写的方法中实现我们需要的功能逻辑。但是这样开发会出现以下2点问题：</p>\n<ol>\n    <li>导致使用者的代码与框架代码产生了极强的耦合性。如果某天框架进行了调整，例如将方法名改为buildBean、或者增加了更多的代理模式会出现一些意想不到的问题。更麻烦的是可能会遇到一些到运行期才出现的问题。</li>\n    <li>我们需要先理解框架的源码才能植入我们的功能，这和很多设计模式的原则是背道而驰的。也会大大影响我们的开发效率。</li>\n</ol>\n<p>出现这些问题就叫做“侵入式”——框架代码侵入到使用者的工程代码，导致2者严重耦合，对未来的升级、扩展、二次开发都有深远的影响。</p>\n\n<h2 id="h2-2">通过注解（Annotation）扩展功能</h2>\n<p>实际上注解和在XML进行配置都是一样的思路，只是注解讲关系写在了源码上，而使用XML是将关系通过XML来描述。这里实现的功能就类似于在<a\n        href="https://www.chkui.com/article/spring/spring_core_bean_lifecycle_callback"\n        rel="nofollow">&nbsp;Bean的定义与控制</a>&nbsp;一文中介绍的Bean的生命周期方法。</p>\n<p>使用注解最大的价值就是非侵入式。非侵入式的好处显而易见：</p>\n<ol>\n    <li>无需和框架代码耦合，更新升级框架风险和成本都很小。</li>\n    <li>任何时候我们需要需要更换框架，只需修改配置或注解，而无需再去调整我们自己的功能代码。</li>\n</ol>\n<p>非侵入式也有一个问题，那就是接入的功能还是需要框架预设，而不可能像继承那样随心所欲。</p>\n<p>我们将前面的代码进行一些修改，支持通过注解来指定扩展的功能：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.xml.beanpostprocessor.annotation;\n\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">BeanFactory</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> List&lt;Object&gt; <span class="code-title">createBeans</span><span\n            class="hljs-params">(List&lt;Class&lt;?&gt;&gt; clslist)</span></span>{\n\t\t<span class="code-comment">//同前文...</span>\n\t}\n\t<span class="hljs-function">Object <span class="code-title">createBean</span><span class="hljs-params">(Class&lt;?&gt; cls)</span></span>{\n\t\tBeanWrapper wrapper = <span class="code-keyword">null</span>;\n\t\tObject ins = cls.newInstance();\n        <span class="code-comment">/**这里增加了一个Handle对象。\n           Handle会对注解进行处理，确定添加容器前后的执行方法。*/</span>\n\t\tHandle handle = processBeforeAndAfterHandle(ins);\n\t\thandle.exeBefore();\n\t\twrapper = <span class="code-keyword">new</span> BeanWrapper(ins);\n\t\thandle.exeAfter();\n\t\t<span class="code-keyword">return</span> wrapper;\n\t}\n\t\n    <span class="code-comment">// 通过反射来确定Bean被添加到容器前后的执行方法。</span>\n\t<span class="hljs-function"><span class="code-keyword">private</span> Handle <span class="code-title">processBeforeAndAfterHandle</span><span\n            class="hljs-params">(Object obj)</span> </span>{\n\t\tMethod[] methods = obj.getClass().getDeclaredMethods();\n\t\tHandle handle = <span class="code-keyword">new</span> Handle(obj);\n\t\t<span class="code-keyword">for</span>(Method method : methods) {\n\t\t\tAnnotation bef = method.getAnnotation(before.class);\n\t\t\tAnnotation aft = method.getAnnotation(after.class);\n\t\t\t<span class="code-keyword">if</span>(<span class="code-keyword">null</span> != bef) handle.setBefore(method);\n\t\t\t<span class="code-keyword">if</span>(<span class="code-keyword">null</span> != aft) handle.setBefore(method);\n\t\t}\n\t\t<span class="code-keyword">return</span> handle;\n\t}\n}</code></pre>\n<p>下面是Handle处理器和对应的注解的代码：</p>\n<pre><code class="java"><span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">Handle</span></span>{\n\tObject instance;\n\tMethod before;\n\tMethod after;\n\tHandle(Object ins){\n\t\t<span class="code-keyword">this</span>.instance = ins;\n\t}\n\t<span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">setBefore</span><span\n            class="hljs-params">(Method method)</span> </span>{\n\t\t<span class="code-keyword">this</span>.before = method;\n\t}\n\t<span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">setAfter</span><span\n            class="hljs-params">(Method method)</span> </span>{\n\t\t<span class="code-keyword">this</span>.after = method;\n\t}\n\t<span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">exeBefore</span><span\n            class="hljs-params">()</span></span>{\n\t\t<span class="code-keyword">if</span>(<span class="code-keyword">null</span> != <span\n            class="code-keyword">this</span>.before) {\n\t\t\t<span class="code-keyword">this</span>.before.invoke(<span class="code-keyword">this</span>.instance, <span\n            class="code-keyword">null</span>);\n\t\t}\n\t}\n\t<span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">exeAfter</span><span\n            class="hljs-params">()</span></span>{\n\t\t<span class="code-keyword">if</span>(<span class="code-keyword">null</span> != <span\n            class="code-keyword">this</span>.after) {\n\t\t\t<span class="code-keyword">this</span>.after.invoke(<span class="code-keyword">this</span>.instance, <span\n            class="code-keyword">null</span>);\n\t\t}\n\t}\n}\n\n<span class="code-comment">//注解----------------------------------------</span>\n<span class="code-meta">@Target</span>({ElementType.METHOD})\n<span class="code-meta">@Retention</span>(RetentionPolicy.RUNTIME)\n<span class="code-meta">@interface</span> before {}\n\n<span class="code-meta">@Target</span>({ElementType.METHOD})\n<span class="code-meta">@Retention</span>(RetentionPolicy.RUNTIME)\n<span class="code-meta">@interface</span> after{}</code></pre>\n<p>使用者的代码，我们将注解添加到Bean的对应的方法上：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">IocExtensionSampleNoPluging</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n    \tList&lt;Class&lt;?&gt;&gt; classes = Arrays.asList(<span class="code-keyword">new</span> Class&lt;?&gt;[]{MyBean1.class, MyBean2.class});\n    \tList&lt;Object&gt; ins = <span class="code-keyword">new</span> BeanFactory().createBeans(classes);\n    \tSystem.out.println(<span class="code-string">"Result:"</span> + ins.toString());\n    }\n}\n\n<span class="code-comment">//预设的Bean1</span>\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MyBean1</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">toString</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"MyBean1 Ins"</span>;\n\t}\n\t\n\t<span class="code-meta">@before</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">init</span><span class="hljs-params">()</span> </span>{\n    \tSystem.out.println(<span class="code-string">"Before Init:"</span> + <span class="code-keyword">this</span>.toString());\n\t}\n}\n\n<span class="code-comment">//预设的Bean2</span>\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MyBean2</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">toString</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"MyBean2 Ins"</span>;\n\t}\n\t\n\t<span class="code-meta">@after</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">post</span><span class="hljs-params">()</span> </span>{\n    \tSystem.out.println(<span class="code-string">"After Init:"</span> + <span class="code-keyword">this</span>.toString());\n\t}\n}</code></pre>\n<p>我们为MyBean1和MyBean2分别添加了init、post方法和对应的@before、@after注解。执行之后输出一下内容：</p>\n<pre><code class="apache"><span class="code-attribute">Before</span> Init:MyBean1 Ins\n<span class="code-attribute">After</span> Init:MyBean2 Ins\n<span class="code-attribute">Result</span>:[Wrapper(MyBean1 Ins), Wrapper(MyBean2 Ins)]</code></pre>\n<p>classpath：chkui.springcore.example.xml.beanpostprocessor.annotation.IocExtensionSample。<a\n        href="https://github.com/chkui/spring-core-example/blob/master/src/main/java/chkui/springcore/example/xml/beanpostprocessor/annotation/IocExtensionSample.java"\n        rel="nofollow">源码地址</a>。</p>\n<p>注解对应的方法都顺利执行。</p>\n<p>通过注解，我们实现了扩展功能，任何时候只需要通过添加或修改注解即可向容器扩展功能。在Spring核心功能里，<a\n        href="http://www.chkui.com/article/spring/spring_core_bean_lifecycle_callback" title="Bean的生命周期管理">Bean的生命周期管理</a>都是通过这种思路实现的，除了注解之外还有XML支持。\n</p>\n<p>\n    在使用spring的过程中，我想各位码友多多少少都通过继承Spring某些类来实现了一些需要扩展的功能。而且我发现网上很多使用spring某些功能的例子也是通过继承实现的。建议尽量不要去采用这种加深耦合的方式实现扩展，Spring提供了多种多样的容器扩展机制，后面的文章会一一介绍。</p>\n\n<h2 id="h2-3">后置处理器</h2>\n<p>\n    后置处理器——BeanPostProcessor是Spring核心框架容器扩展功能之一，作用和Bean的生命周期方法类似，也是在Bean完成初始化前后被调用。但是和生命周期方法不同的是，他无需在每一个Bean上去实现代码，而是通过一个独立的Bean来处理全局的初始化过程。</p>\n<p>BeanPostProcessor与Bean生命周期方法体现出的差异是：<span style="color:#e74c3c">我们无论任何时候都可以加入处理器来实现扩展功能，这样做的好处是无需调整之前的Bean的任何代码也可以植入功能</span>。\n</p>\n<p>这种实现方式与切面（AOP）有一些相似的地方，但是实现的方式是完全不一样的，而且处理器会对所有Bean进行处理。</p>\n<p>BeanPostProcessor的实现非常简单，只添加一个Bean实现BeanPostProcessor接口即可：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.xml.beanpostprocessor;\n<span class="code-keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Processor</span> <span class="code-keyword">implements</span> <span class="code-title">BeanPostProcessor</span> </span>{\n    <span class="code-comment">//初始化之前</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> Object <span class="code-title">postProcessBeforeInitialization</span><span\n            class="hljs-params">(Object bean, String beanName)</span> </span>{\n        <span class="code-keyword">return</span> bean;\n    }\n\t<span class="code-comment">//初始化之后</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> Object <span class="code-title">postProcessAfterInitialization</span><span\n            class="hljs-params">(Object bean, String beanName)</span> </span>{\n        System.out.println(<span class="code-string">"Bean \'"</span> + beanName + <span class="code-string">"\' created : "</span> + bean.toString());\n        <span class="code-keyword">return</span> bean;\n    }\n}</code></pre>\n<p>BeanPostProcessor的使用案例请查看<a href="https://github.com/chkui/spring-core-example" rel="nofollow">实例代码</a>中&nbsp;chkui.springcore.example.xml.beanpostprocessor\n    包中的代码，包含：</p>\n<p>一个实体类：<em>chkui.springcore.example.xml.entity.User</em></p>\n<p>一个服务接口和服务类：<em>chkui.springcore.example.xml.service.UserService</em></p>\n<p>处理器：<em>chkui.springcore.example.xml.beanpostprocessor.Processor</em></p>\n<p>Main入口：<em>chkui.springcore.example.xml.beanpostprocessor.BeanPostProcessor</em></p>\n<p>配置文件：<em>/src/main/resources/xml/config.xml</em></p>\n\n<h3 id="h3-3">更多的后置处理器说明</h3>\n<p>见：<a href="https://www.chkui.com/article/spring/spring_core_post_processor_of_official" title="spring后置处理器">https://www.chkui.com/article/spring/spring_core_post_processor_of_official</a>\n</p>'},392:function(a,s,n){"use strict";Object.defineProperty(s,"__esModule",{value:!0});s.content='<h2 id="h2-1">条件概率</h2>\n<p>事物A独立发生的概率为<img alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=P(A)">，事物B独立发生的概率为<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=P(B)">，那么有：</p>\n<p><img alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=P(A%7CB)">表示事物B发生之后事物A发生的概率；</p>\n<p><img alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=P(B%7CA)">表示事物A发生之后事物B发生的概率；</p>\n\n<h2 id="h2-2">全概率</h2>\n<p>我们可以将公式写成全量的形式：</p>\n<p><img alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=B_k(k%3D1%2C2%2C3...%2Cn)">表示全量相互排斥且性质关联的事物，即：\n</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=B_i%5Ccap%20B_j%3D%5Coslash%20(%E7%A9%BA%E9%9B%86)">，<img\n        alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=B_1%5Ccup%20B_2%20%5Ccup%20.....B_i%20%3D%20%5COmega%20(%E5%85%A8%E9%9B%86%E7%9A%84%E5%AD%90%E9%9B%86)">\n</p>\n<p>那么可以得到</p>\n<p><img alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=P(A)%3D%5Csum_j%5EiP(B_j)P(A%7CB_j)">,这就是全概率公式。\n</p>\n<p>全概率公式的意义在于：无法知道一个事物独立发生的概率，但是我们可以将其在各种条件下发生的概率进行累加获得。</p>\n\n<h3 id="h3-1">全概率的例子</h3>\n<p>\n    例1，已知某种疾病的发病率是0.001，即1000人中会有1个人得病。现有一种试剂可以检验患者是否得病，它的准确率是0.99，即在患者确实得病的情况下，它有99%的可能呈现阳性。它的误报率是5%，即在患者没有得病的情况下，它有5%的可能呈现阳性。一个人检测为阳性的概率是多少。</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=%E8%AE%BEP(A)%3D0.001%E8%A1%A8%E7%A4%BA%E5%8F%91%E7%97%85%E7%8E%87%EF%BC%8C%E5%88%99P(%5Cbar%7BA%7D%20)%3D0.999%E8%A1%A8%E7%A4%BA%E4%B8%8D%E5%8F%91%E7%97%85%E7%8E%87%E3%80%82P(B)%E8%A1%A8%E7%A4%BA%E6%A3%80%E6%B5%8B%E4%B8%BA%E9%98%B3%E6%80%A7%E7%9A%84%E6%A6%82%E7%8E%87%E3%80%82%E6%89%80%E4%BB%A5%EF%BC%9A">\n</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=P(B)%3DP(A)P(B%7CA)%20%2B%20P(%5Cbar%7BA%7D)P(B%7C%5Cbar%7BA%7D)%EF%BC%8C%E4%B8%94P(B%7CA)%3D0.99%2CP(B%7C%5Cbar%7BA%7D)%3D0.05%2C%E6%89%80%E4%BB%A5">\n</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=P(B)%3D0.001%C3%970.99%20%2B%200.999%C3%970.05%3D0.05094"></p>\n<p>例2，袋子中50个球，20个黄球，30个白球。2个人一次从袋中各获取一个球，且不放回，求第二个人取得黄球的概率。</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=P(A)%3D%5Cfrac%7B2%7D%7B5%7D%E8%A1%A8%E7%A4%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%BA%BA%E5%8F%96%E5%BE%97%E9%BB%84%E7%90%83%E7%9A%84%E6%A6%82%E7%8E%87%2C%E5%88%99P(%5Cbar%7BA%7D)%3D%5Cfrac%7B3%7D%7B5%7D%E3%80%82">\n</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=B%E8%A1%A8%E7%A4%BA%E7%AC%AC%E4%BA%8C%E4%B8%AA%E4%BA%BA%E5%8F%96%E5%BE%97%E9%BB%84%E7%90%83%E7%9A%84%E4%BA%8B%E4%BB%B6%E3%80%82%E6%9C%89%EF%BC%9A%0A">\n</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=P(B)%3DP(A)P(B%7CA)%2BP(%5Cbar%7BA%7D)P(B%7C%5Cbar%7BA%7D)%3D%5Cfrac%7B2%7D%7B5%7D%C3%97%5Cfrac%7B19%7D%7B49%7D%2B%5Cfrac%7B3%7D%7B5%7D%C3%97%5Cfrac%7B20%7D%7B49%7D%3D%5Cfrac%7B2%7D%7B5%7D">\n</p>\n<p>从另外一个角度说，无论前面的人抽了多少次，后面的人抽签总体概率是不变的。</p>\n<p>例3，5张卡片上分别标记了1,2,3,4,5，每次取2张，连续取2次，取出后不放回。求第二次取出的卡片，比第一次取出的卡片大的概率。</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=A%E8%A1%A8%E7%A4%BA%E7%AC%AC%E4%BA%8C%E5%BC%A0%E7%89%8C%E5%A4%A7%E7%9A%84%E4%BA%8B%E4%BB%B6%E3%80%82B_i%2Ci%5Cin%5B1%2C5%5D%E8%A1%A8%E7%A4%BA%E7%AC%AC%E4%B8%80%E5%BC%A0%E6%8A%BD%E5%88%B01%E5%88%B05%E7%9A%84%E4%BA%8B%E4%BB%B6%E3%80%82">\n</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=%E7%AC%AC%E4%B8%80%E5%BC%A0%E6%8A%BD%E5%88%B0%E4%BB%BB%E4%BD%95%E4%B8%80%E5%BC%A0%E7%89%8C%E6%A6%82%E7%8E%87%E9%83%BD%E6%98%AF%E4%B8%80%E6%A0%B7%E7%9A%84%EF%BC%8C%E6%89%80%E4%BB%A5P(B_i)%3D%5Cfrac%7B1%7D%7B5%7D%E3%80%82">\n</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=%E7%AC%AC%E4%B8%80%E5%BC%A0%E7%89%8C%E6%8A%BD%E5%88%B01%E6%97%B6%EF%BC%8C%E7%AC%AC%E4%BA%8C%E5%BC%A0%E7%89%8C%E5%A4%A7%E7%9A%84%E6%A6%82%E7%8E%87%E4%B8%BAP(A%7CB_1)%3D1%E3%80%82">\n</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=%E7%AC%AC%E4%B8%80%E5%BC%A0%E7%89%8C%E6%8A%BD%E5%88%B02%E6%97%B6%EF%BC%8C%E7%AC%AC%E4%BA%8C%E5%BC%A0%E7%89%8C%E5%A4%A7%E7%9A%84%E6%A6%82%E7%8E%87%E4%B8%BAP(A%7CB_2)%3D%5Cfrac%7B3%7D%7B4%7D%E3%80%82">\n</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=%E4%BB%A5%E6%AD%A4%E7%B1%BB%E6%8E%A8P(A%7CB_3)%3D%5Cfrac%7B2%7D%7B4%7D%2CP(A%7CB_4)%3D%5Cfrac%7B1%7D%7B4%7D%2CP(A%7CB_5)%3D0%E3%80%82%E6%89%80%E4%BB%A5%EF%BC%9A">\n</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=P(A)%3D%5Csum_%7Bi%3D1%7D%5E%7B5%7DP(B_i)P(A%7CB_i)%3D%5Cfrac%7B1%7D%7B5%7D%C3%971%2B%5Cfrac%7B1%7D%7B5%7D%C3%97%5Cfrac%7B3%7D%7B4%7D%2B%5Cfrac%7B1%7D%7B5%7D%C3%97%5Cfrac%7B2%7D%7B4%7D%2B%5Cfrac%7B1%7D%7B5%7D%C3%97%5Cfrac%7B1%7D%7B4%7D%2B%5Cfrac%7B1%7D%7B5%7D%C3%970%3D%5Cfrac%7B1%7D%7B2%7D">\n</p>\n<p>例4，甲袋有5只白球、7个红球，乙袋有4只白球、2只红球。任意取一个袋子，求从袋子取得白球的概率。</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=%E8%AE%BEA%3A%E8%8E%B7%E5%8F%96%E7%9A%84%E7%99%BD%E7%90%83%E7%9A%84%E4%BA%8B%E4%BB%B6%EF%BC%8CB%3A%E8%8E%B7%E5%BE%97%E7%94%B2%E8%A2%8B%E5%AD%90%E7%9A%84%E4%BA%8B%E4%BB%B6%E3%80%81%5Cbar%7BB%7D%3A%E8%8E%B7%E5%8F%96%E4%B9%99%E8%A2%8B%E5%AD%90%E3%80%82%E9%82%A3%E4%B9%88%EF%BC%9A">\n</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=P(A)%3DP(B)P(A%7CB)%2BP(%5Cbar%7BB%7D)P(A%7C%5Cbar%7BB%7D)"></p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=P(B)%3DP(%5Cbar%7BB%7D)%3D%5Cfrac%7B1%7D%7B2%7D%2CP(A%7CB)%3D%5Cfrac%7B5%7D%7B12%7D%2CP(A%7C%5Cbar%7BB%7D)%3D%5Cfrac%7B4%7D%7B6%7D%2C%E6%89%80%E4%BB%A5%EF%BC%9A">\n</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=P(B)%3D%5Cfrac%7B1%7D%7B2%7D%C3%97%5Cfrac%7B5%7D%7B12%7D%2B%5Cfrac%7B1%7D%7B2%7D%C3%97%5Cfrac%7B4%7D%7B6%7D%3D%5Cfrac%7B13%7D%7B24%7D">\n</p>\n\n<h2 id="h2-3">*贝叶斯公式</h2>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=P(A%7CB)%3DP(A)%C3%97%5Cfrac%7BP(B%7CA)%7D%7BP(B)%7D"></p>\n<p><strong>贝叶斯公式的理解</strong>：</p>\n<p>可以理解他是全概率公式的反向应用，他是求某个条件出现时某个事件发生的概率。定义如下：</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=P(A)%E8%A1%A8%E7%A4%BA%E5%89%8D%E7%BD%AE%E6%A6%82%E7%8E%87%EF%BC%8C%E8%A1%A8%E7%A4%BA%E5%BD%93B%E4%BA%8B%E4%BB%B6%E6%9C%AA%E5%8F%91%E7%94%9F%E6%97%B6A%E4%BA%8B%E4%BB%B6%E5%8F%91%E7%94%9F%E7%9A%84%E6%A6%82%E7%8E%87%E3%80%82">\n</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=P(A%7CB)%E4%B8%BA%E5%90%8E%E7%BD%AE%E6%A6%82%E7%8E%87%EF%BC%8C%E8%A1%A8%E7%A4%BAB%E4%BA%8B%E4%BB%B6%E5%8F%91%E7%94%9F%E4%B9%8B%E5%90%8EA%E4%BA%8B%E4%BB%B6%E5%8F%91%E7%94%9F%E7%9A%84%E6%A6%82%E7%8E%87%E3%80%82">\n</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%85%AC%E5%BC%8F%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%81%9A%E6%98%AF%E4%BA%8B%E4%BB%B6B%E5%8F%91%E7%94%9F%E5%90%8E%E5%AF%B9%E5%89%8D%E7%BD%AE%E6%A6%82%E7%8E%87%E7%9A%84%E4%BF%AE%E6%AD%A3%EF%BC%8C%5Cfrac%7BP(B%7CA)%7D%7BP(B)%7D%E6%98%AF%E4%BF%AE%E6%AD%A3%E5%9B%A0%E5%AD%90%E3%80%82">\n</p>\n<p>沿用前面医学的例子：</p>\n<p><em>例1，已知某种疾病的发病率是0.001，即1000人中会有1个人得病。现有一种试剂可以检验患者是否得病，它的准确率是0.99，即在患者确实得病的情况下，它有99%的可能呈现阳性。它的误报率是5%，即在患者没有得病的情况下，它有5%的可能呈现阳性。一个人检测为阳性时候，他确切患病的几率是多少。</em>\n</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=%E8%AE%BEP(A)%3D0.001%E8%A1%A8%E7%A4%BA%E5%8F%91%E7%97%85%E7%8E%87%EF%BC%8C%E5%88%99P(%5Cbar%7BA%7D%20)%3D0.999%E8%A1%A8%E7%A4%BA%E4%B8%8D%E5%8F%91%E7%97%85%E7%8E%87%E3%80%82P(B%7CA)%3D0.99%2CP(B%7C%5Cbar%7BA%7D)%3D0.05%E3%80%82%E6%89%80%E4%BB%A5%EF%BC%9A"><img\n        alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=P(A%7CB)%3DP(A)%C3%97%5Cfrac%7BP(B%7CA)%7D%7BP(B)%7D%2C%E7%94%A8%E5%85%A8%E6%A6%82%E7%8E%87%E5%85%AC%E5%BC%8F%EF%BC%9A">\n</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=P(A%7CB)%3DP(A)%C3%97%5Cfrac%7BP(B%7CA)%7D%7BP(A)P(B%7CA)%2BP(%5Cbar%7BA%7D)P(B%7C%5Cbar%7BA%7D)%7D"><img\n        alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=P(A%7CB)%3D0.001%C3%97%5Cfrac%7B0.99%7D%7B0.001%C3%970.99%2B0.999*0.05%7D%5Capprox%200.01943%3D1.94%5C%25">\n</p>\n<p>从结论看，这个试剂挺不可靠的。</p>\n<p>将贝叶斯公式的底部展开为全概率公式：</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=P(A_k%7CB)%3DP(A_k)%C3%97%5Cfrac%7BP(B%7CA_k)%7D%7B%5Csum_%7Bj%3D1%7D%5EnP(A_j)P(B%7CA_j)%7D%2Cj%5Cin(0%2Cn)%2CA_j%E8%A1%A8%E7%A4%BA%E7%9B%B8%E4%BA%92%E7%8B%AC%E7%AB%8B%E7%9A%84%E4%BA%8B%E4%BB%B6%E3%80%82">\n</p>\n<p><strong>使用全概率公式展开之后有个很直观的发现：</strong>当我们考察某一个事件的条件概率时——事件<img alt="机器学习中的数学——概率与统计"\n                                                                 src="https://math.jianshu.com/math?formula=B">发生之后<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=A_k">发生的概率，需要将整个样本空间中其他概率事件也加入到其中来。</p>\n\n<h2 id="h2-4">似然函数</h2>\n<p>似然函数个人理解是一种更加“公式化”的条件概率表达式，因为他书写的形式和条件概率相比并没有太大区别——<img alt="机器学习中的数学——概率与统计"\n                                                           src="https://math.jianshu.com/math?formula=P(x%7C%5Ctheta%20)">,只是解读方式不同。这里的<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=x">表示样本特征数据，<img alt="机器学习中的数学——概率与统计"\n                                                                                          src="https://math.jianshu.com/math?formula=%5Ctheta%20">表示模型参数。\n</p>\n<p>如果<img alt="机器学习中的数学——概率与统计"\n          src="https://math.jianshu.com/math?formula=%5Ctheta%20">已知并且固定，那么表示这个是一个概率计算模型，表示：不同的样本<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=x">在固定的模型参数<img alt="机器学习中的数学——概率与统计"\n                                                                                         src="https://math.jianshu.com/math?formula=%5Ctheta%0A">的概率值。\n</p>\n<p>如果<img alt="机器学习中的数学——概率与统计"\n          src="https://math.jianshu.com/math?formula=x">已经并且固定，表示这是一个似然计算模型（统计模型），表示不同的样本用于求解模型参数<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=%5Ctheta">。</p>\n\n<h2 id="h2-5">极大似然估计</h2>\n<p>按照前面似然函数<img alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=P(x%7C%5Ctheta)">的介绍，似然函数可以看做<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=x">是已知的，<img alt="机器学习中的数学——概率与统计"\n                                                                                      src="https://math.jianshu.com/math?formula=%5Ctheta">是未知的，极大似然估计就是在已知<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=x">的情况下求取<img alt="机器学习中的数学——概率与统计"\n                                                                                       src="https://math.jianshu.com/math?formula=%5Ctheta%20">。\n</p>\n<p>在现实的生产生活中也常常会遇到这样的问题。我们以及有了<strong>样本</strong>以及对应的<strong>标签（结论）</strong>，如何根据这些样本来计算（推算）条件<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=%5Ctheta%20">是一件很困难的事情。而极大似然估计就是一个根据样本值<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=x">和结论数据<img alt="机器学习中的数学——概率与统计"\n                                                                                      src="https://math.jianshu.com/math?formula=P(x%7C%5Ctheta)">计算条件参数<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=%5Ctheta%20">的过程。</p>\n<p>总的来说，极大似然估计是一种<strong>参数估计算法</strong>。使用极大似然估计有一个很重要的先决条件——每<strong>一组样本都是独立的，并且有充分的训练样本</strong>。</p>\n<p>先看看样本独立的判断公式：<img alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=P(A%2CB)%3DP(A)%C3%97P(B)">，即2个事物同时发生的概率等于事物独立发生概率的乘积。\n</p>\n<p>极大似然评估的公式及像这个公式。</p>\n<p>设有一组样本<img alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=D%3D%5C%7Bx_1%2Cx_2%2Cx_3...x_n%5C%7D">,所有样本的联合概率密度<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=P(D%7C%5Ctheta)">称为相对于样本<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=%5C%7Bx_1%2Cx_2%2Cx_3...x_n%5C%7D">的似然函数。那么由独立判定公式推断出所有样本的概率为：\n</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=l(%5Ctheta)%3DP(D%7C%5Ctheta)%3DP(x_i%7C%5Ctheta)%3D%5Cprod_%7Bi%3D1%7D%5En%20P(x_i%7C%5Ctheta)">。\n</p>\n<p>设<img alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=%5Chat%7B%5Ctheta%7D">是使得<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=l(%5Ctheta)">取得最大值的<img alt="机器学习中的数学——概率与统计"\n                                                                                                 src="https://math.jianshu.com/math?formula=%5Ctheta%20">值，那么<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=%5Chat%7B%5Ctheta%7D%20">是<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=%5Ctheta%20">的极大似然估计量。可以使用下面的公式表示<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=%5Chat%7B%5Ctheta%7D%20">与<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=D">的关系：</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=%5Chat%7B%5Ctheta%7D%3Dd(D)%3DD%5C%7Bx_1%2Cx_2%2Cx_3...x_n%5C%7D">,<img\n        alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=P(x%7C%5Chat%7B%5Ctheta%7D)%E7%A7%B0%E4%B8%BA%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E8%AF%84%E4%BC%B0%E5%80%BC%E3%80%82">\n</p>\n<p>实际计算时，计算连乘比较麻烦，我们可以引入对数将其转换为一个求和的过程：</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=L(%5Ctheta)%3Dlnl(%5Ctheta)%3D%5Csum_i%5EnlnP(x_i%7C%5Ctheta)">,因为<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=lnxy%3Dlnx%2Blny">。<img alt="机器学习中的数学——概率与统计"\n                                                                                                 src="https://math.jianshu.com/math?formula=L(%5Ctheta)">也称为对数似然函数。\n</p>\n<p>如果<img alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=L(%5Ctheta)">连续可微，那么可以使用导数为0求函数的凸点。即：</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=%5Cfrac%7Bd(L(%5Ctheta))%7D%7Bd%5Ctheta%7D%20%3D%200">。</p>\n<p>将条件因子扩展为M个，即<img alt="机器学习中的数学——概率与统计"\n                    src="https://math.jianshu.com/math?formula=P(x_i%2C%5Ctheta_j)%2Ci%5Cin(0%2Cn%5D%2Cj%5Cin(0%2Cm%5D">,则似然函数（对数似然函数变成）：\n</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=L(%5Ctheta_j)%3D%5Csum_%7Bi%3D1%7D%5En%5Cln%20P(x_i%7C%5Ctheta_j)">\n</p>\n<p>此时每一个<img alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=%5Ctheta_j">的求导变成一个求偏导数的过程：</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=%5Cfrac%7B%E2%88%82L(%5Ctheta_j)%7D%7B%E2%88%82%5Ctheta_k%7D%20%3D%20%5Cfrac%7B%E2%88%82%5Csum_%7Bi%3D1%7D%5En%5Cln%20P(x_i%7C%5Ctheta_j)%7D%7B%E2%88%82%5Ctheta_k%7D">,每一个<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=%5Ctheta_j">都要对<img alt="机器学习中的数学——概率与统计"\n                                                                                             src="https://math.jianshu.com/math?formula=L(%5Ctheta_j)">求导。\n</p>\n\n<h3 id="h3-2">最大似然评估的案例</h3>\n\n<h4 id="h4-1">最大似然评估计算</h4>\n<p>\n    最大似然评估（也称为极大似然评估）的用处是什么？首先可以将每个字眼拆解开来看。<strong>最大</strong>就是要找最大值<strong>，似然</strong>说明并不精确似乎就是这个值<strong>，评估</strong>指的是这是一个过程。\n</p>\n<p>现实生活中的例子：2对夫妇<img alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=(A%2C%5Chat%7BA%7D)%20">和<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=(B%2C%5Chat%7BB%7D)%20">和一个小孩<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=C">。从外观上看，小孩<img alt="机器学习中的数学——概率与统计"\n                                                                                          src="https://math.jianshu.com/math?formula=C">长相比较接近夫妇<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=(A%2C%5Chat%7BA%7D)%20">，有点像<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=B">，不像<img alt="机器学习中的数学——概率与统计"\n                                                                                    src="https://math.jianshu.com/math?formula=%5Chat%7BB%7D%20">,让你猜测<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=C">是谁的小孩。思维正常一点的人肯定会说<img alt="机器学习中的数学——概率与统计"\n                                                                                                   src="https://math.jianshu.com/math?formula=C">是<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=(A%2C%5Chat%7BA%7D)">的小孩，这本身就是一个自然而然的判断过程，用数学解释：\n</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=%E8%AE%BEP(A%7CC)%3EP(B%7CC)%EF%BC%8CP(%5Chat%7BA%7D%7CC)%3EP(%5Chat%7BB%7D%7CC)%E3%80%82P(x%7CC)%E8%A1%A8%E7%A4%BA%E5%B0%8F%E5%AD%A9%E6%9B%B4%E5%83%8F%E8%B0%81%EF%BC%8Cx%5Cin%5BA%2C%5Chat%7BA%7D%2CB%2C%5Chat%7BB%7D%5D%E3%80%82">\n</p>\n<p>使用似然评估，就可以断定小孩更像谁：</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=P(A%7CC)%C3%97P(%5Chat%7BA%7D%7CC)%20%3E%20P(B%7CC)%C3%97P(%5Chat%7BB%7D%7CC)">。\n</p>\n\n<h4 id="h4-2">参数&amp;模型评估</h4>\n<p>最大似然估计更多的应用是在有一定样本数据的情况下用于模型评估，更准确的说是模型中的参数评估。因为似然评估来自于概率独立判决公式——<img alt="机器学习中的数学——概率与统计"\n                                                                         src="https://math.jianshu.com/math?formula=P(A%2CB)%3DP(A)%C3%97P(B)">,所以要求用于评估的样本数据相互独立。\n</p>\n<p>先说一个很直观的案例解释这个问题：</p>\n<p><em>例1，从盒子里连续取球，已知取得红球的概率<img alt="机器学习中的数学——概率与统计"\n                                 src="https://math.jianshu.com/math?formula=P%5Cin%5B0.1%2C0.5%5D">,求当P取何值时最有可能连续三次拿到红球。</em>\n</p>\n<p>只管上来说，肯定是概率越高取得红球的几率越高，所以不做推断也知道<img alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=P%3D0.5">时拿到红球的几率更高。下面通过数学过程来说明这个问题。\n</p>\n<p>设条件<img alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=Y_i%3D1">，表示取得红球，<img alt="机器学习中的数学——概率与统计"\n                                                                                                  src="https://math.jianshu.com/math?formula=Y_i%3D0">表示没取得红球，所以用最大似然评估来计算参数得：\n</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=l(%5Ctheta)%3DP(Y_1)%C3%97P(Y_2)%C3%97P(Y_3)%3DP%5E3">，只管的看就知道取值0.5似然评估最大。\n</p>'}});