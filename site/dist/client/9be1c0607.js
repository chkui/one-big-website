webpackJsonp([9],{350:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h2 id="h2-1">一切从元编程开始</h2>\n<p>一个健壮的系统都要对外部提交的数据进行完整性、合法性的校验。即使开发一个不面对最终用户的工具包，也需要对传入的数据进行缜密的校验来防止引发底层难以追踪的问题。各路大神当然也会注意到这个问题，所以在“元编程”（见<a\n        href="https://www.chkui.com/article/spring/spring_core_jsr250_and_resource" title="JSR250与资源控制">JSR250与资源控制</a>）提出之后相续提交了<em>JSR-303、JSR-349以及JSR-380</em>来完善使用注解进行数据校验的机制，这三个JSR也被称为<em>Bean\n    Validation 1.0、Bean Validation 1.1和Bean Validation 2.0</em>，后文统称为<em>Bean Validation。</em></p>\n<p>先看一个不使用<em>Bean Validation</em>校验数据的代码：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">StandardValidation</span> </span>{\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tSystem.out.println(validationWithoutAnnotation(<span class="code-string">" "</span>, -<span class="hljs-number">1</span>));\n\t}\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> String <span\n            class="code-title">validationWithoutAnnotation</span><span class="hljs-params">(String inputString, Integer inputInt)</span> </span>{\n\t\tString error = <span class="code-keyword">null</span>;\n\t\t<span class="code-keyword">if</span> (<span class="code-keyword">null</span> == inputString) {\n\t\t\terror = <span class="code-string">"inputString不能为null"</span>;\n\t\t} <span class="code-keyword">else</span> <span class="code-keyword">if</span> (<span\n            class="code-keyword">null</span> == inputInt) {\n\t\t\terror = <span class="code-string">"inputInt不能为null"</span>;\n\t\t} <span class="code-keyword">else</span> <span class="code-keyword">if</span> (<span\n            class="hljs-number">1</span> &gt; inputInt.compareTo(<span class="hljs-number">0</span>)) {\n\t\t\terror = <span class="code-string">"inputInt必须大于0"</span>;\n\t\t} <span class="code-keyword">else</span> <span class="code-keyword">if</span> (inputString.isEmpty() || inputString.trim().isEmpty()) {\n\t\t\terror = <span class="code-string">"inputString不能为空字符串"</span>;\n\t\t} <span class="code-keyword">else</span> {\n\t\t\t<span class="code-comment">// DO</span>\n\t\t}\n\t\t<span class="code-keyword">return</span> error;\n\t}\n}\n</code></pre>\n<p>相信很多码友多少都写过类似的代码。使用<em>IF—ELSE</em>是否优雅这种高端问题暂且不谈，但是大量的<em>IF—</em><em>ELSE</em>会导致业务内容越来越多的嵌套在代码中。针对这些问题<em>Bean\n    Validation</em>为数据校验提供了更加规范化、通用化、复用程度更高的校验方法。</p>\n<p>\n    数据校验的原理并不复杂，主要是用注解（Annotation）在域或setter方法上声明JavaBean中数据的准则。Java的数据校验代码主要在javax.validation包中，包括注解、校验器以及校验器工厂，接下来通过例子说明。（例子可执行代码在本人的<a\n        href="https://gitee.com/chkui-com/spring-core-sample" rel="nofollow">gitee</a>库，本文代码在chkui.springcore.example.javabase.validation包）\n</p>\n\n<h2 id="h2-2">标准数据校验</h2>\n<p><a href="https://jcp.org/aboutJava/communityprocess/final/jsr303/index.html"\n      rel="nofollow">JSR提交的Javax.validation定义</a>中已经为数据校验定义了很多方法和注解，但是需要清晰的是JSR仅仅制定了一个规范，具体的功能是由各种框架实现的。本文的例子引入了<a\n        href="http://beanvalidation.org" rel="nofollow">Hibernate Validator 6.0.12.Final</a>包，他与Spring\n    Validator一样，都是根据JSR规范实现校验功能。</p>\n<p>数据校验是围绕一个实体类展开的，下面的代码声明了一个实体类，通过注解标注每个域上的赋值规则：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.validation.entity;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Game</span> </span>{\n\t<span class="code-meta">@NotNull</span> <span class="code-comment">//非空</span>\n\t<span class="code-meta">@Length</span>(min=<span class="hljs-number">0</span>, max=<span\n            class="hljs-number">5</span>) <span class="code-comment">//字符串长度小于5，这个是一个Hibernate Validator增加的注解</span>\n\t<span class="code-keyword">private</span> String name;\n\t\n\t<span class="code-meta">@NotNull</span>\n\t<span class="code-keyword">private</span> String description;\n\t\n\t<span class="code-meta">@NotNull</span>\n\t<span class="code-meta">@Min</span>(<span class="hljs-number">0</span>) <span\n            class="code-comment">//最小值&gt;=0</span>\n\t<span class="code-meta">@Max</span>(<span class="hljs-number">10</span>) <span\n            class="code-comment">//最大值&lt;=10</span>\n\t<span class="code-keyword">private</span> <span class="code-keyword">int</span> currentVersion; \n    <span class="code-comment">//getter and setter…………</span>\n}</code></pre>\n<p>使用校验器对其进行校验：</p>\n<pre><code class="java"><span class="code-keyword">public</span> StandardValidation {\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">validate</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-comment">//引入校验工具</span>\n\t\tValidatorFactory factory = Validation.buildDefaultValidatorFactory();\n        <span class="code-comment">//获取校验器</span>\n\t\tValidator validator = factory.getValidator();\n\t\tGame wow = <span class="code-keyword">new</span> Game();\n        <span class="code-comment">//执行校验</span>\n\t\tSet&lt;ConstraintViolation&lt;Game&gt;&gt; violationSet = validator.validate(wow);\n\t\tviolationSet.forEach(violat -&gt; {\n\t\t\tviolat.getPropertyPath();<span class="code-comment">//校验错误的域</span>\n            violat.getMessage());<span class="code-comment">//校验错误的信息</span>\n\t\t});\n        <span class="code-comment">//设置值之后再次进行校验</span>\n\t\twow.setName(<span class="code-string">"World Of Warcraft"</span>);\n\t\twow.setDescription(<span class="code-string">"由著名游戏公司暴雪娱乐所制作的第一款网络游戏，属于大型多人在线角色扮演游戏。"</span>);\n\t\twow.setCurrentVersion(<span class="hljs-number">8</span>);\n\t\tviolationSet = validator.validate(wow);\n\t\tviolationSet.forEach(violat -&gt; {});\n\t}\n}</code></pre>\n<p>执行完毕之后violationSet中就是校验的结果。如果校验通过那么返回的Set长度为0。</p>\n<p><em>Bean Validation</em>已经为常规的校验功能预设了很多注解，详见<a href="https://beanvalidation.org/2.0/spec/#builtinconstraints"\n                                                  rel="nofollow">关于所有注解的介绍</a>。</p>\n\n<h2 id="h2-3">自定义校验规则</h2>\n<p>虽然在<em>javax.validation.constraints</em>已经定义了很多用于校验的注解，但是肯定无法满足复杂多样的业务需求。所以<em>Bean Validation</em>也支持自定义校验规则。在JSR的文档中对数据域的一个校验被称为<em><strong>Constraint</strong></em>（约束），一个<em><strong>Constraint</strong></em>由一个<em><strong>Annotation</strong></em>（注解）绑定1~n个<strong><em>Validator</em></strong>（校验器）组成。&nbsp;因此可以通过新增<em><strong>Annotation</strong></em>和<strong><em>Validator</em></strong>来定义新的校验方式（或者说是定义新的<em><strong>Constraint</strong></em>）。\n</p>\n\n<h3 id="h3-1">组合注解校验</h3>\n<p>可以通过组合已有的注解来实现新的数据校验规则。例如下面的例子。</p>\n<p>定义新的校验注解：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.validation.annotation;\n<span class="code-meta">@Min</span>(<span class="hljs-number">1</span>)<span class="code-comment">//最小值&gt;=1</span>\n<span class="code-meta">@Max</span>(<span class="hljs-number">300</span>)<span class="code-comment">//最大值&lt;=300</span>\n<span class="code-meta">@Constraint</span>(validatedBy = {}) <span class="code-comment">//不制定校验器</span>\n<span class="code-meta">@Documented</span>\n<span class="code-meta">@Target</span>({ ElementType.ANNOTATION_TYPE, ElementType.METHOD, ElementType.FIELD })\n<span class="code-meta">@Retention</span>(RetentionPolicy.RUNTIME)\n<span class="code-keyword">public</span> <span class="code-meta">@interface</span> Price {\n\t<span class="hljs-function">String <span class="code-title">message</span><span class="hljs-params">()</span> <span\n            class="code-keyword">default</span> "定价必须在$1~$200之间"</span>;\n\tClass&lt;?&gt;[] groups() <span class="code-keyword">default</span> { };\n\tClass&lt;? extends Payload&gt;[] payload() <span class="code-keyword">default</span> { };\n}\n</code></pre>\n<p>在@Price注解中我们标记了@Min(1)和@Max(300)，之后直接在域上标记@Price就会校验对应的值是否满足这个条件：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.validation.entity;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Game</span> </span>{\n    <span class="code-meta">@Price</span>\n\t<span class="code-keyword">private</span> <span class="code-keyword">float</span> price;\n    <span class="code-comment">//Other field</span>\n    <span class="code-comment">//setter and getter</span>\n}</code></pre>\n\n<h3 id="h3-2">自定义校验器</h3>\n<p>除了组合<em>javax.validation.constraints</em>中的注解，还可以自定义校验器（<strong><em>Validator</em></strong>）进行数据校验。</p>\n<p>声明一个用于自定义校验的注解：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.validation.annotation;\n<span class="code-meta">@Constraint</span>(validatedBy = { TypeValidator.class }) <span\n            class="code-comment">//指定校验器</span>\n<span class="code-meta">@Documented</span>\n<span class="code-meta">@Target</span>({ ElementType.ANNOTATION_TYPE, ElementType.METHOD, ElementType.FIELD })\n<span class="code-meta">@Retention</span>(RetentionPolicy.RUNTIME)\n<span class="code-keyword">public</span> <span class="code-meta">@interface</span> Type {\n\t<span class="hljs-function">String <span class="code-title">message</span><span class="hljs-params">()</span> <span\n            class="code-keyword">default</span> "游戏类型错误,可选类型为RPG、ACT、SLG、ARPG"</span>;\n\tClass&lt;?&gt;[] groups() <span class="code-keyword">default</span> {};\n\tClass&lt;? extends Payload&gt;[] payload() <span class="code-keyword">default</span> {};\n}</code></pre>\n<p>注意<em>@Constraint(validatedBy = { TypeValidator.class })</em>这一行代码，他的作用就是将这个注解和校验器进行绑定，当我们执行Validator::validator方法时对应的校验器会被调用。\n</p>\n<p><em>TypeValidator</em>类：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.validation.validator;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">TypeValidator</span> <span class="code-keyword">implements</span> <span\n            class="code-title">ConstraintValidator</span>&lt;<span class="code-title">Type</span>, <span\n            class="code-title">String</span>&gt; </span>{\n\t<span class="code-keyword">private</span> <span class="code-keyword">final</span> List&lt;String&gt; TYPE = Arrays.asList(<span\n            class="code-keyword">new</span> String[]{<span class="code-string">"RPG"</span>, <span class="code-string">"ACT"</span>, <span\n            class="code-string">"SLG"</span>, <span class="code-string">"ARPG"</span>});\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">boolean</span> <span\n            class="code-title">isValid</span><span class="hljs-params">(String value, ConstraintValidatorContext context)</span> </span>{\n\t\t<span class="code-keyword">return</span> TYPE.contains(value);\n\t}\n}</code></pre>\n<p><em>TypeValidator</em>必须实现<em>ConstraintValidator</em>这个接口，并在范型中声明对应的校验注解和数据类型（<em>ConstraintValidator&lt;T,\n    E&gt;</em>，T是绑定的注解类型、E是数据类型）。<em>TypeValidator</em>中判断数值是不是"RPG", "ACT", "SLG", "ARPG"当中的一个，若不是则<em>TypeValidator::isValid</em>返回false表示校验没通过。\n</p>\n<p>在实体类的域上使用自定义的@Type注解：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">Game</span> </span>{\n\t<span class="code-meta">@NotNull</span>\n\t<span class="code-meta">@Type</span>\n\t<span class="code-keyword">private</span> String type;\n    <span class="code-comment">//Other field ......</span>\n    <span class="code-comment">//getter and setter ......</span>\n}</code></pre>\n\n<h2 id="h2-4">分组校验</h2>\n<p>对于业务来说数据录入的规则并不是一成不变的，往往需要根据某些状态来对单个或一组数据进行校验。这个时候我们可以用到分组功能——根据状态启用一组约束。</p>\n<p>观察自定义注解或<em>javax.validation.constraints</em>包中预定以的注解，都有一个<em>groups</em>参数：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="code-meta">@interface</span> Max {\n\t<span class="hljs-function">String <span class="code-title">message</span><span class="hljs-params">()</span> <span\n            class="code-keyword">default</span> "</span>{javax.validation.constraints.Max.message}<span\n            class="code-string">";\n\tClass&lt;?&gt;[] groups() default { }; //用于分组的参数\n\tClass&lt;? extends Payload&gt;[] payload() default { };\n\tlong value();\n}</span></code></pre>\n<p>如果未指定该参数，那么校验都属于<em>javax.validation.groups.Default</em>分组。</p>\n<p>先定义一个分组，用一个没有任何功能的类或者接口即可：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.validation.groups;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n            class="code-title">BetaGroup</span> </span>{}</code></pre>\n<p>然后在校验的注解上通过<em>groups</em>指定分组：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">Game</span> </span>{\n\t\n\t<span class="code-meta">@NotNull</span>\n\t<span class="code-meta">@Min</span>(<span class="hljs-number">0</span>) <span\n            class="code-comment">//最小值&gt;=0</span>\n\t<span class="code-meta">@Max</span>(<span class="hljs-number">10</span>) <span\n            class="code-comment">//最大值&lt;=10</span>\n\t<span class="code-meta">@Max</span>(value=<span class="hljs-number">0</span>, message=<span class="code-string">"未发行的游戏版本为0!"</span>, groups = BetaGroup.class)<span\n            class="code-comment">//分组校验</span>\n\t<span class="code-keyword">private</span> <span class="code-keyword">int</span> currentVersion; \n\t\n\t<span class="code-meta">@AssertTrue</span>(groups = BetaGroup.class)<span class="code-comment">//分组校验</span>\n\t<span class="code-comment">//表示是否为内侧版</span>\n\t<span class="code-keyword">private</span> <span class="code-keyword">boolean</span> beta;\n    <span class="code-comment">//Other field ......</span>\n    <span class="code-comment">//getter and setter ......</span>\n}</code></pre>\n<p>然后执行分组校验：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="code-keyword">enum</span> StandardValidation {\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">validate</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-comment">//引入校验工具</span>\n\t\tValidatorFactory factory = Validation.buildDefaultValidatorFactory();\n\t\tValidator validator = factory.getValidator();\n\n\t\tGame wow = <span class="code-keyword">new</span> Game();\n\t\twow.setName(<span class="code-string">"World Of Warcraft"</span>);\n\t\twow.setDescription(<span class="code-string">"由著名游戏公司暴雪娱乐所制作的第一款网络游戏，属于大型多人在线角色扮演游戏。"</span>);\n\t\twow.setCurrentVersion(<span class="hljs-number">8</span>);\n\t\twow.setType(<span class="code-string">"RPG"</span>);\n\t\twow.setPrice(<span class="hljs-number">401.01F</span>);\n\n        <span class="code-comment">//使用默认分组校验</span>\n\t\tviolationSet = validator.validate(wow);\n\t\t\n\t\t<span class="code-comment">//指定分组校验</span>\n\t\tviolationSet = validator.validate(wow, BetaGroup.class);\n\t}\n}</code></pre>\n<p><em>Validator::validator</em>方法未指定分组时，相当于使用<em>javax.validation.groups.Default</em>分组。而在<em>violationSet=validator.validate(wow,\n    BetaGroup.class);</em>这一行代码指定分组之后，只会执行<em>groups = BetaGroup.class</em>注解的校验。</p>\n<p>可以一次指定多个分组的校验，这样有利于处理复杂的状态：</p>\n<pre><code class="java">validator.validate(wow, Default.class, BetaGroup.class, OtherGroup.class);</code></pre>\n\n<h2 id="h2-5">校验错误级别</h2>\n<p>校验的注解中还有一个参数——<em>payload</em>，他表示“校验问题”的级别。这个参数就像使用<em>Log4j</em>输出日志会指定<em>DEBUG、INFO、WARN</em>等级别一样，在校验数据时会有对“校验问题”进行分类的需求，比如某些页面会对用户录入的数据进行“错误”或“警告”的提示。\n</p>\n<p>在使用payload时需要先声明PalyLoad接口类以标定“问题级别”：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.validation;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">PayLoadLevel</span> </span>{\n    <span class="code-comment">//警告级别</span>\n\t<span class="code-keyword">static</span> <span class="code-keyword">public</span> <span class="hljs-class"><span\n            class="code-keyword">interface</span> <span class="code-title">WARN</span> <span class="code-keyword">extends</span> <span\n            class="code-title">Payload</span> </span>{}\n    <span class="code-comment">//错误级别</span>\n\t<span class="code-keyword">static</span> <span class="code-keyword">public</span> <span class="hljs-class"><span\n            class="code-keyword">interface</span> <span class="code-title">Error</span> <span class="code-keyword">extends</span> <span\n            class="code-title">Payload</span> </span>{}\n}</code></pre>\n<p>然后在JavaBean上指定“校验问题”的级别：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">Game</span> </span>{\n    <span class="code-comment">//默认分组校验错误时，错误级别为Error</span>\n\t<span class="code-meta">@NotNull</span>(payload=PayLoadLevel.Error.class)\n\t<span class="code-meta">@Min</span>(value=<span class="hljs-number">0</span>, payload=PayLoadLevel.Error.class) \n\t<span class="code-meta">@Max</span>(value=<span class="hljs-number">10</span>, payload=PayLoadLevel.Error.class) \n    <span class="code-comment">//BetaGroup分组错误级别为WARN</span>\n\t<span class="code-meta">@Max</span>(value=<span class="hljs-number">0</span>, message=<span class="code-string">"未发行的游戏版本为0!"</span>, groups = BetaGroup.class, payload=PayLoadLevel.WARN.class)\n\t<span class="code-keyword">private</span> <span class="code-keyword">int</span> currentVersion; \n\t\n\t<span class="code-meta">@AssertTrue</span>(groups = BetaGroup.class, payload=PayLoadLevel.WARN.class)\n\t<span class="code-keyword">private</span> <span class="code-keyword">boolean</span> beta;\n    <span class="code-comment">//Other field ......</span>\n    <span class="code-comment">//getter and setter ......\t</span>\n}</code></pre>\n<p>然后在执行校验的时候使用ConstraintViolation::getConstraintDescriptor::getPayload方法获取每一个校验问题的错误级别：</p>\n<pre><code class="java">violationSet = validator.validate(wow, BetaGroup.class);\nviolationSet.forEach(violat -&gt; {\n\tviolat.getPropertyPath();<span class="code-comment">//错误域的名称</span>\n    violat.getMessage();<span class="code-comment">//错误消息</span>\n\tviolat.getConstraintDescriptor().getPayload();<span class="code-comment">//错误级别</span>\n});</code></pre>'},358:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<p>\n    React提供了一系列声明性的API接口，因此在使用时不必担心每次库的更新会修改API接口。这样可以降低编写应用的复杂度，但是带来的问题是无法很好的理解React是如何实现这些功能的。这篇文章会介绍React的差异比对算法——“融合算法”是如何执行的。</p>\n\n<h2 id="h2-1">差异匹配算法实现的前提</h2>\n<p>我们先来看看第一个值得关注的我问题：&nbsp;<code>render()</code>&nbsp;方法的作用是创建React元素的树形结构，当state或props发生更新后，&nbsp;<code>render()</code>&nbsp;会返回一个与之前有差异的结构树。在这个机制下，React需要弄清楚如何匹配最近的树并有效的更新UI。\n</p>\n<p>针对以上问题，有一些通用的算法可供参考，比如比对2颗树的差异，在前一个颗树的基础上生成最小操作树，但是这个算法的时间复杂度为n的三次方=O(n*n*n)，当树的节点较多时，这个算法的时间代价会导致算法几乎无法工作。</p>\n<p>\n    假设在我们使用React时，一共使用了1000个Dom标签元素，那么使用上面的算法，我们要比对数亿次才能得到比对的结果，根本不可能在一个浏览器中短时间完成。React实现了一个计算复杂度是O(n)的算法来解决这个问题，这个算法基于2个假设：</p>\n<ol>\n    <li>不同类型的2个标签元素产生不同的树。</li>\n    <li>开发人员可以为不同的子节点在渲染之前设定一个“key”属性值。</li>\n</ol>\n\n<h2 id="h2-2">差异算法</h2>\n<p>对于2颗有差异的树，React首先比对2颗树的根节点。根据跟节点的类型是否相同，算法接下来会执行不同的操作。</p>\n\n<h2 id="h2-3">Types不一样</h2>\n<p>\n    一旦2棵树之间的根元素类型不一样，React会直接移除旧的树并构建出新的树。例如从&nbsp;<code>&lt;a&gt;</code>&nbsp;变更为&nbsp;<code>&lt;img&gt;</code>、&nbsp;<code>&lt;Article&gt;</code>&nbsp;变更为&nbsp;<code>&lt;Comment&gt;</code>、&nbsp;<code>&lt;Button&gt;</code>&nbsp;变更为&nbsp;<code>&lt;div&gt;</code>&nbsp;，所有的这些变化都会导致整颗树重构。\n</p>\n<p>重构一棵新的树时，所有的旧节点都会移除。组件的<code>componentWillUnmount()</code>方法会被调用。&nbsp;然后到构建完成之后新的Dom会替换原来的Dom。此时组件的<code>componentWillMount()</code>和<code>componentDidMount()</code>会依次被调用。旧树Dom上的所有状态都会丢失。\n</p>\n<p>根据这个特性，根节点之后的所有组件都会卸载并重建，状态也会随之改变。例如下面2个组件对比：</p>\n<pre class="xml"><code class="language-html xml"><span class="code-tag"><span class="code-tag">&lt;</span><span\n        class="code-name"><span class="code-tag"><span class="code-name">div</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">Counter</span></span></span><span class="code-tag"> /&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n        class="code-name">div</span></span></span><span class="code-tag">&gt;</span></span>\n\n<span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n        class="code-name">span</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">Counter</span></span></span><span class="code-tag"> /&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n        class="code-name">span</span></span></span><span class="code-tag">&gt;</span></span></code></pre>\n<p><code>Counter</code>&nbsp;组件会被销毁并重新安装一个新的组件。</p>\n\n<h2 id="h2-4">Dom元素拥有相同的类型</h2>\n<p>当比较React元素为相同类型时，React会查看元素上的属性来比对。比对之后，React会保持的Dom节点不改变然后仅仅更新不同的属性值，例如：</p>\n<pre class="xml"><code class="language-html xml"><span class="code-tag"><span class="code-tag">&lt;</span><span\n        class="code-name"><span class="code-tag"><span class="code-name">div</span></span></span><span\n        class="code-tag"> </span><span class="hljs-attr"><span class="code-tag"><span class="hljs-attr">className</span></span></span><span\n        class="code-tag">=</span><span class="code-string"><span class="code-tag"><span\n        class="code-string">"before"</span></span></span><span class="code-tag"> </span><span class="hljs-attr"><span\n        class="code-tag"><span class="hljs-attr">title</span></span></span><span class="code-tag">=</span><span\n        class="code-string"><span class="code-tag"><span class="code-string">"stuff"</span></span></span><span\n        class="code-tag"> /&gt;</span></span>\n\n<span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n        class="code-name">div</span></span></span><span class="code-tag"> </span><span class="hljs-attr"><span\n        class="code-tag"><span class="hljs-attr">className</span></span></span><span class="code-tag">=</span><span\n        class="code-string"><span class="code-tag"><span class="code-string">"after"</span></span></span><span\n        class="code-tag"> </span><span class="hljs-attr"><span class="code-tag"><span\n        class="hljs-attr">title</span></span></span><span class="code-tag">=</span><span class="code-string"><span\n        class="code-tag"><span class="code-string">"stuff"</span></span></span><span\n        class="code-tag"> /&gt;</span></span></code></pre>\n<p>在比对这2个元素之后，React知道仅仅需要修改当前Dom的<code>className</code>。在更新<code>style</code>时，React同样知道仅仅需要更新修改部分即可。例如：</p>\n<pre class="groovy"><code class="language-html xml"><span class="code-tag">&lt;<span class="code-name">div</span> <span\n        class="hljs-attr">style</span>=<span class="code-string">{{<span class="code-string">color:</span></span> <span\n        class="code-string">\'</span><span class="hljs-attr"><span class="code-string">red</span></span><span\n        class="code-string">\'</span>, <span class="hljs-attr"><span class="code-string">fontWeight:</span></span> <span\n        class="code-string">\'</span><span class="hljs-attr"><span class="code-string">bold</span></span><span\n        class="code-string">\'</span>}} /&gt;</span>\n\n<span class="code-tag">&lt;<span class="code-name">div</span> <span class="hljs-attr">style</span>=<span\n        class="code-string">{{<span class="code-string">color:</span></span> <span class="code-string">\'</span><span\n        class="hljs-attr"><span class="code-string">green</span></span><span class="code-string">\'</span>, <span\n        class="hljs-attr"><span class="code-string">fontWeight:</span></span> <span class="code-string">\'</span><span\n        class="hljs-attr"><span class="code-string">bold</span></span><span class="code-string">\'</span>}} /&gt;</span></code></pre>\n<p>在转换这2个组件时，React知道仅仅需要修改color的样式，而fontWeight不必发生变动。</p>\n<p>在处理完当前Dom节点后，React依次对子节点进行递归。</p>\n\n<h2 id="h2-5">组件元素拥有相同的类型</h2>\n<p>当一个组件发生更新后，实例依然是原来的实例，所以状态还是以前的状态。React通过属性值（props）的更新来影响需要更新组件，此时组件实例的&nbsp;<code>componentWillReceiveProps()</code>&nbsp;和&nbsp;<code>componentWillUpdate()</code>&nbsp;方法会被调用。\n</p>\n<p>然后，&nbsp;<code>render()</code>&nbsp;方法会被调用并返回一个Dom，差异算法会递归比对之前返回Dom的差异。</p>\n\n<h2 id="h2-6">递归子元素</h2>\n<p>默认情况下，在递归子元素的Dom节点时，React同时对2个子元素列表进行迭代比对，如果发现差异都会产生一个突变（<a title="React性能优化"\n                                                               href="https://www.chkui.com/article/react/react_optimizing_performance"\n                                                               rel="nofollow">关于突变的概念请见React学习第六篇性能优化介绍不可变数据结构部分</a>）。\n</p>\n<p>例如，当增加一个元素在子元素的队尾，这2颗树的转换效率很高：</p>\n<pre class="xml"><code class="language-html xml"><span class="code-tag"><span class="code-tag">&lt;</span><span\n        class="code-name"><span class="code-tag"><span class="code-name">ul</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>first<span class="code-tag"><span\n            class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>second<span\n            class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n        class="code-name">ul</span></span></span><span class="code-tag">&gt;</span></span>\n\n<span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n        class="code-name">ul</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>first<span class="code-tag"><span\n            class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>second<span\n            class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>third<span class="code-tag"><span\n            class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n        class="code-name">ul</span></span></span><span class="code-tag">&gt;</span></span></code></pre>\n<p>React先匹配&nbsp;<code>&lt;li&gt;first&lt;/li&gt;</code>&nbsp;2棵树，然后再匹配&nbsp;<code>&lt;li&gt;second&lt;/li&gt;</code>&nbsp;。最后直接就添加&nbsp;<code>&lt;li&gt;third&lt;/li&gt;</code>&nbsp;节点。\n</p>\n<p>如果代码按下面的方式修改2颗树，执行的效率相对较差：</p>\n<pre class="xml"><code class="language-html xml"><span class="code-tag"><span class="code-tag">&lt;</span><span\n        class="code-name"><span class="code-tag"><span class="code-name">ul</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>Duke<span\n            class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>Villanova<span\n            class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n        class="code-name">ul</span></span></span><span class="code-tag">&gt;</span></span>\n\n<span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n        class="code-name">ul</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>Connecticut<span\n            class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>Duke<span\n            class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>Villanova<span\n            class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n        class="code-name">ul</span></span></span><span class="code-tag">&gt;</span></span></code></pre>\n<p>\n    React会突变修改所有的子节点，最终&nbsp;<code>&lt;li&gt;Duke&lt;/li&gt;</code>&nbsp;and&nbsp;<code>&lt;li&gt;Villanova&lt;/li&gt;</code>&nbsp;会被重新渲染。所以这种方式会带来很大的效率问题。\n</p>\n\n<h2 id="h2-7">Keys</h2>\n<p>为了解决上面的问题，React提供了一个“key”属性。当所有的子元素都有一个key值，React直接使用key值来比对树形结构中的所有子节点列表。例如为上面的的例子增加一个key会大大的提升转换效率：</p>\n<pre class="xml"><code class="language-html xml"><span class="code-tag"><span class="code-tag">&lt;</span><span\n        class="code-name"><span class="code-tag"><span class="code-name">ul</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">li</span></span></span><span class="code-tag"> </span><span class="hljs-attr"><span\n          class="code-tag"><span class="hljs-attr">key</span></span></span><span class="code-tag">=</span><span\n          class="code-string"><span class="code-tag"><span class="code-string">"2015"</span></span></span><span\n          class="code-tag">&gt;</span></span>Duke<span class="code-tag"><span class="code-tag">&lt;/</span><span\n            class="code-name"><span class="code-tag"><span class="code-name">li</span></span></span><span\n            class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">li</span></span></span><span class="code-tag"> </span><span class="hljs-attr"><span\n          class="code-tag"><span class="hljs-attr">key</span></span></span><span class="code-tag">=</span><span\n          class="code-string"><span class="code-tag"><span class="code-string">"2016"</span></span></span><span\n          class="code-tag">&gt;</span></span>Villanova<span class="code-tag"><span class="code-tag">&lt;/</span><span\n            class="code-name"><span class="code-tag"><span class="code-name">li</span></span></span><span\n            class="code-tag">&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n        class="code-name">ul</span></span></span><span class="code-tag">&gt;</span></span>\n\n<span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n        class="code-name">ul</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">li</span></span></span><span class="code-tag"> </span><span class="hljs-attr"><span\n          class="code-tag"><span class="hljs-attr">key</span></span></span><span class="code-tag">=</span><span\n          class="code-string"><span class="code-tag"><span class="code-string">"2014"</span></span></span><span\n          class="code-tag">&gt;</span></span>Connecticut<span class="code-tag"><span class="code-tag">&lt;/</span><span\n            class="code-name"><span class="code-tag"><span class="code-name">li</span></span></span><span\n            class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">li</span></span></span><span class="code-tag"> </span><span class="hljs-attr"><span\n          class="code-tag"><span class="hljs-attr">key</span></span></span><span class="code-tag">=</span><span\n          class="code-string"><span class="code-tag"><span class="code-string">"2015"</span></span></span><span\n          class="code-tag">&gt;</span></span>Duke<span class="code-tag"><span class="code-tag">&lt;/</span><span\n            class="code-name"><span class="code-tag"><span class="code-name">li</span></span></span><span\n            class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">li</span></span></span><span class="code-tag"> </span><span class="hljs-attr"><span\n          class="code-tag"><span class="hljs-attr">key</span></span></span><span class="code-tag">=</span><span\n          class="code-string"><span class="code-tag"><span class="code-string">"2016"</span></span></span><span\n          class="code-tag">&gt;</span></span>Villanova<span class="code-tag"><span class="code-tag">&lt;/</span><span\n            class="code-name"><span class="code-tag"><span class="code-name">li</span></span></span><span\n            class="code-tag">&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n        class="code-name">ul</span></span></span><span class="code-tag">&gt;</span></span></code></pre>\n<p>现在React可以知道key=\'2014\'的节点是一个新值另外2个节点仅仅需要移动一下位置。</p>\n<p>在实际使用中，key值并不难找。在常规业务中，很多列表都自然包含业务相关的ID了：</p>\n<pre class="dust"><code class="language-html xml"><span class="code-tag"><span class="xml"><span\n        class="code-tag">&lt;</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span\n        class="code-name">li</span></span></span></span><span class="xml"><span class="code-tag"> </span></span><span\n        class="hljs-attr"><span class="xml"><span class="code-tag"><span\n        class="hljs-attr">key</span></span></span></span><span class="xml"><span class="code-tag">=</span></span><span\n        class="code-string"><span class="code-template-variable">{item.id}</span></span><span class="xml"><span\n        class="code-tag">&gt;</span></span></span><span class="code-template-variable">{item.name}</span><span\n        class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span\n        class="xml"><span class="code-tag"><span class="code-name">li</span></span></span></span><span class="xml"><span\n        class="code-tag">&gt;</span></span></span></code></pre>\n<p>当无法使用业务ID时，也可以额外增加一个ID值来标记列表差异，比如根据要使用的数据生成一个hash值，React不需要key值全局唯一，只需要在兄弟节点之间保持唯一即可。</p>\n<p>最差情况下，你可以使用索引数据（0、1、2、....n）。使用索引需要注意的是，如果列表发生重新排序效率会很糟糕。</p>\n\n<h2 id="h2-8">一些常见的问题</h2>\n<p>在使用React时需要谨记每次调用 <strong><em>render()</em></strong>\n    方法，它总会尝试比对调用前后2棵树是否一致。在某些极端情况下，虽然最终呈现效果并没有发生多大的变化，但是有可能每一个简单的操作都导致React全局重新渲染(例如列表没有Key)。</p>\n<p>\n    React在当前版本的实现中还存在一个问题，可以快捷的告知React子树中某个节点的位置已经发生改变，但是无法告知React他移动到了什么位置。因此在遇到这种情况时，算法会重构整个子树。这个问题告诉我们，如果遇到弹窗之类需要偶尔出现的组件，最好是通过隐藏属性控制他，而非直接移除Dom。</p>\n<p>React依赖启发式算法，如果本文开篇提到的2个基本假设不成立，那么会导致算法效率极差。</p>\n<ol>\n    <li>算法不会尝试匹配不同2个组件之间的子树。如果编码中发现2个组件之间有非常相似的输出，应该尝试将2个组件合并为一个类型的组件。在实际应用中，我们还没发现这样导致问题。</li>\n    <li>用作列表的key值最好是稳定、可预见、唯一的。易变的key值（比如由<code>Math.random()</code>方法生成的值）将会导致许多组件实例和Dom节点被非必要的重新创建，这会导致性能低下且子组件丢失已有的状态。&nbsp;\n    </li>\n</ol>'},386:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h2 id="h2-1">@Configuration</h2>\n<p>在介绍Spring核心容器的系列文章中已经多次出现这个注解，从使用的角度来说可以把他理解为XML配置中的&lt;beans&gt;标签，但是两者肯定是不等价的。</p>\n<p>在&lt;beans&gt;标签中除了使用&lt;bean&gt;声名Bean以外，还有各种&lt;context&gt;标签来扩展功能，比如&lt;context:component-scan/&gt;、&lt;context:annotation-config /&gt;以及&lt;import&gt;等，这些扩展的功能并不是@Configuration注解的参数，而是通过另外一个注解来实现——@ComponentScan、@Import。</p>\n<p>@Configuration的基本使用方法已经在<a href="https://www.chkui.com/article/spring/spring_core_java_base_and_bean_annotation" title="纯Java运行与@Bean">纯Java运行与@Bean</a>的“@Bean注解”部分介绍了使用方法，本篇在此基础上进一步进行说明。</p>\n\n<h2 id="h2-2">@Configuration添加依赖</h2>\n<p>除了在<a href="https://www.chkui.com/article/spring/spring_core_java_base_and_bean_annotation" title="纯Java运行与@Bean">纯Java运行与@Bean</a>文中介绍的使用方法，我们还可以直接通过使用Java代码来添加依赖关系：</p>\n<p>(文中的代码仅用于说明问题，源码在<a href="https://gitee.com/chkui-com/spring-core-sample" rel="nofollow">gitee</a>上，如有需要请自行clone，本文的案例代码在chkui.springcore.example.javabase.configuration包中。)</p>\n<pre><code class="java"><span class="code-meta">@Configuration</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MyConfig</span> </span>{\n\n    <span class="code-meta">@Bean</span>\n    <span class="hljs-function"><span class="code-keyword">public</span> Alice <span class="code-title">alice</span><span class="hljs-params">()</span> </span>{\n        <span class="code-comment">//直接使用方法注入数据。</span>\n        <span class="code-comment">//从表面上看这里调用bob()并没有经过容器处理。而是直接使用了。</span>\n        <span class="code-keyword">return</span> <span class="code-keyword">new</span> Alice(bob());\n    }\n\n    <span class="code-meta">@Bean</span>\n    <span class="hljs-function"><span class="code-keyword">public</span> Bob <span class="code-title">bob</span><span class="hljs-params">()</span> </span>{\n        <span class="code-keyword">return</span> <span class="code-keyword">new</span> Bob();\n    }\n}</code></pre>\n<p>看到这里，思维敏捷的码友通过以下逻辑肯定就发现问题了：</p>\n<ol>\n\t<li>通过@Bean注解是向容器添加一个<a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/config/BeanDefinition.html" rel="nofollow">BeanDefinition</a>，</li>\n\t<li>在所有的<a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/config/BeanDefinition.html" rel="nofollow">BeanDefinition</a>创建之后容器开始创建Bean之前会执行预设的<a href="https://www.chkui.com/article/spring/spring_core_ioc_extension_points" title="IOC功能扩展点">后置处理器BeanFactoryPostProcessor</a>。</li>\n\t<li>最后容器根据<a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/config/BeanDefinition.html" rel="nofollow">BeanDefinition</a>的内容创建Bean。</li>\n\t<li><span style="color:#ffffff"><em><span style="background-color:#4e5f70">&nbsp;return new Alice(bob());&nbsp;</span></em></span>这段代码中<em>MyConfig::bob</em>方法的调用看起来完全和容器无关，这样就违反了依赖注入的原则！</li>\n\t<li>所以是不是Alice类中被注入的Bob实例根本就不是IoC容器中的Bob？</li>\n</ol>\n<p>首先可以很负责的告诉码友们Spring并没有限制这个方式去添加Bean，所以例子中Alice类中的Bob实例就是IoC容器中的实例。即使是这样去注入Bean同样实现了依赖注入的功能。至于怎么解决的看完本文自然就能得到答案了。</p>\n\n<h2 id="h2-3">@Component添加依赖</h2>\n<p>之前在<a href="https://www.chkui.com/article/spring/spring_core_stereotype_component_and_bean_scan" title="Stereotype组件与Bean扫描">Stereotype组件与Bean扫描</a>这篇文章已经提到过，除了在@Configuration中的方法使用@Bean，还可以在@Component及其派生类中的方法使用@Bean。例如下面的例子：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.configuration.bean;\n\n<span class="code-meta">@Component</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">BeanManager</span> </span>{\n\t\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> Cytus <span class="code-title">cytus</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> Cytus();\n\t}\n\t\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> Dva <span class="code-title">dva</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> Dva();\n\t}\n\t\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> Game <span class="code-title">game</span><span class="hljs-params">(Dva dva)</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> Game(cytus(), dva);\n\t}\n}</code></pre>\n<p>BeanManager中的三个方法都会向容器添加Bean。注意第三个方法：<em>public Game game(Dva dva)</em>。这里即采用了通过方法参数注入依赖，也像前面的例子一样直接调用了方法。但是这里与前面介绍的使用@Configuration注解不同，Game中的Cytus实例不是IoC容器中的Cytus。</p>\n<p>通过下面的例子来说明@Configuration和@Component中注入Bean的差异。（代码仅用于展示，有兴趣运行的可以下载<a href="https://gitee.com/chkui-com/spring-core-sample" rel="nofollow">gitee上的源码</a>，代码在<em>chkui.springcore.example.javabase.configuration</em> 包中）。</p>\n<pre><code class="java"><span class="code-comment">//package chkui.springcore.example.javabase.configuration;</span>\n<span class="code-comment">//使用@Configuration注解</span>\n<span class="code-meta">@Configuration</span>\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">Config</span> </span>{\n\t\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> Alice <span class="code-title">alice</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> Alice(bob());\n\t}\n\t\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> Bob <span class="code-title">bob</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> Bob();\n\t}\n}\n<span class="code-comment">//package chkui.springcore.example.javabase.configuration.bean;</span>\n<span class="code-comment">//使用@Component注解</span>\n<span class="code-meta">@Component</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">BeanManager</span> </span>{\n\t\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> Cytus <span class="code-title">cytus</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> Cytus();\n\t}\n\t\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> Dva <span class="code-title">dva</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> Dva();\n\t}\n\t\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> Game <span class="code-title">game</span><span class="hljs-params">(Dva dva)</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> Game(cytus(), dva);\n\t}\n}\n<span class="code-comment">//运行</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">ConfigurationApp</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(Config.class， BeanManager.class);\n\t\tBob bob = ctx.getBean(Bob.class);\n\t\tAlice alice = ctx.getBean(Alice.class);\n\t\tSystem.out.println(<span class="code-string">"Bob instance of IoC hash: "</span> + bob.hashCode());\n\t\tSystem.out.println(<span class="code-string">"Bob instance of Alice hash: "</span> + alice.getBob().hashCode());\n\t\tSystem.out.println(<span class="code-string">"Compare："</span> + (bob == alice.getBob()));\n\t\tSystem.out.println(<span class="code-string">"Config instance："</span> + ctx.getBean(Config.class));\n\n\t\tGame game = ctx.getBean(Game.class);\n\t\tCytus cytus = ctx.getBean(Cytus.class);\n\t\tDva dva = ctx.getBean(Dva.class);\n\t\tSystem.out.println(<span class="code-string">"IoC Cytus: "</span> + cytus.hashCode());\n\t\tSystem.out.println(<span class="code-string">"Game Cytus: "</span> + game.getCytus().hashCode());\n\t\tSystem.out.println(<span class="code-string">"IoC Dva: "</span> + dva.hashCode());\n\t\tSystem.out.println(<span class="code-string">"Game Dva: "</span> + game.getDva().hashCode());\n\t\tSystem.out.println(<span class="code-string">"Cytus："</span> + (cytus == game.getCytus()));\n\t\tSystem.out.println(<span class="code-string">"Dva："</span> + (dva == game.getDva()));\n\t\tSystem.out.println(<span class="code-string">"BeanManager Instance："</span> + ctx.getBean(BeanManager.class));\n\t}\n}</code></pre>\n<p>在最后的main方法中我们对容器中以及Alice、Game中包含的实例进行了hash以及实例对比，在我的电脑上输出结果如下：</p>\n<pre><code class="bash">1.Bob instance of IoC <span class="code-built_in">hash</span>: 1242027525\n2.Bob instance of Alice <span class="code-built_in">hash</span>: 1242027525\n3.Compare：<span class="hljs-literal">true</span>\n4.Config instance：5.chkui.springcore.example.javabase.configuration.Config$<span class="code-variable">$EnhancerBySpringCGLIB</span>$<span class="code-variable">$acdbeb32</span>@74287ea3\n6.IoC Cytus: 2104973502\n7.Game Cytus: 735937428\n8.IoC Dva: 1604247316\n9.Game Dva: 1604247316\n10.Cytus：<span class="hljs-literal">false</span>\n11.Dva：<span class="hljs-literal">true</span>\n12.BeanManager Instance：chkui.springcore.example.javabase.configuration.bean.BeanManager@68746f22</code></pre>\n<p>例子中分别在@Configuration和@Component标记的类中使用@Bean来向容器添加Bean。最后通过输出实例的hash以及地址匹配（使用“==”比对）来确定是否都是同一个单例。</p>\n<p>很明显IoC容器中的Cytus以Game中的Cytus并不是一个实例，其他都是同一个单例。仔细看看第4行和第12行的<strong><em>Config instance</em></strong>和<strong><em>BeanManager instance</em></strong>的输出内容就会得到答案。</p>\n<p>BeanManager是一个常规的类，而在JVM中运行的Config是一个通过CGLIB实现的字节码级别的代理类（<em>如果不知道CGLIB是什么就自己网上找找吧，这玩意在Java界已经红得发紫了</em>）。Spring实际上是使用CGLIB为Config类添加了一个“代理壳”，当我们在任何地方直接调用@Configuration标注的类中的的方法时，代理壳都会将其整理为一个<a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/config/BeanDefinition.html" rel="nofollow">BeanDefinition</a>的转换过程。</p>\n<p>知道两者的差异后我们选择何种方式来添加Bean就很清晰了：</p>\n<p>使用@Configuration能保证不会出现例子中Cytus这样的例外。也能清晰的明确@Configuration等价于一个&lt;beans&gt;统一管理。</p>\n<p>而在@Component或其他组建中使用@Bean好处是不会启动CGLIB这种重量级工具（不过在Spring中即使这里不使用，其他很多地方也在使用）。并且@Component及其相关的Stereotype组件自身就有摸框级别的功能，在这里使用@Bean注解能很好的表明一个Bean的从属和结构关系，但是需要注意直接调用方法的“副作用”。</p>\n<p>个人建议如果没什么特别的要求就使用@Configuration，引入CGLIB并不会影响多少性能，然而坑会少很多。在spring官网将用@Configuration创建的@Bean称呼为"Full"模式、将@Component创建的@Bean称呼为"\'lite"模式，从字面上也能略知他们的差异。</p>\n\n<h2 id="h2-4">多种方式混合使用</h2>\n<p>从XML配置到纯Java配置，Spring变得越来越简便好用，对应的功能也越来越多样化。如果对他的脉络没有清晰的认识，往往会陷入迷惑中。无论功能再复杂我们都要记住本系列文章开篇提到的IoC容器的初衷：</p>\n<p><strong><em>处理容器与Bean、Bean与Bean的关系。Bean是最小的工作单元，一切功能都是在Bean基础上扩展而来的。</em></strong></p>\n<p>所以无论是XML配置还是纯Java配置基本目标就是解决三个问题：向容器添加Bean，确定Bean的功能，确定Bean与Bean之间的依赖关系。</p>\n<p>既然XML和纯Java配置都是解决同样的问题，那么混合使用当然没问题。比如在XML中配置了&lt;context:component-scan/&gt;，那么指定路径下的@Component以及派生注解（@Service、@Comfiguration等）都会被扫描并添加到容器中成为一个Bean。然后IoC容器会根据注解的类型来确定这个Bean是什么功能。、</p>\n<p>下面是一个使用AnnotationConfigApplicationContext启动容器混合使用Java配置与XML配置的例子（源码在本人<a href="https://gitee.com/chkui-com/spring-core-sample" rel="nofollow">gitee的spring-core-sample</a>仓库中，本节的代码在包<em>chkui.springcore.example.javabase.multiconfiguration</em>中）。</p>\n<p>首先我们使用AnnotationConfigApplicationContext启动IoC容器：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.multiconfiguration;\n\n<span class="code-meta">@Configuration</span>\n<span class="code-meta">@ComponentScans</span>({ <span class="code-meta">@ComponentScan</span>(<span class="code-string">"chkui.springcore.example.javabase.multiconfiguration.config"</span>),\n\t\t<span class="code-meta">@ComponentScan</span>(<span class="code-string">"chkui.springcore.example.javabase.multiconfiguration.service"</span>) })\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MultiConfigurationApp</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(MultiConfigurationApp.class);\n\t}\n}</code></pre>\n<p>在Main方法中直接指定了当前的类，所以MultiConfigurationApp类会成为一个Bean。由于是一个Stereotype模式的@Configuration标记类（@Configuration继承自@Component，提供了配置相关的分层功能，关于Stereotype模式的内容相见<a href="https://www.chkui.com/article/spring/spring_core_stereotype_component_and_bean_scan" rel="nofollow">Stereotype组件与Bean扫描</a>），所以容器会用CGLIB来代理它实现配置相关的功能。@ComponentScans是一个辅助注解，他的作用就是整合多个@ComponentScan一起使用。</p>\n<p>在config包中有2个@Configuration类：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.multiconfiguration.config;\n\n<span class="code-meta">@Configuration</span>\n<span class="code-meta">@Import</span>({ClubConfiguration.class})\n<span class="code-meta">@ImportResource</span>(<span class="code-string">"javabase/multiconfiguration/config.xml"</span>)\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MainConfiguration</span> </span>{}</code></pre>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.multiconfiguration.config;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">ClubConfiguration</span> </span>{\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> Mil <span class="code-title">mil</span><span class="hljs-params">()</span> </span>{<span class="code-keyword">return</span> <span class="code-keyword">new</span> Mil();}\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> Mau <span class="code-title">mau</span><span class="hljs-params">()</span> </span>{<span class="code-keyword">return</span> <span class="code-keyword">new</span> Mau();}\n}</code></pre>\n<p>MainConfiguration类被标记了@Configuration注解，所以他会被扫描并添加到容器中。</p>\n<p>@Import注解的作用是引入其他类成为一个Bean，我们可以看到ClubConfiguration类并没有任何注解，但是他通过@Import注解在其他类添加到容器中。</p>\n<p>而@ImportResource等价于XML配置中的&lt;import&gt;标签，作用就是引入一个XML配置文件。对应的XML文件如下：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span> <span class="hljs-attr">...</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span class="code-string">"chkui.springcore.example.javabase.multiconfiguration.bean.Cfc"</span> /&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span class="code-string">"chkui.springcore.example.javabase.multiconfiguration.bean.Jav"</span> /&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>这样XML配置中的2个类也会被添加到容器中。案例中对应的实体类如下：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.multiconfiguration.bean;\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">Mau</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">toString</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"Manchester United[MAU]"</span>;\n\t}\n}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">Cfc</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">toString</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"Chelsea Football Club[CFC]"</span>;\n\t}\n}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">Mil</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">toString</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"A.C Milan [MIL]"</span>;\n\t}\n}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">Jav</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">toString</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"Juventus [JAV]"</span>;\n\t}\n}</code></pre>\n\n<h2 id="h2-5">Conditionally</h2>\n<p>最后在使用@Configuration时可以使用Conditionally特性来确定是否添加Bean。大致用法就是实现Condition接口，然后通过@Conditional注解和@Bean绑定在一起进行条件判断。</p>\n<p>实现Condition：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.multiconfiguration.config;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">SoySauceCondition</span> <span class="code-keyword">implements</span> <span class="code-title">Condition</span> </span>{\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">boolean</span> <span class="code-title">matches</span><span class="hljs-params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">false</span>; <span class="code-comment">//返回false则不会对应的Bean。</span>\n\t}\n}</code></pre>\n<p>然后使用@Conditional注解绑定到一个@Bean上：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.multiconfiguration.config;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">ClubConfiguration</span> </span>{\n\t<span class="code-meta">@Bean</span>\n\t<span class="code-meta">@Conditional</span>(SoySauceCondition.class)\n\t<span class="hljs-function"><span class="code-keyword">public</span> SoySauce <span class="code-title">soySauce</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> SoySauce();\n\t}\n}</code></pre>\n<p>这样，如果SoySauceCondition中的matches方法返回ture则添加SoySauce到IoC容器中，否则不会存在这个Bean。</p>'},392:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h2 id="h2-1">Resource——资源</h2>\n<p>对于一个联机事务型系统（业务系统）来说，所依赖的外部运行信息主要有2个来源：<strong>数据项</strong>和<strong>资源项</strong>。数据项的存放位置通常是使用各种关系性或NoSql数据库，而资源项通常是使用文件、网络信息的方式来存储。\n</p>\n<p>早在JDK1.0的时代Java就已经提供了本地资源和网络资源的读取功能——<strong>java.net.URL</strong>。他可以同时管理本地资源（操作系统资源）以及网络资源，如下面这个例子：</p>\n<p>（文中的代码仅仅用于说明问题，源码请到<a href="https://gitee.com/chkui-com/spring-core-sample" rel="nofollow">案例gitee库下载</a>，对应的代码在包<em>chkui.springcore.example.hybrid.resource</em>中。）\n</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n\t\tclass="code-title">ResourceApp</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n\t\t\tclass="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> <span\n\t\t\tclass="code-keyword">throws</span> MalformedURLException </span>{\n\t\t<span class="code-comment">//读取本地资源</span>\n\t\tURL url = ResourceApp.class.getResource(<span class="code-string">"/extend.properties"</span>);\n\t\tprint(url);\n\t\t<span class="code-comment">//读取互联网资源</span>\n\t\turl = <span class="code-keyword">new</span> URL(<span class="code-string">"http"</span>, <span\n\t\t\tclass="code-string">"www.baidu.com"</span>, <span class="hljs-number">80</span>, <span class="code-string">""</span>);\n\t\tprint(url);\n\t\turl = <span class="code-keyword">new</span> URL(<span class="code-string">"https"</span>, <span\n\t\t\tclass="code-string">"www.chkui.com"</span>, <span class="hljs-number">443</span>, <span class="code-string">"/174870bb04.js"</span>);\n\t\tprint(url);\n\t}\n}\n<span class="code-comment">// 输出</span>\n<span class="code-comment">// file:/work/chkui/spring-core-sample/bin/main/extend.properties</span>\n<span class="code-comment">// http://www.baidu.com:80</span>\n<span class="code-comment">// https://www.chkui.com:443/174870bb04.js</span></code></pre>\n<p>\n\t对于每一个类来说getResource方法可以获取当前类所在的系统路径（getResource("")），以及classpath的路径（getResource("/")），利用这个功能我们可以获取操作系统上所知的任何资源。除了本地文件，URL也可以通过域名规则来获取网络上的资源。</p>\n<p>注意输出内容中的开头<strong><em>file:</em></strong> 、<strong><em>http:</em></strong>以及<strong><em>https:</em></strong>，他们表示资源的协议，除了以上这三者，还有<strong><em>ftp:、mailto:</em></strong>等协议。关于URL的详细解释可以看<a\n\t\thref="http://www.ietf.org/rfc/rfc2396.txt" rel="nofollow">ITEF标准</a>。</p>\n<p>URL指向某一个资源之后，可以使用URL::openStream或URL::getFile等方法进一步获取文件中的内容：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n\t\tclass="code-title">ResourceApp</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n\t\t\tclass="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> <span\n\t\t\tclass="code-keyword">throws</span> MalformedURLException </span>{\n\t\tUrl url = <span class="code-keyword">new</span> URL(<span class="code-string">"https"</span>, <span\n\t\t\tclass="code-string">"www.chkui.com"</span>, <span class="hljs-number">443</span>, <span class="code-string">"/174870bb04.js"</span>);\n\t\t<span class="code-keyword">try</span>(InputStream is = url.openStream()){\n\t\t\t<span class="code-keyword">byte</span>[] buffer = <span class="code-keyword">new</span> <span\n\t\t\tclass="code-keyword">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>];\n\t\t\tis.read(buffer);\n\t\t\tString content = <span class="code-keyword">new</span> String(buffer, Charset.forName(<span\n\t\t\tclass="code-string">"UTF-8"</span>));\n\t\t\tprint(<span class="code-string">"Content :"</span>, content);\n\t\t} <span class="code-keyword">catch</span> (IOException e) {\n\t\t}\n\t}\n}</code></pre>\n\n<h2 id="h2-2">Spring中的资源管理</h2>\n<p>Spring的资源管理在JDK的基础功能上进行了强大的扩展，即使你不用Spring的整个生态或者容器，你也可以将其资源管理作为一个工具整合到自己的系统中而提高效率。它扩展了以下内容：</p>\n<ol>\n\t<li>\n\t\t隐藏底层实现。对于各种各样的资源Spring都使用了不同的实现类来管理，但是他利用适配器模式让使用者仅仅需要了解<strong><em>org.springframework.core.io.Resource</em></strong>接口即可。\n\t</li>\n\t<li>新增资源存在判断、资源操作权限相关的功能，相对于<em>java.net.URL</em>资源不存在则设置为null更友好。</li>\n\t<li>支持通配符来获取资源，例如 ：<em>classpath:a/b/**/applicationContext-*.xml。</em></li>\n</ol>\n\n<h2 id="h2-3">协议与路径</h2>\n<p>在前面的内容中就提到了多个协议，spring的资源管理功能除了标准的协议，还增加了一个——<strong><em>classpath:</em></strong>协议，他表示从当前的classpath根路径开始获取资源。对于Spring的资源管理功能而言，主要有以下几种协议：\n</p>\n<table border="1" cellpadding="1" cellspacing="1" style="width:500px">\n\t<tbody>\n\t<tr>\n\t\t<th>协议&nbsp;</th>\n\t\t<th>例子</th>\n\t\t<th>说明</th>\n\t</tr>\n\t</tbody>\n\t<tbody>\n\t<tr>\n\t\t<td>classpath:</td>\n\t\t<td>classpath:res/extend.properties</td>\n\t\t<td>从当前jvm的classpath根路径开始获取资源。</td>\n\t</tr>\n\t<tr>\n\t\t<td>file:</td>\n\t\t<td>file:///tmp/myfile.data</td>\n\t\t<td>从操作系统(文件路径)的路径获取资源。</td>\n\t</tr>\n\t<tr>\n\t\t<td>http(s):</td>\n\t\t<td>http(s)://www.chkui.com/</td>\n\t\t<td>从互联网获取资源。</td>\n\t</tr>\n\t<tr>\n\t\t<td>(无标记)</td>\n\t\t<td>/data/extend.data</td>\n\t\t<td>根据应用上下文获取资源。</td>\n\t</tr>\n\t</tbody>\n</table>\n<p><strong><em>classpath:</em></strong>、<strong><em>file:</em></strong>、<strong><em>http(s):</em></strong>这三个协议都很明确的指明了获取资源的路径，但是没有声明协议的情况就比较特殊，他需要根据上下文来判定适用的路径。\n</p>\n<p>在<a href="https://www.chkui.com/article/spring/spring_core_context_and_ioc" title="上下文与IoC">上下文与IoC</a>这篇文章中已经介绍过，经过层层继承和实现，Spring提供容器实现功能的主要是<strong><em>ClassPathXmlApplicationContext</em></strong>和<strong><em>FileSystemXmlApplicationContext</em></strong>两个类，这两个Context本质上都是实现了相同的Context功能，最明显的区别之一就是加载文件的路径不同。比如下面的情况：\n</p>\n<pre><code class="java">ApplicationContext ctx = <span\n\t\tclass="code-keyword">new</span> ClassPathXmlApplicationContext(<span class="code-string">"config/ctx.xml"</span>);</code></pre>\n<p>ClassPathXmlApplicationContext默认启用的是<em>ClassPathResource</em>来管理资源，所以上面的路径配置相当于"classpath:config/ctx.xml"。但是如果修改为以下形式：\n</p>\n<pre><code class="java">ApplicationContext ctx = <span\n\t\tclass="code-keyword">new</span> ClassPathXmlApplicationContext(<span class="code-string">"file:///config/ctx.xml"</span>);</code></pre>\n<p>通过协议明确告知路径规则，那么在<em>ApplicationContext</em>会使用对应的<em>FileSystemResource</em>来加载管理资源。</p>\n<p>而<strong><em>FileSystemXmlApplicationContext</em></strong>与<strong><em>ClassPathXmlApplicationContext</em></strong>相互对应——默认使用的<em>FileSystemResource</em>，可以通过声明协议来指定对应的资源加载类。\n</p>\n<p>上面的内容提到了<em>ClassPathResource和FileSystemResource。</em>Spring为不同类型、协议的资源指定了各种各种的<strong><em>org.springframework.core.io.Resource</em></strong>实现类，主要有&nbsp;<em>UrlResource、ClassPathResource、FileSystemResource、ServletContextResource、InputStreamResource、ByteArrayResource</em>。从字面上看大概能了解对应的功能。在使用的时候我们并不需要了解他们的具体实现，只要知道不同的协议对应的资源路径即可。\n</p>\n\n<h2 id="h2-4">获取资源的方法</h2>\n\n<h3 id="h3-1">直接使用ApplicationContext</h3>\n<p>\n\t在明确所支持的协议之后，我们就可以用ResourcePatternResolver::getResources方法来获取资源。ApplicationContext继承了ResourcePatternResolver接口，所以我们通常使用以下方法获取资源：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.resource;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n\t\t\tclass="code-title">ResourceApp</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n\t\t\tclass="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span></span>{\n\t\tApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(ResourceApp.class);\n\t\tResource res = ctx.getResource(<span class="code-string">"classpath:extend.properties"</span>);\n\t\tprint(<span class="code-string">"Resource :"</span>, res);\n\t\tres = ctx.getResource(<span class="code-string">"https://www.chkui.com"</span>);\n\t\tprint(<span class="code-string">"Resource :"</span>, res);\n\t}\n}</code></pre>\n\n<h3 id="h3-2">ResourceLoaderAware注入</h3>\n<p>除了直接使用ApplicationContext，还可以通过继承ResourceLoaderAware的方式来获取资源加载接口：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.resource;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n\t\t\tclass="code-title">LoadResourceBean</span> <span class="code-keyword">implements</span> <span\n\t\t\tclass="code-title">ResourceLoaderAware</span></span>{\n\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n\t\t\tclass="code-title">setResourceLoader</span><span class="hljs-params">(ResourceLoader resourceLoader)</span> </span>{\n\t\tResource res = resourceLoader.getResource(<span class="code-string">"classpath:extend.properties"</span>);\n\t\tSystem.out.println(<span class="code-string">"Bean load Resource :"</span> + res);\n\t}\n}\n</code></pre>\n<p>\n\t实际上这里传入进来的ResourceLoader就是ApplicationContext，所以用ApplicationContextAware也可以实现对应的功能。但是为了明确功能的用途，这里最好还是实现ResourceLoaderAware比较合理。</p>\n\n<h3 id="h3-3">Autowired注入</h3>\n<p>在2.5.x之后，spring可以使用<a href="https://www.chkui.com/article/spring/spring_core_auto_inject_of_annotation"\n\t\t\t\t\t\t title="注解自动装载">@Autowired注解</a>引入ResourceLoader（ApplicationContext）：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.resource;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n\t\t\tclass="code-title">LoadResourceBean</span> <span class="code-keyword">implements</span> <span\n\t\t\tclass="code-title">ResourceLoaderAware</span></span>{\n\t<span class="code-meta">@Autowired</span>\n\tResourceLoader resourceLoader;\n\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n\t\t\tclass="code-title">setResourceLoader</span><span class="hljs-params">(ResourceLoader resourceLoader)</span> </span>{\n\t\tSystem.out.println(<span class="code-string">"Is ApplicationContext? "</span> + (<span\n\t\t\tclass="code-keyword">this</span>.resourceLoader == resourceLoader));\n\t\tResource res = <span class="code-keyword">this</span>.resourceLoader.getResource(<span class="code-string">"classpath:extend.properties"</span>);\n\t\tSystem.out.println(<span class="code-string">"Bean load Resource :"</span> + res);\n\t}\n}</code></pre>\n<p>和普通的Bean一样，还可以通过构造方法和setter方法注入ResourceLoader。</p>\n\n<h3 id="h3-4">XML配置获取资源</h3>\n<p>我们可以直接在XML中指定资源路径，然后在setter或构造方法中获取到对应的资源，看下面的例子。</p>\n<p>XMLConfigBean的Set方法直接获取一个<em>Resource</em>：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.resource;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n\t\t\tclass="code-title">XMLConfigBean</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n\t\t\tclass="code-title">setResource</span><span class="hljs-params">(Resource res)</span> <span\n\t\t\tclass="code-keyword">throws</span> IOException </span>{\n\t\tSystem.out.println(<span class="code-string">"XML load Resource :"</span> + res);\n\t\tProperties p = <span class="code-keyword">new</span> Properties();\n\t\tp.load(res.getInputStream());\n\t\tSystem.out.println(<span class="code-string">"Properties Info: "</span> + p.getProperty(<span\n\t\t\tclass="code-string">"info"</span>));\n\t}\n}</code></pre>\n<p>我们只需要在XML配置文件中指定资源路径位置，Spring会自动帮我们完成转换：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span>&gt;</span>\n\t<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n\t\t\tclass="code-string">"chkui.springcore.example.hybrid.resource.XMLConfigBean"</span>&gt;</span>\n\t\t<span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n\t\t\t\tclass="code-string">"resource"</span> <span class="hljs-attr">value</span>=<span class="code-string">"classpath:extend.properties"</span>/&gt;</span>\n\t<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>在XMLConfigBean::setResource方法中我们拿到的是"classpath:extend.properties"这一项资源。</p>\n\n<h2 id="h2-5">通配符指定资源</h2>\n<p>除了使用指定固定路径的方式获取一项资源，我们还可以使用"?"、"*"等通配符使用匹配规则来获取资源，例如：</p>\n<pre><code class="java">Resource[] resList = ctx.getResources(<span\n\t\tclass="code-string">"classpath:hybrid/**/*.xml"</span>);</code></pre>\n<p>Spring官网将这种资源匹配规则称为“Ant-style匹配”，虽然并不知道源自什么地方（应该是源自<em>Apache Ant</em>项目，但是我在Ant项目文档中还没看到对应的说明，心细致的码友可以再找找），但是Spring官方文档对其有详细的说明，详见<a\n\t\thref="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/util/AntPathMatcher.html"\n\t\trel="nofollow">AntPathMatcher的说明</a>。Ant-style的匹配规则大致如下：</p>\n<ol>\n\t<li>"?"：匹配一个字符。例如<em>"classpath:conf?g.xml"</em>匹配<em>"classpath:config.xml"</em>也匹配<em>"classpath:conf1g.xml"</em>但是不匹配<em>"classpath:conf12g.xml"</em>。\n\t</li>\n\t<li>"*"：匹配0到多个字符。例如<em>"classpath:*.xml"匹配classpath根目录下所有.xml文件。而"classpath:config/*.xml"匹配config文件夹中所有.xml文件。</em>\n\t</li>\n\t<li><em>"**"：匹配0到多个目录。例如"classpath:**/*.xml"匹配整个classpath下所有*.xml文件。"</em><em>classpath:config/**/*.xml"匹配config文件夹以及所有子文件夹的.xml文件。</em>\n\t</li>\n\t<li>{arg1:{a-z}+}：匹配任意多个a-z的字符，并将匹配到的内容赋值到变了arg1中。该条规则实用于<a\n\t\t\thref="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/util/AntPathMatcher.html"\n\t\t\trel="nofollow">AntPathMatcher</a>，当无法在ApplicationContext的资源匹配规则中使用。\n\t</li>\n</ol>\n\n<h3 id="h3-5">classpath*:扩展</h3>\n<p>在通配符的基础上，spring扩展了一个<strong><em>classpath*:</em></strong>协议。</p>\n<p>\n\t对于一个运行的Jvm来说，classpath的“根目录”一般有多个。比如在当前开发的工程有一个包含main方法的类文件——chkui/example/spinrg/app.class，此时引入一个jar包也包含一个一样的类文件chkui/example/spring/app.class（有空的码友可以自己试试Jvm到底运行哪个）。这种情况对于Jvm来说就引出"多个classpath"和"首选classpath"的概念，而classpath:和classpath*的差异就是，前者从首选classpath中优先获取资源，而后者会从所有classpath中寻找资源。而首先classpath一般是我们当前工程的编译文件（案例代码在<em>[project-root]/bin/main</em>）。\n</p>\n<p>其实在Jvm的资源加载方式上已经对<em><strong>classpath:</strong></em>和<strong><em>classpath*:</em></strong>提供了不同的实现，但是理解起来比较“绕”。一般情况下我们使用Class::getResource都是获取首选classpath路径下的资源，而使用ClassLoader::getResources(classPath)可以获取所有classpath下的资源。\n</p>\n<p>下面的代码展示了这个过程，案例代码在<a\n\t\thref="https://gitee.com/chkui-com/spring-core-sample/blob/master/src/main/java/chkui/springcore/example/hybrid/resource/ResourceApp.java"\n\t\trel="nofollow">chkui.springcore.example.hybrid.resource.ResourceApp::multiResourceLoad</a>方法中。</p>\n<p>为了演示这个过程我们引入了Google的Guava包（因为整个工程都没用到guava的内容，所以修改他的类不会产生影响），然后对应的在自己的工程中增加一个Guava包中相同的package和类：</p>\n<pre><code class="java"><span class="code-keyword">package</span> com.google.common.base;\n<span class="code-keyword">public</span> <span class="code-keyword">final</span> <span class="hljs-class"><span\n\t\t\tclass="code-keyword">class</span> <span class="code-title">Preconditions</span> </span>{}</code></pre>\n<p>在编译之后，会在bin文件夹（如果是maven就是/target）中产生一个main/com/google/common/base/Preconditions.class文件。然后通过下面的代码测试资源加载：</p>\n<pre><code class="java"><span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n\t\tclass="code-keyword">void</span> <span class="code-title">multiResourceLoad</span><span\n\t\tclass="hljs-params">()</span> <span class="code-keyword">throws</span> IOException </span>{\n\t\t<span class="code-keyword">final</span> String classPath = <span class="code-string">"com/google/common/base/Preconditions.class"</span>;\n\n\t\t<span class="code-comment">//class.getResource需要使用"/"表示root路径</span>\n        <span class="code-comment">//首选路径的资源</span>\n\t\tprint(<span class="code-string">"classpath: "</span>, ResourceApp.class.getResource(<span class="code-string">"/"</span> + classPath));\n\t\t<span class="code-comment">//Verify没有被覆盖，输出Jar包中的内容,注意jar:file: 协议的格式</span>\n\t\tprint(<span class="code-string">"In Jar classpath: "</span>, ResourceApp.class.getResource(<span\n\t\t\tclass="code-string">"/"</span> + unMultiClassPath));\n\n\t\t<span class="code-comment">//ClassLoader::getResource获取首选路径资源</span>\n\t\tprint(<span class="code-string">"First classpath: "</span>, Verify.class.getClassLoader().getResource(classPath));\n\t\t<span class="code-comment">//ClassLoader::getResources获取所有资源</span>\n\t\tEnumeration&lt;URL&gt; e = ResourceApp.class.getClassLoader().getResources(classPath);\n\t\t<span class="code-keyword">int</span> count = <span class="hljs-number">1</span>;\n\t\t<span class="code-keyword">while</span> (e.hasMoreElements()) {\n\t\t\tURL url = e.nextElement();\n\t\t\tprint(<span class="code-string">"classpath*["</span>, count++ ,<span class="code-string">"]:"</span>, url);\n\t\t}\n\t}</code></pre>\n<p>\n\t运行之后，只有在最后的迭代器中输出了Guava包中的Preconditions.class的路径，而其余位置都输出的是我自行创建的Preconditions.class，也就是首选classpath下的Preconditions.class，首选的资源也就是ClassLoader::getResources获取的迭代器的第一个值。</p>\n<p>Spring的<strong><em>classpath*:</em></strong>协议实际上底层也是用<em>ClassLoader::getResources</em>的方式实现的，不过扩展了支持通配符并将资源转换为org.springframework.core.io.Resource。上面用JDK演示的代码用spring的资源管理实现为下面的形式：\n</p>\n<pre><code class="java"><span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n\t\tclass="code-keyword">void</span> <span class="code-title">multiResourceLoad</span><span class="hljs-params">(ApplicationContext ctx)</span></span>{\n    ApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext();\n    <span class="code-keyword">final</span> String classPath = <span class="code-string">"com/google/common/base/Preconditions.class"</span>;\n    <span class="code-keyword">final</span> String unMultiClassPath = <span class="code-string">"com/google/common/base/Verify.class"</span>;\n    print(<span class="code-string">"classpath: "</span>, Arrays.asList(ctx.getResources(<span class="code-string">"classpath:"</span> + classPath)));\n    print(<span class="code-string">"classpath*: "</span>, Arrays.asList(ctx.getResources(<span class="code-string">"classpath*:"</span> + classPath)));\n    print(<span class="code-string">"unmulti-classpath*: "</span>, Arrays.asList(ctx.getResources(<span\n\t\t\tclass="code-string">"classpath*:"</span> + unMultiClassPath)));\n}</code></pre>\n\n<h2 id="h2-6">Spring中的各项资源</h2>\n<p>\n\t不仅仅是ApplicationContext::getResources方法，实际上Spring中绝大部分外部资源加载都是通过前面介绍的规则使用同一个工具类完成的，所以我们可以在许多地方使用对应的"协议"来管理我们的资源，比如下面的例子：</p>\n<pre><code class="java"><span class="code-meta">@ImportResource</span>(<span class="code-string">"classpath:hybrid/resource/config-*.xml"</span>)\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n\t\t\tclass="code-title">ResourceApp</span> </span>{}</code></pre>'}});