webpackJsonp([18],{358:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h2 id="h2-1">React</h2>\n<p>本文记录了本人以及目前团队从无到有使用React的过程，我们将从webpack开始说起，一步一步展现React最基本的开发生态。在这里并不会介绍任何jsx或es6相关的语法，只聚焦于如何使用react生态搭建利于团队协作、有利于提升开发效率的开发环境。</p>\n\n<h2 id="h2-2">脚手架工具——webpack&nbsp;</h2>\n<p>工欲善必须利其器，想要高效的开发react，必须保证有一个高效有序的开发环境。我们使用的是Facebook开源的脚手架工具——webpack来搭建一个完全不依赖服务器的开发环境。实现高效集成、实时编辑可见、动态编译jsx和es6等强悍功能。</p>\n\n<h3 id="h3-1">添加webpack</h3>\n<p>webpack最早是Facebook的instagram团队研发出的脚手架工具，用于支持前端系统的开发。虽然webpack一直都和react嵌套在一起使用，但是他的使用场景并不局限于react，你可以把他应用于所有的前端开发场景。</p>\n<p>webpack也是依赖nodejs和npm的，在安装webpack之前务必先安装nodejs的环境，如果在此之前你还没有安装nodejs的环境，可以看这篇<a title="nodejs安装介绍" href="http://www.chkui.com/article/nodeJs/install_nodejs_runtime_environment">关于nodejs安装</a>的文章获得一些参考。</p>\n<p>可以像下面这样安装一个全局的webpack环境。</p>\n<pre class=""><code class=""><span class="code-variable"><span class="code-variable">$ </span></span>npm install webpack -g</code></pre>\n<p>或者以依赖工程的方式安装</p>\n<pre class=""><code class=""><span class="code-comment"><span class="code-comment"># 进入项目目录</span></span>\n<span class="code-comment"><span class="code-comment"># 确定已经有 package.json，没有就通过 npm init 创建</span></span>\n<span class="code-comment"><span class="code-comment"># 安装 webpack 依赖</span></span>\n<span class="code-variable"><span class="code-variable">$ </span></span>npm install webpack --save-dev</code></pre>\n\n<h3 id="h3-2">测试运行webpack</h3>\n<p>（本例子的代码存放在：<a title="React搭建开发环境示例代码" href="https://github.com/chkui/webpack-demo" rel="nofollow">https://github.com/chkui/webpack-demo</a>。下载后用 npm install 下载npm依赖即可使用。）</p>\n<p>Setp1:简单打包</p>\n<p>首先我们增加一些用于测试元素。先写一个index.html</p>\n<pre class="xml"><code class="language-html xml"><span class="code-meta"><span class="code-meta">&lt;!DOCTYPE html&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span class="code-name">html</span></span></span><span class="code-tag"> </span><span class="hljs-attr"><span class="code-tag"><span class="hljs-attr">lang</span></span></span><span class="code-tag">=</span><span class="code-string"><span class="code-tag"><span class="code-string">"en"</span></span></span><span class="code-tag">&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span class="code-name">head</span></span></span><span class="code-tag">&gt;</span></span>\n    <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span class="code-name">meta</span></span></span><span class="code-tag"> </span><span class="hljs-attr"><span class="code-tag"><span class="hljs-attr">charset</span></span></span><span class="code-tag">=</span><span class="code-string"><span class="code-tag"><span class="code-string">"UTF-8"</span></span></span><span class="code-tag">&gt;</span></span>\n    <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span class="code-name">title</span></span></span><span class="code-tag">&gt;</span></span>Title<span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span class="code-name">title</span></span></span><span class="code-tag">&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span class="code-name">head</span></span></span><span class="code-tag">&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span class="code-name">body</span></span></span><span class="code-tag">&gt;</span></span>\n    <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span class="code-name">script</span></span></span><span class="code-tag"> </span><span class="hljs-attr"><span class="code-tag"><span class="hljs-attr">src</span></span></span><span class="code-tag">=</span><span class="code-string"><span class="code-tag"><span class="code-string">"bundle.js"</span></span></span><span class="code-tag">&gt;</span></span><span class="undefined"></span><span class="code-tag"><span class="undefined"></span><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span class="code-name">script</span></span></span><span class="code-tag">&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span class="code-name">body</span></span></span><span class="code-tag">&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span class="code-name">html</span></span></span><span class="code-tag">&gt;</span></span></code></pre>\n<p>然后添加一个entry.js</p>\n<pre class="javascript"><code class="language-javascript"><span class="code-comment"><span class="code-comment">/**\n * Created by chkui on 2016/11/16.\n */</span></span>\n<span class="code-built_in"><span class="code-built_in">require</span></span>(<span class="code-string"><span class="code-string">"!style!css!./style.css"</span></span>);\n<span class="code-built_in"><span class="code-built_in">document</span></span>.write(<span class="code-string"><span class="code-string">\'&lt;h1&gt;hello webpack&lt;/h1&gt;\'</span></span>);</code></pre>\n<p>然后就可以执行打包命令了：</p>\n<pre class=""><code class="language-bash"><span class="code-variable">$ </span>webpack ./entry.js bundle.js</code></pre>\n<p>运行以后，就会发现在目录中生成了一个bundle.js文件。浏览器中打开index.html就会看到执行效果。</p>\n<p>Step2:利用webpack分析工具打包&nbsp;</p>\n<p>增加一个名为module.js的文件：</p>\n<pre class="javascript"><code class="language-javascript"><span class="code-comment"><span class="code-comment">/**\n * Created by chkui on 2016/11/16.\n */</span></span>\n<span class="code-built_in"><span class="code-built_in">module</span></span>.exports = <span class="code-string"><span class="code-string">\'It works from module.js.\'</span></span></code></pre>\n<p>在原来的entry.js增加引用：</p>\n<pre class="javascript"><code class="language-javascript"><span class="code-comment"><span class="code-comment">/**\n * Created by chkui on 2016/11/16.\n */</span></span>\n<span class="code-built_in"><span class="code-built_in">require</span></span>(<span class="code-string"><span class="code-string">"!style!css!./style.css"</span></span>);\n<span class="code-built_in"><span class="code-built_in">document</span></span>.write(<span class="code-string"><span class="code-string">\'&lt;h1&gt;hello webpack&lt;/h1&gt;\'</span></span>);\n<span class="code-comment"><span class="code-comment">//新增对module.js的引用</span></span>\n<span class="code-built_in"><span class="code-built_in">document</span></span>.write(<span class="code-built_in"><span class="code-built_in">require</span></span>(<span class="code-string"><span class="code-string">\'./module.js\'</span></span>));</code></pre>\n<p>然后同样执行webpack打包命令：</p>\n<pre class=""><code class="language-bash"><span class="code-variable">$ </span>webpack ./entry.js bundle.js</code></pre>\n<p>然后在打开index.html，会发现我们新增加的module.js的内容被正确输出。这是因为我们在页面中通过nodejs的require的方式引入的module.js，而使用webpack打包时会自动在依赖关系中引入module.js。</p>\n\n<h3 id="h3-3">加载器</h3>\n<p>webpack提供了一个非常强大的loader功能，这个功能可以用于管理各种依赖关系模块，在webpack中所有的文件都视作一个模块。</p>\n<p>首先npm导入webpack loader：</p>\n<pre class="sql"><code class="language-bash">npm <span class="code-keyword">install</span> css-loader <span class="code-keyword">style</span>-loader</code></pre>\n<p>添加一个用于测试的style.css文件：</p>\n<pre class="css"><code class="language-css"><span class="code-selector-tag"><span class="code-selector-tag">h1</span></span>{\n    <span class="code-attribute"><span class="code-attribute">color</span></span>:red;\n}</code></pre>\n<p>在entry.js中添加引用：</p>\n<pre class="javascript"><code class="language-javascript"><span class="code-comment"><span class="code-comment">/**\n * Created by chkui on 2016/11/16.\n */</span></span>\n<span class="code-built_in"><span class="code-built_in">require</span></span>(<span class="code-string"><span class="code-string">"!style!css!./style.css"</span></span>);<span class="code-comment"><span class="code-comment">//添加对css的引用</span></span>\n<span class="code-built_in"><span class="code-built_in">document</span></span>.write(<span class="code-string"><span class="code-string">\'&lt;h1&gt;hello webpack&lt;/h1&gt;\'</span></span>);\n<span class="code-built_in"><span class="code-built_in">document</span></span>.write(<span class="code-built_in"><span class="code-built_in">require</span></span>(<span class="code-string"><span class="code-string">\'./module.js\'</span></span>));</code></pre>\n<p>使用命令行打包：</p>\n<pre class=""><code class="language-bash">webpack ./entry.js bundle.js --<span class="code-keyword">module</span>-bind <span class="code-string"><span class="code-string">\'css=style!css\'</span></span></code></pre>\n<p>会发现css的样式生效了。可以将繁琐的“!style!css!./style.css”简写成"./style.css"。</p>\n\n<h3 id="h3-4">使用配置管理</h3>\n<p>细心的人会发现，我们每次使用命令行打包都带了大量的参数，这样不仅繁琐更不利于规模化使用。webpack同样可以使用标准化配置文件来替代命令行中的各种参数。</p>\n<p>webpack的配置文件是nodejs的文件，通常命名为&nbsp;<code>webpack.config.js</code>。我们在工程中增加配置文件：</p>\n<pre class="typescript"><code class="language-javascript"><span class="code-comment"><span class="code-comment">/**\n * Created by chkui on 2016/11/16.\n */</span></span>\n<span class="code-built_in"><span class="code-built_in">module</span></span>.exports = {\n    entry: <span class="code-string"><span class="code-string">\'./entry.js\'</span></span>,<span class="code-comment"><span class="code-comment">//定义要引入的js文件</span></span>\n    output: {\n        path: __dirname,\n        filename: <span class="code-string"><span class="code-string">\'bundle.js\'</span></span> <span class="code-comment"><span class="code-comment">//定义要输出的js文件</span></span>\n    },\n    <span class="code-built_in"><span class="code-keyword">module</span></span>: {\n        loaders: [<span class="code-comment"><span class="code-comment">//定义加载内容</span></span>\n            {test: <span class="hljs-regexp"><span class="hljs-regexp">/\\.css$/</span></span>, loader: <span class="code-string"><span class="code-string">\'style!css\'</span></span>}\n        ]\n    }\n}</code></pre>\n<p>现在，我们在命令行中输入webpack就可以实现和前面一样的打包。</p>\n\n<h3 id="h3-5">丰富打包输出内容</h3>\n<p>可以使用：</p>\n<pre class="lua"><code class="lua">webpack <span class="code-comment"><span class="code-comment">--progress --colors</span></span></code></pre>\n<p>命令来丰富打包输出的内容，更容易了解出现的问题。</p>\n\n<h3 id="h3-6">监听更新模式</h3>\n<p>在我们进行编码开发的时候，每次对文件的编辑我们都想立即看到编译效果，如果每次编辑都要去打包，会非常麻烦。webpack提供了一个监听模式（类似grunt的watch），用于监听每次对文件的修改，修改后会立即进行增量更新。启用监听模式：</p>\n<pre class="lua"><code class="lua">webpack <span class="code-comment"><span class="code-comment">--progress --colors --watch</span></span></code></pre>\n<p>监听模式使用的是内存增量更新。webpack会将所有需要打包的文件copy到内存，然后监控文件修改，如果文件发生了修改，会将修改的文件替换内存中的对应文件。因此开发完之后，切记进行一次手动打包才能生效。</p>\n\n<h3 id="h3-7">开发环境模式</h3>\n<p>webpack更强大的是，他整合了nodejs的express提供了一个静态服务器。（虽然没有官方正式，我觉得webstrom和微信本地开发环境都是整合的nodejs的express）</p>\n<p>使用了开发环境模式，我们所有的动态修改和操作都可以实时看到效果，并且解决了静态资源各种路径引用的问题。首先npm安装工具：</p>\n<pre class="sql"><code class="language-bash">npm <span class="code-keyword">install</span> webpack-dev-<span class="code-keyword">server</span> -g</code></pre>\n<p>然后使用命令行工具启用开发环境：</p>\n<pre class="lua"><code class="language-bash">webpack-dev-server <span class="code-comment">--progress --colors</span></code></pre>\n<p>webpack的开发环境模式很强悍，比使用--watch更犀利的地方在于可以实现编辑即可见。浏览器立即同步刷新运行。开发环境模式可以延伸到生产环境实现代码同步级别的热部署。&nbsp;</p>\n\n<h4 id="h4-1">开发环境扩展——Linux下文件变化监控个数配置</h4>\n<p>webpack在linux下监控文件的变化用到了 Inotify机制。有可能在文件比较多的时候修改、编辑文件无法触发webpack热部署。我们可以通过一下方式检测并调整监控文件个数：</p>\n<pre class="tcl"><code class="language-bash"><span class="code-comment"><span class="code-comment">#检查inotify监控文件的个数</span></span>\ncat /<span class="code-keyword">proc</span>/sys/fs/inotify/max_user_watches</code></pre>\n<p>然后可以</p>\n<pre class="bash"><code class="language-bash"><span class="code-comment"><span class="code-comment">#将同时监控的文件个数修改为18000</span></span>\n<span class="code-built_in"><span class="code-built_in">echo</span></span> fs.inotify.max_user_watches=18000 | sudo tee <span class="hljs-_"><span class="hljs-_">-a</span></span> /etc/sysctl.conf &amp;&amp; sudo sysctl -p\n</code></pre>\n<p>再次查看个数可以看到输出已经配置的参数</p>\n\n<h4 id="h4-2">开发环境扩展——webstorm的坑</h4>\n<p>由于本人的前端页面使用webstorm开发，在使用过程中发现了一个webstorm的坑。webstorm有文件缓存的功能，在编辑完毕保存之后并不会实时的更新磁盘文件，这样的就导致webpack的开发环境无法同步更新文件。以下是解决方法：</p>\n<p>1.File-&gt;settings-&gt;System Settings</p>\n<p>2.找到弹出框的Use "safe write"，将其勾选解除。</p>\n<p><img alt="React 搭建开发环境" height="507" src="https://file.mahoooo.com/res/file/react_establish_development_environment_1.png" width="1020"></p>\n\n<h3 id="h3-8">输出调试信息</h3>\n<p>webpack的配置较为复杂，一不小心就会出现错误。它提供了一个输出调试信息的参数：</p>\n<pre class="lua"><code class="language-bash">$ webpack <span class="code-comment">--display-error-details</span></code></pre>\n<p>调试运行webpack命令出错的时候使用。Webpack 中涉及路径配置最好使用绝对路径，建议通过&nbsp;<code>path.resolve(__dirname, "app/folder")</code>&nbsp;或&nbsp;<code>path.join(__dirname, "app", "folder")</code>&nbsp;的方式来配置，以兼容 Windows 环境。</p>\n\n<h3 id="h3-9">webpack插件</h3>\n<p>某些时候，webpack的常规功能无法满足我们的需求，我们可以为webpack开发插件，或者使用其他开发团队已经完成的插件。</p>\n<p>下面是一个插件的标准格式：</p>\n<pre class="javascript"><code class="language-javascript"><span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">function</span></span></span><span class="hljs-function"> </span><span class="code-title"><span class="hljs-function"><span class="code-title">MyPlugin</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options</span></span></span><span class="hljs-function">) </span></span>{\n  <span class="code-comment"><span class="code-comment">// Configure your plugin with options...</span></span>\n}\n\nMyPlugin.prototype.apply = <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">compiler</span></span></span><span class="hljs-function">) </span></span>{\n  compiler.plugin(<span class="code-string"><span class="code-string">"compile"</span></span>, <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">params</span></span></span><span class="hljs-function">) </span></span>{\n    <span class="code-built_in"><span class="code-built_in">console</span></span>.log(<span class="code-string"><span class="code-string">"The compiler is starting to compile..."</span></span>);\n  });\n\n  compiler.plugin(<span class="code-string"><span class="code-string">"compilation"</span></span>, <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">compilation</span></span></span><span class="hljs-function">) </span></span>{\n    <span class="code-built_in"><span class="code-built_in">console</span></span>.log(<span class="code-string"><span class="code-string">"The compiler is starting a new compilation..."</span></span>);\n\n    compilation.plugin(<span class="code-string"><span class="code-string">"optimize"</span></span>, <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{\n      <span class="code-built_in"><span class="code-built_in">console</span></span>.log(<span class="code-string"><span class="code-string">"The compilation is starting to optimize files..."</span></span>);\n    });\n  });\n\n  compiler.plugin(<span class="code-string"><span class="code-string">"emit"</span></span>, <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">compilation, callback</span></span></span><span class="hljs-function">) </span></span>{\n    <span class="code-built_in"><span class="code-built_in">console</span></span>.log(<span class="code-string"><span class="code-string">"The compilation is going to emit files..."</span></span>);\n    callback();\n  });\n};\n\n<span class="code-built_in"><span class="code-built_in">module</span></span>.exports = MyPlugin;</code></pre>\n<p>需要实现什么功能，可以按照这个标准去开发自己的插件。</p>\n\n<h2 id="h2-3">React开发</h2>\n<p>使用webpack搭建好开发环境后，我们就可以开始着手开发react了。开始之前，我们还是要优先完成开发环境的配置和搭建。</p>\n<p>react使用的语法是jsx，现在还新增了对es6的支持。为了可以高效开发，我们需要使用webpack的loader功能，将jsx或es6使用语法糖转义成浏览器可以识别的标准JavaScript语法。</p>\n<p>下面将继续在前文webpack的基础上继续说明如何开发react。</p>\n\n<h3 id="h3-10">安装必要的依赖工具</h3>\n<p>react的基础工具包：</p>\n<pre class="sql"><code class="language-bash">$ npm <span class="code-keyword">install</span> react <span class="code-comment">--save-dev</span></code></pre>\n<p>react的dom组件：</p>\n<pre class="sql"><code class="language-bash">$ npm <span class="code-keyword">install</span> react react-dom <span class="code-comment">--save-dev</span></code></pre>\n<p>在前面介绍webpack的时候已经介绍了加载器的概念，这里需要额外安装babel用于对react的jsx风格的编码进行解析，babel除了jsx外还可以解析es6等。安装babel：</p>\n<pre class=""><code class="language-bash"><span class="code-variable">$ </span>npm install babel-loader</code></pre>\n<p>安装babel-loader之后\\node_modules目录中会额外多安装一个babel-core，这是babel的核心包。</p>\n<p>有了babel，我们还需要安装编码转换规则，用于解析jsx、es6等等。</p>\n<pre class="sql"><code class="language-bash">$ npm <span class="code-keyword">install</span> babel-preset-es2015 babel-preset-react <span class="code-comment">--save-dev</span></code></pre>\n<p>除了babel提供的es6和jsx，webpack还可以使用各种loader来转换编码，比如coffeescript等。想要什么就去google找吧。</p>\n\n<h3 id="h3-11">完善本地开发环境命令</h3>\n<p>前面的案例使用 webpack-dev-server 来热部署本地开发环境提升开发效率。但是每次都靠长长的命令行启动和停止太过于繁琐。我们可以利用npm的package.json配置脚本运行来统一管理脚本命令：</p>\n<pre class="actionscript"><code class="language-javascript">{\n  <span class="code-string"><span class="code-string">"name"</span></span>: <span class="code-string"><span class="code-string">"demo2-react"</span></span>,\n  <span class="code-string"><span class="code-string">"version"</span></span>: <span class="code-string"><span class="code-string">"1.0.0"</span></span>,\n  <span class="code-string"><span class="code-string">"description"</span></span>: <span class="code-string"><span class="code-string">"react demo"</span></span>,\n  <span class="code-string"><span class="code-string">"main"</span></span>: <span class="code-string"><span class="code-string">"index.js"</span></span>,\n  <span class="code-string"><span class="code-string">"scripts"</span></span>:{\n    <span class="code-string"><span class="code-string">"dev"</span></span>: <span class="code-string"><span class="code-string">"webpack-dev-server --progress --colors --inline"</span></span> <span class="code-comment"><span class="code-comment">//配置运行命令</span></span>\n  },\n  <span class="code-comment"><span class="code-comment">//more</span></span>\n}</code></pre>\n<p>添加了scripts后，我们今后只需要运行</p>\n<pre class=""><code class="language-bash"><span class="code-variable">$ </span>npm run dev</code></pre>\n<p>即可使用配置好的命令行参数启动本地开发环境服务器。</p>\n\n<h3 id="h3-12">终于可以开始码农的核心工作了</h3>\n<p>（demo代码存放在：<a title="React搭建开发环境示例代码" href="https://github.com/chkui/react-demo" rel="nofollow">https://github.com/chkui/react-demo</a>。下载后用 npm install 下载npm依赖即可使用）</p>\n<p>前面准备了这么久，就是为了随后我们可以快乐的编码。首先我们按照下面这个结构创建工程结构：</p>\n<pre class="haml"><code class="haml"><span class="code-comment"><span class="code-comment">/root</span></span>\n-<span class="ruby"><span class="ruby">-</span><span class="hljs-regexp"><span class="ruby"><span class="hljs-regexp">/dev\n</span></span></span></span>-<span class="ruby"><span class="hljs-regexp"><span class="ruby"><span class="hljs-regexp">---/js</span></span></span><span class="ruby">\n</span></span>-<span class="ruby"><span class="ruby">-----</span><span class="hljs-regexp"><span class="ruby"><span class="hljs-regexp">/index\n</span></span></span></span>-<span class="ruby"><span class="hljs-regexp"><span class="ruby"><span class="hljs-regexp">-------/comps</span></span></span><span class="ruby">\n</span></span>-<span class="ruby"><span class="ruby">---------component1.jsx\n</span></span>-<span class="ruby"><span class="ruby">---------main.jsx\n</span></span>-<span class="ruby"><span class="ruby">-------index.js\n</span></span>-<span class="ruby"><span class="ruby">---</span><span class="hljs-regexp"><span class="ruby"><span class="hljs-regexp">/style\n</span></span></span></span>-<span class="ruby"><span class="hljs-regexp"><span class="ruby"><span class="hljs-regexp">-----/index</span></span></span><span class="ruby">\n</span></span>-<span class="ruby"><span class="ruby">-------index.css\n</span></span>-<span class="ruby"><span class="ruby">---index.html</span></span></code></pre>\n<p>然后根据工程的结构修改我们的webpack.config.js：</p>\n<pre class="typescript"><code class="language-javascript"><span class="code-comment"><span class="code-comment">/**\n * Created by Administrator on 2016/11/17.\n */</span></span>\n<span class="code-keyword"><span class="code-keyword">var</span></span> path = <span class="code-built_in"><span class="code-built_in">require</span></span>(<span class="code-string"><span class="code-string">\'path\'</span></span>);\n<span class="code-built_in"><span class="code-built_in">module</span></span>.exports = {\n    entry: [<span class="code-string"><span class="code-string">\'./dev/js/index/comps/main.jsx\'</span></span>],<span class="code-comment"><span class="code-comment">//定义要引入的js文件</span></span>\n    output: {\n        path: __dirname,\n        filename: <span class="code-string"><span class="code-string">\'./dev/js/index/index.js\'</span></span> <span class="code-comment"><span class="code-comment">//定义要输出的js文件</span></span>\n    },\n    <span class="code-built_in"><span class="code-keyword">module</span></span>: {\n        loaders: [{\n            test: <span class="hljs-regexp"><span class="hljs-regexp">/\\.js[x]?$/</span></span>,\n            exclude: <span class="hljs-regexp"><span class="hljs-regexp">/(node_modules|bower_components)/</span></span>,\n            loader: <span class="code-string"><span class="code-string">\'babel-loader\'</span></span>,\n            query: {\n                presets: [<span class="code-string"><span class="code-string">\'es2015\'</span></span>,<span class="code-string"><span class="code-string">\'react\'</span></span>]\n            }\n        }, {\n            test: <span class="hljs-regexp"><span class="hljs-regexp">/\\.css$/</span></span>,\n            loader: <span class="code-string"><span class="code-string">\'style!css\'</span></span>\n        }, {\n            test: <span class="hljs-regexp"><span class="hljs-regexp">/\\.(png|jpg)$/</span></span>,\n            loader: <span class="code-string"><span class="code-string">\'url?limit=25000\'</span></span> <span class="code-comment"><span class="code-comment">//只解析小于25000字节的图片</span></span>\n        }]\n    }\n};</code></pre>\n<p>和前面介绍webpack的例子相比，这里的配置文件新增了了一个babel-loader的配置。</p>\n<p>test后的正则表达式表示对所有的js或者jsx文件进行解析；</p>\n<p>exclude表示不解析npm安装目录下和bower安装目录下的文件；</p>\n<p>loader表示使用的解析工具；</p>\n<p>query表示扩展参数，这里的\'es2015\'和\'react\'表示启用babel-preset-es2015和bable-preset-react解析规则。这里需要注意的是解析的优先级的倒序的，即会先解析‘react’。</p>\n<p>然后我们添加编码内容（所有的例子都分别实现了jsx规范和es2015规范）：</p>\n<p>index.html：</p>\n<pre class="xml"><code class="language-html xml"><span class="code-meta"><span class="code-meta">&lt;!DOCTYPE html&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span class="code-name">html</span></span></span><span class="code-tag"> </span><span class="hljs-attr"><span class="code-tag"><span class="hljs-attr">lang</span></span></span><span class="code-tag">=</span><span class="code-string"><span class="code-tag"><span class="code-string">"en"</span></span></span><span class="code-tag">&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span class="code-name">head</span></span></span><span class="code-tag">&gt;</span></span>\n    <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span class="code-name">meta</span></span></span><span class="code-tag"> </span><span class="hljs-attr"><span class="code-tag"><span class="hljs-attr">charset</span></span></span><span class="code-tag">=</span><span class="code-string"><span class="code-tag"><span class="code-string">"UTF-8"</span></span></span><span class="code-tag">&gt;</span></span>\n    <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span class="code-name">title</span></span></span><span class="code-tag">&gt;</span></span>Title<span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span class="code-name">title</span></span></span><span class="code-tag">&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span class="code-name">head</span></span></span><span class="code-tag">&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span class="code-name">body</span></span></span><span class="code-tag">&gt;</span></span>\n    <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span class="code-name">div</span></span></span><span class="code-tag"> </span><span class="hljs-attr"><span class="code-tag"><span class="hljs-attr">id</span></span></span><span class="code-tag">=</span><span class="code-string"><span class="code-tag"><span class="code-string">"comp"</span></span></span><span class="code-tag">&gt;</span></span><span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span class="code-name">div</span></span></span><span class="code-tag">&gt;</span></span>\n    <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span class="code-name">script</span></span></span><span class="code-tag"> </span><span class="hljs-attr"><span class="code-tag"><span class="hljs-attr">src</span></span></span><span class="code-tag">=</span><span class="code-string"><span class="code-tag"><span class="code-string">"/dev/js/index/index.js"</span></span></span><span class="code-tag">&gt;</span></span><span class="undefined"></span><span class="code-tag"><span class="undefined"></span><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span class="code-name">script</span></span></span><span class="code-tag">&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span class="code-name">body</span></span></span><span class="code-tag">&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span class="code-name">html</span></span></span><span class="code-tag">&gt;</span></span></code></pre>\n<p>main.jsx：</p>\n<pre class="javascript"><code class="language-javascript"><span class="code-comment"><span class="code-comment">/**\n * Created by chkui on 2016/11/17.\n */</span></span>\n\n<span class="code-comment"><span class="code-comment">//jsx</span></span>\n<span class="code-comment"><span class="code-comment">/*\nvar React = require(\'react\');\nvar ReactDOM = require(\'react-dom\');\nvar Comp1 = require(\'./component1.jsx\');\nrequire(\'../../../style/index/index.css\');\n\nReactDOM.render(\n    &lt;div className="main"&gt;\n        react jsx demo:\n        &lt;Comp1 /&gt;\n    &lt;/div&gt;,\n    document.getElementById(\'comp\')\n);\n*/</span></span>\n\n<span class="code-comment"><span class="code-comment">//es2015</span></span>\n<span class="code-keyword"><span class="code-keyword">import</span></span> React <span class="code-keyword"><span class="code-keyword">from</span></span> <span class="code-string"><span class="code-string">\'react\'</span></span>;\n<span class="code-keyword"><span class="code-keyword">import</span></span> ReactDOM <span class="code-keyword"><span class="code-keyword">from</span></span> <span class="code-string"><span class="code-string">\'react-dom\'</span></span>;\n<span class="code-keyword"><span class="code-keyword">import</span></span> Comp1 <span class="code-keyword"><span class="code-keyword">from</span></span> <span class="code-string"><span class="code-string">\'./component1.jsx\'</span></span> <span class="code-comment"><span class="code-comment">/*切记，大写是变量小写是标签*/</span></span>\n<span class="code-keyword"><span class="code-keyword">import</span></span> style <span class="code-keyword"><span class="code-keyword">from</span></span> <span class="code-string"><span class="code-string">\'../../../style/index/index.css\'</span></span>\n\nReactDOM.render(\n    <span class="xml"><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">div</span></span></span></span><span class="xml"><span class="code-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="code-tag"><span class="hljs-attr">className</span></span></span></span><span class="xml"><span class="code-tag">=</span></span><span class="code-string"><span class="xml"><span class="code-tag"><span class="code-string">"main"</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n        react es2015 demo:\n        </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">Comp1</span></span></span></span><span class="xml"><span class="code-tag"> /&gt;</span></span></span><span class="xml">\n    </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">div</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span></span>\n    ,\n    <span class="code-built_in"><span class="code-built_in">document</span></span>.getElementById(<span class="code-string"><span class="code-string">\'comp\'</span></span>)\n);\n</code></pre>\n<p>component1.jsx：</p>\n<pre class="scala"><code class="language-javascript"><span class="code-comment"><span class="code-comment">/**\n * Created by Administrator on 2016/11/17.\n */</span></span>\n\n<span class="code-comment"><span class="code-comment">//jsx</span></span>\n<span class="code-comment"><span class="code-comment">/*\nvar React = require(\'react\');\nvar comp1 = React.createClass({\n    render: function () {\n        return (\n          &lt;div className = "index"&gt;\n            hello react!\n          &lt;/div&gt;\n        );\n    }\n});\nmodule.exports = comp1;\n*/</span></span>\n\n<span class="code-comment"><span class="code-comment">//es6</span></span>\n<span class="code-keyword"><span class="code-keyword">import</span></span> <span class="code-type">React</span> <span class="code-keyword">from</span> <span class="code-string"><span class="code-string">"react"</span></span>\n<span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">Comp1</span></span></span><span class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span class="hljs-class"><span class="code-title">Component</span></span></span></span>{\n    <span class="code-comment"><span class="code-comment">//构造函数</span></span>\n    <span class="code-keyword">constructor</span>(...args){\n        <span class="code-keyword"><span class="code-keyword">super</span></span>(...args);\n    }\n    <span class="code-comment"><span class="code-comment">//覆盖父类的渲染方法</span></span>\n    render() {\n        <span class="code-keyword"><span class="code-keyword">return</span></span> (\n            <span class="xml"><span class="code-tag">&lt;<span class="code-name">div</span> <span class="hljs-attr">className</span> = <span class="code-string"><span class="code-string">"index"</span></span>&gt;</span>\n                hello react!\n            <span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>\n        );\n    }\n}\n<span class="code-keyword">export</span> <span class="code-keyword"><span class="code-keyword">default</span></span> <span class="code-type">Comp1</span>;\n</code></pre>\n<p>编码完毕之后，我们使用我们设定好的脚本运行我们的本地开发环境：</p>\n<pre class=""><code class="language-bash"><span class="code-variable">$ </span>npm run dev</code></pre>\n<p>启动时，所有的文本都会被读取到内存中，我们可以根据输出来聊天到底添加了哪些依赖的文件。启动完成后，浏览器上输入&nbsp;http://localhost:8080/dev/index.html 或&nbsp;http://localhost:8080/webpack-dev-server/dev/index.html 即可看到我们用react开发的页面。此时修改js或css文件，编辑效果都会立刻呈现在浏览器上。</p>\n\n<h2 id="h2-4">React浏览器调试工具</h2>\n<p>Facebook提供了基于chrome的页面调试工具，可以看到所有react组件及其效果。</p>\n<p>工具安装：</p>\n<ol>\n    <li>首先最重要的是——翻墙-_-。不翻墙chrome的网上商店就别想了。</li>\n    <li>然后在chrome网店搜索“React Developer Tool”。</li>\n    <li>找到后添加到chrome。</li>\n</ol>\n<p>添加完成后可以发现在chrome中增加了react的图标。</p>\n<p><img alt="React 搭建开发环境" height="282" src="https://file.mahoooo.com/res/file/react_establish_development_environment_2.png" width="638"></p>\n<p>然后在demo页面按F12打开开发人员工具，会发现多了一个React栏目。选择这个栏目后，会显示出React组件的效果。</p>\n<p><img alt="React 搭建开发环境" height="198" src="https://file.mahoooo.com/res/file/react_establish_development_environment_3.png" width="693"></p>'},360:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h2 id="h2-1">阅读之前</h2>\n<p>在了解<em>Next.js</em>之前，需要掌握<a href="https://www.chkui.com/category/react" title="React">React</a>的基本使用方法。</p>\n<p>参考代码：<a href="https://github.com/chkui/nextjs-getting-started">https://github.com/chkui/nextjs-getting-started</a> 。\n</p>\n<h2 id="h2-2">搭建</h2>\n<h3 id="h3-1">安装</h3>\n<pre><code class="bash"><span class="code-comment"># 创建项目目录</span>\nmkdir you_project\n<span class="code-comment"># 进入项目目录</span>\n<span class="code-built_in">cd</span> you_project\n<span class="code-comment"># 初始化package.json</span>\nnpm init -y\n<span class="code-comment"># 安装依赖包</span>\nnpm install --save react react-dom next\n<span class="code-comment"># 创建一个pages文件夹</span>\nmkdir pages\n</code></pre>\n<p>依次执行以上命令之后，<em>Next.js</em>运行所需的最基本的目录和依赖就创建好了。</p>\n<h3 id="h3-2">运行</h3>\n<p>将<em>package.json</em>里的“scripts"字段修改为：</p>\n<pre><code class="json">{\n  <span class="hljs-attr">"scripts"</span>: {\n    <span class="hljs-attr">"dev"</span>: <span class="code-string">"next"</span>,\n    <span class="hljs-attr">"build"</span>: <span class="code-string">"next build"</span>,\n    <span class="hljs-attr">"start"</span>: <span class="code-string">"next start"</span>\n  }\n}\n</code></pre>\n<p>运行以下命令启动<em>Next.js</em>：</p>\n<pre><code class="shell">npm run dev\n</code></pre>\n<p>在浏览器打开<a href="http://localhost:3000/">http://localhost:3000/</a> 看到输出"404 - This page could not be found"，表示<em>Next.js</em>安装成功。\n</p>\n<h3 id="h3-3">添加页面</h3>\n<p><em>./pages</em>是<em>Next.js</em>默认的网页路径，其中的<em>index.js</em>就代表整个网站的主页。创建一个*./pages/index.js*组件：</p>\n<pre><code class="JavaScript"><span class="code-keyword">const</span> Index = <span class="hljs-function"><span\n        class="hljs-params">()</span> =&gt;</span> (\n  <span class="xml"><span class="code-tag">&lt;<span class="code-name">div</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">p</span>&gt;</span>Hello World!<span class="code-tag">&lt;/<span\n              class="code-name">p</span>&gt;</span>\n  <span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>\n)\n<span class="code-keyword">export</span> <span class="code-keyword">default</span> Index\n</code></pre>\n<p>添加*./pages/index.js*后网站会自动刷新，呈现"Hello World!"。</p>\n<h2 id="h2-3">页面与导航栏</h2>\n<h3 id="h3-4">页面</h3>\n<p>添加<a href="http://localhost:3000/about">http://localhost:3000/about</a> 路径下的页面。</p>\n<p>创建*./pages/about.js*文件，添加以下内容：</p>\n<pre><code class="JavaScript"><span class="code-keyword">export</span> <span class="code-keyword">default</span> () =&gt; (\n  <span class="xml"><span class="code-tag">&lt;<span class="code-name">div</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">p</span>&gt;</span>About page<span class="code-tag">&lt;/<span\n              class="code-name">p</span>&gt;</span>\n  <span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>\n)\n</code></pre>\n<p>然后在浏览器输入<a href="http://localhost:3000/about">http://localhost:3000/about</a> 即可看到新增的About。</p>\n<h3 id="h3-5">导航栏</h3>\n<p>对*./pages/index.js*稍加修改引入导航栏功能：</p>\n<pre><code class="JavaScript"><span class="code-keyword">import</span> Link <span class="code-keyword">from</span> <span\n        class="code-string">\'next/link\'</span>\n\n<span class="code-keyword">const</span> Index = <span class="hljs-function"><span\n            class="hljs-params">()</span> =&gt;</span> (\n  <span class="xml"><span class="code-tag">&lt;<span class="code-name">div</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">Link</span> <span class="hljs-attr">href</span>=<span\n            class="code-string">"/about"</span>&gt;</span>\n      <span class="code-tag">&lt;<span class="code-name">a</span> <span class="hljs-attr">style</span>=<span\n              class="code-string">{{fontSize:</span> <span class="hljs-attr">20</span>}}&gt;</span>About Page<span\n              class="code-tag">&lt;/<span class="code-name">a</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">Link</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">p</span>&gt;</span>Hello Next.js<span class="code-tag">&lt;/<span\n              class="code-name">p</span>&gt;</span>\n  <span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>\n)\n\n<span class="code-keyword">export</span> <span class="code-keyword">default</span> Index\n</code></pre>\n<p><strong>注意</strong>：使用了<em>Next.js</em>作为服务端渲染工具，切记仅使用<em>next/link</em>中的Link组件。</p>\n<p>除了<code>&lt;a&gt;</code>标签，<code>&lt;button&gt;</code>或自定义的组件都可以被<code>Link</code>包装，只要传递<em>Click事件</em>即可，将上面的代码稍作修改实验这个效果：\n</p>\n<pre><code class="JavaScript"><span class="code-keyword">import</span> Link <span class="code-keyword">from</span> <span\n        class="code-string">\'next/link\'</span>\n\n<span class="code-keyword">const</span> Index = <span class="hljs-function"><span\n            class="hljs-params">()</span> =&gt;</span> (\n    <span class="xml"><span class="code-tag">&lt;<span class="code-name">div</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">Link</span> <span class="hljs-attr">href</span>=<span\n                class="code-string">"/about"</span>&gt;</span>\n            <span class="code-tag">&lt;<span class="code-name">button</span>&gt;</span>Click Me<span class="code-tag">&lt;/<span\n                class="code-name">button</span>&gt;</span>\n        <span class="code-tag">&lt;/<span class="code-name">Link</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">Link</span> <span class="hljs-attr">href</span>=<span\n                class="code-string">"/about"</span>&gt;</span>\n            <span class="code-tag">&lt;<span class="code-name">A</span>/&gt;</span>\n        <span class="code-tag">&lt;/<span class="code-name">Link</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">p</span>&gt;</span>Hello Next.js<span\n                class="code-tag">&lt;/<span class="code-name">p</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>\n)\n\n<span class="code-keyword">export</span> <span class="code-keyword">default</span> Index\n\n<span class="code-keyword">const</span> A = <span class="hljs-function"><span\n            class="hljs-params">props</span> =&gt;</span> (<span class="xml"><span class="code-tag">&lt;<span\n            class="code-name">div</span> <span class="hljs-attr">onClick</span>=<span class="code-string">{e</span> =&gt;</span> {\n    props.onClick(e)\n}}&gt;Click Me<span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>)\n</code></pre>\n<p>关于<em>Next.js</em>路由管理相关的细节内容，<a href="https://github.com/zeit/next.js#routing" title="可以到这里查看">可以到这里查看</a></p>\n<h2 id="h2-4">页面、资源与组件</h2>\n<p><em>./pages</em>是一个保留路径，在*/pages*路径下任何js文件中导出的默认React组件都被视作一个页面。</p>\n<p>除了*./pages*，<em>Next.js</em>还有一个保留路径是*./static*，它用来存放图片等静态资源。</p>\n<p><em>Next.js</em>会对*./pages<em>中的React组件进行“包装"，所以</em>./pages*内外的React组件在呈现结果上有一些差异，看下面的例子。</p>\n<h3 id="h3-6">创建网站结构</h3>\n<p>在工程根目录创建*/components*文件夹，然后添加以下组件：</p>\n<pre><code class="JavaScript"><span class="code-keyword">import</span> Link <span class="code-keyword">from</span> <span\n        class="code-string">\'next/link\'</span>\n\n<span class="code-keyword">const</span> linkStyle = {\n    <span class="hljs-attr">marginRight</span>: <span class="hljs-number">15</span>\n}\n\n<span class="code-keyword">const</span> Header = <span class="hljs-function"><span\n            class="hljs-params">()</span> =&gt;</span> (\n    <span class="xml"><span class="code-tag">&lt;<span class="code-name">div</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">Link</span> <span class="hljs-attr">href</span>=<span\n                class="code-string">"/"</span>&gt;</span>\n            <span class="code-tag">&lt;<span class="code-name">a</span> <span class="hljs-attr">style</span>=<span\n                    class="code-string">{linkStyle}</span>&gt;</span>Home<span class="code-tag">&lt;/<span\n                class="code-name">a</span>&gt;</span>\n        <span class="code-tag">&lt;/<span class="code-name">Link</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">Link</span> <span class="hljs-attr">href</span>=<span\n                class="code-string">"/about"</span>&gt;</span>\n            <span class="code-tag">&lt;<span class="code-name">a</span> <span class="hljs-attr">style</span>=<span\n                    class="code-string">{linkStyle}</span>&gt;</span>About<span class="code-tag">&lt;/<span\n                class="code-name">a</span>&gt;</span>\n        <span class="code-tag">&lt;/<span class="code-name">Link</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>\n)\n\n<span class="code-keyword">export</span> <span class="code-keyword">default</span> Header\n</code></pre>\n<p>然后将<code>Header</code>整合到<code>about.js</code>和<code>index.js</code>中：</p>\n<pre><code class="JavaScript"><span class="code-keyword">import</span> Header <span\n        class="code-keyword">from</span> <span class="code-string">\'../components/Header\'</span>\n<span class="code-keyword">export</span> <span class="code-keyword">default</span> () =&gt; (\n    <span class="xml"><span class="code-tag">&lt;<span class="code-name">div</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">Header</span> /&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">p</span>&gt;</span>Hello Next.js<span\n                class="code-tag">&lt;/<span class="code-name">p</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>\n)\n</code></pre>\n<p>再次进行页面操作，就会出现表头静止页面变换的效果。</p>\n<h3 id="h3-7">网站布局</h3>\n<p>通常情况下，开发一个网站先制定一个通用的布局（尤其是响应式布局的网站），然后再向布局中的添加各个部分的内容。使用<em>Next.js</em>可以通过组件的方式来设计一个布局，看下面的例子。\n    在*/components*中增加<code>Layout</code>和<code>Footer</code>组件:</p>\n<pre><code class="JavaScript"><span class="code-comment">// componments/layout.js</span>\n<span class="code-keyword">import</span> Header <span class="code-keyword">from</span> <span class="code-string">\'./header\'</span>\n<span class="code-keyword">import</span> Footer <span class="code-keyword">from</span> <span class="code-string">\'./footer\'</span>\n\n<span class="code-keyword">const</span> layoutStyle = {\n    <span class="hljs-attr">margin</span>: <span class="hljs-number">20</span>,\n    <span class="hljs-attr">padding</span>: <span class="hljs-number">20</span>,\n    <span class="hljs-attr">border</span>: <span class="code-string">\'1px solid #DDD\'</span>\n}\n\n<span class="code-keyword">const</span> Layout = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> (\n    <span class="xml"><span class="code-tag">&lt;<span class="code-name">div</span> <span class="hljs-attr">style</span>=<span\n            class="code-string">{layoutStyle}</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">Header</span> /&gt;</span>\n        {props.children}\n        <span class="code-tag">&lt;<span class="code-name">Footer</span> /&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>\n)\n\n<span class="code-keyword">export</span> <span class="code-keyword">default</span> Layout\n</code></pre>\n<pre><code class="JavaScript"><span class="code-comment">// components/footer.js</span>\n<span class="code-keyword">const</span> Footer = <span class="hljs-function"><span\n            class="hljs-params">()</span> =&gt;</span> (\n    <span class="xml"><span class="code-tag">&lt;<span class="code-name">div</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">p</span> <span class="hljs-attr">style</span>=<span\n                class="code-string">{{color:</span>\'<span class="hljs-attr">blue</span>\'}}&gt;</span>Footer<span\n                class="code-tag">&lt;/<span class="code-name">p</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>\n)\n\n<span class="code-keyword">export</span> <span class="code-keyword">default</span> Footer\n</code></pre>\n<p>然后将*/pages/index.js*修改为：</p>\n<pre><code class="JavaScript"><span class="code-keyword">import</span> Layout <span\n        class="code-keyword">from</span> <span class="code-string">\'../components/layout\'</span>\n\n<span class="code-keyword">export</span> <span class="code-keyword">default</span> () =&gt; (\n    <span class="xml"><span class="code-tag">&lt;<span class="code-name">Layout</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">p</span>&gt;</span>Hello Next.js<span\n                class="code-tag">&lt;/<span class="code-name">p</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">Layout</span>&gt;</span></span>\n)\n</code></pre>\n<p>这样，页面的内容和布局就完全隔离开了。</p>\n<h2 id="h2-5">页面跳转</h2>\n<h3 id="h3-8">传递参数</h3>\n<p>在实际应用中，经常需要在页面间传递参数，可以使用<a href="https://www.chkui.com/article/react/react_high_order_component"\n                              title="高阶组件">高阶组件</a><code>withRouter</code>来实现。\n    下面的代码对*/pages/index.js<em>进行了一些修改，使其在跳转时携带</em>query*参数：</p>\n<pre><code class="JavaScript"><span class="code-keyword">const</span> SubLink = <span class="hljs-function"><span\n        class="hljs-params">props</span> =&gt;</span> (\n    <span class="xml"><span class="code-tag">&lt;<span class="code-name">li</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">Link</span> <span class="hljs-attr">href</span>=<span\n                class="code-string">{</span>`/<span class="hljs-attr">post</span>?<span\n                class="hljs-attr">title</span>=<span class="code-string">${props.title}</span>`}&gt;</span>\n            <span class="code-tag">&lt;<span class="code-name">a</span>&gt;</span>{props.title}<span class="code-tag">&lt;/<span\n                class="code-name">a</span>&gt;</span>\n        <span class="code-tag">&lt;/<span class="code-name">Link</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">li</span>&gt;</span></span>\n)\n\n<span class="code-keyword">export</span> <span class="code-keyword">default</span> () =&gt; (\n    &lt;Layout&gt;\n        &lt;h2&gt;Information&lt;/h2&gt;\n        &lt;SubLink title="First Post"/&gt;\n        &lt;SubLink title="Second Post"/&gt;\n        &lt;SubLink title="Third Post"/&gt;\n    &lt;/Layout&gt;\n)\n</code></pre>\n<p>点击<em>First Post</em>之后浏览器的URL会出现这样的路径：“<a href="http://localhost:3000/post?title=First%20Post”">http://localhost:3000/post?title=First%20Post”</a>\n    。接下来利用<code>withRouter</code>来获取这个参数。创建*./pages/post.js*的文件：</p>\n<pre><code class="JavaScript"><span class="code-keyword">import</span> {withRouter} <span\n        class="code-keyword">from</span> <span class="code-string">\'next/router\'</span>\n<span class="code-keyword">import</span> Layout <span class="code-keyword">from</span> <span class="code-string">\'../components/layout\'</span>\n\n<span class="code-keyword">const</span> Page = withRouter(<span class="hljs-function">(<span\n            class="hljs-params">props</span>) =&gt;</span> (\n    <span class="xml"><span class="code-tag">&lt;<span class="code-name">Layout</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">h3</span>&gt;</span>Post Page<span\n                class="code-tag">&lt;/<span class="code-name">h3</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">p</span>&gt;</span>Info:{props.router.query.title}<span\n                class="code-tag">&lt;/<span class="code-name">p</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">Layout</span>&gt;</span></span>\n))\n<span class="code-keyword">export</span> <span class="code-keyword">default</span> Page\n</code></pre>\n<p>现在点击<em>First Post</em>链接之后，跳转的页面会显示<em>First Post</em>。</p>\n<h3 id="h3-9">路径隐藏</h3>\n<p>\n    <em>Next.js</em>提供了一个让URL更加清晰干净的特性功能——URL隐藏（官网直译的话应该叫“URL遮挡”），他的作用是可以隐藏原来比较复杂的URL，让网站路径更加清晰，有利于SEO等。实现这个特性非常简单，在使用<code>Link</code>组件时传递一个<em>as</em>参数。下面将继续修改*./pages/index.js*中的内容以实现这个特性：\n</p>\n<pre><code class="JavaScript"><span class="code-keyword">const</span> SubLink = <span class="hljs-function"><span\n        class="hljs-params">props</span> =&gt;</span> (\n    <span class="xml"><span class="code-tag">&lt;<span class="code-name">li</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">Link</span> <span class="hljs-attr">as</span>=<span\n                class="code-string">{</span>`<span class="hljs-attr">p</span>/${<span class="hljs-attr">props.as</span>}`} <span\n                class="hljs-attr">href</span>=<span class="code-string">{</span>`/<span\n                class="hljs-attr">post</span>?<span class="hljs-attr">title</span>=<span class="code-string">${props.title}</span>`}&gt;</span>\n            <span class="code-tag">&lt;<span class="code-name">a</span>&gt;</span>{props.title}<span class="code-tag">&lt;/<span\n                class="code-name">a</span>&gt;</span>\n        <span class="code-tag">&lt;/<span class="code-name">Link</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">li</span>&gt;</span></span>\n)\n\n<span class="code-keyword">export</span> <span class="code-keyword">default</span> () =&gt; (\n    &lt;Layout&gt;\n        &lt;h2&gt;Information&lt;/h2&gt;\n        &lt;SubLink as="first-post" title="First Post"/&gt;\n        &lt;SubLink as="first-post" title="Second Post"/&gt;\n        &lt;SubLink as="first-post" title="Third Post"/&gt;\n    &lt;/Layout&gt;\n)\n</code></pre>\n<p>注意观察<code>SubLink</code>组件中的修改，为<code>Link</code>增加了一个as参数，这个参数传递的内容将会在浏览器的地址栏显示。例如点击<em>FIrst\n    Post</em>后，浏览器的地址栏会显示<a href="http://localhost:3000/p/first-post">http://localhost:3000/p/first-post</a>\n    ，但是我们通过<code>withRouter</code>组件获取的URL还是<em>href</em>传递的路径。</p>\n<h2 id="h2-6">服务端渲染</h2>\n<p>只要运行了<em>Next.js</em>，他时时刻刻都在执行服务端渲染，可以通过刷新页面看到效果。如果没有太多需求，不进行任何调整<em>Next.js</em>能为我们完成静态页面的服务端渲染，但是通常情况下，还需要处理异步请求等等情况。\n</p>\n<h3 id="h3-10">二次服务端渲染</h3>\n<p>前面介绍了在<code>Link</code>组件上使用<em>as</em>参数可以设置浏览器路径栏上显示的内容。但是这个时候仅仅支持客户端跳转，如果进行页面刷新会出现404页面。导致这个问题出现的原因是在服务端并不知道*/p/first-post<em>对应</em>/pages*文件夹中的哪个文件。为了解决这个问题，需要在服务端进行二次渲染。\n</p>\n<p>首先需要添加<em>Express</em>服务：</p>\n<pre><code class="bash">npm install --save express\n</code></pre>\n<p>安装完成之后在根目录添加一个<em>server.js</em>文件，其内容如下：</p>\n<pre><code class="JavaScript"><span class="code-keyword">const</span> express = <span\n        class="code-built_in">require</span>(<span class="code-string">\'express\'</span>)\n<span class="code-keyword">const</span> next = <span class="code-built_in">require</span>(<span class="code-string">\'next\'</span>)\n\n<span class="code-comment">// 不等于\'production\'则表示运行的是开发环境</span>\n<span class="code-keyword">const</span> dev = process.env.NODE_ENV !== <span class="code-string">\'production\'</span>\n<span class="code-comment">// 创建一个服务端运行的Next app</span>\n<span class="code-keyword">const</span> app = next({dev})\n<span class="code-comment">// 请求处理器</span>\n<span class="code-keyword">const</span> handle = app.getRequestHandler()\n\napp.prepare()\n    .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n        <span class="code-keyword">const</span> server = express()\n\n        server.get(<span class="code-string">\'/p/:id\'</span>, (req, res) =&gt; {\n            <span class="code-comment">//将/p/:id的路径切换成/post?title=req.params.id的路径</span>\n            app.render(req, res, <span class="code-string">\'/post\'</span>, {<span class="hljs-attr">title</span>: req.params.id})\n        })\n\n        server.get(<span class="code-string">\'*\'</span>, (req, res) =&gt; {\n            <span class="code-keyword">return</span> handle(req, res)\n        })\n\n        server.listen(<span class="hljs-number">3000</span>, (err) =&gt; {\n            <span class="code-keyword">if</span> (err) <span class="code-keyword">throw</span> err\n            <span class="code-built_in">console</span>.log(<span class="code-string">\'&gt; Ready on http://localhost:3000\'</span>)\n        })\n    })\n    .catch(<span class="hljs-function">(<span class="hljs-params">ex</span>) =&gt;</span> {\n        <span class="code-built_in">console</span>.error(ex.stack)\n        process.exit(<span class="hljs-number">1</span>)\n    })\n</code></pre>\n<p>然后修改<em>package.json</em>的“scripts"字段，将启动方式方式指向<em>server.js</em>：</p>\n<pre><code class="json"><span class="code-string">"scripts"</span>: {\n    <span class="hljs-attr">"dev"</span>: <span class="code-string">"node server.js"</span>,\n    <span class="hljs-attr">"build"</span>: <span class="code-string">"next build"</span>,\n    <span class="hljs-attr">"start"</span>: <span class="code-string">"NODE_ENV=production node server.js"</span>\n  }\n</code></pre>\n<p>完成这2步网站服务端也可以正常跳转，实现功能的位置是这段代码：</p>\n<pre><code class="JavaScript">server.get(<span class="code-string">\'/p/:id\'</span>, (req, res) =&gt; {\n\tapp.render(req, res, <span class="code-string">\'/post\'</span>, {<span class="hljs-attr">title</span>: req.params.id})\n})\n</code></pre>\n<p>他将原来的请求“/p/:id”转换为请求"/post?title=id"。</p>\n<p>更多的<a href="https://github.com/zeit/next.js#custom-server-and-routing" title="服务端渲染的配置">服务端渲染的配置说明请看这里</a>。</p>\n<h3 id="h3-11">数据异步请求</h3>\n<p>对于一个前后端分离的系统来说，异步数据请求是几乎每个页面都需要的。<em>Next.js</em>通过<code>getInitialProps</code>来实现。\n    下面的示例数据来自<a href="https://www.tvmaze.com/api">https://www.tvmaze.com/api</a> 。创建*./pages/tvshows.js*的文件：</p>\n<pre><code class="JavaScript"><span class="code-keyword">import</span> Layout <span\n        class="code-keyword">from</span> <span class="code-string">\'../components/layout.js\'</span>\n<span class="code-keyword">import</span> Link <span class="code-keyword">from</span> <span class="code-string">\'next/link\'</span>\n<span class="code-keyword">import</span> fetch <span class="code-keyword">from</span> <span class="code-string">\'isomorphic-unfetch\'</span>\n\n<span class="code-keyword">const</span> TvShow = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> (\n    <span class="xml"><span class="code-tag">&lt;<span class="code-name">Layout</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">h1</span>&gt;</span>Batman TV Shows<span class="code-tag">&lt;/<span\n                class="code-name">h1</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">ul</span>&gt;</span>\n            {props.shows.map(({show}) =&gt; (\n                <span class="code-tag">&lt;<span class="code-name">li</span> <span class="hljs-attr">key</span>=<span\n                        class="code-string">{show.id}</span>&gt;</span>\n                    <span class="code-tag">&lt;<span class="code-name">Link</span> <span\n                            class="hljs-attr">href</span>=<span class="code-string">{</span>`/<span\n                            class="hljs-attr">tv</span>?<span class="hljs-attr">id</span>=<span class="code-string">${show.id}</span>`}&gt;</span>\n                        <span class="code-tag">&lt;<span class="code-name">a</span>&gt;</span>{show.name}<span\n                class="code-tag">&lt;/<span class="code-name">a</span>&gt;</span>\n                    <span class="code-tag">&lt;/<span class="code-name">Link</span>&gt;</span>\n                <span class="code-tag">&lt;/<span class="code-name">li</span>&gt;</span>\n            ))}\n        <span class="code-tag">&lt;/<span class="code-name">ul</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">Layout</span>&gt;</span></span>\n)\n\nTvShow.getInitialProps = <span class="code-keyword">async</span> <span class="hljs-function"><span class="code-keyword">function</span>(<span\n            class="hljs-params"></span>) </span>{\n    <span class="code-comment">//contxt是衔接Next.js包装组件和自定义主键的上下文，包含的参数有asPath、pathname、query</span>\n\n    <span class="code-comment">// 发送异步请求</span>\n    <span class="code-keyword">const</span> res = <span class="code-keyword">await</span> fetch(<span\n            class="code-string">\'https://api.tvmaze.com/search/shows?q=batman\'</span>)\n\n    <span class="code-comment">// 从response中异步读取数据流</span>\n    <span class="code-keyword">const</span> data = <span class="code-keyword">await</span> res.json()\n\n    <span class="code-built_in">console</span>.log(<span class="code-string">`Show data fetched. Count: <span\n            class="hljs-subst">${data.length}</span>`</span>)\n\n    <span class="code-comment">// 返回已获取的数据</span>\n    <span class="code-keyword">return</span> {\n        <span class="hljs-attr">shows</span>: data\n    }\n}\n\n<span class="code-keyword">export</span> <span class="code-keyword">default</span> TvShow\n</code></pre>\n<p><code>TvShow</code>组件的作用是异步请求数据并组装成列表展示。</p>\n<p>然后再创建一个查看详情的页面——<em>./pages/tv.js</em>，实现过程和上面一样：</p>\n<pre><code class="JavaScript"><span class="code-keyword">import</span> Layout <span\n        class="code-keyword">from</span> <span class="code-string">\'../components/layout\'</span>\n<span class="code-keyword">import</span> fetch <span class="code-keyword">from</span> <span class="code-string">\'isomorphic-unfetch\'</span>\n\n<span class="code-keyword">const</span> Tv =  <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> (\n    <span class="xml"><span class="code-tag">&lt;<span class="code-name">Layout</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">h1</span>&gt;</span>{props.show.name}<span class="code-tag">&lt;/<span\n                class="code-name">h1</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">p</span>&gt;</span>{props.show.summary.replace(/<span\n                class="code-tag">&lt;<span class="code-name">[</span>/]?<span class="hljs-attr">p</span>&gt;</span>/g, \'\')}<span\n                class="code-tag">&lt;/<span class="code-name">p</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">img</span> <span class="hljs-attr">src</span>=<span\n                class="code-string">{props.show.image.medium}/</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">Layout</span>&gt;</span>\n)\n\nTv.getInitialProps = async function (context) {\n    const { id } = context.query\n    const res = await fetch(`https://api.tvmaze.com/shows/${id}`)\n    const show = await res.json()\n\n    console.log(`Fetched show: ${show.name}`)\n\n    return { show }\n}\nexport default Tv\n</span></code></pre>\n<p>按照这个套路可以解决绝大部分数据异步请求的问题。不过如果数据组装过慢，会出页面现卡顿的问题，可以通过服务端缓存或异步页面加载实现，后续的篇幅会介绍。</p>\n<h2 id="h2-7">样式</h2>\n<h3 id="h3-12">源生添加样式</h3>\n<p>一个页面永远离不开样式，在<em>Next.js</em>中推荐一种简介高效的方法——<code>&lt;style jsx&gt;</code>。</p>\n<p>为的主页添加一些样式：</p>\n<pre><code class="JavaScript">(\n    &lt;Layout&gt;\n        &lt;h2&gt;Information&lt;/h2&gt;\n        &lt;SubLink as="first-post" title="First Post"/&gt;\n        &lt;SubLink as="first-post" title="Second Post"/&gt;\n        &lt;SubLink as="first-post" title="Third Post"/&gt;\n        &lt;style jsx&gt;{`\n            h2{\n                font-family: "Arial";\n            }\n        `}&lt;/style&gt;\n        &lt;style jsx global&gt;{`\n            .list{\n                list-style: none;\n                margin: 5px 0;\n            }\n        `}&lt;/style&gt;\n    &lt;/Layout&gt;\n)\n</code></pre>\n<p><code>&lt;style jsx&gt;</code>的作用就是为当前组件声明样式，需要注意的是在这个标签内声明的样式只能覆盖当前组件，子组件是不会出现层叠效果的。而<code>&lt;style jsx\n    global&gt;</code>标签的效果则是和标准的css层叠效果一致，在这个标签中声明的样式会影响到子组件。</p>\n<h3 id="h3-13">Loader添加载样式</h3>\n<p><em>Next.js</em>可以加载各种样式文件，下面以<em>Sass/Scss</em>为例。</p>\n<p>首先添加相关依赖：</p>\n<pre><code class="bash">npm install --save @zeit/next-sass node-sass\n</code></pre>\n<p>在项目根目录添加<em>next.config.js</em>文件，用于指示<em>Next</em>加载对用的功能：</p>\n<pre><code class="bash">const withSass = require(<span class="code-string">\'@zeit/next-sass\'</span>)\nmodule.exports = withSass()\n</code></pre>\n<p>现在就可以加载*.scss<em>文件了，添加一个</em>/pages/post.scss*文件：</p>\n<pre><code class="css">$<span class="code-selector-tag">font-size</span>: 50<span class="code-selector-tag">px</span>;\n<span class="code-selector-class">.header</span>{\n  <span class="code-attribute">font-size</span>: $font-size;\n  <span class="code-attribute">color</span>:red;\n}\n</code></pre>\n<p>修改*/pages/post.js*加载样式：</p>\n<pre><code class="JavaScript"><span class="code-keyword">import</span> {withRouter} <span\n        class="code-keyword">from</span> <span class="code-string">\'next/router\'</span>\n<span class="code-keyword">import</span> Layout <span class="code-keyword">from</span> <span class="code-string">\'../components/layout\'</span>\n<span class="code-comment">//加载样式</span>\n<span class="code-keyword">import</span> <span class="code-string">\'./post.scss\'</span>\n\n<span class="code-keyword">const</span> Page = withRouter(<span class="hljs-function">(<span\n            class="hljs-params">props</span>) =&gt;</span> (\n    <span class="xml"><span class="code-tag">&lt;<span class="code-name">Layout</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">h3</span> <span class="hljs-attr">className</span>=<span\n                class="code-string">"header"</span>&gt;</span>Post Page<span class="code-tag">&lt;/<span\n                class="code-name">h3</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">p</span>&gt;</span>Info:{props.router.query.title}<span\n                class="code-tag">&lt;/<span class="code-name">p</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">Layout</span>&gt;</span></span>\n))\n\n<span class="code-keyword">export</span> <span class="code-keyword">default</span> Page\n</code></pre>\n<p>由于是使用的<em>webpack</em>的<em>Loader</em>，可以根据需要在<em>next.config.js</em>文件中进行一些相关的设置：</p>\n<pre><code class="JavaScript"><span class="code-built_in">module</span>.exports = withSass({\n  <span class="hljs-attr">cssModules</span>: <span class="hljs-literal">true</span>,\n  <span class="hljs-attr">cssLoaderOptions</span>: {\n    <span class="hljs-attr">importLoaders</span>: <span class="hljs-number">1</span>,\n    <span class="hljs-attr">localIdentName</span>: <span class="code-string">"[local]___[hash:base64:5]"</span>,\n  }\n})\n</code></pre>\n<p>然后在组件中直接以对象的方式使用：</p>\n<pre><code class="JavaScript"><span class="code-keyword">import</span> style <span\n        class="code-keyword">from</span> <span class="code-string">\'./post.scss\'</span>\n<span class="code-keyword">const</span> Page = withRouter(<span class="hljs-function">(<span\n            class="hljs-params">props</span>) =&gt;</span> {\n    <span class="code-built_in">console</span>.log(style)\n    <span class="code-keyword">return</span> (\n        <span class="xml"><span class="code-tag">&lt;<span class="code-name">Layout</span>&gt;</span>\n            <span class="code-tag">&lt;<span class="code-name">h3</span> <span class="hljs-attr">className</span>=<span\n                    class="code-string">{style.header}</span>&gt;</span>Post Page<span class="code-tag">&lt;/<span\n                    class="code-name">h3</span>&gt;</span>\n            <span class="code-tag">&lt;<span class="code-name">p</span>&gt;</span>Info:{props.router.query.title}<span\n                    class="code-tag">&lt;/<span class="code-name">p</span>&gt;</span>\n        <span class="code-tag">&lt;/<span class="code-name">Layout</span>&gt;</span></span>\n    )\n})\n</code></pre>\n<p>更多关于cssLoaderOptions的参数说明可以查看<a href="https://github.com/webpack-contrib/css-loader#options"\n                                   title="webpack里css-loader的options说明">webpack里css-loader的options说明</a>。除了scss,<a\n        href="https://github.com/zeit/next.js#css-in-js" title="*Next.js*还支持css、less、post css的Loader"><em>Next.js</em>还支持css、less、post\n    css的Loader</a>。</p>\n<h2 id="h2-8">发布</h2>\n<p>在了解以上内容之后，已经可以开发一个网站了，接下来介绍如何发布生产包。</p>\n<p><em>package.json</em>中的“scripts"字段可以设置打包和生产运行方式：</p>\n<pre><code class="json">  <span class="code-string">"scripts"</span>: {\n    <span class="hljs-attr">"dev"</span>: <span class="code-string">"node server.js"</span>,\n    <span class="hljs-attr">"build"</span>: <span class="code-string">"next build"</span>,\n    <span class="hljs-attr">"start"</span>: <span class="code-string">"NODE_ENV=production node server.js"</span>\n  }\n</code></pre>\n<p>首先进行打包：</p>\n<pre><code class="bash">npm run build\n</code></pre>\n<p>打包完毕之后可以启动生产环境：</p>\n<pre><code class="bash">npm start\n</code></pre>\n<p>现在用浏览器打开<a href="http://localhost:3000/">http://localhost:3000/</a> 地址可以发现运行的是生产环境（可以使用React工具查看，也可以打开开发人员模式）。\n    由于之前了在<em>server.js</em>中引入了Express，所以现在启动的是一个Express服务器。打包之后的文件都在*./.next*\n    路径下，可以仅仅拷贝<strong>依赖包（node_module）</strong>、<strong>package.json</strong>、<strong>server.js</strong>以及**./.next**来运行生产环境。\n</p>\n<p>除了使用<em>Express</em>这一类第三方nodejs服务器，<a href="https://zeit.co/now" title="*Next.js*还提供了许多其他方式来部署和方法"><em>Next.js</em>还提供了许多其他方式来部署和方法</a>\n</p>'}});