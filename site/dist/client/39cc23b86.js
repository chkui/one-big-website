webpackJsonp([3],{326:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h2 id="h2-1">分区规范</h2>\n<p>首先要明确，JVM规范中并没有常量池这一说法，都是各种不同的jvm实现为了便于处理加以区分的。在JVM规范中统一称呼为方法区（JDK7之后这样说也不准确，有些数据常量数据又迁移到堆中）。下面的常量池主要以Java8自带的HotSpot为例，其他版本的Jvm会有各种区别。在HotSpot中，JDK6之前的版本所有常量池都在永生代（permanent generation）中，而JDK8取消了永生带用元空间（metaspace）替换，可以简单的理解常量池被移动到元空间中了（但实际处理还是有很多差异，大部分以前放置在永生代数据被迁移到堆中，而元数据区仅存放引用。但是这样说便于理解）。JDK7是一个过渡版本，只是将字符串移动到堆中。</p>\n\n<h2 id="h2-2">class常量池</h2>\n<p>当 .java文件被<span style="color:#FF0000">转译</span>成.class文件之后的字节码中包含一系列描述信息、符号引用和字面量信息。在jvm启动时，这些信息会被加载到class常量池中，当一个类要被<span style="color:#FF0000">编译</span>加载之前这些符号和字符串会经过JVM的加载器将其实例化成为一个常量值（Class对象的实例）存在在运行时常量区。所谓的class常量池并不会真的需要分配一个内存空间（常量池），直接从本地磁盘上加载转换也是可行的，这主要取决与JVM的版本和一些参数的配置处理。</p>\n\n<h2 id="h2-3">运行时常量池</h2>\n<p>运行时常量池（Runtime Constant Pool）主要用于存放jvm在运行时所有静态量。参考"深入理解java虚拟机"一书2.2.6对其的描述：运行时常量池是方法区的一部分。class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是<strong>常量池表</strong>（Constant Pool Tabel），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入该常量池。运行时常量池并不仅仅局限于加载类时产生常量，与<strong>class常量池</strong>的区别是可以在运行期间添加各种数据到这个区域，例如jvm会将代码中直接声明的字符串放置到常量池中，这些字符串被称为字面量。通过<em>String::intern</em> 也可以向常量池表添加新的字面量。</p>\n\n<h2 id="h2-4">代码与字节码案例</h2>\n<p>下面通过一些例子来加深堆常量池的理解。</p>\n<p>字面量定义变量值：</p>\n<pre><code class="java"><span class="code-comment">//会直接在常量池中生成一个字符串常量，并将str1的引用（指针）指向它。</span>\nString str1 = <span class="code-string">"myString"</span>;\nString str2 = <span class="code-string">"myString"</span>;\n<span class="code-comment">//都是指向常量池的同一地址，所以这里输出为true;</span>\nSystem.out.println(str1 == str2);</code></pre>\n<p>与字符串相比，数字处理的情况就比较有趣了。先看一个单纯的例子：</p>\n<pre><code class="java">Integer num1 = <span class="hljs-number">127</span>;\nInteger num2 = <span class="hljs-number">127</span>;\nInteger num3 = <span class="hljs-number">128</span>;\nInteger num4 = <span class="hljs-number">128</span>;\nSystem.out.println(num1 == num2);<span class="code-comment">//TRUE</span>\nSystem.out.println(num3 == num4);<span class="code-comment">//FALSE</span></code></pre>\n<p>第一个对比输出为true，而第二个输出为false。这就是10次Java笔试9次都会遇到的Integer 预设-128~127对象的问题——为了循环、迭代等等常见处理不反复创建新的区域来存储值，Jvm预设了部分Integer整数值，无论哪申请这些值，都指定到固定的常量地址。</p>\n<p>再来看一个有意思的例子：</p>\n<pre><code class="java"><span class="code-keyword">int</span> i = <span class="hljs-number">128</span>;\nInteger I1 = <span class="hljs-number">128</span>;\nInteger I2 = <span class="hljs-number">128</span>;\nSystem.out.println(I1 == I2);<span class="code-comment">//false</span>\nSystem.out.println(I1 == i);<span class="code-comment">//true</span>\nSystem.out.println(I2 == i);<span class="code-comment">//true</span></code></pre>\n<p>输出的结果主要受到Java5之后装箱和拆箱的机制影响。</p>\n<blockquote>\n    <p>字节码解释说明：</p>\n    <p>在每一个字节码指令之后都会有注解说明。每一行注解包括2部分内容，1是指令进行的操作描述，2是操作之后的结果。2部分用;号分割。</p>\n    <p>操作结果中S代表<strong>stack</strong>——线程栈，L代表<strong>local</strong>——本地存储。I(128)表示类型为Integer值为128的引用。"string"标示一个常量，S("string")表示类型为String值为"string"的堆数据。例如，S=[I(128)],L=[128]标示线程栈中存在一个值为128的Integer类型引用，而缓存的L[0]位置存放了值为128的整数。</p>\n    <p>缓存的下标从1开始，因为0位置已经留给了this。</p>\n    <p>用于存放指令集运算结果的本地存储我们通称为缓存。</p>\n</blockquote>\n<p>首先，在Java5之前，是不能这样写的。Java5之后有了装箱机制，这样的语句实际上执行的是 <em>Integer I1 =&nbsp;Integer.valueOf(128)</em>。所以变量I1和I2是指向2个实例的引用地址，因此 "I1==I2"是false很好理解。那么另外2个==为什么是true呢。看下面的Java代码和对应的字节码：</p>\n<pre><code class="java"><span class="code-keyword">int</span> slot1 = <span class="hljs-number">128</span>;\nInteger slot2 = <span class="hljs-number">128</span>;\nSystem.out.println(slot1 == slot2);</code></pre>\n<p>对应的字节码是：&nbsp;</p>\n<pre><code class="apache"> <span class="code-attribute">0</span>: sipush        128 //128压栈;S=[128],L=[]\n <span class="code-attribute">3</span>: istore_1          //128出栈,写入缓存;S=[],L=[128]\n <span class="code-attribute">4</span>: sipush        128 //128压栈;S=[128],L=[128]\n <span class="code-attribute">7</span>: invokestatic  #16 //128出栈,执行I.valueOf(128)结果入栈;S=[I(128)],L=[128]\n<span class="code-attribute">10</span>: astore_2          //I(128)出栈写入缓存。S=[],L=[128,I(128)]\n<span class="code-attribute">11</span>: getstatic     #22 //从常量池读取PrintStream压栈;S=[PrintStream],L=[128,I(128)]\n<span class="code-attribute">14</span>: aload_2           //缓存数据[2]压栈；S=[I(128),PrintStream],L=[128,I(128)]\n<span class="code-attribute">15</span>: invokevirtual #28 //I(128)出栈，执行I.intValue结果入栈;S=[128,PrintStream],L=[128,I(128)]\n<span class="code-attribute">18</span>: iload_1           //缓存数据[1]压栈；S=[128,128,PrintStream],L=[128,I(128)]\n<span class="code-attribute">19</span>: if_icmpne     26  //S[0]和S[1]出栈使用if_icmpne数值对比。S=[PrintStream],L=[128,I(128)]\n<span class="code-attribute">22</span>: iconst_1          //将整数1压入栈;S=[1,PrintStream],L=[128,I(128)]\n<span class="code-attribute">23</span>: goto          27  //跳转到27行\n<span class="code-attribute">26</span>: iconst_0          //将整数0压入栈;S=[0,PrintStream],L=[128,I(128)]\n<span class="code-attribute">27</span>: invokevirtual #32 //S[0]和S[1]出栈使用println输出;S=[],L=[128,I(128)]\n<span class="code-attribute">30</span>: return            \n</code></pre>\n<p>核心在4~10行装箱，将一个128整数转换成一个Integer的引用，数据存储在堆中。然后在14～19行拆箱，将堆中的Integer数据转换成一个int整数，然后再用int整数和int整数进行==比较（if_icmpne）。所以比较之后会输出true。</p>\n<p>接下来是一个解释class常量池和常量池的例子。</p>\n<p>Java代码：</p>\n<pre><code class="java">String slot1 = <span class="code-string">"myString"</span>;\nString slot2 = <span class="code-keyword">new</span> String(<span class="code-string">"myString"</span>);\nSystem.out.println(slot1 == slot2); <span class="code-comment">//FALSE</span></code></pre>\n<p>"myString"这样的字符串，在类加载编译字节码时（从class常量池转变成运行时的常量池）就会生成一个常量并放置在常量池中，随后所有使用到这个字符串的位置，都是直接从常量池引用。下面是对应的字节码：</p>\n<pre><code class="apache"> <span class="code-attribute">0</span>: ldc           #16 //常量池读取<span class="code-string">"myString"</span>压栈;S=[<span class="code-string">"myString"</span>],L=[]\n <span class="code-attribute">2</span>: astore_1          //写入本地缓存;S=[],L=[<span class="code-string">"myString"</span>]\n <span class="code-attribute">3</span>: new           #18 //堆中创建一个String实例压栈;S=[S()],L=[<span class="code-string">"myString"</span>]\n <span class="code-attribute">6</span>: dup               //复制栈顶;S=[S(),S()],L=[<span class="code-string">"myString"</span>]\n <span class="code-attribute">7</span>: ldc           #16 //常量池读取<span class="code-string">"myString"</span>压栈;S=[<span class="code-string">"myString"</span>,S(),S()],L=[<span class="code-string">"myString"</span>]\n <span class="code-attribute">9</span>: invokespecial #20 //弹出S[0,1]作为参数使用init初始化;S=[S(<span class="code-string">"myString"</span>)],L=[<span class="code-string">"myString"</span>]\n<span class="code-attribute">12</span>: astore_2          //弹出栈顶写入缓存[2];S=[],L=[<span class="code-string">"myString"</span>,S(<span class="code-string">"myString"</span>)]\n<span class="code-attribute">13</span>: getstatic     #23 //获取输出常量;S=[PrintStream],L=[<span class="code-string">"myString"</span>,S(<span class="code-string">"myString"</span>)]\n<span class="code-attribute">16</span>: aload_1           //缓存[1]入栈;S=[<span class="code-string">"myString"</span>,PrintStream],L=[<span class="code-string">"myString"</span>,S(<span class="code-string">"myString"</span>)]\n<span class="code-attribute">17</span>: aload_2           //缓存[2]入栈;S=[S(<span class="code-string">"myString"</span>),<span class="code-string">"myString"</span>,PrintStream],L=[<span class="code-string">"myString"</span>,S(<span class="code-string">"myString"</span>)]\n<span class="code-attribute">18</span>: if_acmpne     25  //弹出S[0,1]比较;S=[PrintStream],L=[<span class="code-string">"myString"</span>,S(<span class="code-string">"myString"</span>)]\n<span class="code-attribute">21</span>: iconst_1          //整数1压栈;S=[1,PrintStream],L=[<span class="code-string">"myString"</span>,S(<span class="code-string">"myString"</span>)]\n<span class="code-attribute">22</span>: goto          26  //跳转26\n<span class="code-attribute">25</span>: iconst_0          //整数0压栈;S=[0,PrintStream],L=[<span class="code-string">"myString"</span>,S(<span class="code-string">"myString"</span>)]\n<span class="code-attribute">26</span>: invokevirtual #29 //弹出S[0,1]执行输出;S=[],L=[<span class="code-string">"myString"</span>,S(<span class="code-string">"myString"</span>)]\n<span class="code-attribute">29</span>: return\n</code></pre>\n<p>Java字节码中的ldc标示从常量池获取一个引用入栈，例子将常量池的引用#16压入栈，然后astore_1将#16写到本地存储[1]位置。所以slot1 = "myString"意味着slot1指向了常量池存放"myString"的位置。</p>\n<p>3~12行完成slot2 = new String("myString")的过程：3行，new指令先在栈上创建了一个指向一个String实例堆空间的引用；6行，在栈顶复制这个引用；7行，从常量池读取"myString"这个常量的引用；9行，弹出栈顶的"myString"引用作为执行String.init方法的参数，执行完都会更新堆中的数据；12）将栈顶dup指令复制出的引用弹出并写入本地存储[2]位置。此时slot2引用了堆空间中的一个String实例。所以slot1==slot2操作（if_acmpne）肯定返回false。</p>\n<p>这个例子揭开了一个Java基础问题的答案——String s = new String("String")是创建了2个字符串还是一个？我觉得回答1个或者2个都说得过去，字面常量"String"在加载期已经创建到常量池中了，然后在运行期执行这段代码时，只是从常量池ldc到栈上然后使用它在堆中创建一个新的String实例。从运行期看，确实这个时候只创建了一个实例，但是从整个JVM来看，确实存在2个地址都有"String"的字符串。其实这个问题扩展一下来聊更有价值：</p>\n<pre><code class="java"><span class="code-keyword">package</span> example;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">StringExample</span> </span>{\n\t<span class="code-keyword">final</span> <span class="code-keyword">static</span> String static1 = <span class="code-string">"myString"</span>;\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tString slot1 = static1;\n\t\tString slot2 = <span class="code-string">"my"</span> + <span class="code-string">"String"</span>;\n\t\tString slot3 = <span class="code-keyword">new</span> String(static1);\n\t\tString slot4 = <span class="code-keyword">new</span> String(<span class="code-string">"myString"</span>);\n\t\tString slot5 = <span class="code-keyword">new</span> String(slot1);\n\t}\n}</code></pre>\n<p>问题是这个main方法运行后在整个JVM内存中创建了几个"myString"？先看了字节码再给答案。</p>\n<pre><code class="apache"><span class="code-attribute">public</span> class string.StringExample {\n  <span class="code-attribute">static</span> final java.lang.String static1; //static签名\n\n  <span class="code-attribute">public</span> string.StringExample();\n    <span class="code-attribute">Code</span>:                    //构造方法\n       <span class="code-attribute">0</span>: aload_0            //读取本地存储[0]压入栈\n       <span class="code-attribute">1</span>: invokespecial #13  //弹出栈顶引用执行Object.init方法\n       <span class="code-attribute">4</span>: return\n\n  <span class="code-attribute">public</span> static void main(java.lang.String[]); //main方法\n    <span class="code-attribute">Code</span>:\n       <span class="code-attribute">0</span>: ldc           #8   //从常量池读引用#8(<span class="code-string">"myString"</span>)压入栈\n       <span class="code-attribute">2</span>: astore_1           //弹出栈顶引用写入本地内存[1],即slot1=static1\n       <span class="code-attribute">3</span>: ldc           #8   //从常量池读#8(<span class="code-string">"myString"</span>)压入栈\n       <span class="code-attribute">5</span>: astore_2           //弹出栈顶引用写入本地内存[2],即slot2=<span class="code-string">"my"</span>+<span class="code-string">"String"</span>\n       <span class="code-attribute">6</span>: new           #21  //在堆中创建一个String实例并将引用压入栈\n       <span class="code-attribute">9</span>: dup                //复制栈顶元素\n      <span class="code-attribute">10</span>: ldc           #8   //从常量池读#8(<span class="code-string">"myString"</span>)压入栈\n      <span class="code-attribute">12</span>: invokespecial #23  //弹出栈顶引用，使用String.init方法初始化堆   \n      <span class="code-attribute">15</span>: astore_3           //弹出栈顶堆引用写入本地存储[3]\n      <span class="code-attribute">16</span>: new           #21  //16～25行执行过错和6～15行一样               \n      <span class="code-attribute">19</span>: dup\n      <span class="code-attribute">20</span>: ldc           #8                  \n      <span class="code-attribute">22</span>: invokespecial #23  \n      <span class="code-attribute">25</span>: astore        4    //栈顶元素写入本地存储[4]\n      <span class="code-attribute">27</span>: new           #21  //与16～15行一致               \n      <span class="code-attribute">30</span>: dup\n      <span class="code-attribute">31</span>: aload_1            //区别在31行是从本地存储[1]的位置读取数据，而[1]引用#8(<span class="code-string">"myString"</span>)\n      <span class="code-attribute">32</span>: invokespecial #23  \n      <span class="code-attribute">35</span>: astore        5    //栈顶元素写入本地存储[5]\n      <span class="code-attribute">37</span>: return\n}\n</code></pre>\n<p>如果看明白了字节码，这个答案就很清晰了，整个JVM一共三个值等于"myString"的字符串，即创建了3个字符串。</p>\n<p>首先，在java代码编译成字节码时，static关键字定义的常量会直接替换为字面量放置在class常量池，所以例子中&nbsp;<em>String slot3 = new String(static1)</em> 这样的写法等于&nbsp;<em>String slot3 = new String("myString") </em>。</p>\n<p>其次，常量池值只有#8的引用值为"myString"的字面量，所以在声明字符串时"my"+"String"这样的写法并不会额外生成多的字符串，编译器会直接合并为"myString"。</p>'},332:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<p>使用apt安装好处在于统一升级方便，不用单独手工安装。默认情况下nginx已经支持apt-get安装，但是安装的包是比较老旧的10.x版本。我们可以通过添加nginx\n    deb安装源的方式来使用最新稳定版的nginx，还可以实时通过update和upgrade命令保持最新的未定版nginx。</p>\n\n<h2 id="h2-1">添加apt-key</h2>\n<pre class="css"><code class="language-bash"><span class="code-selector-tag">sudo</span> <span\n        class="code-selector-tag">apt-key</span> <span class="code-selector-tag">add</span> <span\n        class="code-selector-tag">nginx_signing</span><span class="code-selector-class">.key</span></code></pre>\n<p>由于需要使用nginx官方指定的deb源下载最新稳定版本的nginx，所以需要先添加一个信任公钥（PGP）。可以将下列公钥复制保存为一个名为nginx_signing.key的文件（也可到<a\n        href="http://nginx.org/keys/nginx_signing.key" rel="nofollow">官网</a>去下载）：</p>\n<pre class="groovy"><code class="groovy">-----BEGIN PGP PUBLIC KEY BLOCK-----\n<span class="code-string"><span class="code-string">Version:</span></span> GnuPG v2<span class="hljs-number"><span\n            class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.22</span></span> (GNU/Linux)\n\nmQENBE5OMmIBCAD+FPYKGriGGf7NqwKfWC83cBV01gabgVWQmZbMcFzeW+hMsgxH\nW6iimD0RsfZ9oEbfJCPG0CRSZ7ppq5pKamYs2+EJ8Q2ysOFHHwpGrA2C8zyNAs4I\nQxnZZIbETgcSwFtDun0XiqPwPZgyuXVm9PAbLZRbfBzm8wR/<span class="hljs-number"><span class="hljs-number">3</span></span>SWygqZBBLdQk5TE\nfDR+Eny<span class="hljs-regexp"><span class="hljs-regexp">/M1RVR4xClECONF9UBB2ejFdI1LD45APbP2hsN/</span></span>piFByU1t7yK2gpFyRt\n<span class="hljs-number"><span class="hljs-number">97</span></span>WzGHn9MV5/TL7AmRPM4pcr3JacmtCnxXeCZ8nLqedoSuHFuhwyDnlAbu8I16O5\nXRrfzhrHRJFM1JnIiGmzZi6zBvH0ItfyX6ttABEBAAG0KW5naW54IHNpZ25pbmcg\na2V5IDxzaWduaW5nLWtleUBuZ2lueC5jb20+iQE+BBMBAgAoAhsDBgsJCAcDAgYV\nCAIJCgsEFgIDAQIeAQIXgAUCV2K1+AUJGB4fQQAKCRCr9b2Ce9m<span class="hljs-regexp"><span\n            class="hljs-regexp">/YloaB/</span></span><span class="hljs-number"><span class="hljs-number">9</span></span>XGrol\nkocm7l<span class="hljs-regexp"><span class="hljs-regexp">/tsVjaBQCteXKuwsm4XhCuAQ6YAwA1L1UheGOG/</span></span>aa2xJvrXE8X32tgcTjr\nKoYoXWcdxaFjlXGTt6jV85qRguUzvMOxxSEM2Dn115etN9piPl0Zz+<span class="hljs-number"><span\n            class="hljs-number">4</span></span>rkx8+<span class="hljs-number"><span class="hljs-number">2</span></span>vJG\nF+eMlruPXg/zd88NvyLq5gGHEsFRBMVufYmHtNfcp4okC1klWiRIRSdp4QY1wdrN\n<span class="hljs-number"><span class="hljs-number">1</span></span>O+<span class="hljs-regexp"><span\n            class="hljs-regexp">/oCTl8Bzy6hcHjLIq3aoumcLxMjtBoclc/</span></span><span class="hljs-number"><span\n            class="hljs-number">5</span></span>OTioLDwSDfVx7rWyfRhcBzVbwD\noe<span class="hljs-regexp"><span class="hljs-regexp">/PD08AoAA6fxXvWjSxy+dGhEaXoTHjkCbz/</span></span>l6NxrK3JFyauDgU4K4MytsZ1HDi\nMgMW8hZXxszoICTTiQEcBBABAgAGBQJOTkelAAoJEKZP1bF62zmo79oH/<span class="hljs-number"><span\n            class="hljs-number">1</span></span>XDb29S\nYtWp+MTJTPFEwlWRiyRuDXy3wBd/BpwBRIWfWzMs1gnCjNjk0EVBVGa2grvy9Jtx\nJKMd6l<span class="hljs-regexp"><span class="hljs-regexp">/PWXVucSt+U/</span></span>+GO8rBkw14SdhqxaS2l14v6gyMeUrSbY3XfToGfwHC4sa/\nThn8X4jFaQ2XN5dAIzJGU1s5JA0tjEzUwCnmrKmyMlXZaoQVrmORGjCuH0I0aAFk\nRS0UtnB9HPpxhGVbs24xXZQnZDNbUQeulFxS4uP3OLDBAeCHl+v4t/uotIad8v6J\nSO93vc1evIje6lguE81HHmJn9noxPItvOvSMb2yPsE8mH4cJHRTFNSEhPW6ghmlf\nWa9ZwiVX5igxcvaIRgQQEQIABgUCTk5b0gAKCRDs8OkLLBcgg1G+AKCnacLb/+W6\ncflirUIExgZdUJqoogCeNPVwXiHEIVqithAM1pdY/gcaQZmIRgQQEQIABgUCTk5f\nYQAKCRCpN2E5pSTFPnNWAJ9gUozyiS+<span class="hljs-number"><span class="hljs-number">9</span></span>jf2rJvqmJSeWuCgVRwCcCUFhXRCpQO2Y\nVa3l3WuB+rgKjsQ=\n=EWWI\n-----END PGP PUBLIC KEY BLOCK-----</code></pre>\n<p>然后执行以下命令：</p>\n<pre class="css"><code class="language-bash"><span class="code-selector-tag">sudo</span> <span\n        class="code-selector-tag">apt-key</span> <span class="code-selector-tag">add</span> <span\n        class="code-selector-tag">nginx_signing</span><span class="code-selector-class">.key</span></code></pre>\n\n<h2 id="h2-2">设置apt的deb源</h2>\n<p>首先需要明确当前的ubuntu版本，在安装nginx时不同的ubuntu版本对应不同的nginx安装包。对照如下：</p>\n<table border="1" cellpadding="1" cellspacing="1" style="width:500px">\n    <tbody>\n    <tr>\n        <td>版本</td>\n        <td>安装包别名</td>\n        <td>适用平台</td>\n    </tr>\n    <tr>\n        <td>14.04</td>\n        <td>trusty</td>\n        <td>x86_64, i386, aarch64/arm64</td>\n    </tr>\n    <tr>\n        <td>16.04</td>\n        <td>xenial</td>\n        <td>x86_64, i386, ppc64el, aarch64/arm64</td>\n    </tr>\n    <tr>\n        <td>17.10</td>\n        <td>artful</td>\n        <td>x86_64, i386</td>\n    </tr>\n    </tbody>\n</table>\n<p>打开apt的安装源配置文件——/etc/apt/sources.list。在文件尾部添加：</p>\n<ul>\n    <li>deb http://nginx.org/packages/ubuntu/ <span style="color:#FF0000">code</span> nginx</li>\n    <li>deb-src http://nginx.org/packages/ubuntu/ <span style="color:#FF0000">code</span> nginx</li>\n</ul>\n<p>注意标红的code需要根据ubuntu的版本号按照上面的表替换对应的别名。</p>\n<p>设置好之后使用checklog命令可以看到现在已经切换到最新的稳定版本了。（不会输出日志，只有一个版本号）</p>\n\n<h2 id="h2-3">安装nginx</h2>\n<p>最后更新安装源列表，然后安装nginx。</p>\n<pre class="sql"><code class="language-bash">apt-get <span class="code-keyword">update</span>\napt-<span class="code-keyword">get</span> <span class="code-keyword">install</span> nginx</code></pre>\n\n<h2 id="h2-4">安装最新发布版本</h2>\n<p>除了稳定版本，也可以通过apt的方式安装最新发布版本（Mainline）。只需要修改安装源头的路径即可——将/etc/apt/sources.list中的deb源修改为：</p>\n<ul>\n    <li>deb http://nginx.org/packages/mainline/ubuntu/ <span style="color:#FF0000"><em>code</em></span> nginx</li>\n    <li>deb-src http://nginx.org/packages/mainline/ubuntu/ <span style="color:#FF0000"><em>code</em></span> nginx</li>\n</ul>\n<p>更多的安装方式详见<a href="http://nginx.org/en/docs/install.html" rel="nofollow">官网</a></p>'},360:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<p>使用spring的这几个配置，可以将旧&lt;xml&gt;配置形式完全使用Java实现，也可以和&lt;xml&gt;嵌套使用。</p>\n<p>@Configuration和@Bean可以配合使用,案例：</p>\n<p>传统XML配置：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n                class="code-string">"classA"</span> <span class="hljs-attr">class</span>=<span class="code-string">"com.ClassA"</span>&gt;</span>\n                <span class="code-tag">&lt;<span class="code-name">constructor-arg</span> <span\n                        class="hljs-attr">ref</span>=<span class="code-string">"ClassB"</span>/&gt;</span>\n        <span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n                class="code-string">"classB"</span> <span class="hljs-attr">class</span>=<span class="code-string">"com.ClassB"</span>&gt;</span>\n                <span class="code-tag">&lt;<span class="code-name">constructor-arg</span> <span\n                        class="hljs-attr">ref</span>=<span class="code-string">"c"</span>/&gt;</span>\n        <span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n                class="code-string">"classC"</span> <span class="hljs-attr">class</span>=<span class="code-string">"com.ClassC"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>对应的可以使用@Configuration和@Bean来实现：</p>\n<pre><code class="java"><span class="code-meta">@Configuration</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">config</span></span>{\n        <span class="code-keyword">public</span> <span class="code-meta">@Bean</span> <span class="hljs-function">ClassA <span\n            class="code-title">classA</span><span class="hljs-params">()</span> </span>{\n                <span class="code-keyword">return</span> <span class="code-keyword">new</span> ClassA(classB());\n        }\n        <span class="code-keyword">public</span> <span class="code-meta">@Bean</span> <span class="hljs-function">ClassB <span\n            class="code-title">classB</span><span class="hljs-params">()</span> </span>{\n                <span class="code-keyword">return</span> <span class="code-keyword">new</span> ClassB(c());\n        }\n        <span class="code-keyword">public</span> <span class="code-meta">@Bean</span> <span class="hljs-function">ClassC <span\n            class="code-title">classC</span><span class="hljs-params">()</span> </span>{\n\n        }\n}</code></pre>\n<p>@DependsOn注解类似于&lt;xml&gt;的depends-on元素，案例如下：</p>\n<pre><code class="java"><span class="code-meta">@DependsOn</span>({<span class="code-string">"classA"</span>,<span\n        class="code-string">"classB"</span>})\n<span class="code-meta">@Component</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">ClassC</span></span>{\n   <span class="code-comment">//codes here</span>\n}</code></pre>\n<p>这样，在初始化ClassC之前，一定会先初始化ClassA和ClassB。</p>\n<p>@Import是导入通过@Configuration配置的Bean。</p>\n<p>先通过@Configuration声明配置类</p>\n<pre><code class="java"><span class="code-meta">@Configuration</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Config</span> </span>{\n    <span class="code-keyword">public</span> <span class="code-meta">@Bean</span> <span\n            class="hljs-function">ClassA <span class="code-title">classA</span> <span\n            class="hljs-params">()</span> </span>{\n        <span class="code-keyword">return</span> <span class="code-keyword">new</span> ClassA();\n    }\n}</code></pre>\n<p>然后使用@Import导入配置类</p>\n<pre><code class="java"><span class="code-meta">@Configuration</span>\n<span class="code-meta">@Import</span>(Config.class)  <span class="code-comment">//导入CDConfig的配置</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">ConfigExt</span> </span>{\n    <span class="code-meta">@Bean</span>(name = <span class="code-string">"classB"</span>)\n    <span class="hljs-function"><span class="code-keyword">public</span> ClassB <span\n            class="code-title">classB</span><span class="hljs-params">(ClassA classA)</span> </span>{\n        <span class="code-comment">// 注入ClassA类型的bean</span>\n        <span class="code-keyword">return</span> <span class="code-keyword">new</span> ClassB(classA);\n    }\n}</code></pre>\n<p>@ImportResource类似于XML配置的&lt;import&gt;元素，如：&lt;import resource="importxml.xml" /&gt;。</p>\n<p>使用方式如下：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"classA"</span> <span class="hljs-attr">class</span>=<span\n        class="code-string">"com.ClassA"</span>&gt;</span>\n       <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n               class="code-string">"classB"</span> <span class="hljs-attr">ref</span>=<span\n               class="code-string">"classB"</span> /&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"classB"</span> <span class="hljs-attr">class</span>=<span\n        class="code-string">"com.ClassB"</span>/</span></code></pre>\n<p>Java类注入：</p>\n<pre><code class="java"><span class="code-meta">@Configuration</span>\n<span class="code-meta">@Import</span>(Config.class)  \n<span class="code-meta">@ImportResource</span>(<span class="code-string">"classpath:importxml.xml"</span>) <span\n            class="code-comment">//导入xml配置项</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">ConfigExt</span></span>{\n\n}</code></pre>'},363:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<p>“Spring”——每一个Javaer开发者都绕不开的字眼，从21世纪第一个十年国内异常活跃的SSH框架，到现在以Spring\n    Boot作为入口粘合了各种应用。Spring现在已经完成了从web入口到微服务架构再到数据处理整个生态，看着现在<a href="https://spring.io/projects" rel="nofollow">https://spring.io/projects</a>上长长的项目清单，一脸懵逼的自问到这些到底是啥？可以干嘛？\n</p>\n\n<h2 id="h2-1">一切都从IoC开始</h2>\n<p>\n    早期的Spring并没有这么多亮瞎眼的项目，仅仅是围绕着core、context、beans以及MVC提供了一个简单好用搭建网站级应用的工具。那个时候完全是一个与J2EE的繁杂多样对抗简单便捷的小清新。Srping之父Rod的一本《J2EE\n    Development without\n    EJB》宣告J2EE那么名堂完全没多大用处。经过这么多年的发展，事实也证明除了Servlet、JDBC以及JSP似乎其他东西可有可无。后来Vertx、WebFlux等Reactive机制框架的出现，以及前后端分离开发的盛行，似乎Servlet也可有可无了、jsp也快消失了。所以现在Oracle干脆把J2EE这个烫手山芋直接丢给开源社区了。</p>\n<p>Rod的轮子理论造就了Spring的2大核心概念——IoC（Inversion of Control）和beans。Spring\n    IoC和Beans的概念度娘、谷哥一搜一大把，在此就不重复介绍了。个人认为IoC和Beans最基本的实现思想来自于设计模式的几大原则，它之所以这么好用并且深入人心就是体现了设计模式的精髓。</p>\n<p><strong>依赖倒转原则：</strong>Spring的介绍Framework文档的开篇就提到反向依赖注入（DI——<em>dependency injection</em>&nbsp;），其目标是让调用者不要主动去使用被调用者，而是让被调用者向调用者提供服务。IoC和beans的配合完美实现了这个过程，一个@component注解添加一个bean到Ioc容器，一个@autowired注解Ioc容器会找到对应的类注入进来。\n</p>\n<p><strong>接口隔离原则：</strong>Ioc不仅仅根据class类型注入bean，他还会根据接口类型自动装配注入一个bean。</p>\n<p><strong>里氏代换原则：</strong>在接口隔离的原则的基础上我们可以利用XML配置文件来制定装配的服务。例如javax.sql.DataSource是Java里提供数据库链接服务的接口，世面上有各种各样开源或闭源的工具实现了DataSource接口，例如c3p0和druid。我们想要切换他们仅仅需要像下面这样添加或删除一个bean（当然先要引入Jar包）:\n</p>\n<pre><code class="xml"><span class="code-comment">&lt;!-- c3p0 --&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"ds"</span> <span class="hljs-attr">class</span>=<span class="code-string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span>\n     <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n             class="code-string">"driverClass"</span> <span class="hljs-attr">value</span>=<span class="code-string">"com.mysql.jdbc.Driver"</span>/&gt;</span>\n     <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n             class="code-string">"jdbcUrl"</span> <span class="hljs-attr">value</span>=<span class="code-string">"jdbc:mysql://localhost:3306/c3p0jdbctemplate"</span>/&gt;</span>\n     <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n             class="code-string">"user"</span> <span class="hljs-attr">value</span>=<span\n             class="code-string">"admin"</span>/&gt;</span>\n     <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n             class="code-string">"password"</span> <span class="hljs-attr">value</span>=<span class="code-string">"123456"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n<span class="code-comment">&lt;!-- druid --&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"dataSource"</span> <span class="hljs-attr">class</span>=<span class="code-string">"com.alibaba.druid.pool.DruidDataSource"</span>&gt;</span>\n     <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n             class="code-string">"url"</span> <span class="hljs-attr">value</span>=<span class="code-string">"jdbc:mysql://localhost:3306/c3p0jdbctemplate"</span> /&gt;</span>\n\t <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n             class="code-string">"username"</span> <span class="hljs-attr">value</span>=<span class="code-string">"admin"</span>/&gt;</span>\n\t <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n             class="code-string">"password"</span> <span class="hljs-attr">value</span>=<span class="code-string">"123456"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n</code></pre>\n<p><strong>聚合复用原则：</strong>SpringFramework号称非侵入式框架，我们在使用的过程中也很少有继承的情况，基本上所有的特性都是通过注解（Annotation）来实现，需要某一项服务也是将其注入后使用。虽然我们在开发的过程中为了实现一些高级功能会继承重写某些方法后，然后再将我们的新类添加到Ioc中，但是Spring本身并不太鼓励这样去实现。\n</p>\n<p>除了前面4项原则，<strong>迪米特法则</strong>和<strong>开闭原则</strong>并没有太直观的体现。对于迪米特法则来说Ioc机制本身就实现了调用者与被调用者之间不会直接发生依赖关系（new创建）。而开闭原则，Spring框架本身那么多构建类都是按照这个原则开发的——新功能用新的类实现，而非增加原有方法。\n</p>\n\n<h2 id="h2-2">Beans</h2>\n\n<h3 id="h3-1">配置</h3>\n<p>\n    现在我们知道Spring的2大核心是IoC和Beans。IoC字面翻译叫“控制反转”，这个“反转”过程实现的思想其实蛮简单的：就是先有一个容器（container），我们把实现各种功能的bean（一个类的实例）一股脑向容器里面扔，至于最后这些bean被谁用了通过配置和注解来确定。</p>\n<p>\n    上面提到了配置，在2.5版本之前配置只能通过XML文件实现，之后引入了annotation配置的方式，然后3.x版本之后可以完全使用Java代码来实现配置而无需XML文件。配置文件的格式和作用其实也不复杂，就是告诉容器我要扔进去什么bean。扔进去的bean当然需要初始化一些数据了，丢一个光秃秃没有任何数据的实例到容器中貌似也没多大用处，所以XML文件中就提供了一些标签来标记如何初始化数据：</p>\n<pre><code class="xml"><span class="php"><span class="code-meta">&lt;?</span>xml version=<span\n        class="code-string">"1.0"</span> encoding=<span class="code-string">"UTF-8"</span><span\n        class="code-meta">?&gt;</span></span>\n<span class="code-comment">&lt;!-- 省略xmlns --&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">beans</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n            class="code-string">"otherBean"</span> <span class="hljs-attr">class</span>=<span class="code-string">"myProject.OtherBean"</span> /&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n            class="code-string">"myBean"</span> <span class="hljs-attr">class</span>=<span class="code-string">"myProject.MyClass"</span>&gt;</span>\n        <span class="code-comment">&lt;!-- 通过setOtherBean方法设置OtherBean的实例 --&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"otherBean"</span> <span class="hljs-attr">ref</span>=<span class="code-string">"otherBean"</span>/&gt;</span>\n        <span class="code-comment">&lt;!-- 通过setValue方法设置数值 --&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"value"</span> <span class="hljs-attr">value</span>=<span class="code-string">"myValue"</span>/&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n\n<h3 id="h3-2">参数</h3>\n<p>下面是Bean相关的参数，它们可以用<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-definition"\n        rel="nofollow">XML&lt;bean&gt;标签</a>来配置，也可以用<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-java-bean-annotation"\n        rel="nofollow">@bean</a>传递一个参数来设定：</p>\n<table border="1" cellpadding="1" cellspacing="1" style="width:500px">\n    <tbody>\n    <tr>\n        <td>class</td>\n        <td>标记当前Bean加载的类</td>\n    </tr>\n    <tr>\n        <td>name</td>\n        <td>\n            <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-beanname"\n               rel="nofollow">Bean的别名和名称。</a></td>\n    </tr>\n    <tr>\n        <td>\n            <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes"\n               rel="nofollow">scope</a></td>\n        <td>Bean的范围，默认是单例。</td>\n    </tr>\n    <tr>\n        <td>\n            <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-collaborators"\n               rel="nofollow">constructor</a></td>\n        <td>构造函数注入&lt;constructor-arg /&gt;</td>\n    </tr>\n    <tr>\n        <td>\n            <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-collaborators"\n               rel="nofollow">properties</a></td>\n        <td>属性注入&lt;property&gt;</td>\n    </tr>\n    <tr>\n        <td>autowiring</td>\n        <td>\n            <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire"\n               rel="nofollow">auto注入模式</a></td>\n    </tr>\n    <tr>\n        <td>lazy</td>\n        <td>\n            <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lazy-init"\n               rel="nofollow">懒加载模式</a></td>\n    </tr>\n    <tr>\n        <td>initialization</td>\n        <td>\n            <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lifecycle-initializingbean"\n               rel="nofollow">制定初始化类时执行的方法</a></td>\n    </tr>\n    <tr>\n        <td>destruction</td>\n        <td>\n            <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lifecycle-disposablebean"\n               rel="nofollow">制定类销毁时要执行的方法</a></td>\n    </tr>\n    </tbody>\n</table>\n<p>Spring Framework的官网用了一个小节专门介绍bean的命名方式，既可以用id来标识，又可以用name来标识，第一次看还挺晕乎的。</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"myBeanId"</span> <span class="hljs-attr">name</span>=<span class="code-string">“myAlias1,myAlias2”</span> /&gt;</span></code></pre>\n<p>其实注意一下四点即可：</p>\n<ol>\n    <li>id和name均可以标识一个bean，但是id必须是全局一对一的，而一个bean可以用多个name，用,号分割。</li>\n    <li>如果不给bean制定id，那么容器会为他自动生成一个唯一的序列号。</li>\n    <li>name可以配合&lt;alias&gt;标签使用来转换别名。</li>\n</ol>\n<p>个人感觉使用spring到现在name出现场景并不多，也很少看到哪个开源项目通过name的方式向外暴露服务。</p>\n\n<h3 id="h3-3">创建模式与Scope</h3>\n<p>\n    Bean只是一个和IoC容器相对应的概念：IoC容器存放并管理bean，bean是IoC机制的最小工作单元。往后的AOP等功能都是建立在Bean的基础上拓展开来的——要使用Spring这些功能首先得是一个Ioc容器中的Bean。Bean实际上就是一个Java类的实例，只不过实例化工作交给了Ioc容器而已。</p>\n<p>Bean的实例化有3种方式——构造方法创建、静态工厂、动态工厂。每一个Bean对应的<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes"\n        rel="nofollow">Scope</a>实际上就2个参数——<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-singleton"\n        rel="nofollow">singleton</a>与<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-prototype"\n        rel="nofollow">prototype</a>（实际上还有其他参数可以使用，这里说只有2个具体原因见后面Scope的说明）。</p>\n\n<h4 id="h4-1">单例构造创建</h4>\n<p>90%的Bean都是直接通过这种方法方法来创建的。这也是我们最常见的配置方式：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"myBean"</span> <span class="hljs-attr">class</span>=<span class="code-string">"myProject.MyClass"</span> /&gt;</span></code></pre>\n<p>当以上面这样的方式配置一个bean时，Ioc容器会直接调用构造方法来创建一个类实例（当然在定义类时必须提供一个公开的构造方法）。由于默认情况下bean的scope参数是<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-singleton"\n        rel="nofollow">singleton</a>，所以创建出来bean在不指定scope的状态下都是一个单例。</p>\n<p>某些时候我们会在类当中再用static 来设定一个嵌入类：</p>\n<pre><code class="java"><span class="code-keyword">package</span> myProject;\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MyClass</span> </span>{\n\t<span class="code-keyword">static</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">MyNestClass</span></span>{\n\t\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-title">MyNestClass</span><span\n                class="hljs-params">()</span></span>{}\n\t}\n}</code></pre>\n<p>可以通过“$”符号关联的方式创建这个Bean：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"myBean"</span> <span class="hljs-attr">class</span>=<span class="code-string">"myProject.MyClass$MyNestClass"</span> /&gt;</span></code></pre>\n\n<h4 id="h4-2">静态工厂创建</h4>\n<p>静态工厂创建bean和静态工厂模式的概念一样，就是指定一个工厂类，然后通过一个静态方法返回一个新的bean。</p>\n<p>XML配置：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"myFactory"</span>\n    <span class="hljs-attr">class</span>=<span class="code-string">"myProject.MyFactory"</span>\n    <span class="hljs-attr">factory-method</span>=<span\n            class="code-string">"createInstance"</span>/&gt;</span></code></pre>\n<p>工厂类：</p>\n<pre><code class="java"><span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MyFactory</span> </span>{\n    <span class="code-keyword">static</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">MyClass</span></span>{};\n    <span class="code-keyword">private</span> <span class="code-keyword">static</span> MyClass myClass = <span\n            class="code-keyword">new</span> MyClass();\n    <span class="hljs-function"><span class="code-keyword">private</span> <span class="code-title">MyFactory</span><span\n            class="hljs-params">()</span> </span>{}\n\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> MyClass <span\n            class="code-title">createInstance</span><span class="hljs-params">()</span> </span>{\n        <span class="code-keyword">return</span> myClass;\n    }\n}</code></pre>\n\n<h4 id="h4-3">动态工厂创建</h4>\n<p>动态工厂在设计模式上叫“抽象工厂”，spring官网将其自称为实例工厂（instance\n    factory）。这里叫“动态工厂”是想对他们加以区分。虽然“实例工厂”并不是教科书似的抽象工厂，但是目的就是实现工厂动态创建。动态工厂与静态工厂最大的区别就是会先将工厂本身设置成一个bean（实例化），然后再通过这个工厂bean来创建“产品bean”。看下面的例子：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"myLocator"</span> <span class="hljs-attr">class</span>=<span class="code-string">"myProject.MyLocator"</span>&gt;</span>\n    <span class="code-comment">&lt;!-- 自身就是一个实例化的bean，可以设定任何bean的配置 --&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n\n<span class="code-comment">&lt;!-- 绑定bean与一个动态工厂 --&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"instanceFactory"</span>\n    <span class="hljs-attr">factory-bean</span>=<span class="code-string">"myLocator"</span>\n    <span class="hljs-attr">factory-method</span>=<span\n            class="code-string">"createInstance"</span>/&gt;</span></code></pre>\n<pre><code class="java"><span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MyFactory</span> </span>{\n    <span class="code-keyword">static</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">MyClass</span></span>{};\n    <span class="hljs-function"><span class="code-keyword">public</span> MyClass <span\n            class="code-title">createInstance</span><span class="hljs-params">()</span> </span>{\n        <span class="code-keyword">return</span> <span class="code-keyword">new</span> MyClass();\n    }\n}</code></pre>\n<p>一个工厂可以同时用于创建多个bean方法：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"myLocator"</span> <span class="hljs-attr">class</span>=<span class="code-string">"myProject.MyFactory"</span> /&gt;</span>\n\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"serverOne"</span>\n    <span class="hljs-attr">factory-bean</span>=<span class="code-string">"myLocator"</span>\n    <span class="hljs-attr">factory-method</span>=<span class="code-string">"createClassOne"</span>/&gt;</span>\n\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"serverTwo"</span>\n    <span class="hljs-attr">factory-bean</span>=<span class="code-string">"myLocator"</span>\n    <span class="hljs-attr">factory-method</span>=<span\n            class="code-string">"createClassTwo"</span>/&gt;</span></code></pre>\n<pre><code class="java"><span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MyFactory</span> </span>{\n    <span class="code-keyword">static</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">MyServerOne</span></span>{};\n    <span class="code-keyword">static</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">MyServerTwo</span></span>{};\n    \n    <span class="hljs-function"><span class="code-keyword">public</span> MyServerOne <span class="code-title">createClassOne</span><span\n            class="hljs-params">()</span> </span>{\n        <span class="code-keyword">return</span> <span class="code-keyword">new</span> MyServerOne();\n    }\n    <span class="hljs-function"><span class="code-keyword">public</span> MyServerTwo <span class="code-title">createClassTwo</span><span\n            class="hljs-params">()</span> </span>{\n        <span class="code-keyword">return</span> <span class="code-keyword">new</span> MyServerTwo();\n    }\n}</code></pre>\n\n<h4 id="h4-4">为什么需要实例化方法</h4>\n<p>可能你会想，Spring实例化提供一个简单的bean创建实例就好了，干嘛还要整静态工厂、抽象工厂之类的东西？</p>\n<p>\n    实际上我个人认为Spring的架构大神们是想通过一套简单的机制帮你实现设计模式中的所有创建模式——静态工厂、抽象工厂、单例模式、建造者模式和原型模式。因为IoC的最大任务之一就是代替我们创建各种Bean（类实例），而类实例的创建无非就是这几种创建模式。</p>\n<p>这里仅仅介绍了2种工厂模式，下面将结合Bean的Scope属性介绍其他模式的思路。</p>\n\n<h4 id="h4-5">Scope</h4>\n<p>scope直译过来叫范围、界限、广度。不过按照字面意思理解Bean的Scopd属性肯定要跑偏的。Scope数据涉及2个层面的含义。</p>\n<p>首先在实现层面，对于设计模式来说，Scope就只有2种模式——<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-singleton"\n        rel="nofollow">singleton</a>模式和<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-prototype"\n        rel="nofollow">prototype</a>模式。</p>\n<p>其次在应用层面，除了上面2个，Scope还提供了<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-request"\n        rel="nofollow">request</a>、<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-session"\n        rel="nofollow">session</a>、<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-application"\n        rel="nofollow">application</a>、<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/web.html#websocket-stomp-websocket-scope"\n        rel="nofollow">websocket</a>。从字面上看就知道实际上这些Scope参数仅仅是指定了一个bean的适用范围。</p>\n<p>\n    以<a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-request"\n        rel="nofollow">request</a>为例，要启用他需要保证应用的“上下文”是web模式，例如XmlWebApplicationContext，其他情况下会抛出异常。然后"scope=request"的工作方式就是外部发起一个请求后，web层（servlet）启用一个线程来响应这个请求。到了业务层面我们需要指定一些bean来处理这个请求，当这些bean设定为request时，那么它仅仅用于这一次请求就抛弃。下一次请求出现时会创建一个新的实例。\n</p>\n<p>所以不管是<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-request"\n        rel="nofollow">request</a>、<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-session"\n        rel="nofollow">session</a>、<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-application"\n        rel="nofollow">application</a>还是<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/web.html#websocket-stomp-websocket-scope"\n        rel="nofollow">websocket</a>，实际上都是通过<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-prototype"\n        rel="nofollow">prototype</a>模式创建的实例，也就是设计模式中的原型模式，虽然并不一定是教科书般的标准，但是在整个容器中他实现了原型的特性。</p>\n<p>\n    此外<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-singleton"\n        rel="nofollow">singleton</a>模式和&nbsp;Gang of Four\n    (GoF)中定义的通过ClassLoad实现的单例模式也有很大的区别，但是对于Ioc容器而言，任何bean在一个容器中绝对是一个单例，现在所有的资源都通过容器来管理依赖关系，那么最终的效果也是一个单例。</p>\n\n<h4 id="h4-6">建造者模式</h4>\n<p>到目前为止，还有一个创建模式未出场——建造者模式。建造者模式实际上就是通过一个标准的方法组装一个复杂的对象。</p>\n<p>\n    标准的建造者模式先得有一个Director提供外部访问接口，外部调用者要创建一个复杂对象时向接口传递指定参数，然后Director根据参数调用Builder提供的各种方法，这些方法再用concrete去构建最终的Product。</p>\n<p>实际上把复杂对象创建的过程看成各个bean依赖构造的过程即可实现模式，例如：</p>\n<pre><code class="xml"><span class="code-comment">&lt;!-- cpu部件 --&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"amdCpu"</span> <span class="hljs-attr">class</span>=<span class="code-string">"myProject.cpu.Amd"</span>/&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"intelCpu"</span> <span class="hljs-attr">class</span>=<span class="code-string">"myProject.cpu.Intel"</span>/&gt;</span>\n<span class="code-comment">&lt;!-- 显卡部件 --&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"amdGraphics"</span> <span class="hljs-attr">class</span>=<span class="code-string">"myProject.graphics.Amd"</span>/&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"nvdiaGraphics"</span> <span class="hljs-attr">class</span>=<span class="code-string">"myProject.graphics.Nvdia"</span>/&gt;</span>\n\n<span class="code-comment">&lt;!-- 组装电脑1 --&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"myComputer"</span> <span class="hljs-attr">class</span>=<span class="code-string">"myProject.computer.MyComputer"</span>&gt;</span>\n     <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n             class="code-string">"cpu"</span> <span class="hljs-attr">ref</span>=<span\n             class="code-string">"amdCpu"</span>/&gt;</span>\n     <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n             class="code-string">"graphics"</span> <span class="hljs-attr">ref</span>=<span class="code-string">"nvdiaGraphics"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n\n<span class="code-comment">&lt;!-- 组装电脑2 --&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"yourComputer"</span> <span class="hljs-attr">class</span>=<span class="code-string">"myProject.computer.YourComputer"</span>&gt;</span>\n     <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n             class="code-string">"cpu"</span> <span class="hljs-attr">ref</span>=<span\n             class="code-string">"intelCpu"</span>/&gt;</span>\n     <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n             class="code-string">"graphics"</span> <span class="hljs-attr">ref</span>=<span class="code-string">"amdGraphics"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span></code></pre>'}});