webpackJsonp([6],{358:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<p>在<a href="https://www.chkui.com/article/spring/spring_core_ioc_extension_points" title="IoC功能扩展点">IoC功能扩展点</a>这篇文章中介绍了BeanFactoryPostProcessor及其使用方法，本篇介绍Spring官方提供的典型BeanFactoryPostProcessor。\n</p>\n\n<h2 id="h2-1">占位符参数替换——PropertyPlaceholderConfigurer</h2>\n<p>\n    如果你的工程有很多配置内容放置到Java的标准配置文件*.properties中，当把Properties的内容整合到Spring中时就会用到PropertyPlaceholderConfigurer。PropertyPlaceholderConfigurer3个功能：</p>\n<ol>\n    <li>将配置中${property-name}格式的占位符换为加载的*.properties文件中的内容。</li>\n    <li>将配置中${property-name}格式的占位符替换为环境变量systemProperties（System.getProperty(key)）中的内容。</li>\n    <li>如果文件和环境中有相同的key，按照规则对数据进行合并。</li>\n</ol>\n\n<h3 id="h3-1">基本使用方法</h3>\n<p>PropertyPlaceholderConfigurer继承了配置BeanFactoryPostProcessor接口，在IoC开始初始化Bean之前修改对应<a\n        href="https://www.chkui.com/article/spring/spring_core_ioc_extension_points" title="IoC功能扩展点">BeanDefinition</a>。在使用时我们直接向容器添加一个PropertyPlaceholderConfigurer即可：\n</p>\n<pre><code class="xml"><span class="code-comment">&lt;!-- 启用占位符替换需要引入PropertyPlaceholderConfigurer --&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n        class="code-string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span>\n    <span class="code-comment">&lt;!-- 指定*.properties文件的路径 --&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"locations"</span> <span class="hljs-attr">value</span>=<span class="code-string">"classpath:project/config.properties"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n\n<span class="code-comment">&lt;!-- 替换Bean中的内容 --&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"A"</span> <span class="hljs-attr">class</span>=<span\n        class="code-string">"x.y.z.User"</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"name"</span> <span class="hljs-attr">value</span>=<span class="code-string">"${user.name}"</span>/&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"address"</span> <span class="hljs-attr">value</span>=<span class="code-string">"${user.address}"</span>/&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"age"</span> <span class="hljs-attr">value</span>=<span class="code-string">"${user.age}"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span></code></pre>\n<p>对应的config.properties文件中的内容：</p>\n<pre><code class="json">user.name=\'Alice\'\nuser.address=\'China\'\nuser.age=<span class="hljs-number">20</span></code></pre>\n<p>除了直接引入一个Bean，可以通过全局上下文配置启动这一项功能：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">context:property-placeholder</span> <span\n        class="hljs-attr">location</span>=<span\n        class="code-string">"classpath:project/config.properties"</span>/&gt;</span></code></pre>\n\n<h3 id="h3-2">设置环境变量加载行为</h3>\n<p>\n    前面说了PropertyPlaceholderConfigurer除了会用*.properties文件中的参数去替换占位符的内容，还会使用环境变量（System.getProperty(key)）中的参数去替换。如果一个参数在配置文件中和系统环境变量中都存在，那么默认会使用*.properties中的参数来替换配置中的占位符。可以使用PropertyPlaceholderConfigurer::systemPropertiesMode来修改这个行为。他接受3个参数：</p>\n<ul>\n    <li>PropertyPlaceholderConfigurer.SYSTEM_PROPERTIES_MODE_NEVER(0)：从不加载环境变量中的参数。</li>\n    <li>PropertyPlaceholderConfigurer.SYSTEM_PROPERTIES_MODE_FALLBACK(1)：优先使用*.properties文件中的变量，如果不存在再使用环境变量中的。</li>\n    <li>PropertyPlaceholderConfigurer.SYSTEM_PROPERTIES_MODE_OVERRIDE(2)：优先使用环境变量中的参数。</li>\n</ul>\n<p>可以这样设置：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span\n        class="hljs-attr">class</span>=<span class="code-string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span>\n    <span class="code-comment">&lt;!-- 优先使用环境变量中的参数 --&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"systemPropertiesMode"</span> <span class="hljs-attr">value</span>=<span\n            class="code-string">"2"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span></code></pre>\n\n<h3 id="h3-3">动态设置参数&amp;动态替换类</h3>\n<p>除了通过环境变量和*.properties配置文件引入参数，还可以直接写在XML的配置上：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span\n        class="hljs-attr">class</span>=<span class="code-string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span>\n    <span class="code-comment">&lt;!-- 加载资源文件位置 --&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"locations"</span>&gt;</span>\n        <span class="code-tag">&lt;<span\n                class="code-name">value</span>&gt;</span>classpath:myProject/config.properties<span class="code-tag">&lt;/<span\n            class="code-name">value</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">property</span>&gt;</span>\n    <span class="code-comment">&lt;!-- 动态添加配置参数 --&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"properties"</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">value</span>&gt;</span>define.runtime.class=x.y.z.A<span\n            class="code-tag">&lt;/<span class="code-name">value</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">property</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n<span class="code-comment">&lt;!-- 动态加载一个类 --&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span class="code-string">"${define.runtime.class}"</span>/&gt;</span></code></pre>\n<p>上面XML配置还展示了一个动态装载类的方法。</p>\n\n<h2 id="h2-2">按命名规则注入——PropertyOverrideConfigurer</h2>\n<p>\n    PropertyOverrideConfigurer就是在PropertyPlaceholderConfigurer的基础上扩展了一些功能节约一些写配置文件的时间。他可以让你不必在XML文件写占位符而直接注入数据。看下面的例子：</p>\n<p>通过&lt;bean&gt;标签引入了PropertyOverrideConfigurer类，然后有一个独立的User单例，以及将Cpu、Ram、Graphics单例组合到Pc中。</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span>&gt;</span>\n    <span class="code-comment">&lt;!-- 引入PropertyOverrideConfigurer --&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"org.springframework.beans.factory.config.PropertyOverrideConfigurer"</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"locations"</span> <span class="hljs-attr">value</span>=<span class="code-string">"classpath:xml/configoverride/config.properties"</span>/&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n    <span class="code-comment">&lt;!-- 配置Bean之间的组合关系 --&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n            class="code-string">"user"</span> <span class="hljs-attr">class</span>=<span class="code-string">"chkui.springcore.example.xml.configoverride.User"</span> /&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n            class="code-string">"cpu"</span> <span class="hljs-attr">class</span>=<span class="code-string">"chkui.springcore.example.xml.configoverride.entity.Cpu"</span> /&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n            class="code-string">"ram"</span> <span class="hljs-attr">class</span>=<span class="code-string">"chkui.springcore.example.xml.configoverride.entity.Ram"</span> /&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n            class="code-string">"graphics"</span> <span class="hljs-attr">class</span>=<span class="code-string">"chkui.springcore.example.xml.configoverride.entity.Graphics"</span> /&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n            class="code-string">"pc"</span> <span class="hljs-attr">class</span>=<span class="code-string">"chkui.springcore.example.xml.configoverride.entity.Pc"</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"cpu"</span> <span class="hljs-attr">ref</span>=<span\n                class="code-string">"cpu"</span>/&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"ram"</span> <span class="hljs-attr">ref</span>=<span\n                class="code-string">"ram"</span>/&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"graphics"</span> <span class="hljs-attr">ref</span>=<span class="code-string">"graphics"</span>/&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>对应的*.properties配置是这样的：</p>\n<pre><code class="bash">user.name=Alice\nuser.address=china\nuser.age=20\n\npc.cpu.brand=AMD\npc.graphics.brand=Nvdia\npc.ram.brand=Kingston</code></pre>\n<p>Cpu类的结构：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.xml.configoverride.entity;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Cpu</span> </span>{\n\t<span class="code-keyword">private</span> String brand;\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">getBrand</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> brand;\n\t}\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setBrand</span><span class="hljs-params">(String brand)</span> </span>{\n\t\t<span class="code-keyword">this</span>.brand = brand;\n\t}\n}</code></pre>\n<p>这个时候PropertyOverrideConfigurer会根据容器中Bean的id或name来注入数据，比如*.properties配置中的"pc"就对应XML中的&lt;bean id="pc"&gt;，接着pc中有一个域（成员变量）名为cpu那么它对应*.properties配置文件中"pc.cpu."，所以pc.cpu.brand=AMD的配置会告诉PropertyOverrideConfigurer向pc单例中的cpu实例的"brand"域注入数据"AMD"。</p>\n<p>所以使用PropertyOverrideConfigurer运行之后，不需要在XML使用${property-name}这样的参数它会按照id或name的结构注入数据，此时user.getName() ==\n    "Alice"。如果类的关系是这个多层的结构一样可以根据Properties的结构注入数据，例如 pc.getPc().getBrand() == "AMD"。</p>\n<p>例子的可执行代码见<strong><a\n        href="https://gitee.com/chkui-com/spring-core-sample/tree/master/src/main/java/chkui/springcore/example/xml/configoverride"\n        rel="nofollow">本人码云库中configoverride包</a>。</strong></p>'},366:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h3 id="h3-1">依赖注入</h3>\n<p>在<a href="https://www.chkui.com/article/spring/spring_core_design_pattern_and_ioc" rel="nofollow">设计模式与IoC</a>这篇文章中，介绍了Spring基础的三大支柱的两项内容——IoC、Bean。本篇将继续围绕着Bean的创建时的注入方式来介绍Spring的核心思想与设计模式。\n</p>\n<p>天底下所有面向对象的语言都不可能只用一个类来解决问题，即使是最简单的应用程序都存在类与类之间的依存关系。如下面这个人人都理解的组合例子：</p>\n<pre><code class="java"><span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">Foo</span></span>{\n   <span class="code-keyword">private</span> Other other;\n   <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-title">Foo</span><span\n           class="hljs-params">()</span></span>{\n      other = <span class="code-keyword">new</span> Other();\n   }\n}\n\n<span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">Other</span></span>{}</code></pre>\n<p>在设计模式上关于类的组合与继承的适用性不属于本篇的讨论范围，但是从Spring框架非侵入式的设计思路来看，组合才是使用Spring的正确姿势。</p>\n<p>官方将这种组合的关系叫做“依赖注入（DI——<em>Dependency injection</em>）”。从名字上来看这也是一种依托Ioc容器很自然的实现方式——所有的Bean都放置在容器中，然后通过一些配置来告诉容器bean与bean之间的依存关系。一个类除了在内部块中通过new关键字实现一个组合关系，也可以通过构造方法传参或接口方法设置。\n</p>\n<p>由于IoC容器不可能去修改一个类内部的代码，所以类与类的组合方式通过构造方法（Constructor）和set方法（Setter）来实现。此外，Ioc可以根据接口（interface）来注入对应的实现类（class extands\n    interface）,所以从设计模式的角度来说，依赖注入的方式很好的规避了<strong>标准组合模式</strong>中new关键字违反<strong>依赖倒置原则</strong>的问题。</p>\n\n<h3 id="h3-2">构造方法注入</h3>\n<p>直接通过构造方法注入组合数据。</p>\n<p>class：</p>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">A</span> </span>{\n    <span class="code-keyword">private</span> B b;\n    <span class="code-keyword">private</span> C c;\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-title">Foo</span><span\n            class="hljs-params">(B b, C c)</span> </span>{\n       <span class="code-keyword">this</span>.b = b;\n       <span class="code-keyword">this</span>.c = c;\n    }\n}\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">B</span> </span>{}\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">C</span> </span>{}\n</code></pre>\n<p>xml：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n            class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.A"</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">constructor-arg</span> <span\n                class="hljs-attr">ref</span>=<span class="code-string">"b"</span>/&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">constructor-arg</span> <span\n                class="hljs-attr">ref</span>=<span class="code-string">"c"</span>/&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n            class="code-string">"b"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.B"</span>/&gt;</span>\n\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n            class="code-string">"c"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.C"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>如果是源生类型的参数，可以通过指定类型来注入数据：</p>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">A</span> </span>{\n    <span class="code-keyword">private</span> <span class="code-keyword">int</span> b;\n    <span class="code-keyword">private</span> String c;\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-title">Foo</span><span\n            class="hljs-params">(<span class="code-keyword">int</span> b, String c)</span> </span>{\n       <span class="code-keyword">this</span>.b = b;\n       <span class="code-keyword">this</span>.c = c;\n    }\n}\n</code></pre>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.A"</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span\n            class="code-string">"int"</span> <span class="hljs-attr">value</span>=<span class="code-string">"1"</span>/&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span\n            class="code-string">"java.lang.String"</span> <span class="hljs-attr">value</span>=<span\n            class="code-string">"42"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span></code></pre>\n<p>也可以通过索引的方式：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.A"</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span\n            class="code-string">"0"</span> <span class="hljs-attr">value</span>=<span class="code-string">"1"</span>/&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span\n            class="code-string">"1"</span> <span class="hljs-attr">value</span>=<span class="code-string">"42"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span></code></pre>\n<p>配合<a href="http://download.oracle.com/javase/6/docs/api/java/beans/ConstructorProperties.html" rel="nofollow">@ConstructorProperties</a>注解，还可以直接使用名称来注入：\n</p>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">A</span> </span>{\n    <span class="code-keyword">private</span> <span class="code-keyword">int</span> b;\n    <span class="code-keyword">private</span> String c;\n    <span class="code-meta">@ConstructorProperties</span>({<span class="code-string">"b"</span>, <span\n            class="code-string">"c"</span>})\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-title">Foo</span><span\n            class="hljs-params">(<span class="code-keyword">int</span> b, String c)</span> </span>{\n       <span class="code-keyword">this</span>.b = b;\n       <span class="code-keyword">this</span>.c = c;\n    }\n}\n</code></pre>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"exampleBean"</span> <span class="hljs-attr">class</span>=<span class="code-string">"examples.ExampleBean"</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"b"</span> <span class="hljs-attr">value</span>=<span class="code-string">"1"</span>/&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"c"</span> <span class="hljs-attr">value</span>=<span class="code-string">"42"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span></code></pre>\n<p>在Debug模式下不用这个注解也可以实现按名字注入，但是千万别这样做。</p>\n\n<h3 id="h3-3">Set方法注入</h3>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">A</span> </span>{\n    <span class="code-keyword">private</span> B b;\n    <span class="code-keyword">private</span> C c;\n    <span class="code-keyword">private</span> String value;\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setA</span><span class="hljs-params">(A a)</span></span>{<span\n            class="code-keyword">this</span>.a = a;}\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setB</span><span class="hljs-params">(B b)</span></span>{<span\n            class="code-keyword">this</span>.b = b;}\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setB</span><span class="hljs-params">(String value)</span></span>{<span\n            class="code-keyword">this</span>.value = value;}\n}\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">B</span> </span>{}\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">C</span> </span>{}\n</code></pre>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.A"</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"b"</span> <span class="hljs-attr">ref</span>=<span class="code-string">"b"</span>/&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"c"</span> <span class="hljs-attr">ref</span>=<span class="code-string">"c"</span>/&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"value"</span> <span class="hljs-attr">value</span>=<span class="code-string">"1"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"b"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.B"</span>/&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"c"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.C"</span>/&gt;</span></code></pre>\n\n<h3 id="h3-4">使用&nbsp;Constructor还是Setter？</h3>\n<p>\n    2种注入方法在使用的过程中我们应该如何选取呢？Spring官方给出的答案是如果注入的数据或bean是一个“必要依赖”那么使用构造方法注入，如果属于配置性的非必须数据，使用Set方法注入。但是在实际应用时，会发现绝大部分注入方式都是通过Setter实现的，包括一些很流行的开源工具，例如下面的druid：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"ds"</span> <span class="hljs-attr">class</span>=<span class="code-string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span>\n     <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n             class="code-string">"driverClass"</span> <span class="hljs-attr">value</span>=<span class="code-string">"com.mysql.jdbc.Driver"</span>/&gt;</span>\n     <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n             class="code-string">"jdbcUrl"</span> <span class="hljs-attr">value</span>=<span class="code-string">"jdbc:mysql://localhost:3306/c3p0jdbctemplate"</span>/&gt;</span>\n     <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n             class="code-string">"user"</span> <span class="hljs-attr">value</span>=<span\n             class="code-string">"admin"</span>/&gt;</span>\n     <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n             class="code-string">"password"</span> <span class="hljs-attr">value</span>=<span class="code-string">"123456"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span></code></pre>\n<p>话说你不提供账户和密码能链接到数据库吗？这算必要依赖还是配置性依赖？所以也不用死守这些规则。下面是一些关键性的建议：</p>\n<ol>\n    <li>数据配置类使用constructor注入的方法来实现，因为这样可以将bean设置为一个不可变对象（<em>immutable objects</em>）。这样结合单例模式能够很好实现享元模式共享数据，结合原型模式可以创建“浅对比”对象（变更则替换）。\n    </li>\n    <li>如果构造函数要传入的参数太多，证明你的类要完成的责任太多，这个时候用Setter当然比较合理，但是建议回头去看看类当中是不是有可以拆分的功能。</li>\n    <li>Setter注入主要用于可选的依赖关系，如果没有设置值，类应该提供默认值。所以Setter方法应该检查传入值的有效性（not null、not blank等）。</li>\n    <li>如果出现了循环依赖，其实可以通过一个bean使用setter注入另外一个bean使用constructor注入来解决，不过最好检查一下代码为什么会循环，这是设计模式上的大忌。</li>\n    <li>最有一个建议最重要。如果用第三方类，别人给什么你只能用什么，没得选。</li>\n</ol>\n\n<h3 id="h3-5">注入参数</h3>\n<p>在XML配置中，用来设定注入方式和注入数据的XML标签很多，详细内容就不一一复述了，常规用法可以到官网&nbsp;<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-properties-detailed"\n        rel="nofollow">Dependencies and configuration in detail</a>&nbsp; 一节了解。这里仅仅说明一些要点：</p>\n<ol>\n    <li>父子Bean。Ioc容器提供Bean的父子关系配置。父子关系Bean可以进行数据合并，但是很少看见什么地方有实际应用。</li>\n    <li>&lt;idref&gt;标签和&lt;ref&gt;标签的差异：1)前者只能通过id引入，后者可以通过id或name引入；2)前者可以直接用value属性替换，但是value属性的效率会差很多；3)前者只能适用与当前配置文件或当前容器，后者可以引入任何位置的内容。</li>\n    <li>当需要设置一个null值时，用&lt;null&gt;标签代替value=""。在执行代码时直接传入一个null。</li>\n</ol>\n\n<h3 id="h3-6">自动装配</h3>\n<p>这里所说的自动装配是通过&lt;bean&gt;上的autowire属性实现的功能，与@Autowired注解并不是一回事，但是他的一些参数会影像@Autowired注解的行为。</p>\n<p>\n    在有@Autowired注解的情况下，autowire属性现在用得很少。基本上他实现的结果和@Autowired差不多，就是让Ioc容器根据bean的类型或者bean名称等自动将容器中其他能对应得上的bean注入到对于的构造方法或者set方法中。详情了解&nbsp;<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire"\n        rel="nofollow">Autowiring collaborators</a>。</p>\n\n<h3 id="h3-7">方法注入</h3>\n<p>如果每一个Bean都是单例模式，那么我们通过常规的XML配置引用的手段就可以实现所有的依赖组合关系。但是每个bean都有不同的生命周期，常规配置方法很难实现某些应用不同生命周期bean的依赖关系。</p>\n<p>第一种方式是通过继承&nbsp;ApplicationContextAware 类，继承后可以直接使用&nbsp;applicationContext 的 getBean 接口来获取任何一个 bean。</p>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n<span class="code-keyword">import</span> org.springframework.beans.BeansException;\n<span class="code-keyword">import</span> org.springframework.context.ApplicationContext;\n<span class="code-keyword">import</span> org.springframework.context.ApplicationContextAware;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">BeanManagerFoo</span> <span class="code-keyword">implements</span> <span\n            class="code-title">ApplicationContextAware</span> </span>{\n\n    <span class="code-keyword">private</span> ApplicationContext applicationContext;\n\n    <span class="code-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span\n            class="code-title">getBean</span><span class="hljs-params">(Class&lt;T&gt; type)</span></span>{\n\t\t<span class="code-keyword">return</span> applicationContext.getBean(type);\n\t}\n\n    <span class="hljs-function"><span class="code-keyword">public</span> Object <span\n            class="code-title">getBean</span><span class="hljs-params">(String id)</span></span>{\n\t\t<span class="code-keyword">return</span> springContext.getBean(id);\n\t}\n\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setApplicationContext</span><span class="hljs-params">(\n            ApplicationContext applicationContext)</span> <span\n            class="code-keyword">throws</span> BeansException </span>{\n        <span class="code-keyword">this</span>.applicationContext = applicationContext;\n    }\n}</code></pre>\n<p>第二种方法是使用Lookup Method。</p>\n<p>Lookup Method的实现思路是使用CGLIB生成了动态代理类并放置到Ioc中代替源生的类。看下面的例子。</p>\n<p>首先实现我们的抽象类，抽象的要求至少有一个抽象方法：</p>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n\n<span class="code-keyword">public</span> <span class="code-keyword">abstract</span> <span class="hljs-class"><span\n            class="code-keyword">class</span> <span class="code-title">A</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> String <span\n            class="code-title">getName</span><span class="hljs-params">()</span> </span>{\n        B b = <span class="code-keyword">this</span>.createB();\n        <span class="code-keyword">return</span> b.getName();\n    }\n\n    <span class="hljs-function"><span class="code-keyword">protected</span> <span class="code-keyword">abstract</span> B <span\n            class="code-title">createB</span><span class="hljs-params">()</span></span>;\n}\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">B</span> </span>{\n    <span class="code-keyword">private</span> String name = <span class="code-string">"B class"</span>;\n    <span class="hljs-function"><span class="code-keyword">public</span> String <span\n            class="code-title">getName</span><span class="hljs-params">()</span></span>{\n        <span class="code-keyword">return</span> <span class="code-keyword">this</span>.name;\n    }\n}</code></pre>\n<p>然后通过&lt;lookup-method&gt;标签来指定获取bean的方式：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"b"</span> <span class="hljs-attr">class</span>=<span\n        class="code-string">"x.y.B"</span> <span class="hljs-attr">scope</span>=<span\n        class="code-string">"prototype"</span> /&gt;</span>\n\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.A"</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">lookup-method</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"createB"</span> <span class="hljs-attr">bean</span>=<span\n            class="code-string">"b"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span></code></pre>\n<p>现在，在调用A.getName方法时都会创建一个新的B类实例。需要注意scope属性，如果修改为<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-singleton"\n        rel="nofollow">singleton</a>则每次都获取同一个B实例。</p>\n<p>使用动态代理由于是字节码级别的变换，所有有很多限制需要注意：方法和类都不能用fina关键字；测试用例需要自己实现代理模式，否则抽象类没有实现；</p>\n<p>第三种方法是使用委派模式，即我们执行A.compute方法时，实际执行的是被委派的B.reimplement方法。</p>\n<p>先定义2个基础类——Origin、Replace：</p>\n<pre><code class="java"><span class="code-keyword">package</span> x.y\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Origin</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">int</span> <span\n            class="code-title">compute</span><span class="hljs-params">(<span class="code-keyword">int</span> in1, <span\n            class="code-keyword">int</span> in2)</span> </span>{\n        <span class="code-keyword">return</span> in1+in2;\n    }\n}\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Replace</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">int</span> <span\n            class="code-title">reimplement</span><span\n            class="hljs-params">(Object o, Method m, Object[] args)</span> </span>{\n        <span class="code-keyword">int</span> in1 = (<span class="code-keyword">int</span>)args[<span\n            class="hljs-number">0</span>];\n        <span class="code-keyword">int</span> in2 = (<span class="code-keyword">int</span>)args[<span\n            class="hljs-number">1</span>];\n        <span class="code-keyword">return</span> in1+in2;\n    }\n}</code></pre>\n<p>然后定义Spring配置：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"origin"</span> <span class="hljs-attr">class</span>=<span\n        class="code-string">"x.y.Origin"</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">replaced-method</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"compute"</span> <span class="hljs-attr">replacer</span>=<span class="code-string">"replace"</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">arg-type</span>&gt;</span>int<span\n            class="code-tag">&lt;/<span class="code-name">arg-type</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">arg-type</span>&gt;</span>int<span\n            class="code-tag">&lt;/<span class="code-name">arg-type</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">replaced-method</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"replace"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.Replace"</span>/&gt;</span></code></pre>\n<p>这个时候，在任何时候执行“origin”这个bean的compute方法，实际上都是执行的Replace::reimplement方法。</p>\n<p>上面&lt;arg-type/&gt;的参数用全称或简写都可以，例如java.lang.String，使用String，Str都是指向这个类型。</p>\n<p>\n    使用委派模式的好处是限制少、灵活，并且不会用到CGLIB这种重量级工具。但是委派之后委派方法的真实参数和被委派方法的参数完全不一样，开发时需要时时刻刻紧跟委派类的结构来修改代码。一旦委派类发生任何修改而没有相应的调整被委派类，可能会出现意想不到的问题。</p>'},367:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<p>在前面两篇介绍Sring核心与设计模式的文章中，分别介绍了<a title="Ioc容器"\n                                   href="https://www.chkui.com/article/spring/spring_core_design_pattern_and_ioc">Ioc容器</a>和\n    <a title="Bean的依赖关系" href="https://www.chkui.com/article/spring/spring_core_design_pattern_and_ioc">Bean的依赖关系</a>。如果阅读过前2文就会知道，Spring的整个运转机制就是围绕着IoC容器以及Bean展开的。IoC就是一个篮子，所有的Bean都向里面扔。除了提供篮子功能创建并存放Bean之外，IoC还要负责管理Bean与Bean之间的关系——依赖注入。之前也提到Bean是Spring核心容器的最小工作单元，Spring一些更高级的功能（例如切面、代理）都是在Bean的基础上实现。\n</p>\n<p>除了管理Bean与Bean之间的关系，IoC还提供了对Bean自身进行控制的各项功能，本文将介绍Bean的<strong>生命周期功能</strong>以及<strong>状态定义功能。</strong></p>\n\n<h2 id="h2-1">前置依赖</h2>\n<p>\n    Bean与Bean之间存在依赖关系，可以是强依赖（通过XML和注解直接声明依赖）、也可以是弱依赖（ApplicationContextAware等方式获取）。当一个Bean需要另外一个Bean完成初始化后自身才能工作时，例如一个Bean依赖DataSoruce，但是DataSource的初始化需要较长时间。这个时候用<em>depends-on</em>声明前置依赖即可：\n</p>\n<pre><code class="xml"><span class="code-comment">&lt;!-- 依赖多个Bean使用,号分割 --&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"beanOne"</span> <span class="hljs-attr">class</span>=<span class="code-string">"ExampleBean"</span> <span\n        class="hljs-attr">depends-on</span>=<span class="code-string">"manager,accountDao"</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"manager"</span> <span class="hljs-attr">ref</span>=<span\n            class="code-string">"manager"</span> /&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"manager"</span> <span class="hljs-attr">class</span>=<span class="code-string">"ManagerBean"</span> /&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"accountDao"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.jdbc.JdbcAccountDao"</span> /&gt;</span></code></pre>\n\n<h2 id="h2-2">延迟加载</h2>\n<p>通常情况下，所有的&nbsp;<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-singleton"\n        rel="nofollow">singleton</a>&nbsp;类型的Bean都会在容器创建后进行初始化，简单的说就是启动Jvm就开始创建（实际上是创建ApplicationContext的某个实现类实例之后）。</p>\n<p>IoC支持所有的&nbsp;<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-singleton"\n        rel="nofollow">singleton</a>&nbsp;Bean在使用时再加载，这样做的好处是可以大大节省初始化的时间。<span style="color:#e74c3c">但是如果你的应用对启动时间的长短并不敏感，建议让所有的&nbsp;</span><a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-singleton"\n        rel="nofollow"><span style="color:#e74c3c">singleton</span></a><span style="color:#e74c3c">&nbsp;都启动时加载。这样可以在启动时就发现一些问题，而不是在运行很久直到使用时才由用户去触发这个问题</span>。或者可以根据场景来使用决定是否延迟，例如开发时使用延迟加载，而在集成测试或上生产时关闭。\n</p>\n<p>可以设置全局延迟加载，也可以设置某个Bean延迟加载：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span> <span class="hljs-attr">default-lazy-init</span>=<span\n        class="code-string">"true"</span>&gt;</span>\n    <span class="code-comment">&lt;!-- 所有的Bean知道使用的时候才会进行加载... --&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<pre><code class="xml"><span class="code-comment">&lt;!-- 只有lazy类延迟加载 --&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"lazy"</span> <span class="hljs-attr">class</span>=<span class="code-string">"com.foo.ExpensiveToCreateBean"</span> <span\n        class="hljs-attr">lazy-init</span>=<span class="code-string">"true"</span>/&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">name</span>=<span\n        class="code-string">"not.lazy"</span> <span class="hljs-attr">class</span>=<span class="code-string">"com.foo.AnotherBean"</span>/&gt;</span></code></pre>\n<p>需要注意的是，在设置某个单独的Bean延迟加载时，如果有某个没有延迟加载的Bean要依赖他，那实际上也会在初始化的时候就加载。</p>\n<p>还要强调一下，这里的“加载”仅仅是为了表示一个类被Ioc创造并放置容器中，和classLoad方法将class文件中的字节码加载到方法区的加载是两个概念。</p>\n<p>延迟加载在设计模式上是单例模式一种延伸，通常也被称为懒汉模式。单例通常有双重锁+volatile、静态类和枚举三种方式实现。在<a\n        href="http://www.baidu.com/link?url=kGkdnL7l_ll3LfLYL8dxNgxmZdGW-wKRbUh6i8wRu2CERbWLWDBkpLtu38Jg9qTx0-KOIOBr6FXsjRwJigZmxa"\n        target="_blank" rel="nofollow">Effective&nbsp;<em>Java</em></a>一书中对三种模式都有深入的解析。而对于Spring容器而言，枚举的方式肯定不好用了，静态类由于属于自身代码级别应该也不会用，所以双重锁的实现方式较为可信。不过我没去看过源码，仅属于猜测。\n</p>\n\n<h2 id="h2-3">生命周期方法</h2>\n<p>一个Bean的创建、使用再到最后销毁称为"Bean的生命周期"。Spring框架为Bean的生命周期各个阶段提供了多种回掉方法来处理各种状态或者数据。</p>\n\n<h3 id="h3-1">初始化方法</h3>\n<p>\n    当一个Bean完成初始化并注入各项参数之后，初始化回掉方法会被调用，简单的说就是完成创建之后会被调用。实现初始化回调方法有2个路径：1.继承org.springframework.beans.factory.InitializingBean接口，然后实现\n    afterPropertiesSet方法。2.在Bean的XML配置上使用init-method属性来制定要调用的初始化：</p>\n<p>继承实现：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.A"</span> /&gt;</span></code></pre>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">A</span> <span class="code-keyword">implements</span> <span class="code-title">InitializingBean</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">afterPropertiesSet</span><span class="hljs-params">()</span></span>{\n        <span class="code-comment">// init</span>\n    }\n}</code></pre>\n<p>配置实现：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span\n        class="code-string">"x.y.A"</span> <span class="hljs-attr">init-method</span>=<span\n        class="code-string">"init"</span> /&gt;</span></code></pre>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">A</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">init</span><span class="hljs-params">()</span></span>{}\n}</code></pre>\n<p>2种方法都等效，实际使用是我们应该使用哪一种方法呢？</p>\n<p>InitializingBean是Spring早期实现的一个生命周期回调方法。但是在JCP推出JSR-250和<a title="JSR-330"\n                                                             href="https://www.chkui.com/article/java/java_jsr330"\n>JSR-330</a>规范之后，Spring的大神们开始意识到基于元编程思想和配置手段来实现非侵入式框架（Not\n    Coupled）才是正道。所以现在都是推荐使用配置文件和JSR-250的@PostConstruct（关于各种Annotation的使用请关注后续的文章）。现在依然保留InitializingBean应该是考虑到兼容问题。</p>\n\n<h3 id="h3-2">销毁方法</h3>\n<p>与创建方法相对应的是销毁方法。当一个类将要被销毁之前，对应的销毁回调方法会被调用。销毁方法也有一个继承实现和配置+注解实现：</p>\n<p>继承实现：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.A"</span> /&gt;</span></code></pre>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">A</span> <span class="code-keyword">implements</span> <span class="code-title">DisposableBean</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">destroy</span><span class="hljs-params">()</span></span>{\n        <span class="code-comment">// 销毁资源</span>\n    }\n}</code></pre>\n<p>配置实现：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span\n        class="code-string">"x.y.A"</span> <span class="hljs-attr">destroy-method</span>=<span class="code-string">"cleanUp"</span> /&gt;</span></code></pre>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">A</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">cleanUp</span><span class="hljs-params">()</span></span>{\n        <span class="code-comment">// 销毁资源</span>\n    }\n}</code></pre>\n<p>依然建议销毁手段也使用配置或@PreDestroy来设定销毁方法。</p>\n\n<h3 id="h3-3">全局配置初始化与销毁方法</h3>\n<p>IoC容器还提供了全局配置初始化与销毁方法的配置：</p>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">A</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">init</span><span class="hljs-params">()</span></span>{\n        <span class="code-comment">// 初始化资源</span>\n    }\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">destroy</span><span class="hljs-params">()</span></span>{\n        <span class="code-comment">// 销毁资源</span>\n    }\n}</code></pre>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span> <span class="hljs-attr">default-init-method</span>=<span\n        class="code-string">"init"</span> <span class="hljs-attr">default-destroy-method</span>=<span\n        class="code-string">"destroy"</span>&gt;</span>\n     <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n             class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span\n             class="code-string">"x.y.A"</span>/&gt;</span>\n     <span class="code-comment">&lt;!-- bean configuration --&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>通过在&lt;beans&gt;标签上使用<em>default-init-method</em>和<em>default-destroy-method</em>&nbsp;属性参数，可以为容器中所有的Bean统一指定初始化和销毁的生命周期方法。\n</p>\n<p>如果在&lt;beans&gt;上设定2个默认的生命周期方法，同时在&lt;bean&gt;上也指定了<em>init-method</em>或<em>destroy-method，</em>回调方法会以&lt;bean&gt;上的配置为准。这样就保证全局配置与单独配置可以共存。\n</p>\n<p>使用初始化或销毁2个生命周期方法注意的要点：</p>\n<ol>\n    <li>\n        初始化和销毁都提供了3种手段：XML配置、注解、以及实现接口。系统的各个部分会交由不同的团队开发，不遵循统一的规范，建议使用满足JSR规范的注解——@PostConstruct、@PreDestroy。如果是统一的团队，准训一致的规范，建议使用&lt;beans&gt;的属性统一名称使用全局配置。\n    </li>\n    <li>如果Bean设计到代理模式时（例如使用了AOP），那么生命周期方法被调用时，有可能代理类还没有被创建出来。因为生命周期方法是实体类完成对应工作之后就会被调用，而与代理类无关。</li>\n</ol>'}});