webpackJsonp([10],{364:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<p><a href="https://www.chkui.com/" title="@随风溜达的向日葵">@随风溜达的向日葵</a></p>\n<h2 id="h2-1">Nextjs</h2>\n<p><a href="https://nextjs.org/"><em>Nextjs</em></a>是<a href="https://reactjs.org/"><em>React</em></a>生态中非常受欢迎的SSR（server\n    side render——服务端渲染）框架，只需要几个步骤就可以搭建一个支持SSR的工程（_Nextjs_的快速搭建见<a\n            href="https://www.chkui.com/article/react/nextjs_getting_starting"><em>Next.js入门</em></a>）。 本文的案例代码来自于<a\n            href="https://github.com/palmg/website-standard-with-next">前端标准模板项目</a>。</p>\n<h2 id="h2-2">服务端组织数据</h2>\n<p><em>Nextjs</em>提供了便捷强大的服务端渲染功能——<strong>getInitialProps()</strong>，通过这个方法可以简单为服务端和前端同时处理异步请求数据：</p>\n<pre><code class="javascript"><span class="code-keyword">const</span> load = <span class="code-keyword">async</span> () =&gt;{\n    <span class="code-keyword">return</span> <span class="code-keyword">new</span> <span\n            class="code-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res, rej</span>)=&gt;</span>{\n        res(<span class="code-string">\'Success\'</span>)\n    })\n}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">Simple</span> <span\n        class="code-keyword">extends</span> <span class="code-title">React</span>.<span\n        class="code-title">Component</span></span>{\n    <span class="code-keyword">static</span> <span class="code-keyword">async</span> getInitialProps({req, query}) {\n        <span class="code-keyword">const</span> data = <span class="code-keyword">await</span> load();\n        <span class="code-keyword">return</span> {data}\n    }\n    render() {\n        <span class="code-keyword">return</span>(<span class="xml"><span class="code-tag">&lt;<span\n            class="code-name">p</span>&gt;</span>{this.props.data}<span class="code-tag">&lt;/<span\n            class="code-name">p</span>&gt;</span></span>)\n    }\n}\n</code></pre>\n<p>Next的强大之一体现在就这么几行代码就解决了SSR中最麻烦的前后端异步数据组装功能。再复杂的异步数据组装过程都可以放置到代码中的Promise对象中。</p>\n<h2 id="h2-3">页面与内页</h2>\n<p>在继续述说本文内容之前还需要强化两个概念——<strong>内页</strong>与<strong>页面</strong>。</p>\n<p>通过浏览器输入一个地址获取到的内容称之为<strong>页面</strong>。</p>\n<p>而在单页面应用中也会有通过导航栏或菜单控制的内容切换效果，我们将这些切换的内容称之为<strong>内页</strong>。单页面应用中一般会先打开一个页面，然后通过Dom的增删改模拟页面切换的效果。</p>\n<h2 id="h2-4">Nextjs中SSR渲染的局限性</h2>\n<p>\n    <code>getInitialProps()</code>方法虽然强大好用，但是现在还存在一个问题——<strong>只能在“内页”中使用</strong>。<em>Nextjs_规定了所有放置到<code>./pages</code>中的文件（通常是*.js_文件，也可以引入</em>.ts*文件）都视为一个内页，这些文件中被导出的React组件可以直接输入地址上访问。例如现在有<a\n        href="https://github.com/palmg/website-standard-with-next/blob/master/pages/about.js"><em>./pages/about.js</em></a>文件，运行\n    <em>Nextjs</em> 后在浏览输入<code>http://localhost:3000/about</code>就可以看到这个组件，而<a\n        href="https://github.com/palmg/website-standard-with-next/blob/master/pages/async/simple.js"><em>./pages/async/simple.js</em></a>对用的路径是<code>http://localhost:3000/async/simple</code>。\n</p>\n<p>但是在其他路径（比如<code>./component</code>）的组件是无法使用<code>getInitialProps()</code>方法的。乍一看这样似乎没多大问题，但是某些应用又需要这些组件不能放置到<code>./pages</code>中暴露到_url_中，又需要异步加载数据。看下面的例子。\n</p>\n<h3 id="h3-1">按需加载菜单的例子</h3>\n<p><img src="https://oscimg.oschina.net/oscnet/fd51a66e0f097658f7db8e37fb621c76857.jpg" alt="Nextjs+React非页面组件SSR渲染"\n        title="应用菜单" class="zoom-in-cursor"></p>\n<p>如上图。在企业级应用中（例如OA系统）通常不太需要实现SSR，这个时候可以根据角色权限在组件的<code>componentDidMount()</code>方法中异步加载菜单，但是在某些时候（例如一个可配置菜单的内容网站，或者对企业级应用进行服务端缓存）也会有菜单异步加载并且实现SSR的需要，这个时候需要在_Nextjs_框架的基础上扩展。\n</p>\n<p>看到这里可能你会想可以把菜单的组装像下面放到每个内页的<code>getInitialProps()</code>方法中去：</p>\n<pre><code class="javascript"><span class="code-keyword">const</span> Comp = <span class="hljs-function"><span\n        class="hljs-params">props</span> =&gt;</span>(<span class="xml"><span class="code-tag">&lt;<span\n        class="code-name">div</span>&gt;</span><span class="code-tag">&lt;<span class="code-name">Menus</span> <span\n        class="hljs-attr">menus</span>=<span class="code-string">{props.menus}/</span>&gt;</span><span class="code-tag">&lt;<span\n        class="code-name">div</span>&gt;</span>{props.pageData}<span class="code-tag">&lt;/<span\n        class="code-name">div</span>&gt;</span><span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span>);\nComp.getInitialProps = async ({req})=&gt;{\n    //load Menu Promise\n    const menus = await getMenus();\n    //load Page Data Promise\n    const pageData = await getPageData();\n    return {menus, pageData}\n}\n</span></code></pre>\n<p>这样做在实现上没问题，但是在架构设计上是颇为糟糕的。以下三个原因：</p>\n<ol>\n    <li>\n        对于React有各种各样的描述，比如单向数据流、组件化等等。但是他的核心思想其实是<strong>分而治之</strong>。在Jquery“统治”的年代可以使用_selector_(比如<code>$(\'#id\')</code>)轻易获取到页面上的任何元素。一个项目如果没有很好的规范化管理（长久的人工规范化管理是需要投入不少成本的），久而久之会发现各个板块之间耦合性越来越强、坑越来越多(代码腐烂)。而React的单向数据流让组件与组件之间没有直接的沟通方式，规范化从技术层面就被强化，进而才会产生了_Redux_、_Flux_这一类按照“分-总-分”的模式（实际上就是一个消息总线模式）去控制模块间沟通的。所以将业务逻辑相关性并不强的页面和菜单放置在一个地方处理并不合理。\n    </li>\n    <li>绝大多数项目都不是一个人开发的，一个架构设计者要考虑到未来参与项目的开发者水平参差不齐。如果让框架级的结构直接暴露到业务开发者的面前，保不准某个负责业务开发的小伙伴忽略或修改了什么代码导致框架级的坑出现。</li>\n    <li>按照上面的代码，实际上要求每个内页都保留<code>const menus = await getMenus();</code>、<code>&lt;Menus menus={props.menus}/&gt;</code>这一类的代码（每个内页都复制粘贴）。在架构上这叫“样板式代码”，架构设计者应当尽量将这些代码通过“分层”的方式放到一个地方去处理。\n    </li>\n</ol>\n<p>所以有理由为_Nextjs_的<code>./pages</code>之外的组件实现ssr数据异步加载。</p>\n<h2 id="h2-5">组件ssr异步数据实现</h2>\n<p>为了实现本文的需求——让所有组件实现类似于<code>getInitialProps()</code>的方法，我们先要理清_Nextjs_前后端渲染的过程。</p>\n<h3 id="h3-2">渲染过程</h3>\n<p>_Nextjs_为使用者提供了<a href="https://github.com/palmg/website-standard-with-next/blob/master/pages/_app.js"><code>./pages/_app.js</code></a>和<a\n        href="https://github.com/palmg/website-standard-with-next/blob/master/pages/_document.js"><code>./pages/_document.js</code></a>在内页处理之前执行某些任务,后者用于构建整个HTML的结构。并且<a\n        href="https://github.com/palmg/website-standard-with-next/blob/master/pages/_document.js"><code>./pages/_document.js</code></a>只会在服务端执行。本文将开发者自行实现的内页称为_page,现在对于_Nextjs_就有三个类型的构建——_<em>document</em>、_<em>app_和_component</em>,每个构建都可以包含<code>static\n    getInitialProps()</code>、<code>constructor()</code>和<code>render()</code>方法，他们的执行过程如下。</p>\n<h4 id="h4-1">服务端执行过程</h4>\n<ol>\n    <li>_document getInitialProps()</li>\n    <li>_app getInitialProps()</li>\n    <li>_page getInitialProps()</li>\n    <li>_app constructor()</li>\n    <li>_app render()</li>\n    <li>_page constructor()</li>\n    <li>_page render()</li>\n    <li>_document constructor()</li>\n    <li>_document render()</li>\n</ol>\n<p>以上的过程分解如下：</p>\n<ol>\n    <li>\n        <p><strong>组装异步数据（1~3）</strong>：服务端会先开始执行<code>_document.getInitialProps()</code>这个静态方法，方法中会执行<code>_app.getInitialProps()</code>再遍历所有的<code>_page.getInitialProps()</code>执行到这里所有的异步数据完成组装。\n        </p>\n    </li>\n    <li>\n        <p><strong>渲染React组件（4~7）</strong>：有了数据之后开始渲染页面，会使用<a\n                href="https://reactjs.org/docs/react-dom-server.html"><code>ReactDOMServer</code></a>执行产生一个HTML格式的字符串。\n        </p>\n    </li>\n    <li>\n        <p><strong>构建静态HTML（8~9）</strong>：有了<a href="https://reactjs.org/docs/react-dom-server.html"><code>ReactDOMServer</code></a>产生的字符串剩下的工作就是将其组装为一个标准的HTML文档返回给客户端。\n        </p>\n    </li>\n</ol>\n<h4 id="h4-2">客户端执行过程</h4>\n<p><strong>初始化页面时（首次打开页面）：</strong></p>\n<ol>\n    <li>_app constructor()</li>\n    <li>_app render()</li>\n    <li>_page constructor()</li>\n    <li>_page render()</li>\n</ol>\n<p>\n    客户端在首次打开页面时（或刷新页面）服务端已经提供了完整的HTML文档可以立即显示。此时React的组件依然执行一次虚拟Dom渲染，所以所有的组件都会执行。然后_Nextjs_利用类似于_React_服务端渲染的_checksum_的机制防止虚拟Dom对真实Dom进行渲染，关于_React_服务端渲染的_checksum_机制可以到<a\n        href="https://www.chkui.com/article/react/react_server_render_with_checksum">React 前后端同构防止重复渲染</a>一文了解。</p>\n<p><strong>内页跳转时（通过<code>next/link</code>跳转）：</strong></p>\n<ol>\n    <li>_app getInitialProps()</li>\n    <li>_page getInitialProps()</li>\n    <li>_app render()</li>\n    <li>_page constructor()</li>\n    <li>_page render()</li>\n</ol>\n<p>客户端跳转到一个新的内页和服务端渲染就没有什么关系了。__app和_page_的<code>getInitialProps()</code>先组装数据，然后通过<code>props</code>将组装好的数据传递给组件去渲染。需要注意的是_app的构造方法在内页跳转的时候并不会执行，因为它只在整个页面渲染的时候实例化一次。\n</p>\n<h3 id="h3-3">实现</h3>\n<p>在了解_Nextjs_解执行过程之后实现需求就很简单了——先通过_document或_app的<code>getInitialProps()</code>方法完成数据组装，然后将数据传递给对应的组件即可。当然按照分而治之的思想不能直接在框架去完成业务的事，需要为组件提供一个注册接口然后由_document或_app使用注册的方法去构建业务数据。\n</p>\n<p><strong>数据加载方法注册</strong></p>\n<p>首先需要为我们组件提供一个注册异步加载数据的接口，组件可以利用这个接口注册异步加载数据的方法让框架统一去<code>getInitialProps()</code>执行。 <a\n        href="https://github.com/palmg/website-standard-with-next/blob/master/util/serverInitProps.js"><code>./util/serverInitProps.js</code></a>提供了这个功能:\n</p>\n<pre><code class="javascript"><span class="code-keyword">const</span> FooDict = {};\n<span class="code-comment">//注册方法</span>\n<span class="code-keyword">export</span> <span class="code-keyword">const</span> registerAsyncFoo = <span\n            class="hljs-function">(<span class="hljs-params">key, foo, params = {}</span>) =&gt;</span> {\n    FooDict[key] = {foo, params};\n};\n\n<span class="code-comment">//获取方法</span>\n<span class="code-keyword">export</span> <span class="code-keyword">const</span> executeAsyncFoo = <span\n            class="code-keyword">async</span> () =&gt; {\n    <span class="code-keyword">const</span> valueDict = {};\n    <span class="code-keyword">const</span> keys = <span class="code-built_in">Object</span>.keys(FooDict);\n    <span class="code-keyword">for</span> (<span class="code-keyword">let</span> key <span\n            class="code-keyword">of</span> keys) {\n        <span class="code-keyword">const</span> dict = FooDict[key];\n        valueDict[key] = <span class="code-keyword">await</span> dict.foo(dict.params);\n    }\n    <span class="code-keyword">return</span> valueDict;\n};\n\n\n</code></pre>\n<p>然后我们在<a\n        href="https://github.com/palmg/website-standard-with-next/blob/master/components/app/application/menu.js"><code>menu</code></a>组件中注册异步获取数据的方法：\n</p>\n<pre><code class="javascript">registerAsyncFoo(<span class="code-string">\'menus\'</span>, getMenus);\n</code></pre>\n<p><code>getMenus</code>模拟异步获取数据的过程:</p>\n<pre><code class="javascript"><span class="code-keyword">import</span> {Menus} <span\n        class="code-keyword">from</span> <span class="code-string">"../../../../data/menuData"</span>;\n<span class="code-keyword">export</span> <span class="code-keyword">const</span> getMenus = <span class="hljs-function"><span\n            class="hljs-params">()</span> =&gt;</span> {\n    <span class="code-comment">//可以将这个promise修改为一个net方法实现异步动态装菜菜单</span>\n    <span class="code-keyword">return</span> <span class="code-keyword">new</span> <span\n            class="code-built_in">Promise</span>(<span class="hljs-function">(<span\n            class="hljs-params">resolve, reject</span>) =&gt;</span> {\n        resolve(Menus)\n    })\n};\n</code></pre>\n<p>注册完成后再<code>_app</code>中执行异步加载：</p>\n<pre><code class="javascript"><span class="code-keyword">import</span> {executeAsyncFoo} <span\n        class="code-keyword">from</span> <span class="code-string">"../util/serverInitProps"</span>;\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">ExpressApp</span> <span\n        class="code-keyword">extends</span> <span class="code-title">App</span> </span>{\n    <span class="code-keyword">static</span> <span class="code-keyword">async</span> getInitialProps({Component, router, ctx}) {\n        info(<span class="code-string">\'Execute _App getInitialProps()!\'</span>, <span class="code-string">\'executeReport\'</span>);\n        <span class="code-comment">/**\n         * app的getInitialProps会在服务端被调用一次，在前端每次切换页面时被调用。\n         */</span>\n        <span class="code-keyword">let</span> pageProps = {}, appProps = {};\n        <span class="code-keyword">if</span> (Component.getInitialProps) {\n            pageProps = <span class="code-keyword">await</span> Component.getInitialProps(ctx);\n        }\n        <span class="code-keyword">if</span> (ctx &amp;&amp; !ctx.req) {<span class="code-comment">//客户端执行</span>\n            appProps = <span class="code-built_in">window</span>.__NEXT_DATA__.props.appProps;\n        } <span class="code-keyword">else</span> {<span class="code-comment">//服务端执行</span>\n            appProps = <span class="code-keyword">await</span> executeAsyncFoo();\n        }\n        <span class="code-keyword">return</span> {pageProps, appProps}\n    }\n    <span class="code-comment">//other function</span>\n}\n</code></pre>\n<p>在服务端获取到数据之后会返回给<code>_ducoment</code>，_Nextjs_会将这些数据写到HTML的<code>window.__NEXT_DATA__</code>对象上而后在客户端可以从这个对象获取到已经在服务端加载的数据。\n    最后用React的Context特性传递数据，有需要用到这些数据的组件可以从<a\n            href="https://github.com/palmg/website-standard-with-next/blob/master/components/app/applicationContext.js"><code>ApplicationContext</code></a>中获取这些数据:\n</p>\n<pre><code class="javascript"><span class="code-comment">//_app</span>\n<span class="code-keyword">import</span> ApplicationContext <span class="code-keyword">from</span> <span\n            class="code-string">\'../components/app/applicationContext\'</span>\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">ExpressApp</span> <span\n        class="code-keyword">extends</span> <span class="code-title">App</span> </span>{\n     <span class="code-comment">//other function</span>\n     render() {\n        info(<span class="code-string">\'Execute _App render()!\'</span>, <span class="code-string">\'executeReport\'</span>);\n        <span class="code-keyword">const</span> {Component, pageProps, appProps} = <span\n            class="code-keyword">this</span>.props;\n        <span class="code-keyword">return</span> (\n            &lt;ApplicationContext.Provider value={appProps}&gt;\n                &lt;Application&gt;\n                    &lt;Component {...pageProps} /&gt;\n                &lt;/Application&gt;\n            &lt;/ApplicationContext.Provider&gt;\n        )\n    }\n    //other function\n}\n</code></pre>\n<pre><code class="javascript"><span class="code-comment">//menu</span>\n<span class="code-keyword">import</span> ApplicationContext <span class="code-keyword">from</span> <span\n            class="code-string">\'../applicationContext\'</span>\n<span class="code-keyword">const</span> Menu = <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> {\n    <span class="code-keyword">return</span> (\n        <span class="xml"><span class="code-tag">&lt;<span\n                class="code-name">ApplicationContext.Consumer</span>&gt;</span>\n            {appProps =&gt; {\n                const {menus} = appProps;\n                return menus.map(menu =&gt; (\n                    <span class="code-tag">&lt;<span class="code-name">Link</span> <span\n                            class="hljs-attr">href</span>=<span class="code-string">{menu.href}</span>&gt;</span>\n                        <span class="code-tag">&lt;<span class="code-name">a</span>&gt;</span>{menu.name}<span\n                    class="code-tag">&lt;/<span class="code-name">a</span>&gt;</span>\n                    <span class="code-tag">&lt;/<span class="code-name">Link</span>&gt;</span>\n                ))\n            }}\n        <span class="code-tag">&lt;/<span class="code-name">ApplicationContext.Consumer</span>&gt;</span>\n    );\n};\n</span></code></pre>\n<p><a href="https://github.com/palmg/website-standard-with-next/blob/master/util/serverInitProps.js"><code>./util/serverInitProps.js</code></a>可以在任何组件中使用，<code>_app</code>会逐一执行方法获取数据按照kev-value的方式设置到<code>ApplicationContext</code>中，而任意组件要做的仅仅是从<code>ApplicationContext</code>拿到目标数据。\n</p>\n<p>当然传递数据的方式不仅仅局限于React的Context特性，换成Redux或全局管理数据的方法都是可行的。</p>\n<p><a href="https://www.chkui.com/" title="@随风溜达的向日葵">@随风溜达的向日葵</a></p>'},370:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h2 id="h2-1">Flow</h2>\n<p>Flow是Facebook开源的静态代码检查工具，他的作用是在运行代码之前对React组件以及Jsx语法进行静态代码的检查以发现一些可能存在的问题。Flow可以用于所有前端开发的项目而不仅仅局限于React，码友们可以到\n  <a title="Flow官网" href="https://flow.org/en/docs/getting-started/" rel="nofollow">官网</a>仔细了解（友情提示：可能需要VPN，非常不稳定），本文只介绍如何配合React开发使用。</p>\n<p>Flow仅仅是一个用于检查的工具，安装使用都很方便，使用时注意以下3点即可：</p>\n<ol>\n  <li>将Flow增加到我们的项目中。</li>\n  <li>确保编译之后的代码移除了Flow相关的语法。</li>\n  <li>在需要检查的地方增加了Flow相关的类型注解。（类似与Java的Annotation机制）</li>\n</ol>\n<p>接下来我们来一一说明以上三点的具体内容。码友们边阅读边操作即可。</p>\n\n<h2 id="h2-2">将Flow增加到我们的项目中</h2>\n<p>安装最新版本的Flow：</p>\n<p>Npm：</p>\n<pre class="sql"><code class="language-bash">npm <span class="code-keyword">install</span> <span class="code-comment">--save-dev flow-bin</span></code></pre>\n<p>安装完成之后在package.json文件中增加执行脚本：</p>\n<pre class="actionscript"><code class="language-javascript">{\n  <span class="code-comment"><span class="code-comment">// ...</span></span>\n  <span class="code-string"><span class="code-string">"scripts"</span></span>: {\n    <span class="code-string"><span class="code-string">"your-script-name"</span></span>: <span class="code-string"><span class="code-string">"flow"</span></span>,\n    <span class="code-comment"><span class="code-comment">// ...</span></span>\n  },\n  <span class="code-comment"><span class="code-comment">// ...</span></span>\n}</code></pre>\n<p>然后初始化Flow：</p>\n<pre class="nginx"><code class="language-bash"><span class="code-attribute">npm</span> run flow init</code></pre>\n<p>执行完成后，Flow会在终端输出一下内容：</p>\n<pre class="css"><code class="css">&gt; <span class="code-selector-tag"><span class="code-selector-tag">yourProjectName</span></span>@<span class="code-keyword"><span class="code-keyword">1</span></span>.<span class="code-keyword"><span class="code-keyword">0</span></span>.<span class="code-keyword"><span class="code-keyword">0</span></span> flow /yourProjectPath\n&gt; flow <span class="code-string"><span class="code-string">"init"</span></span>\n</code></pre>\n<p>然后在根目录下生成一个名为&nbsp;.flowconfig 的文件，打开之后是这样的：</p>\n<pre class="json"><code class="language-bash">[ignore]\n\n[include]\n\n[libs]\n\n[lints]\n\n[options]\n\n[strict]\n</code></pre>\n<p>基本上，配置文件没有什么特殊需求是不用去配置的，Flow默认涵盖了当前目录之后的所有文件。[include]用于引入项目之外的文件。例如：</p>\n<pre class="gradle"><code class="gradle">[<span class="code-keyword"><span class="code-keyword">include</span></span>]\n\n..<span class="hljs-regexp"><span class="hljs-regexp">/otherProject/</span></span>a.js\n\n[libs]\n</code></pre>\n<p>他会将和当前项目平级的otherProject/a.js 文件纳入进来。关于配置文件请看<a title="Flow配置文件说明" href="https://flow.org/en/docs/config/" rel="nofollow">这里</a>。</p>\n\n<h2 id="h2-3">编译之后的代码移除Flow相关的语法</h2>\n<p>Flow在JavaScript语法的基础上增加了一些 注解（annotation）进行了扩展。因此浏览器无法正确的解读这些Flow相关的语法，我们必须在编译之后的代码中（最终发布的代码）将增加的Flow注解移除掉。具体方法需要看我们使用了什么样的编译工具。下面将说明一些React开发常用的编译工具</p>\n\n<h3 id="h3-1">Create React App</h3>\n<p>如果你的项目是使用<a title="Create React App" href="https://github.com/facebook/create-react-app" rel="nofollow">Create React App</a>直接创建的。那么移除Flow语法的事项就不用操心了，Create React App已经帮你搞定了这个事，直接跳过这一小节吧。</p>\n\n<h3 id="h3-2">Babel</h3>\n<p>在15.x版本之前入坑React的码友应该绝大部分都用的Babel作为语法糖编译器，那个时候毕竟Create React App完全没有成熟。如果使用Babel我们还需要安装一个Babel对于Flow的preset：</p>\n<pre class="sql"><code class="language-apache">npm <span class="code-keyword">install</span> <span class="code-comment">--save-dev babel-preset-flow</span></code></pre>\n<p>然后，我们需要在<a title="Babel配置文件" href="http://babeljs.io/docs/usage/babelrc/" rel="nofollow">项目根目录Babel的配置文件 .babelrc 中</a>添加一个Flow相关的preset：</p>\n<pre class="json"><code class="language-javascript">{\n  <span class="code-string"><span class="hljs-attr">"presets"</span></span>: [\n    <span class="code-string"><span class="code-string">"flow"</span></span>,\n    <span class="code-comment">//other config</span>\n  ]\n}</code></pre>\n\n<h3 id="h3-3">其他方式</h3>\n<p>如果你既没有使用Create React App也没使用Babel作为语法糖编译器，那么可以使用<a title="Flow语法处理工具" href="https://github.com/flowtype/flow-remove-types" rel="nofollow">&nbsp;flow-remove-types </a>这个工具在发布之前移除Flow代码。</p>\n\n<h2 id="h2-4">运行Flow</h2>\n<p>完成上述步骤之后，就可以开始运行flow了：</p>\n<pre class="nginx"><code class="language-bash"><span class="code-attribute">npm</span> run flow</code></pre>\n<p>然后会输类似一下的内容：</p>\n<pre class="css"><code class="css">&gt; <span class="code-selector-tag"><span class="code-selector-tag">yourProjectName</span></span>@<span class="code-keyword"><span class="code-keyword">1</span></span>.<span class="code-keyword"><span class="code-keyword">0</span></span>.<span class="code-keyword"><span class="code-keyword">0</span></span> flow /yourProjectPath\n&gt; flow\n\nLaunching Flow server for /yourProjectPath\nSpawned flow server (pid=<span class="hljs-number"><span class="hljs-number">10705</span></span>)\nLogs will go to /tmp/flow/zSworkzSchkuizSone-big-website.log\nMonitor logs will go to /tmp/flow/zSworkzSchkuizSone-big-website.monitor_log\nNo errors!\n</code></pre>\n<p>第一次运行会生成很多临时文件比较慢，之后会快许多。</p>\n\n<h2 id="h2-5">增加Flow注解</h2>\n<p>如果你了解C++/C#的元编程或者Java的Annotation，那么理解Flow的Annotation就会非常轻松。大概就是在文件、方法、代码块之前增加一个注解（Annotation）用来告知Flow的执行行为。</p>\n<p>首先，Flow只检查包含 // @flow 注解的文件。所以如果需要检查，我们需要这样编写我们的文件：</p>\n<pre class="scala"><code class="language-javascript"><span class="code-comment"><span class="code-comment">// @flow</span></span>\n<span class="code-keyword"><span class="code-keyword">import</span></span> <span class="code-type">React</span> <span class="code-keyword">from</span> <span class="code-string"><span class="hljs-symbol">\'reac</span>t\'</span>\n\n<span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span class="hljs-class"><span class="code-title">Component</span></span></span><span class="hljs-class"> </span></span>{\n    render(){\n        <span class="code-keyword"><span class="code-keyword">return</span></span> (<span class="xml"><span class="code-tag">&lt;<span class="code-name">div</span>&gt;</span><span class="code-type">MyComponent</span><span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>)\n    }\n}\n\n<span class="code-keyword">export</span> <span class="code-keyword"><span class="code-keyword">default</span></span> <span class="code-type">MyComponent</span></code></pre>\n<p>然后我们再运行Flow就变成这样的风格了：</p>\n<pre class="scala"><code class="language-bash">&gt; yourProjectName@<span class="hljs-number">1.0</span><span class="hljs-number">.0</span> flow /yourProjectPath\n&gt; flow\n\n<span class="code-type">Error</span> ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ dev/src/home/test.js:<span class="hljs-number">5</span>:<span class="hljs-number">21</span>\n\n<span class="code-type">Cannot</span> use property <span class="code-type">Component</span> [<span class="hljs-number">1</span>] <span class="code-keyword">with</span> less than <span class="hljs-number">1</span> <span class="code-built_in"><span class="hljs-class"><span class="code-keyword">type</span></span></span><span class="hljs-class"> <span class="code-title">argument</span>.</span>\n\n     dev/src/home/test.js\n      <span class="hljs-number">2</span>│\n      <span class="hljs-number">3</span>│ <span class="code-keyword">import</span> <span class="code-type">React</span> from <span class="code-string"><span class="hljs-symbol">\'reac</span>t\'</span>\n      <span class="hljs-number">4</span>│\n      <span class="hljs-number">5</span>│ <span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MyComponent</span> <span class="code-keyword">extends</span> <span class="code-title">React</span>.<span class="code-title">Component</span> </span>{\n      <span class="hljs-number">6</span>│     <span class="hljs-function"><span class="code-title">render</span></span>(){\n      <span class="hljs-number">7</span>│         <span class="code-built_in"><span class="code-keyword">return</span></span> (&lt;div&gt;<span class="code-type">MyComponent</span>&lt;/div&gt;)\n      <span class="hljs-number">8</span>│     }\n\n     /tmp/flow/flowlib_cc1898a/react.js\n [<span class="hljs-number">1</span>] <span class="hljs-number">26</span>│ <span class="code-built_in">declare</span> <span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">React</span></span><span class="code-variable"><span class="hljs-class"><span class="code-title">$Component</span></span></span><span class="hljs-class"><span class="code-title">&lt;Props</span>, <span class="code-title">State</span> </span>= void&gt; {</code></pre>\n<p>到这里，Flow已经算是安装成功了，接下来的事是要增加各种注解以加强类型限定或者参数检测。之后的内容将简要介绍flow的相关语法规则。</p>\n\n<h2 id="h2-6">React组件参数检查</h2>\n<p><a title="PropType参数类型检测" href="https://chkui.com/article/react/react_typechecking_with_proptypes_and_dom_element">React组件参数检查</a>介绍了React通过PropType机制限定使用者使用组件传递的参数类型以及范围，但是PropType是一种运行检测机制，在程序跑起来之后获取到具体数据才会执行检查。而Flow是静态检查，是在代码编译运行之前进行一次检查，两者相辅相成互不干扰。</p>\n\n<h3 id="h3-4">Props参数检查</h3>\n<p>承接上面 MyComponent 的例子，我们引入Flow的注解对代码进行检查：</p>\n<pre class="scala"><code class="language-javascript"><span class="code-comment"><span class="code-comment">// @flow</span></span>\n<span class="code-comment"><span class="code-comment">// flow的例子，可以看看和PropType的差异在哪</span></span>\n<span class="code-keyword"><span class="code-keyword">import</span></span> <span class="code-type">React</span> <span class="code-keyword">from</span> <span class="code-string"><span class="hljs-symbol">\'reac</span>t\'</span>\n\n<span class="hljs-class"><span class="code-keyword">type</span> <span class="code-title">Props</span> </span>= {\n    num : number,\n    text : ?string\n}\n\n<span class="code-comment"><span class="code-comment">//通过&lt;&gt;引入Flow类型检查</span></span>\n<span class="code-comment"><span class="code-comment">//可以直接写成 React.Component&lt;{num : number, text ?: string}&gt;这样的形式</span></span>\n<span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span class="hljs-class"><span class="code-title">Component</span></span></span><span class="hljs-class"><span class="code-title">&lt;</span></span><span class="code-title"><span class="hljs-class"><span class="code-title">Props</span></span></span><span class="hljs-class"><span class="code-title">&gt;</span> </span></span>{\n    render(){\n        <span class="code-keyword"><span class="code-keyword">return</span></span> (<span class="xml"><span class="code-tag">&lt;<span class="code-name">div</span>&gt;</span>{<span class="code-keyword">this</span>.props.num}\\{<span class="code-keyword">this</span>.props.text}<span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>)\n    }\n}\n\n<span class="code-keyword">export</span> <span class="code-keyword"><span class="code-keyword">default</span></span> <span class="code-type">MyComponent</span></code></pre>\n<p>然后在运行Flow，输出了No Error。</p>\n<p>然后我们使用这个组件：</p>\n<pre class="scala"><code class="language-javascript"><span class="code-comment"><span class="code-comment">// @flow</span></span>\n<span class="code-comment"><span class="code-comment">// flow的例子，可以看看和PropType的差异在哪</span></span>\n<span class="code-keyword"><span class="code-keyword">import</span></span> <span class="code-type">React</span> <span class="code-keyword">from</span> <span class="code-string"><span class="hljs-symbol">\'reac</span>t\'</span>\n\n<span class="hljs-class"><span class="code-keyword">type</span> <span class="code-title">Props</span> </span>= {\n    num : number,\n    text : ?string\n}\n\n<span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span class="hljs-class"><span class="code-title">Component</span></span></span><span class="hljs-class"><span class="code-title">&lt;</span></span><span class="code-title"><span class="hljs-class"><span class="code-title">Props</span></span></span><span class="hljs-class"><span class="code-title">&gt;</span> </span></span>{\n    render(){\n        <span class="code-keyword"><span class="code-keyword">this</span></span>.props.myValue;\n        <span class="code-keyword"><span class="code-keyword">return</span></span> (<span class="xml"><span class="code-tag">&lt;<span class="code-name">div</span>&gt;</span>{<span class="code-keyword">this</span>.props.num}\\{<span class="code-keyword">this</span>.props.text}<span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>)\n    }\n}\n\n<span class="code-comment"><span class="code-comment">//void 表示 undefined 不传递参数</span></span>\n<span class="code-comment"><span class="code-comment">//这里传递类型发生错误</span></span>\n<span class="code-keyword">const</span> <span class="code-type">UseComponent</span> = (props : <span class="code-keyword">void</span>) =&gt;(<span class="xml"><span class="code-tag">&lt;<span class="code-name"><span class="code-type">MyComponent</span></span> <span class="hljs-attr">num</span>=<span class="code-string"><span class="code-string">"2"</span></span> <span class="hljs-attr">text</span>=<span class="code-string">{<span class="hljs-number">2</span>}/</span>&gt;</span>)\n\nexport <span class="code-keyword">default</span> <span class="code-type">UseComponent</span></span></code></pre>\n<p>运行flow之后输出：</p>\n<pre class="actionscript"><code class="language-bash">Error ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ dev/src/home/test.js:<span class="hljs-number">12</span>:<span class="hljs-number">20</span>\n\nCannot <span class="code-keyword">get</span> <span class="code-keyword">this</span>.props.myValue because property myValue <span class="code-keyword">is</span> missing <span class="code-keyword"><span class="code-keyword">in</span></span> Props [<span class="hljs-number">1</span>].\n\n      <span class="hljs-number">9</span>│\n [<span class="hljs-number">1</span>] <span class="hljs-number">10</span>│ <span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MyComponent</span> <span class="code-keyword">extends</span> <span class="code-title">React</span>.<span class="code-title">Component</span>&lt;<span class="code-title">Props</span>&gt; </span>{\n     <span class="hljs-number">11</span>│     <span class="hljs-function"><span class="code-title">render</span></span>(){\n     <span class="hljs-number">12</span>│         <span class="code-keyword">this</span>.props.myValue;\n     <span class="hljs-number">13</span>│         <span class="code-built_in"><span class="code-keyword">return</span></span> (&lt;div&gt;{<span class="code-keyword">this</span>.props.num}\\{<span class="code-keyword">this</span>.props.text}&lt;/div&gt;)\n     <span class="hljs-number">14</span>│     }\n     <span class="hljs-number">15</span>│ }\n\n\nError ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ dev/src/home/test.js:<span class="hljs-number">17</span>:<span class="hljs-number">40</span>\n\nCannot create MyComponent element because:\n • string [<span class="hljs-number">1</span>] <span class="code-keyword">is</span> incompatible <span class="code-keyword">with</span> number [<span class="hljs-number">2</span>] <span class="code-keyword"><span class="code-keyword">in</span></span> property num.\n • number [<span class="hljs-number">3</span>] <span class="code-keyword">is</span> incompatible <span class="code-keyword">with</span> string [<span class="hljs-number">4</span>] <span class="code-keyword"><span class="code-keyword">in</span></span> property text.\n\n    [<span class="hljs-number">2</span>]  <span class="hljs-number">6</span>│     num : number,\n    [<span class="hljs-number">4</span>]  <span class="hljs-number">7</span>│     text : ?string\n          :\n        <span class="hljs-number">14</span>│     }\n        <span class="hljs-number">15</span>│ }\n        <span class="hljs-number">16</span>│\n [<span class="hljs-number">1</span>][<span class="hljs-number">3</span>] <span class="hljs-number">17</span>│ <span class="code-keyword">const</span> UseComponent = (props : <span class="code-keyword">void</span>) =&gt;(&lt;MyComponent num=<span class="code-string"><span class="code-string">"2"</span></span> text={<span class="hljs-number">2</span>}/&gt;)\n        <span class="hljs-number">18</span>│\n        <span class="hljs-number">19</span>│ <span class="code-built_in">export</span> <span class="code-keyword">default</span> UseComponent\n\n\n\nFound <span class="hljs-number">3</span> errors</code></pre>\n<p>输出内容可以看出一共有2个错误栏输出：</p>\n<ul>\n  <li>第一栏表示myValue并没有声明。</li>\n  <li>第二栏[1]违反了[2]的限定，[3]违反了[4]的限定。我们将组件变更为&lt;MyComponent num={2}&nbsp;text="2"/&gt;即可检查通过。</li>\n</ul>\n\n<h3 id="h3-5">增加对State的检查</h3>\n<p>React的数据通过两处控制——<a title="React 深入说明JSX语法与Props特性" href="https://www.chkui.com/article/react/react_understand_jsx_and_props">props</a> 和&nbsp;<a title="React 状态、事件与动态渲染" href="https://www.chkui.com/article/react/react_state_event_and_render">state</a>。Flow也提供了state数据的检查，我们在例子中增加state检查：</p>\n<pre class="scala"><code class="language-javascript"><span class="code-comment"><span class="code-comment">// @flow</span></span>\n<span class="code-comment"><span class="code-comment">// flow的例子，可以看看和PropType的差异在哪</span></span>\n<span class="code-keyword"><span class="code-keyword">import</span></span> <span class="code-type">React</span> <span class="code-keyword">from</span> <span class="code-string"><span class="hljs-symbol">\'reac</span>t\'</span>\n\n<span class="hljs-class"><span class="code-keyword">type</span> <span class="code-title">Props</span> </span>= {\n    num : number,\n    text : ?string\n}\n\n<span class="hljs-class"><span class="code-keyword">type</span> <span class="code-title">State</span> </span>= {\n    count: number,\n};\n\n<span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span class="hljs-class"><span class="code-title">Component</span></span></span><span class="hljs-class"><span class="code-title">&lt;</span></span><span class="code-title"><span class="hljs-class"><span class="code-title">Props</span></span></span><span class="hljs-class">, </span><span class="code-title"><span class="hljs-class"><span class="code-title">State</span></span></span><span class="hljs-class"><span class="code-title">&gt;</span> </span></span>{\n    <span class="code-keyword">constructor</span>(...props){\n        <span class="code-keyword"><span class="code-keyword">super</span></span>(...props)\n        <span class="code-keyword"><span class="code-keyword">this</span></span>.state = {count:<span class="code-string">\'<span class="hljs-number">1</span>\'</span>}\n    }\n\n    render(){\n        <span class="code-keyword"><span class="code-keyword">return</span></span> (<span class="xml"><span class="code-tag">&lt;<span class="code-name">div</span>&gt;</span>{<span class="code-keyword">this</span>.props.num}\\{<span class="code-keyword">this</span>.props.text}<span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>)\n    }\n}\n\n<span class="code-keyword">const</span> <span class="code-type">UseComponent</span> = (props : <span class="code-keyword">void</span>) =&gt;(<span class="xml"><span class="code-tag">&lt;<span class="code-name"><span class="code-type">MyComponent</span></span> <span class="hljs-attr">num</span>=<span class="code-string">{<span class="hljs-number">2</span>}</span> <span class="hljs-attr">text</span>=<span class="code-string"><span class="code-string">"2"</span></span>/&gt;</span>)\n\nexport <span class="code-keyword">default</span> <span class="code-type">UseComponent</span></span></code></pre>\n<p>此时运行Flow会输出：</p>\n<pre class="scala"><code class="language-bash"><span class="code-type">Error</span> ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ dev/src/home/test.js:<span class="hljs-number">17</span>:<span class="hljs-number">29</span>\n\n<span class="code-type">Cannot</span> assign <span class="hljs-class"><span class="code-keyword">object</span> <span class="code-title">literal</span> <span class="code-title">to</span> <span class="code-title">this</span>.<span class="code-title">state</span> <span class="code-title">because</span> <span class="code-title">string</span> [1] <span class="code-title">is</span> <span class="code-title">incompatible</span></span>\n<span class="code-keyword">with</span> number [<span class="hljs-number">2</span>] <span class="code-keyword">in</span> property count.\n\n [<span class="hljs-number">2</span>] <span class="hljs-number">11</span>│     count: number,\n     <span class="hljs-number">12</span>│ };\n     <span class="hljs-number">13</span>│\n     <span class="hljs-number">14</span>│ <span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MyComponent</span> <span class="code-keyword">extends</span> <span class="code-title">React</span>.<span class="code-title">Component&lt;Props</span>, <span class="code-title">State&gt;</span> </span>{\n     <span class="hljs-number">15</span>│     constructor(...props){\n     <span class="hljs-number">16</span>│         <span class="code-keyword">super</span>(...props)\n [<span class="hljs-number">1</span>] <span class="hljs-number">17</span>│         <span class="code-keyword">this</span>.state = {count:<span class="code-string">\'<span class="hljs-number">1</span>\'</span>}\n     <span class="hljs-number">18</span>│     }\n     <span class="hljs-number">19</span>│\n     <span class="hljs-number">20</span>│     <span class="hljs-function"><span class="code-title">render</span></span>(){\n</code></pre>\n<p>检测出state.count在构造函数中赋值的类型错误。</p>\n\n<h3 id="h3-6">组件默认值</h3>\n<p>使用Flow后一样可以使用默认值，但是必须要注意默认值的类型要和注解声明的一致：</p>\n<pre class="scala"><code class="language-javascript"><span class="code-keyword"><span class="code-keyword">import</span></span> * <span class="code-keyword">as</span> <span class="code-type">React</span> <span class="code-keyword">from</span> <span class="code-string"><span class="hljs-symbol">\'reac</span>t\'</span>;\n\n<span class="hljs-class"><span class="code-keyword">type</span> <span class="code-title">Props</span> </span>= {\n  foo: number, \n};\n\n<span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span class="hljs-class"><span class="code-title">Component</span></span></span><span class="hljs-class"><span class="code-title">&lt;</span></span><span class="code-title"><span class="hljs-class"><span class="code-title">Props</span></span></span><span class="hljs-class"><span class="code-title">&gt;</span> </span></span>{\n  <span class="code-keyword">static</span> defaultProps = {\n    foo: <span class="hljs-number"><span class="hljs-number">42</span></span>, \n  };\n}</code></pre>\n\n<h3 id="h3-7">函数类型的组件</h3>\n<p>除了使用Class关键字，使用函数同样可以构造一个React组件，配合Flow使用：</p>\n<pre class="javascript"><code class="language-javascript"><span class="code-keyword"><span class="code-keyword">import</span></span> React <span class="code-keyword"><span class="code-keyword">from</span></span> <span class="code-string"><span class="code-string">\'react\'</span></span>;\n\ntype Props = {<span class="code-comment"><span class="code-comment">//参数检查</span></span>\n  foo: number,\n  bar?: string,\n};\n\n<span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">function</span></span></span><span class="hljs-function"> </span><span class="code-title"><span class="hljs-function"><span class="code-title">MyComponent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props: Props</span></span></span><span class="hljs-function">) </span></span>{\n  <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="xml"><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">div</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">{props.bar}</span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">div</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span></span>;\n}\n\nMyComponent.defaultProps = {\n  foo: <span class="hljs-number"><span class="hljs-number">42</span></span> <span class="code-comment"><span class="code-comment">//指定默认值</span></span>\n};</code></pre>\n\n<h3 id="h3-8">React事件、子组件、高阶组件检查扩展</h3>\n<p>除了对单个组件基本的检查，Flow还提供了对React事件、refs、子组件、高阶组件、Redux。本文就不一一介绍了，有需要的码友可以按照下面的资源清单去了解相关的内容：</p>\n<ul>\n  <li><a title="Flow React事件检查" href="https://flow.org/en/docs/react/events/" rel="nofollow">React事件</a></li>\n  <li><a title="Flow Refs引入对象检查" href="https://flow.org/en/docs/react/refs/" rel="nofollow">Refs引入对象</a></li>\n  <li><a title="Flow React子组件列表检查" href="https://flow.org/en/docs/react/children/" rel="nofollow">子组件列表</a></li>\n  <li><a title="Flow React高阶组件参数检查" href="https://flow.org/en/docs/react/hoc/" rel="nofollow">高阶组件参数</a></li>\n  <li><a title="Flow ReactRedux整合参数检查" href="https://flow.org/en/docs/react/redux/" rel="nofollow">Redux整合</a></li>\n</ul>\n\n<h3 id="h3-9">类型检查扩展</h3>\n<p>Flow会检查所有的JavaScript基础类型——Boolean、String、Number、null、undefined（在Flow中用void代替）。除此之外还提供了一些操作符号，例如例子中的 text : ?string，他表示参数存在“没有值”的情况，除了传递string类型之外，还可以是null或undefined。需要特别注意的是，这里的没有值和JavaScript的表达式的“非”是两个概念，Flow的“没有值”只有null、void（undefined），而JavaScript表达式的“非”包含：null、undefined、0、false。</p>\n<p>除了前面的例子中给出的各种类型参数，Flow还有更丰富的检查功能，查看 <a title="Flow 检查参数说明" href="https://flow.org/en/docs/types/" rel="nofollow">这里</a> 以了解更多内容。</p>\n\n<h3 id="h3-10">React数据类型参考</h3>\n<p>对于Flow来说，除了常规的JavaScript数据类型之外，React也有自己特有的数据类型。比如React.Node、React.Key、React.Ref&lt;&gt;等。需要详细了解的，可以查看官网关于<a title="Flow React类型的说明" href="https://flow.org/en/docs/react/types/" rel="nofollow">React类型的说明</a>。</p>\n<p>需要特别说明的是，如果所要使用React的类型，在通过ES6引入React对象时需要使用这样的方式：</p>\n<pre class="python"><code class="language-javascript"><span class="code-keyword"><span class="code-keyword">import</span></span> * <span class="code-keyword"><span class="code-keyword">as</span></span> React <span class="code-keyword"><span class="code-keyword">from</span></span> <span class="code-string"><span class="code-string">\'react\'</span></span>\n<span class="code-comment">//替换 <span class="code-keyword">import</span> React <span class="code-keyword">from</span> <span class="code-string">\'react\'</span></span>\n\n<span class="code-comment">//或者单独引入一个类型</span>\n<span class="code-comment">//<span class="code-keyword">import</span> type {Node} <span class="code-keyword">from</span> <span class="code-string">\'react</span></span></code></pre>\n<p>两者的差异在于ES6的星号import的特性，使用*号会将一个文件中的所有 export 内容组合成一个对象返回，而不使用星号仅仅能获取到exprot default 那个原型。而引入Flow后不会修改React的默认导出类型，因为默认导出不一定是一个对象，他会通过export为React扩展更多的类型。</p>\n<p>比如我们用React.Node限制render方法的返回类型：</p>\n<pre class="scala"><code class="language-javascript"><span class="code-keyword"><span class="code-keyword">import</span></span> * <span class="code-keyword">as</span> <span class="code-type">React</span> <span class="code-keyword">from</span> <span class="code-string"><span class="hljs-symbol">\'reac</span>t\'</span>\n<span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span class="hljs-class"><span class="code-title">Component</span></span></span><span class="hljs-class"><span class="code-title">&lt;</span></span></span>{}&gt; {\n  render(): <span class="code-type">React</span>.<span class="code-type">Node</span> {\n    <span class="code-comment"><span class="code-comment">// ...</span></span>\n  }\n}</code></pre>\n\n<h2 id="h2-7">遇到的一些问题</h2>\n<p>我在使用的过程中目前遇到的问题之一是import 样式资源&nbsp;或&nbsp; 图片时报 “./xxx.scss. Required module not found” 的异常，查看官方文档了解Flow只支持.js、.jsx、.mjs、.json的文件，如果需要导入其他文件需要并支持需要扩展options。在.flowconfig添加options：</p>\n<pre class=""><code class="">[ignore]\n[<span class="code-keyword"><span class="code-keyword">include</span></span>]\n[libs]\n[lints]\n[options]\n<span class="code-keyword"><span class="code-keyword">module</span></span>.file_ext=.scss\n[strict]</code></pre>\n<p>此外，某些IDE对Flow的支持不是很好。我目前所使用的webstorm 2017.3.5相对还不错，不过切记要到File-&gt;Setting-&gt;Languages&amp;Frameworks-&gt;Javascript中将version设置为Flow。</p>\n\n<h2 id="h2-8">写在最后的使用心得</h2>\n<p>引入并按照Flow的规范去约束每一个组件会导致开发量增加不少（当然你引入不用是另外一回事，但是不用引入他做什么？）。搭建好Flow的框架仅仅是开始，之后除了团队成员要去了解flow的使用方法，早期还会遇到各种坑需要去解决。而且Flow也要比React的 <a title="React 深入说明JSX语法与Props特性" href="/article/react/react_understand_jsx_and_props">PropTypes</a>&nbsp;”重“许多。</p>\n<p>JavaScript本来是一个类型推导的原型语言，弄个Flow进来搞得越来越像Java这种强类型语言，也不知道是好是坏，而Java10又学JavaScript等加入了val这种可以类型推导的关键字....。</p>\n<p>总的来说引入规范是有成本的，具体要看团队规模以及项目大小，不是引入越多的技术栈就越有逼格。如果你独立项目的前端开发人数并不多，或者代码膨胀（代码腐烂）速度也没有让你措手不及，建议慎重引入Flow。个人觉得Flow除了开发人员自检还要整合到整个测试框架中，在集成测试或某个版本的代码发布之前进行集中检查。需要思考它在项目的开发、测试、仿真、上线迭代周期中扮演的角色，甚至整合到类似与CMMI之类的管理流程去反向量化考核代码质量。</p>'},406:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<p>Vert.x可以使用Zookeeper和Ignite等框架来创建集群，但是首选框架还是Hazelcast。此外，码友们也可以通过<em>ClusterManager</em>接口实现或引入需要的集群管理工具。本文将说明Vert.x是如何利用Hazelcast来创建和管理集群的，同时你也会了解到Vertx如何创建单机实例。</p>\n<h2 id="h2-1"><strong>集群创建</strong></h2>\n<p>在创建Vert.x集调用群时，调用方法和创建单机实例是有差异的。集群需要调<em>Vertx.clusteredVertx</em>异步方法创建。集群可以完全新建和引入已有的Hazelcast实例二种方式来创建。如下：</p>\n<p>1.新建实例</p>\n<blockquote>\n    <p>ClusterManager mgr = new HazelcastClusterManager();</p>\n</blockquote>\n<p>2.引入Hazelcast实例</p>\n<blockquote>\n    <p>ClusterManager mgr = new HazelcastClusterManager(hazelcastInstance);</p>\n</blockquote>\n<p>详情可以参考官方手册<a title="Hazelcast" href="http://vertx.io/docs/vertx-hazelcast/java/" rel="nofollow">http://vertx.io/docs/vertx-hazelcast/java/</a>。</p>\n\n<h2 id="h2-2">新建集群过程</h2>\n<p>调用<em>Vertx.clusteredVertx</em>静态方法后，Vert.x会利用Vertx工厂方法创建Vertx实例。如下</p>\n<p>其中简单直白的使用 <em>new&nbsp;VertxImpl();</em>来创建Vertx实例。</p>\n<pre class="gradle"><code class="gradle">VertxFactoryImpl.clusteredVertx(VertxOptions <span class="code-keyword"><span class="code-keyword">options</span></span>, <span class="code-keyword"><span class="code-keyword">final</span></span> Handler&lt;AsyncResult&lt;Vertx&gt;&gt; resultHandler) {\n    <span class="code-keyword"><span class="code-keyword">options</span></span>.setClustered(<span class="code-keyword"><span class="code-keyword">true</span></span>);<span class="code-comment"><span class="code-comment">//设置参数，启用集群</span></span>\n    <span class="code-keyword"><span class="code-keyword">new</span></span> VertxImpl(<span class="code-keyword"><span class="code-keyword">options</span></span>, resultHandler);<span class="code-comment"><span class="code-comment">//创建Vertx实例</span></span>\n}</code></pre>\n<p style="text-align:center">图1启动集群</p>\n<p>在<em>VertxImpl</em>的构造方法中，若需要创建集群，则执行：</p>\n<pre class="gradle"><code class="gradle">VertxImpl(VertxOptions <span class="code-keyword"><span class="code-keyword">options</span></span>, Handler&lt;AsyncResult&lt;Vertx&gt;&gt; resultHandler) {\n    <span class="code-comment"><span class="code-comment">// some code</span></span>\n    <span class="code-keyword"><span class="code-keyword">if</span></span> (<span class="code-keyword"><span class="code-keyword">options</span></span>.isClustered()) {\n      <span class="code-keyword"><span class="code-keyword">this</span></span>.clusterManager = getClusterManager(<span class="code-keyword"><span class="code-keyword">options</span></span>);<span class="code-comment"><span class="code-comment">//1.获取集群管理对象</span></span>\n      <span class="code-keyword"><span class="code-keyword">this</span></span>.clusterManager.setVertx(<span class="code-keyword"><span class="code-keyword">this</span></span>);<span class="code-comment"><span class="code-comment">//2. 设置实例</span></span>\n      <span class="code-keyword"><span class="code-keyword">this</span></span>.clusterManager.<span class="code-keyword"><span class="code-keyword">join</span></span>(ar -&gt; {<span class="code-comment"><span class="code-comment">//3. 加入集群</span></span>\n        <span class="code-keyword"><span class="code-keyword">if</span></span> (ar.failed()) {\n          log.error(<span class="code-string"><span class="code-string">"Failed to join cluster"</span></span>, ar.cause());\n        } <span class="code-keyword"><span class="code-keyword">else</span></span> {\n          <span class="code-comment"><span class="code-comment">// Provide a memory barrier as we are setting from a different thread</span></span>\n          <span class="code-keyword"><span class="code-keyword">synchronized</span></span> (VertxImpl.<span class="code-keyword"><span class="code-keyword">this</span></span>) {\n            haManager = <span class="code-keyword"><span class="code-keyword">new</span></span> HAManager(<span class="code-keyword"><span class="code-keyword">this</span></span>, deploymentManager, clusterManager, <span class="code-keyword"><span class="code-keyword">options</span></span>.getQuorumSize(),\n                                      <span class="code-keyword"><span class="code-keyword">options</span></span>.getHAGroup(), haEnabled);\n            createAndStartEventBus(<span class="code-keyword"><span class="code-keyword">options</span></span>, resultHandler);\n          }\n        }\n      });\n    } <span class="code-keyword"><span class="code-keyword">else</span></span> {\n      <span class="code-keyword"><span class="code-keyword">this</span></span>.clusterManager = <span class="code-keyword"><span class="code-keyword">null</span></span>;\n      createAndStartEventBus(<span class="code-keyword"><span class="code-keyword">options</span></span>, resultHandler);\n    }\n    <span class="code-comment"><span class="code-comment">// some code</span></span>\n  }</code></pre>\n<p style="text-align:center">图2</p>\n<p>这里会分3部来创建集群，首先调用<em>getClusterManager</em>来获取集群的配置管理实例。如下：</p>\n<pre class="gradle"><code class="language-java">getClusterManager(VertxOptions <span class="code-keyword">options</span>) {\n    <span class="code-keyword"><span class="code-keyword">if</span></span> (<span class="code-keyword">options</span>.isClustered()) {\n      <span class="code-keyword"><span class="code-keyword">if</span></span> (<span class="code-keyword">options</span>.getClusterManager() != <span class="code-keyword"><span class="code-keyword">null</span></span>) {<span class="code-comment"><span class="code-comment">//判断是否已经创建集群管理对方</span></span>\n        <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="code-keyword">options</span>.getClusterManager();<span class="code-comment"><span class="code-comment">//若已创建，直接使用这个对象。</span></span>\n      } <span class="code-keyword"><span class="code-keyword">else</span></span> {<span class="code-comment"><span class="code-comment">//若无创建，执行新建过程。</span></span>\n        ClusterManager mgr;\n        String clusterManagerClassName = System.getProperty(<span class="code-string"><span class="code-string">"vertx.cluster.managerClass"</span></span>);<span class="code-comment"><span class="code-comment">/*通过系统参数设置集群管理对象*/</span></span>\n        <span class="code-keyword"><span class="code-keyword">if</span></span> (clusterManagerClassName != <span class="code-keyword"><span class="code-keyword">null</span></span>) {<span class="code-comment"><span class="code-comment">//clusterManagerClassName变量指定的类名存在，开始加载</span></span>\n          <span class="code-comment"><span class="code-comment">// We allow specify a sys prop for the cluster manager factory which overrides ServiceLoader</span></span>\n          <span class="code-keyword"><span class="code-keyword">try</span></span> {\n            <span class="code-keyword">Class</span>&lt;?&gt; clazz = <span class="code-keyword">Class</span>.forName(clusterManagerClassName);\n            mgr = (ClusterManager)clazz.newInstance();\n          } <span class="code-keyword"><span class="code-keyword">catch</span></span> (Exception e) {\n            <span class="code-keyword"><span class="code-keyword">throw</span></span> <span class="code-keyword"><span class="code-keyword">new</span></span> IllegalStateException(<span class="code-string"><span class="code-string">"Failed to instantiate "</span></span> + clusterManagerClassName, e);\n          }\n        } <span class="code-keyword"><span class="code-keyword">else</span></span> {<span class="code-comment"><span class="code-comment">//clusterManagerClassName指定的变量null,使用默认加载器。</span></span>\n          ServiceLoader&lt;ClusterManager&gt; mgrs = ServiceLoader.load(ClusterManager.<span class="code-keyword">class</span>);\n          <span class="code-keyword"><span class="code-keyword">if</span></span> (!mgrs.iterator().hasNext()) {\n            <span class="code-keyword"><span class="code-keyword">throw</span></span> <span class="code-keyword"><span class="code-keyword">new</span></span> IllegalStateException(<span class="code-string"><span class="code-string">"No ClusterManagerFactory instances found on classpath"</span></span>);\n          }\n          mgr = mgrs.iterator().<span class="code-keyword">next</span>();\n        }\n        <span class="code-keyword"><span class="code-keyword">return</span></span> mgr;\n      }\n    } <span class="code-keyword"><span class="code-keyword">else</span></span> {\n      <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="code-keyword"><span class="code-keyword">null</span></span>;\n    }\n  }</code></pre>\n<p style="text-align:center">图3，获取集群管理类<br> 从源码看，<em><code>getClusterManager</code></em>并没有什么特殊的地方。首先检查用户在创建Vertx实例之前，是否创建了集群的管理对象<code><em>ClusterManager</em>。创建了，则使用这个管理对象，没有创建则自行新建一个。</code></p>\n<p>注意</p>\n<blockquote>\n    <p>String clusterManagerClassName = System.getProperty("vertx.cluster.managerClass");</p>\n</blockquote>\n<p>这行代码 ，这说明可以通过JVM环境参数（<em>-Dvertx.cluster.managerClass=[className]</em>）来指定Vertx加载集群管理对象类。这在官方手册中并没有任何一个地方说明。</p>\n<p>如果指定了managerClass，则会使用默认加载方式加载指定的类，并转换成<em>ClusterManager</em>接口。</p>\n<p>如果没有指定managerClass，则使用默认集群加载类启动集群。</p>\n<blockquote>\n    <p>ServiceLoader&lt;ClusterManager&gt; mgrs = ServiceLoader.load(ClusterManager.class);&nbsp;</p>\n</blockquote>\n<p>ServiceLoader是Java在1.6定义的聚群接口类，有点类似于spring的Ioc容器。其过程也是加载类。详细说明请查阅&nbsp;<a href="http://my.oschina.net/hanzhankang/blog/109794" rel="nofollow">通过ServiceLoader实现链式处理</a>&nbsp;一文，解释得很清楚。</p>\n<p>可以看到在<em>vertx-hazelcast-[vertsion].jar</em>包中，<em>META-INF/services/io.vertx.core.spi.cluster.ClusterManager</em>指定了<em>ClusterManager</em>要<em>ServiceLoader</em>加载<em>HazelcastClusterManager。</em></p>\n<blockquote>\n    <p>io.vertx.spi.cluster.hazelcast.HazelcastClusterManager</p>\n</blockquote>\n<p>回到图2，Vert.x接下来使用</p>\n<blockquote>\n    <p>clusterManager.setVertx(this)</p>\n</blockquote>\n<p>将vertx实例设置到集群管理类中。 随后调用</p>\n<blockquote>\n    <p>clusterManager.join</p>\n</blockquote>\n<p>来加入集群。 下面是<em>clusterManager.join</em>的源码</p>\n<pre class="less"><code class="less"><span class="code-selector-tag"><span class="code-selector-tag">synchronized</span></span> <span class="code-selector-tag"><span class="code-selector-tag">void</span></span> <span class="code-selector-tag"><span class="code-selector-tag">join</span></span>(Handler&lt;AsyncResult&lt;Void&gt;&gt; resultHandler) {\n    <span class="code-selector-tag"><span class="code-selector-tag">vertx</span></span><span class="code-selector-class"><span class="code-selector-class">.executeBlocking</span></span>(fut -&gt; {\n      <span class="code-selector-tag"><span class="code-selector-tag">if</span></span> (!active) {<span class="code-comment"><span class="code-comment">//确保只初始化一次</span></span>\n        active = true;\n        <span class="code-selector-tag"><span class="code-selector-tag">if</span></span> (customHazelcastCluster) {<span class="code-comment"><span class="code-comment">//当使用的是用户自己创建的Hazelcast实例时</span></span>\n          nodeID = hazelcast<span class="code-selector-class"><span class="code-selector-class">.getLocalEndpoint</span></span>()<span class="code-selector-class"><span class="code-selector-class">.getUuid</span></span>();<span class="code-comment"><span class="code-comment">//获取节点编号</span></span>\n          membershipListenerId = hazelcast<span class="code-selector-class"><span class="code-selector-class">.getCluster</span></span>()<span class="code-selector-class"><span class="code-selector-class">.addMembershipListener</span></span>(this);<span class="code-comment"><span class="code-comment">//获取当前节点监听成员变换的事件的ID</span></span>\n          fut<span class="code-selector-class"><span class="code-selector-class">.complete</span></span>();\n          return;\n        }\n        if (conf == null) {<span class="code-comment"><span class="code-comment">//获取Hazelcast的Config</span></span>\n          conf = loadConfigFromClasspath();\n          <span class="code-selector-tag"><span class="code-selector-tag">if</span></span> (conf == null) {\n            log<span class="code-selector-class"><span class="code-selector-class">.warn</span></span>(<span class="code-string"><span class="code-string">"Cannot find cluster configuration on classpath and none specified programmatically. Using default hazelcast configuration"</span></span>);\n          }\n        }\n        <span class="code-comment"><span class="code-comment">//新建hazelcast实例</span></span>\n        hazelcast = Hazelcast.newHazelcastInstance(conf);\n        nodeID = hazelcast.getLocalEndpoint().getUuid();\n        membershipListenerId = hazelcast.getCluster().addMembershipListener(this);\n        fut.complete();\n      }\n    }, resultHandler);\n  }</code></pre>\n<p style="text-align:center">图4，新建hazelcast实例</p>\n<p>如果用户自己创建并传入Hazelcast实例，<em>ClusterManager</em>只是简单的从中获取需要的参数。如果未创建实例，则<em>ClusterManager</em>会自行创建。</p>\n<p>首先，loadConfigFromClasspath会用来加载本地的配置文件。</p>\n<pre class="cs"><code class="language-java"><span class="hljs-function"><span class="hljs-function">Config </span><span class="code-title"><span class="hljs-function"><span class="code-title">loadConfigFromClasspath</span></span></span><span class="hljs-params"><span class="hljs-function">(<span class="hljs-params"></span>)</span></span><span class="hljs-function"> </span></span>{\n    Config cfg = <span class="code-keyword"><span class="hljs-literal">null</span></span>;\n    <span class="code-keyword"><span class="code-keyword">try</span></span> (InputStream <span class="code-keyword">is</span> = getConfigStream();\n         InputStream bis = <span class="code-keyword"><span class="code-keyword">new</span></span> BufferedInputStream(<span class="code-keyword">is</span>)) {\n      <span class="code-keyword"><span class="code-keyword">if</span></span> (<span class="code-keyword">is</span> != <span class="code-keyword"><span class="hljs-literal">null</span></span>) {\n        cfg = <span class="code-keyword"><span class="code-keyword">new</span></span> XmlConfigBuilder(bis).build();<span class="code-comment"><span class="code-comment">//创建HazelcastConfig</span></span>\n      }\n    } <span class="code-keyword"><span class="code-keyword">catch</span></span> (IOException ex) {\n      log.error(<span class="code-string"><span class="code-string">"Failed to read config"</span></span>, ex);\n    }\n    <span class="code-keyword"><span class="code-keyword">return</span></span> cfg;\n  }</code></pre>\n<p style="text-align:center">图5，加载HazelcastConfig</p>\n<p>getConfigStream用来读取配置文件。</p>\n<pre class="kotlin"><code class="language-java"><span class="hljs-function">InputStream <span class="code-title">getConfigStream</span><span class="hljs-params">()</span> </span>{\n    ClassLoader ctxClsLoader = Thread.currentThread().getContextClassLoader();\n    InputStream <span class="code-keyword">is</span> = <span class="code-keyword"><span class="hljs-literal">null</span></span>;\n    <span class="code-keyword"><span class="code-keyword">if</span></span> (ctxClsLoader != <span class="code-keyword"><span class="hljs-literal">null</span></span>) {\n      <span class="code-keyword">is</span> = ctxClsLoader.getResourceAsStream(CONFIG_FILE);\n    }\n    <span class="code-keyword"><span class="code-keyword">if</span></span> (<span class="code-keyword">is</span> == <span class="code-keyword"><span class="hljs-literal">null</span></span>) {\n      <span class="code-keyword">is</span> = getClass().getClassLoader().getResourceAsStream(CONFIG_FILE);\n      <span class="code-keyword"><span class="code-keyword">if</span></span> (<span class="code-keyword">is</span> == <span class="code-keyword"><span class="hljs-literal">null</span></span>) {\n        <span class="code-keyword">is</span> = getClass().getClassLoader().getResourceAsStream(DEFAULT_CONFIG_FILE);\n      }\n    }\n    <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="code-keyword">is</span>;\n  }</code></pre>\n<p style="text-align:center">图6，读取配置文件</p>\n<p>如图5、图6的源码。<em>getConfigStream</em>会先加载classpath下的<em>cluster.xml（CONFIG_FILE）</em>文件。如果不存在，则加载jar包内的<em>default-cluster.xml（DEFAULT_CONFIG_FILE）</em>文件。读取完毕后，<em>loadConfigFromClasspath</em>使用Hazelcast的<em>XmlConfigBuilder</em>来构建<em>HazelcastConfig</em>。而后会用这个Config初始化Hazelcast。</p>\n<p>集群创建成功后， 会初始化一个<em>HAManager</em>实例，用于做verticle迁移。后面在详细说明HA模式。</p>\n<p>最后，在VertxImpl中，会调用<em>createAndStartEventBus</em>方法在集群环境运行的EventBus。</p>'}});