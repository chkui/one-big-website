webpackJsonp([4],{319:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='\n<p>通常情况下，图形界面的发行版 <em><strong>linux</strong></em> 可以在 <strong><em>Setting-&gt;Device-&gt;Display</em></strong> 中直接设置多个屏幕的分辨率。但是坑总是无处不在的，有时候明明用得好好的分辨率就出毛病了，而且不能在界面上设置。此时可以通过 <em><strong>xrandr</strong></em> 命令来直接设置分辨率。</p>\n\n<h2 id="h2-1">常规方法</h2>\n<p>1.查看显示模式参数：</p>\n<pre class="bash"><code class="language-bash"><span class="code-comment"><span class="code-comment">#1440 900就是要修改的分辨率，根据需要可以使用1920 1080、1720 900等</span></span>\n<span class="code-variable"><span class="code-variable">$cvt</span></span> 1440 900\n<span class="code-comment"><span class="code-comment">#输出内容</span></span>\n1440x900 59.89 Hz (CVT 1.30MA) hsync: 55.93 kHz; pclk: 106.50 MHz\nModeline <span class="code-string"><span class="code-string">"1440x900_60.00"</span></span>  106.50  1440 1528 1672 1904  900 903 909 934 -hsync +vsync</code></pre>\n<p>Modeline之后的内容就是我们后面添加显示模式要使用的参数。</p>\n<p>2.通过addMode命令增加一个现实模式：</p>\n<pre class="bash"><code class="language-bash"><span class="code-comment"><span class="code-comment">#将Modeline的阿才能书复制到 --newmode之后即可</span></span>\n<span class="code-comment"><span class="code-comment">#后面的参数可以根据需要调整，请查阅cvt相关的说明</span></span>\n<span class="code-variable"><span class="code-variable">$xrandr</span></span> --newmode <span class="code-string"><span class="code-string">"1440x900_60.00"</span></span>  106.50  1440 1528 1672 1904  900 903 909 934 -hsync +vsync</code></pre>\n<p>3.增加到对应的显示器。</p>\n<p>先用xrandr命令查询对应的显示器：</p>\n<pre class="scss"><code class="language-bash"><span class="code-variable"><span class="code-variable">$xrandr</span></span>\n<span class="code-comment">#输出类似以下的内容</span>\nWAYLAND0 connected primary 1366x768+0+0 (<span class="code-attribute">normal</span> <span class="code-attribute">left</span> inverted <span class="code-attribute">right</span> x axis y axis) 309mm x 173mm\n   1366x768      60<span class="code-selector-class">.00</span>*+\n   1360x768      59<span class="code-selector-class">.80</span>    59<span class="code-selector-class">.96</span>\n   1024x768      60<span class="code-selector-class">.04</span>    60<span class="code-selector-class">.00</span>\n   960x720       60<span class="code-selector-class">.00</span>\n   928x696       60<span class="code-selector-class">.05</span>\nWAYLAND1 connected 1024x768+1366+0 (<span class="code-attribute">normal</span> <span class="code-attribute">left</span> inverted <span class="code-attribute">right</span> x axis y axis) 0mm x 0mm\n   1024x768      60<span class="code-selector-class">.00</span>*\n   800x600       60<span class="code-selector-class">.32</span>    56<span class="code-selector-class">.25</span>\n   848x480       60<span class="code-selector-class">.00</span>\n   640x480       59<span class="code-selector-class">.94</span>\n</code></pre>\n<p>记住WAYLAND0\\WAYLAND1的名称，这是我们显示器的代理名称。通常用手提的话WAYLAND0就是对应的手提电脑的显示器、其余的都是扩增屏幕。</p>\n<p>然后向对应显示器下增加一个模式：</p>\n<pre class="bash"><code class="language-bash"><span class="code-variable"><span class="code-variable">$xrandr</span></span> --addmode WAYLAND1 <span class="code-string"><span class="code-string">"1440x900_60.00"</span></span></code></pre>\n<p>然后就OK了..........</p>\n\n<h2 id="h2-2">遇到的问题</h2>\n<p>但是，要是天底下的事情都这么轻松世界就完美了。</p>\n\n<h3 id="h3-1">问题一，xrand命令指针对当前用户</h3>\n<p>在使用 xrand命令时切记是针对当前用户的。例如我就是创建了一个管理员用户，然后把root账户禁用了。在执行命令时习惯性的加 <strong><em>sudo</em></strong>，最后会输出类似于 <em>"MIT-MAGIC-COOKIE-1 keyCan\'t open display :0.0" </em>这样的内容。</p>\n\n<h3 id="h3-2"><strong><em>问题二，最后一步输出 xrandr: Configure crtc 0 failed</em></strong></h3>\n<p>在最后一行&nbsp;<strong><em>$xrandr --addmode WAYLAND1 "1440x900_60.00" </em></strong>命令之后并没有修改成功，而是输出了<strong><em>xrandr: Configure crtc 0 failed&nbsp;</em></strong>或&nbsp;<strong><em>xrandr: Configure crtc 1 failed</em></strong>这样的内容。查阅了一圈资料。在askubuntu找到说明。据说是升级到Ubuntu17.10之后，使用AMD/ATI的显卡容易遇到这个坑，wayland识别不了显示器。这个时候打开Setting的Displays面板显示的是 Unknown Display，最高分辨率只能到1024*768，最不费劲的方法是可以通过安装新的驱动源来解决（但是我安装了一次还是不行）。</p>\n<p>实际上，只要显卡和显示器都支持某个分辨率，直接告诉显卡按照这个分辨率输出图像就好了，不用wayland去识别显示器。</p>\n<p>首先关闭wayland服务，wayland是17.10之后新用的显示器服务（据说是可以在登陆界面选择和X.org切换，但是我的居然没有）。关闭方法：</p>\n<p>1.打开配置文件：</p>\n<pre class="nginx"><code class="language-bash"><span class="code-comment"><span class="code-comment">#打开custom.conf文件，不同发行版文件位置可能有差异</span></span>\n<span class="code-attribute">vim</span> /etc/gdm3/custom.conf</code></pre>\n<p>2.修改文件，找到 <strong><em>#WaylandEnable=false</em></strong> 这一行，然后去掉注释。</p>\n<pre class="ini"><code class="language-bash"><span class="code-comment"><span class="code-comment"># Uncoment the line below to force the login screen to use Xorg</span></span>\n<span class="hljs-attr">WaylandEnable</span>=<span class="hljs-literal"><span class="hljs-literal">false</span></span>\n<span class="code-comment"><span class="code-comment">#......</span></span></code></pre>\n<p>3.最后reboot重启电脑。</p>\n<p>4.启动完成后输入 xrandr 命令发现之前的&nbsp;WAYLAND0 和&nbsp;WAYLAND1 变成了输出端口的名称：</p>\n<pre class="swift"><code class="language-bash"><span class="code-variable">$xrandr</span>\n<span class="code-comment">#输出</span>\n<span class="code-type">Screen</span> <span class="hljs-number">0</span>: minimum <span class="hljs-number">320</span> x <span class="hljs-number">200</span>, current <span class="hljs-number">2806</span> x <span class="hljs-number">900</span>, maximum <span class="hljs-number">8192</span> x <span class="hljs-number">8192</span>\neDP-<span class="hljs-number">1</span> connected primary 1366x768+<span class="hljs-number">0</span>+<span class="hljs-number">0</span> (normal <span class="code-keyword">left</span> inverted <span class="code-keyword">right</span> x axis y axis) 309mm x 173mm\n   1366x768      <span class="hljs-number">60.00</span>*+\n   1360x768      <span class="hljs-number">59.80</span>    <span class="hljs-number">59.96</span>\n   1024x768      <span class="hljs-number">60.04</span>    <span class="hljs-number">60.00</span>\n   960x720       <span class="hljs-number">60.00</span>\n   928x696       <span class="hljs-number">60.05</span>\n<span class="code-type">HDMI</span>-<span class="hljs-number">1</span> disconnected (normal <span class="code-keyword">left</span> inverted <span class="code-keyword">right</span> x axis y axis)\n<span class="code-type">DP</span>-<span class="hljs-number">1</span> connected 1440x900+<span class="hljs-number">1366</span>+<span class="hljs-number">0</span> (normal <span class="code-keyword">left</span> inverted <span class="code-keyword">right</span> x axis y axis) 0mm x 0mm\n   1024x768      <span class="hljs-number">60.00</span>\n   800x600       <span class="hljs-number">60.32</span>    <span class="hljs-number">56.25</span>\n   848x480       <span class="hljs-number">60.00</span>\n   640x480       <span class="hljs-number">59.94</span>\n<span class="code-type">HDMI</span>-<span class="hljs-number">2</span> disconnected (normal <span class="code-keyword">left</span> inverted <span class="code-keyword">right</span> x axis y axis)</code></pre>\n<p>这里的DP-1就是我用的外接显示器，但是现在只能显示到1024*768。然后按照前面介绍的方法依次执行<em><strong>$cvt 1440 900</strong></em>、<strong><em>$xrandr newmode</em></strong>、<em><strong>$xrandr addmode DP-1 "1440x900_60.00"</strong></em>，仅仅是最后addmode的参数有些许差异。</p>\n<p>修改后，在Displays里可以看到最新的分辨率。</p>\n\n<h2 id="h2-3">永久性问题</h2>\n<p>最后，用这个方法有个最大的问题是没法保存。每次重启过后还是没法识别显示器的分辨率，又回到修改之前的状态。</p>\n<p>有些地方说可以像下面这样添加或修改&nbsp;/etc/X11/xorg.conf&nbsp; 文件：</p>\n<pre class="nginx"><code class="nginx"><span class="code-attribute"><span class="code-attribute">Section</span></span> <span class="code-string"><span class="code-string">"Monitor"</span></span>\nIdentifier <span class="code-string"><span class="code-string">"Configured Monitor"</span></span>\nModeline <span class="code-string"><span class="code-string">"1920x1080_60.00"</span></span>  <span class="hljs-number"><span class="hljs-number">173</span></span>.<span class="hljs-number"><span class="hljs-number">00</span></span>  <span class="hljs-number"><span class="hljs-number">1920</span></span> <span class="hljs-number"><span class="hljs-number">2048</span></span> <span class="hljs-number"><span class="hljs-number">2248</span></span> <span class="hljs-number"><span class="hljs-number">2576</span></span>  <span class="hljs-number"><span class="hljs-number">1080</span></span> <span class="hljs-number"><span class="hljs-number">1083</span></span> <span class="hljs-number"><span class="hljs-number">1088</span></span> <span class="hljs-number"><span class="hljs-number">1120</span></span> -hsync +vsync\nOption <span class="code-string"><span class="code-string">"PreferredMode"</span></span> <span class="code-string"><span class="code-string">"1920x1080_60.00"</span></span>\nEndSection\nSection <span class="code-string"><span class="code-string">"Screen"</span></span>\nIdentifier <span class="code-string"><span class="code-string">"Default Screen"</span></span>\nMonitor <span class="code-string"><span class="code-string">"Configured Monitor"</span></span>\nDevice <span class="code-string"><span class="code-string">"Configured Video Device"</span></span>\nEndSection\nSection <span class="code-string"><span class="code-string">"Device"</span></span>\nIdentifier <span class="code-string"><span class="code-string">"Configured Video Device"</span></span>\nEndSection</code></pre>\n<p>但是我修改之后没有任何效果。而且还多出一份&nbsp;/etc/X11/xorg.conf.failsafe 文件。不知道是不是17.0.4特有的原因，毕竟我也是将系统升级为17.0.4之后分辨率才出问题的。</p>\n<p>既然 xorg.conf 配置无法生效，我直接将命令创建为一个shell，然后开机运行即可：</p>\n<pre class="css"><code class="language-bash"><span class="code-comment"><span class="code-selector-id">#view-port-init</span><span class="code-selector-class">.sh</span></span>\n<span class="code-selector-tag">xrandr</span> <span class="code-selector-tag">--newmode</span> <span class="code-string">"1920<span class="code-selector-tag">x1080_60</span><span class="code-selector-class">.00</span>"</span>  173<span class="code-selector-class">.00</span>  1920 2048 2248 2576  1080 1083 1088 1120 <span class="code-selector-tag">-hsync</span> +<span class="code-selector-tag">vsync</span>\n<span class="code-selector-tag">xrandr</span> <span class="code-selector-tag">--addmode</span> <span class="code-selector-tag">DP-1</span> <span class="code-string">"1920<span class="code-selector-tag">x1080_60</span><span class="code-selector-class">.00</span>"</span>\n<span class="code-comment"><span class="code-selector-id">#DP-1</span>这里请根据自己的参数修改。</span>\n</code></pre>\n<p>参考：<a href="https://askubuntu.com/questions/136139/xrandr-configure-crtc-0-failed-when-trying-to-change-resolution-on-external-m?answertab=active#tab-top" rel="nofollow">xrandr-configure-crtc-0-failed-when-trying-to-change-resolution</a>。</p>\n'},348:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<p>在前面两篇介绍Sring核心与设计模式的文章中，分别介绍了<a title="Ioc容器"\n                                   href="https://www.chkui.com/article/spring/spring_core_design_pattern_and_ioc">Ioc容器</a>和\n    <a title="Bean的依赖关系" href="https://www.chkui.com/article/spring/spring_core_design_pattern_and_ioc">Bean的依赖关系</a>。如果阅读过前2文就会知道，Spring的整个运转机制就是围绕着IoC容器以及Bean展开的。IoC就是一个篮子，所有的Bean都向里面扔。除了提供篮子功能创建并存放Bean之外，IoC还要负责管理Bean与Bean之间的关系——依赖注入。之前也提到Bean是Spring核心容器的最小工作单元，Spring一些更高级的功能（例如切面、代理）都是在Bean的基础上实现。\n</p>\n<p>除了管理Bean与Bean之间的关系，IoC还提供了对Bean自身进行控制的各项功能，本文将介绍Bean的<strong>生命周期功能</strong>以及<strong>状态定义功能。</strong></p>\n\n<h2 id="h2-1">前置依赖</h2>\n<p>\n    Bean与Bean之间存在依赖关系，可以是强依赖（通过XML和注解直接声明依赖）、也可以是弱依赖（ApplicationContextAware等方式获取）。当一个Bean需要另外一个Bean完成初始化后自身才能工作时，例如一个Bean依赖DataSoruce，但是DataSource的初始化需要较长时间。这个时候用<em>depends-on</em>声明前置依赖即可：\n</p>\n<pre><code class="xml"><span class="code-comment">&lt;!-- 依赖多个Bean使用,号分割 --&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"beanOne"</span> <span class="hljs-attr">class</span>=<span class="code-string">"ExampleBean"</span> <span\n        class="hljs-attr">depends-on</span>=<span class="code-string">"manager,accountDao"</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"manager"</span> <span class="hljs-attr">ref</span>=<span\n            class="code-string">"manager"</span> /&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"manager"</span> <span class="hljs-attr">class</span>=<span class="code-string">"ManagerBean"</span> /&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"accountDao"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.jdbc.JdbcAccountDao"</span> /&gt;</span></code></pre>\n\n<h2 id="h2-2">延迟加载</h2>\n<p>通常情况下，所有的&nbsp;<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-singleton"\n        rel="nofollow">singleton</a>&nbsp;类型的Bean都会在容器创建后进行初始化，简单的说就是启动Jvm就开始创建（实际上是创建ApplicationContext的某个实现类实例之后）。</p>\n<p>IoC支持所有的&nbsp;<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-singleton"\n        rel="nofollow">singleton</a>&nbsp;Bean在使用时再加载，这样做的好处是可以大大节省初始化的时间。<span style="color:#e74c3c">但是如果你的应用对启动时间的长短并不敏感，建议让所有的&nbsp;</span><a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-singleton"\n        rel="nofollow"><span style="color:#e74c3c">singleton</span></a><span style="color:#e74c3c">&nbsp;都启动时加载。这样可以在启动时就发现一些问题，而不是在运行很久直到使用时才由用户去触发这个问题</span>。或者可以根据场景来使用决定是否延迟，例如开发时使用延迟加载，而在集成测试或上生产时关闭。\n</p>\n<p>可以设置全局延迟加载，也可以设置某个Bean延迟加载：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span> <span class="hljs-attr">default-lazy-init</span>=<span\n        class="code-string">"true"</span>&gt;</span>\n    <span class="code-comment">&lt;!-- 所有的Bean知道使用的时候才会进行加载... --&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<pre><code class="xml"><span class="code-comment">&lt;!-- 只有lazy类延迟加载 --&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"lazy"</span> <span class="hljs-attr">class</span>=<span class="code-string">"com.foo.ExpensiveToCreateBean"</span> <span\n        class="hljs-attr">lazy-init</span>=<span class="code-string">"true"</span>/&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">name</span>=<span\n        class="code-string">"not.lazy"</span> <span class="hljs-attr">class</span>=<span class="code-string">"com.foo.AnotherBean"</span>/&gt;</span></code></pre>\n<p>需要注意的是，在设置某个单独的Bean延迟加载时，如果有某个没有延迟加载的Bean要依赖他，那实际上也会在初始化的时候就加载。</p>\n<p>还要强调一下，这里的“加载”仅仅是为了表示一个类被Ioc创造并放置容器中，和classLoad方法将class文件中的字节码加载到方法区的加载是两个概念。</p>\n<p>延迟加载在设计模式上是单例模式一种延伸，通常也被称为懒汉模式。单例通常有双重锁+volatile、静态类和枚举三种方式实现。在<a\n        href="http://www.baidu.com/link?url=kGkdnL7l_ll3LfLYL8dxNgxmZdGW-wKRbUh6i8wRu2CERbWLWDBkpLtu38Jg9qTx0-KOIOBr6FXsjRwJigZmxa"\n        target="_blank" rel="nofollow">Effective&nbsp;<em>Java</em></a>一书中对三种模式都有深入的解析。而对于Spring容器而言，枚举的方式肯定不好用了，静态类由于属于自身代码级别应该也不会用，所以双重锁的实现方式较为可信。不过我没去看过源码，仅属于猜测。\n</p>\n\n<h2 id="h2-3">生命周期方法</h2>\n<p>一个Bean的创建、使用再到最后销毁称为"Bean的生命周期"。Spring框架为Bean的生命周期各个阶段提供了多种回掉方法来处理各种状态或者数据。</p>\n\n<h3 id="h3-1">初始化方法</h3>\n<p>\n    当一个Bean完成初始化并注入各项参数之后，初始化回掉方法会被调用，简单的说就是完成创建之后会被调用。实现初始化回调方法有2个路径：1.继承org.springframework.beans.factory.InitializingBean接口，然后实现\n    afterPropertiesSet方法。2.在Bean的XML配置上使用init-method属性来制定要调用的初始化：</p>\n<p>继承实现：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.A"</span> /&gt;</span></code></pre>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">A</span> <span class="code-keyword">implements</span> <span class="code-title">InitializingBean</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">afterPropertiesSet</span><span class="hljs-params">()</span></span>{\n        <span class="code-comment">// init</span>\n    }\n}</code></pre>\n<p>配置实现：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span\n        class="code-string">"x.y.A"</span> <span class="hljs-attr">init-method</span>=<span\n        class="code-string">"init"</span> /&gt;</span></code></pre>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">A</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">init</span><span class="hljs-params">()</span></span>{}\n}</code></pre>\n<p>2种方法都等效，实际使用是我们应该使用哪一种方法呢？</p>\n<p>InitializingBean是Spring早期实现的一个生命周期回调方法。但是在JCP推出JSR-250和<a title="JSR-330"\n                                                             href="https://www.chkui.com/article/java/java_jsr330"\n>JSR-330</a>规范之后，Spring的大神们开始意识到基于元编程思想和配置手段来实现非侵入式框架（Not\n    Coupled）才是正道。所以现在都是推荐使用配置文件和JSR-250的@PostConstruct（关于各种Annotation的使用请关注后续的文章）。现在依然保留InitializingBean应该是考虑到兼容问题。</p>\n\n<h3 id="h3-2">销毁方法</h3>\n<p>与创建方法相对应的是销毁方法。当一个类将要被销毁之前，对应的销毁回调方法会被调用。销毁方法也有一个继承实现和配置+注解实现：</p>\n<p>继承实现：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.A"</span> /&gt;</span></code></pre>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">A</span> <span class="code-keyword">implements</span> <span class="code-title">DisposableBean</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">destroy</span><span class="hljs-params">()</span></span>{\n        <span class="code-comment">// 销毁资源</span>\n    }\n}</code></pre>\n<p>配置实现：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span\n        class="code-string">"x.y.A"</span> <span class="hljs-attr">destroy-method</span>=<span class="code-string">"cleanUp"</span> /&gt;</span></code></pre>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">A</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">cleanUp</span><span class="hljs-params">()</span></span>{\n        <span class="code-comment">// 销毁资源</span>\n    }\n}</code></pre>\n<p>依然建议销毁手段也使用配置或@PreDestroy来设定销毁方法。</p>\n\n<h3 id="h3-3">全局配置初始化与销毁方法</h3>\n<p>IoC容器还提供了全局配置初始化与销毁方法的配置：</p>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">A</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">init</span><span class="hljs-params">()</span></span>{\n        <span class="code-comment">// 初始化资源</span>\n    }\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">destroy</span><span class="hljs-params">()</span></span>{\n        <span class="code-comment">// 销毁资源</span>\n    }\n}</code></pre>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span> <span class="hljs-attr">default-init-method</span>=<span\n        class="code-string">"init"</span> <span class="hljs-attr">default-destroy-method</span>=<span\n        class="code-string">"destroy"</span>&gt;</span>\n     <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n             class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span\n             class="code-string">"x.y.A"</span>/&gt;</span>\n     <span class="code-comment">&lt;!-- bean configuration --&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>通过在&lt;beans&gt;标签上使用<em>default-init-method</em>和<em>default-destroy-method</em>&nbsp;属性参数，可以为容器中所有的Bean统一指定初始化和销毁的生命周期方法。\n</p>\n<p>如果在&lt;beans&gt;上设定2个默认的生命周期方法，同时在&lt;bean&gt;上也指定了<em>init-method</em>或<em>destroy-method，</em>回调方法会以&lt;bean&gt;上的配置为准。这样就保证全局配置与单独配置可以共存。\n</p>\n<p>使用初始化或销毁2个生命周期方法注意的要点：</p>\n<ol>\n    <li>\n        初始化和销毁都提供了3种手段：XML配置、注解、以及实现接口。系统的各个部分会交由不同的团队开发，不遵循统一的规范，建议使用满足JSR规范的注解——@PostConstruct、@PreDestroy。如果是统一的团队，准训一致的规范，建议使用&lt;beans&gt;的属性统一名称使用全局配置。\n    </li>\n    <li>如果Bean设计到代理模式时（例如使用了AOP），那么生命周期方法被调用时，有可能代理类还没有被创建出来。因为生命周期方法是实体类完成对应工作之后就会被调用，而与代理类无关。</li>\n</ol>'},353:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<h2 id="h2-1"><span style="font-family:微软雅黑,microsoft yahei">调用堆栈</span></h2>\n<p><em>&nbsp;&nbsp;&nbsp;&nbsp;io.vertx.ext.mongo.impl.MongoClientImpl；</em></p>\n<p><em>&nbsp;&nbsp;&nbsp;&nbsp;io.vertx.ext.mongo.impl.MongoHolder;</em></p>\n<p><em>&nbsp;&nbsp;&nbsp;&nbsp;io.vertx.ext.mongo.impl.config.MongoClientOptionsParser;</em></p>\n\n<h2 id="h2-2">实现过程</h2>\n<p>当调用<em>MongoClient::createShared()</em>或<em>MongoClient::createNonShared()</em>方法创建<em>mongo</em>的客户端时，最终都会调用到<em>MongoClientImpl</em>的构造函数。</p>\n<pre class="kotlin"><code class="language-java"> <span class="hljs-function"><span class="code-keyword"><span class="code-keyword">public</span></span> <span class="code-title">MongoClientImpl</span><span class="hljs-params">(Vertx vertx, JsonObject config, String dataSourceName)</span> </span>{\n    Objects.requireNonNull(vertx);\n    Objects.requireNonNull(config);\n    Objects.requireNonNull(dataSourceName);\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.vertx = vertx;\n    <span class="code-comment"><span class="code-comment">// 检查或创建新的MongHolder</span></span>\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.holder = lookupHolder(dataSourceName, config);\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.mongo = holder.mongo();\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.useObjectId = config.getBoolean(<span class="code-string"><span class="code-string">"useObjectId"</span></span>, <span class="code-keyword"><span class="hljs-literal">false</span></span>);\n  }</code></pre>\n<p>如果是通过<em>createNonShared</em>方法创建client时，这里传入的<em>dataSourceName</em>是一个UUID。当使用<em>createShared</em>创建<em>client</em>,会在<em>lookupHolder</em>方法中检查是否已经创建了同名的客户端，否则新建。</p>\n<p>下图是检查数据源的过程。会根据传入的&nbsp;<em>datasourceName </em>从 <em>vertx </em>实例的共享数据实例（<em>io.vertx.core.shareddata.SharedData</em>）中获取同名的 <em>MongoHolder </em>实例。</p>\n<pre class="cpp"><code class="language-java"> <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">private</span></span></span><span class="hljs-function"> MongoHolder </span><span class="code-title"><span class="hljs-function"><span class="code-title">lookupHolder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String datasourceName, JsonObject config)</span></span></span><span class="hljs-function"> </span></span>{\n    <span class="code-keyword">synchronized</span> (vertx) {\n      <span class="code-comment"><span class="code-comment">// 获取共享数据实例中的map</span></span>\n      LocalMap&lt;String, MongoHolder&gt; <span class="code-built_in">map</span> = vertx.sharedData().getLocalMap(DS_LOCAL_MAP_NAME);\n\n      <span class="code-comment"><span class="code-comment">// 检查datasourceName对应的MongoHolder 是否存在</span></span>\n      MongoHolder theHolder = <span class="code-built_in">map</span>.get(datasourceName);\n\n      <span class="code-comment"><span class="code-comment">// 不存在则新构建，并将构建的结果放入sharedData的map中</span></span>\n      <span class="code-keyword"><span class="code-keyword">if</span></span> (theHolder == <span class="code-keyword">null</span>) {\n        theHolder = <span class="code-keyword"><span class="code-keyword">new</span></span> MongoHolder(config, () -&gt; removeFromMap(<span class="code-built_in">map</span>, datasourceName));\n        <span class="code-built_in">map</span>.put(datasourceName, theHolder);\n      } <span class="code-keyword"><span class="code-keyword">else</span></span> {\n        <span class="code-comment"><span class="code-comment">// 递增被引用的计数</span></span>\n        theHolder.incRefCount();\n      }\n      <span class="code-keyword"><span class="code-keyword">return</span></span> theHolder;\n    }\n  }</code></pre>\n<p>如果实例不存在，则会创建新的&nbsp;<em>MongoHolder </em>实例。<span style="color:#FF8C00">个人认为这里有个很不完美的地方是为了解决懒汉模式的问题，增加了一个线程锁。在高并发请求数据库连接资源时，这里会有阻塞。因此我在自己的实现类中存储了MongoClient的实例。不过这个线程锁可以有效减少数据库连接池的爆发式增长，在数据库连接池资源较少的情况下，有不错的效果（比如我们某个项目使用了阿里云的mongDB，最低配置只有200个连接）</span>。</p>\n<p>下图是&nbsp;<em>MongoHolder </em>的构造方法。</p>\n<pre class="kotlin"><code class="language-java"><span class="hljs-function"><span class="code-keyword"><span class="code-keyword">public</span></span> <span class="code-title">MongoHolder</span><span class="hljs-params">(JsonObject config, Runnable closeRunner)</span> </span>{\n      <span class="code-keyword"><span class="code-keyword">this</span></span>.config = config;\n      <span class="code-keyword"><span class="code-keyword">this</span></span>.closeRunner = closeRunner;\n    }</code></pre>\n<p><em>&nbsp;&nbsp;&nbsp;&nbsp;MongoHolder&nbsp;</em>构造方法只是简单的设置了成员变量 <em>config&nbsp;</em>和 <em>closeRunner </em>的值。<em>closeRunner</em>当调用<em>MongoClient::close()</em>方法时，用于回调销毁<em>SharedData::localMap</em>中的对应索引数据。<em>config </em>是用户传入的配置参数，需要注意的是，<em>config </em>传递到这里一直没有被改变。</p>\n<p>创建&nbsp;<em>MongoHolder&nbsp;</em>的实例成功后，接下来会调用&nbsp;<em>MongoHolder::mongo() </em>来创建一个真正&nbsp;<em>com.mongodb.async.client.MongoClient</em> 实例。这里同样使用了懒汉模式，存在线程锁，如果MongoClient的实例存在直接返回，如果不存在，则新建一个实例。</p>\n<pre class="java"><code class="language-java"><span class="code-keyword"><span class="code-keyword">synchronized</span></span> com.mongodb.async.client.<span class="hljs-function"><span class="hljs-function">MongoClient </span><span class="code-title"><span class="hljs-function"><span class="code-title">mongo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{\n      <span class="code-keyword"><span class="code-keyword">if</span></span> (mongo == <span class="code-keyword"><span class="code-keyword">null</span></span>) {\n        <span class="code-comment"><span class="code-comment">// 解析外部传递的config</span></span>\n        MongoClientOptionsParser parser = <span class="code-keyword"><span class="code-keyword">new</span></span> MongoClientOptionsParser(config);\n\n        <span class="code-comment"><span class="code-comment">// 将解析结果用于创建新的com.mongodb.async.client.MongoClient实例</span></span>\n        mongo = MongoClients.create(parser.settings());\n        String dbName = config.getString(<span class="code-string"><span class="code-string">"db_name"</span></span>, DEFAULT_DB_NAME);\n        db = mongo.getDatabase(dbName);\n      }\n      <span class="code-keyword"><span class="code-keyword">return</span></span> mongo;\n    }</code></pre>\n<p><em>&nbsp;&nbsp;&nbsp;&nbsp;MongoClientOptionsParser 对象</em>是创建Mongo客户端的关键，他会解析用户传递的参数来创建mongDB客户端，理解他的解析方法有利于创建合适的客户端。</p>\n<p><em>&nbsp;&nbsp;&nbsp;&nbsp;MongoClientOptionsParser </em>的构造方法共有60行，这里分几段说明。为了更好的理解创建过程，建议了解下<a title="MongoDB异步Java驱动" href="http://mongodb.github.io/mongo-java-driver/3.2/driver-async" rel="nofollow">MongoDB异步Java驱动</a>。下面的构造客户端参数的第一部分。</p>\n<pre class="gradle"><code class="language-java"> <span class="hljs-function"><span class="code-keyword"><span class="code-keyword">public</span></span> <span class="code-title">MongoClientOptionsParser</span><span class="hljs-params">(JsonObject config)</span> </span>{\n    Objects.requireNonNull(config);\n    \n    <span class="code-comment"><span class="code-comment">// 创建mongoDB的构建对象</span></span>\n    MongoClientSettings.Builder <span class="code-keyword">options</span> = MongoClientSettings.builder();\n\n    <span class="code-comment"><span class="code-comment">// 注册对象数据的存储规则</span></span>\n    <span class="code-keyword">options</span>.codecRegistry(CodecRegistries.fromRegistries(commonCodecRegistry, CodecRegistries.fromCodecs(<span class="code-keyword"><span class="code-keyword">new</span></span> JsonObjectCodec(config))));\n\n    <span class="code-comment"><span class="code-comment">// 获取连接串，所有的定义参数都来自连接串</span></span>\n    String cs = config.getString(<span class="code-string"><span class="code-string">"connection_string"</span></span>);\n\n    <span class="code-comment"><span class="code-comment">// 解析连接串</span></span>\n    ConnectionString connectionString = (cs == <span class="code-keyword"><span class="code-keyword">null</span></span>) ? <span class="code-keyword"><span class="code-keyword">null</span></span> : <span class="code-keyword"><span class="code-keyword">new</span></span> ConnectionString(cs);\n\n    <span class="code-comment"><span class="code-comment">// 解析集群参数</span></span>\n    ClusterSettings clusterSettings = <span class="code-keyword"><span class="code-keyword">new</span></span> ClusterSettingsParser(connectionString, config).settings();\n    <span class="code-keyword">options</span>.clusterSettings(clusterSettings);\n\n    <span class="code-comment"><span class="code-comment">// 解析连接池参数</span></span>\n    ConnectionPoolSettings connectionPoolSettings = <span class="code-keyword"><span class="code-keyword">new</span></span> ConnectionPoolSettingsParser(connectionString, config).settings();\n    <span class="code-keyword">options</span>.connectionPoolSettings(connectionPoolSettings);\n\n    <span class="code-comment"><span class="code-comment">// some code</span></span>\n}</code></pre>\n<p>首先创建&nbsp;<em>MongoClientSettings </em>的构造对象。</p>\n<p>然后根据传递的参数构建&nbsp;<em>CodecRegistry </em>实例。<em>CodecRegistry </em>的说明见 <a title="mongDB官网CodecRegistry的API说明" href="http://api.mongodb.com/java/3.2/?com/mongodb/async/client/MongoClientSettings.html" rel="nofollow">mongDB官网CodecRegistry的API说明</a>。<em>CodecRegistry 用于指定相关的对象在mongoDB的读写实现类，</em>例如官方已经源生实现了<em>&nbsp;StringCodec、IntegerCodec</em>来处理Java的<em>String、Integer</em>对象<em>。</em></p>\n<p>这段代码的最后部分，创建一个&nbsp;<em>ConnectionString&nbsp;</em>实例来分解和存储连接串的解析结果。<em>ConnectionString </em>是&nbsp;<em>mongoDB&nbsp;</em>官方实现的解析连接串参数方法<em>。</em>可以将http协议串解析成对应的初始化参数，例如设置连接池最小连接数为20，最大连接数为200：&nbsp;<span style="color:#FF8C00"><em>mongodb://host:27017/?minPoolSize=20&amp;maxPoolSize=200 </em></span>。详细说明见&nbsp;<a title="ConnectionString API" href="http://api.mongodb.com/java/3.2/?com/mongodb/ConnectionString.html" rel="nofollow"><em>ConnectionString&nbsp;</em>的API文档</a> &nbsp;和 <a title="mongoDB官方指引手册" href="http://mongodb.github.io/mongo-java-driver/3.2/driver-async/reference/connecting/connection-settings/" rel="nofollow">mongoDB官方指引手册</a>&nbsp;。</p>\n<p>下面的代码是&nbsp;<em>ClusterSettingsParser&nbsp;</em>对传入的数据进行解析，<em>vertx-mongdb</em>解析连接参数都是采用类似的思路：优先使用mongodb源生连接串中指定的参数，如果参数不存在，则使用用户传入的参数。因此，在我们设计mongodb的连接参数时，可以在传入的JsonObject实例中统一在key="connection_string"的参数中一次性制定mongdb风格的连接字符串，还可以在这个实例中通过key值设置vertx风格的各种连接参数。如果2个参数都存在，则优先使用连接字符串。</p>\n<pre class="java"><code class="java"><span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">public</span></span></span><span class="hljs-function"> </span><span class="code-title"><span class="hljs-function"><span class="code-title">ClusterSettingsParser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ConnectionString connectionString, JsonObject config)</span></span></span><span class="hljs-function"> </span></span>{\n\n    <span class="code-comment"><span class="code-comment">// 创建mongdb集群builder方法</span></span>\n    ClusterSettings.Builder settings = ClusterSettings.builder();\n\n    <span class="code-comment"><span class="code-comment">// 优先从连接字符串中使用mongdb源生方法解析相关参数 </span></span>\n    <span class="code-keyword"><span class="code-keyword">if</span></span> (connectionString != <span class="code-keyword"><span class="code-keyword">null</span></span>) {\n      settings.applyConnectionString(connectionString);\n    } <span class="code-keyword"><span class="code-keyword">else</span></span> {\n      <span class="code-comment"><span class="code-comment">// 如果连接字符串中相关的参数不存在，则从用户传入的config中提取指定的数据</span></span>\n      <span class="code-comment"><span class="code-comment">// 设置host列表</span></span>\n      <span class="code-comment"><span class="code-comment">// 在parseHosts中优先解析config是否存在包含key=hosts的JsonArray实例，如果有则会即系多个连接服务器</span></span>\n      <span class="code-comment"><span class="code-comment">// 如果没有key=hosts，则解析host和port是否存在</span></span>\n      List&lt;ServerAddress&gt; hosts = parseHosts(config);\n      settings.hosts(hosts);\n\n      <span class="code-comment"><span class="code-comment">// 设置mongdb的运行模式和replica模式</span></span>\n      String replicaSet = config.getString(<span class="code-string"><span class="code-string">"replicaSet"</span></span>);\n      <span class="code-keyword"><span class="code-keyword">if</span></span> (hosts.size() == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; replicaSet == <span class="code-keyword"><span class="code-keyword">null</span></span>) {\n        settings.mode(ClusterConnectionMode.SINGLE);\n      } <span class="code-keyword"><span class="code-keyword">else</span></span> {\n        settings.mode(ClusterConnectionMode.MULTIPLE);\n      }\n      <span class="code-keyword"><span class="code-keyword">if</span></span> (replicaSet != <span class="code-keyword"><span class="code-keyword">null</span></span>) {\n        settings.requiredReplicaSetName(replicaSet);\n      }\n    }\n\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.settings = settings.build();\n  }</code></pre>\n<p>这里就不一一说明每一个解析方法，基本上都是一样的套路。</p>\n<p>解析完连接参数后，用这些参数直接调用<em>MongoClients::create</em>来创建mongdb的客户端实例。然后从客户端从获取mongodb的连接。</p>\n\n<h2 id="h2-3"><span style="font-family:微软雅黑,microsoft yahei">总结</span></h2>\n<p>至此，mongdb的创建过程完毕。在创建的过程中，可以实现mongdb源生的连接串，也可以使用vertx风格的JsonObject。mongdb自身已经实现了全异步接口，因此vertx-mongdb只是在此基础上进行了一层封装。下面的附表是vertx-mongdb相关的设置参数。可以在建立vertx-mongdb实例时，通过JsonObject传入。</p>\n<pre class="actionscript"><code class="actionscript">{\n  <span class="code-comment"><span class="code-comment">// 设置单个mongdb服务时使用host、port指定主机和端口</span></span>\n  <span class="code-string"><span class="code-string">"host"</span></span> : <span class="code-string"><span class="code-string">"17.0.0.1"</span></span>, <span class="code-comment"><span class="code-comment">// string --mongdb实例所在的地址</span></span>\n  <span class="code-string"><span class="code-string">"port"</span></span> : <span class="hljs-number"><span class="hljs-number">27017</span></span>,      <span class="code-comment"><span class="code-comment">// int --mongdb实例的端口号</span></span>\n\n  <span class="code-comment"><span class="code-comment">// 设置集群mongdb服务器时使用队列</span></span>\n  <span class="code-string"><span class="code-string">"hosts"</span></span> : [\n    {\n      <span class="code-string"><span class="code-string">"host"</span></span> : <span class="code-string"><span class="code-string">"cluster1"</span></span>, <span class="code-comment"><span class="code-comment">// string --集群1地址</span></span>\n      <span class="code-string"><span class="code-string">"port"</span></span> : <span class="hljs-number"><span class="hljs-number">27000</span></span>       <span class="code-comment"><span class="code-comment">// int --集群1端口号</span></span>\n    },\n    {\n      <span class="code-string"><span class="code-string">"host"</span></span> : <span class="code-string"><span class="code-string">"cluster2"</span></span>, <span class="code-comment"><span class="code-comment">// string --集群2地址</span></span>\n      <span class="code-string"><span class="code-string">"port"</span></span> : <span class="hljs-number"><span class="hljs-number">28000</span></span>       <span class="code-comment"><span class="code-comment">// int --集群2端口号</span></span>\n    },\n    ...\n  ],\n\n  <span class="code-comment"><span class="code-comment">// 数据库分布式方法</span></span>\n  <span class="code-string"><span class="code-string">"replicaSet"</span></span> :  <span class="code-string"><span class="code-string">"foo"</span></span>    <span class="code-comment"><span class="code-comment">// string</span></span>\n\n  <span class="code-comment"><span class="code-comment">// 连接池参数</span></span>\n  <span class="code-string"><span class="code-string">"maxPoolSize"</span></span> : <span class="hljs-number"><span class="hljs-number">100</span></span>,                <span class="code-comment"><span class="code-comment">// int --最大连接数</span></span>\n  <span class="code-string"><span class="code-string">"minPoolSize"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>,                <span class="code-comment"><span class="code-comment">// int --最小连接数</span></span>\n  <span class="code-string"><span class="code-string">"maxIdleTimeMS"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>,          <span class="code-comment"><span class="code-comment">// long --单个连接空闲释放时间，0时表示没有时间限制</span></span>\n  <span class="code-string"><span class="code-string">"maxLifeTimeMS"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>,         <span class="code-comment"><span class="code-comment">// long --单个连接最大存活时间，0时表示灭有时间限制</span></span>\n  <span class="code-string"><span class="code-string">"waitQueueMultiple"</span></span>  : <span class="hljs-number"><span class="hljs-number">500</span></span>,         <span class="code-comment"><span class="code-comment">// int --等待获取连接的排队队列最大数量。</span></span>\n  <span class="code-string"><span class="code-string">"waitQueueTimeoutMS"</span></span> : <span class="hljs-number"><span class="hljs-number">120000</span></span>,      <span class="code-comment"><span class="code-comment">// long --等待获取连接的最大等待时间。</span></span>\n  <span class="code-string"><span class="code-string">"maintenanceFrequencyMS"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>,   <span class="code-comment"><span class="code-comment">// long</span></span>\n  <span class="code-string"><span class="code-string">"maintenanceInitialDelayMS"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="code-comment"><span class="code-comment">// long</span></span>\n\n  <span class="code-comment"><span class="code-comment">// 账户、密码、连接信息</span></span>\n  <span class="code-string"><span class="code-string">"username"</span></span>   : <span class="code-string"><span class="code-string">"john"</span></span>,     <span class="code-comment"><span class="code-comment">// string</span></span>\n  <span class="code-string"><span class="code-string">"password"</span></span>   : <span class="code-string"><span class="code-string">"passw0rd"</span></span>, <span class="code-comment"><span class="code-comment">// string</span></span>\n  <span class="code-string"><span class="code-string">"authSource"</span></span> : <span class="code-string"><span class="code-string">"some.db"</span></span>   <span class="code-comment"><span class="code-comment">// string</span></span>\n  <span class="code-string"><span class="code-string">"authMechanism"</span></span>     : <span class="code-string"><span class="code-string">"GSSAPI"</span></span>,        <span class="code-comment"><span class="code-comment">// string --认证机制相关配置，详情见http://docs.mongodb.org/manual/core/authentication/</span></span>\n  <span class="code-string"><span class="code-string">"gssapiServiceName"</span></span> : <span class="code-string"><span class="code-string">"myservicename"</span></span>, <span class="code-comment"><span class="code-comment">// string --Kerberos单点登录相关接口API配置。</span></span>\n\n  <span class="code-comment"><span class="code-comment">// 联网相关的配置</span></span>\n  <span class="code-string"><span class="code-string">"connectTimeoutMS"</span></span> : <span class="hljs-number"><span class="hljs-number">10000</span></span> , <span class="code-comment"><span class="code-comment">// int // --连接到mongdb数据库实例返回的等待时间</span></span>\n  <span class="code-string"><span class="code-string">"socketTimeoutMS"</span></span>  : <span class="hljs-number"><span class="hljs-number">0</span></span>,    <span class="code-comment"><span class="code-comment">// int // --通过socket完成数据库相关操作的等待与返回时间，0时表示没有限制。</span></span>\n  <span class="code-string"><span class="code-string">"sendBufferSize"</span></span>    : <span class="hljs-number"><span class="hljs-number">0</span></span>,  <span class="code-comment"><span class="code-comment">// int // --设置通过socket发送数据的缓存大小,0时表示使用操作系统默认值。</span></span>\n  <span class="code-string"><span class="code-string">"receiveBufferSize"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>,  <span class="code-comment"><span class="code-comment">// int --设置通过socket获取数据的缓存大小,0时表示使用操作系统默认值。</span></span>\n  <span class="code-string"><span class="code-string">"keepAlive"</span></span> : <span class="hljs-literal"><span class="hljs-literal">false</span></span>       <span class="code-comment"><span class="code-comment">// boolean --设置是否保持数据库连接，默认为false</span></span>\n\n  <span class="code-comment"><span class="code-comment">// 设置集群之间的心跳配置</span></span>\n  <span class="code-string"><span class="code-string">"heartbeat.socket"</span></span> : {\n  <span class="code-string"><span class="code-string">"connectTimeoutMS"</span></span> : <span class="hljs-number"><span class="hljs-number">300000</span></span>, <span class="code-comment"><span class="code-comment">// int </span></span>\n  <span class="code-string"><span class="code-string">"socketTimeoutMS"</span></span>  : <span class="hljs-number"><span class="hljs-number">100000</span></span>, <span class="code-comment"><span class="code-comment">// int</span></span>\n  <span class="code-string"><span class="code-string">"sendBufferSize"</span></span>    : <span class="hljs-number"><span class="hljs-number">8192</span></span>,  <span class="code-comment"><span class="code-comment">// int</span></span>\n  <span class="code-string"><span class="code-string">"receiveBufferSize"</span></span> : <span class="hljs-number"><span class="hljs-number">8192</span></span>,  <span class="code-comment"><span class="code-comment">// int</span></span>\n  <span class="code-string"><span class="code-string">"keepAlive"</span></span> : <span class="hljs-literal"><span class="hljs-literal">true</span></span>           <span class="code-comment"><span class="code-comment">// boolean</span></span>\n  }\n\n  <span class="code-comment"><span class="code-comment">// 设置客户端和mongdb实例的心跳测试</span></span>\n  <span class="code-string"><span class="code-string">"heartbeatFrequencyMS"</span></span> :    <span class="hljs-number"><span class="hljs-number">5000</span></span> <span class="code-comment"><span class="code-comment">// long 集群监视器监控到达每个mongdb实例的心跳频率</span></span>\n  <span class="code-string"><span class="code-string">"minHeartbeatFrequencyMS"</span></span> : <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="code-comment"><span class="code-comment">// long 当前客户端到服务器的监控频率</span></span>\n}</code></pre>\n'}});