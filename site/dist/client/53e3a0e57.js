webpackJsonp([5],{339:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<p>JSR330是Jcp给出的官方标准反向依赖注入规范。Java大部分反向依赖注入的工具或者框架目前基本上都满足JSR330规范、例如spring、guice以及Dagger。</p>\n<p>以我们最常用的spring为例。</p>\n<p>JSR中<span style="color:#cc0000">@Inject</span>可以当做<span style="color:#cc0000">@AutoWired</span>来使用。而<span\n        style="color:#cc0000">@Named</span>可以当做<span style="color:#cc0000">@Component</span>来使用。</p>\n<p>使用JSR330首先要引入javax.inject包：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">dependency</span>&gt;</span>  \n    <span class="code-tag">&lt;<span class="code-name">groupId</span>&gt;</span>javax.inject<span class="code-tag">&lt;/<span\n            class="code-name">groupId</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">artifactId</span>&gt;</span>javax.inject<span class="code-tag">&lt;/<span\n            class="code-name">artifactId</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">version</span>&gt;</span>1<span class="code-tag">&lt;/<span\n            class="code-name">version</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">dependency</span>&gt;</span> </code></pre>\n<p>目前Maven中央仓库中就一个inject的jar。</p>\n<p>首先使用xml配置通过注解扫描添加bean。</p>\n<pre><code class="xml"><span class="php"><span class="code-meta">&lt;?</span>xml version=<span\n        class="code-string">"1.0"</span> encoding=<span class="code-string">"UTF-8"</span><span\n        class="code-meta">?&gt;</span></span>\n<span class="code-tag">&lt;<span class="code-name">beans</span> <span class="hljs-attr">xmlns</span>=<span\n        class="code-string">"http://www.springframework.org/schema/beans"</span>\n    <span class="hljs-attr">xmlns:xsi</span>=<span\n            class="code-string">"http://www.w3.org/2001/XMLSchema-instance"</span>\n    <span class="hljs-attr">xmlns:context</span>=<span class="code-string">"http://www.springframework.org/schema/context"</span>  \n    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="code-string">"http://www.springframework.org/schema/beans  \n    http://www.springframework.org/schema/beans/spring-beans-3.1.xsd  \n    http://www.springframework.org/schema/context  \n    http://www.springframework.org/schema/context/spring-context-3.1.xsd"</span>&gt;</span>  \n    <span class="code-tag">&lt;<span class="code-name">context:component-scan</span>  <span class="hljs-attr">base-package</span>=<span\n            class="code-string">"com.demo.jsr330"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span>  </code></pre>\n<p>然后像下面这个添加一个bean</p>\n<pre><code class="java"><span class="code-meta">@Named</span>  \n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">service</span> </span>{\n  <span class="hljs-function"><span class="code-keyword">public</span>  <span class="code-keyword">void</span>   <span\n          class="code-title">print</span><span class="hljs-params">()</span></span>{\n     System.out.println(<span class="code-string">"Service  print  method is invoked"</span>);  \n  }  \n}  </code></pre>\n<p>然后将这个bean注入到其他bean中去使用</p>\n<pre><code class="java"><span class="code-meta">@Named</span>  \n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Faction</span> </span>{\n  <span class="code-meta">@Inject</span>\n  Service service;\n\n  <span class="hljs-function"><span class="code-keyword">public</span>  <span class="code-keyword">void</span>  <span\n          class="code-title">show</span><span class="hljs-params">()</span></span>{\n     service.print()； \n  }  \n}  </code></pre>\n<p>JSR330还定义了<span style="color:#FF0000">@Qualifier</span>和<span style="color:#FF0000">@Provider</span>，对应到spring都给出了标准的实现。\n</p>\n<p>使用JSR330代替原注解的好处是无论使用任何反向依赖注入工具或框架，只要他是支持JSR330的，都可以平滑的切换。</p>'},345:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<h2 id="h2-1">Maven生命周期阶段</h2>\n<p>Maven为打包过程提供了各种各样的生命周期功能，主要有：</p>\n<ol>\n    <li>Validate：验证，对工程的所有内容进行验证。</li>\n    <li>compile：编译。</li>\n    <li>test：运行测试用例。</li>\n    <li>package：将代码进行打包并生成到本地。</li>\n    <li>integration-test：与其他的工程进行集成测试，会将依赖内容放置到一个统一环境中。</li>\n    <li>verify：校验功能，检查包的质量。</li>\n    <li>install：将打包之后的文件放置到本地仓库。</li>\n    <li>deploy：将已经打包的文件放置到远程仓库。</li>\n    <li>clean：清除之前构建的内容。</li>\n    <li>site：针对当前的工程生成一个可视化的站点文档。</li>\n</ol>\n<h2 id="h2-2">常用命令</h2>\n<p>对应以上生命周期都有一个对应的命令。</p>\n<ol>\n    <li><code>mvn compile</code>，编译代码，编译之后代码会出现在/target目录中，整合了IDE会自动执行这个步骤。</li>\n    <li><code>mvn test</code>，运行单元测试。</li>\n    <li><code>mvn test-compile</code>, 编译测试用用欧，并执行。如果在IDE中通过IDE会自定对单元测试代码打包。</li>\n    <li><code>mvn package</code>，对项目进行打包，打包之后会出现在/targer目录下。</li>\n    <li><code>mvn install</code>，安装包，会将打包之后的包安装到本地仓库对应的位置。</li>\n    <li><code>mvn deploy</code>，将包发布到远程仓库。</li>\n</ol>\n<p>maven打包基本上就涉及以上命令，除此之外还有一些配套的命令：</p>\n<ol>\n    <li><code>mvn site</code>，输出到/target一个依赖视图文档。</li>\n    <li>``</li>\n</ol>\n<h2 id="h2-3">Xml文件元素定义</h2>\n<ol>\n    <li>project：整个XML文档的最顶层标签。</li>\n    <li>modelVersion：使用的maven模型版本<code>&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</code></li>\n    <li>groupId：组织Id。<code>&lt;groupId&gt;com.mycompany.app&lt;/groupId&gt;</code></li>\n    <li>artifactId：标识符号id。<code>&lt;artifactId&gt;my-app&lt;/artifactId&gt;</code></li>\n    <li>packaging：打包模式， 例如JAR, WAR, EAR。<code>&lt;packaging&gt;jar&lt;/packaging&gt;</code></li>\n    <li>version：当前的版本号。<code>&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</code></li>\n    <li>name：项目名称。<code>&lt;name&gt;Maven Quick Start Archetype&lt;/name&gt;</code></li>\n    <li>url：项目地址。<code>&lt;url&gt;http://maven.apache.org&lt;/url&gt;</code></li>\n    <li>description: 项目介绍。</li>\n</ol>\n<h2 id="h2-4">测试用例运行规则</h2>\n<p>测试用例在运行的时候装载和排除一下格式的文件。\n    包含：</p>\n<ol>\n    <li><code>**/*Test.java</code></li>\n    <li><code>**/Test*.java</code></li>\n    <li><code>**/*TestCase.java</code></li>\n</ol>\n<p>排除：</p>\n<ol>\n    <li><code>**/Abstract*Test.java</code></li>\n    <li><code>**/Abstract*TestCase.java</code></li>\n</ol>\n<h2 id="h2-5">SNAPSHOT（快照版本）</h2>\n<p>当版本号使用<code>-SNAPSHOT</code>结构的后缀时表示这是一个快照版本。快照版本一般用于开发分支，快照版本即使不改变版本号也会自动获取到最新版本。以只相对的是发布（<code>Release</code>）版本，只要不使用<code>-SNAPSHOT</code>结尾的都是发布版本。每一个发布版本只对应一个编号。\n</p>\n<h2 id="h2-6">插件使用</h2>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">build</span>&gt;</span>\n  <span class="code-tag">&lt;<span class="code-name">plugins</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">plugin</span>&gt;</span>\n      <span class="code-tag">&lt;<span class="code-name">groupId</span>&gt;</span>org.apache.maven.plugins<span\n            class="code-tag">&lt;/<span class="code-name">groupId</span>&gt;</span>\n      <span class="code-tag">&lt;<span class="code-name">artifactId</span>&gt;</span>maven-compiler-plugin<span\n            class="code-tag">&lt;/<span class="code-name">artifactId</span>&gt;</span>\n      <span class="code-tag">&lt;<span class="code-name">version</span>&gt;</span>3.3<span class="code-tag">&lt;/<span\n            class="code-name">version</span>&gt;</span>\n      <span class="code-tag">&lt;<span class="code-name">configuration</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">source</span>&gt;</span>1.5<span class="code-tag">&lt;/<span\n            class="code-name">source</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">target</span>&gt;</span>1.5<span class="code-tag">&lt;/<span\n            class="code-name">target</span>&gt;</span>\n      <span class="code-tag">&lt;/<span class="code-name">configuration</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">plugin</span>&gt;</span>\n  <span class="code-tag">&lt;/<span class="code-name">plugins</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">build</span>&gt;</span>\n</code></pre>\n<p>\n    上面是在<code>build</code>过程中使用插件的一个配置。插件的使用方式和依赖比较类似，也是2级菜单引入一个插件，插件也是要标记<code>groupId</code>、<code>artifactId</code>以及<code>version</code>等内容。<code>configuration</code>标签用于向插件传递参数（插件就好像一个方法执行一个任务，某些方法需要我们提供参数才能正常运行）。\n</p>\n<p>这个配置会在build阶段被运行（package，install，deploy）。</p>\n<p>插件可以在maven执行的各个生命周期被使用。（<a href="http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html"\n                              title="maven生命周期">maven生命周期</a>）插件的类型繁多，除了直接通过<code>&lt;plugin&gt;</code>引入，实际上maven的各种标签功能也是通过插件实现的，需要知道使用某个插件可以查看官方提供的<a\n        href="http://maven.apache.org/plugins/" title="插件清单">插件清单</a>。</p>\n<p>##　资源文件管理</p>\n<p>一个Java程序肯定会涉及到各种各样的配置文件，在maven的结构下通常我们会将资源文件放置到<code>${root}/src/main/resources</code>目录下。如下面结构的<code>application.properties</code>。\n</p>\n<pre><code class="sql">my-app\n|<span class="code-comment">-- pom.xml</span>\n`<span class="code-comment">-- src</span>\n    |<span class="code-comment">-- main</span>\n    |   |<span class="code-comment">-- java</span>\n    |   |   `<span class="code-comment">-- com</span>\n    |   |       `<span class="code-comment">-- mycompany</span>\n    |   |           `<span class="code-comment">-- app</span>\n    |   |               `<span class="code-comment">-- App.java</span>\n    |   `<span class="code-comment">-- resources</span>\n    |       `<span class="code-comment">-- META-INF</span>\n    |           `<span class="code-comment">-- application.properties</span>\n    `<span class="code-comment">-- test</span>\n        `<span class="code-comment">-- java</span>\n            `<span class="code-comment">-- com</span>\n                `<span class="code-comment">-- mycompany</span>\n                    `<span class="code-comment">-- app</span>\n                        `<span class="code-comment">-- AppTest.java</span>\n</code></pre>\n<p>例如上面这个文件格式，</p>\n<p>对于maven项目而言，classpath的根路径是从java开始的，与之对应的，<code>/resources</code>路径也是一个classpath的root，编译或者打包后，会将<code>resource</code>中的文件合并到一个classpath中。如下图的是根据上面的结构打包成JAR之后的文件格式。\n</p>\n<pre><code class="sql">|<span class="code-comment">-- META-INF</span>\n|   |<span class="code-comment">-- MANIFEST.MF</span>\n|   |<span class="code-comment">-- application.properties</span>\n|   `<span class="code-comment">-- maven</span>\n|       `<span class="code-comment">-- com.mycompany.app</span>\n|           `<span class="code-comment">-- my-app</span>\n|               |<span class="code-comment">-- pom.properties</span>\n|               `<span class="code-comment">-- pom.xml</span>\n`<span class="code-comment">-- com</span>\n    `<span class="code-comment">-- mycompany</span>\n        `<span class="code-comment">-- app</span>\n            `<span class="code-comment">-- App.class</span>\n</code></pre>\n<p>META-INF用于存放程序入口的相关信息，可以将他理解为classpath的一个root，所以在其中的各种配置文件也可以直接在classpath中获取，除此之外还存在<code>MANIFEST.MF</code>、<code>pom.properties</code>、<code>pom.xml</code>等几个文件。这些问价那都是maven在<code>package</code>时生成的标准文件，<code>MANIFEST.MF</code>告知了程序的入口，另外两个文件标记了maven的依赖关系。\n</p>\n<p>对应的，也可以在test目录下建立一个<code>resources</code>目录，在执行单元测试的时候，它会被加入到单元测试时的classpath中。</p>\n<h2 id="h2-7">资源文件参数化</h2>\n<p>通常情况下，发布生产和发布测试某些参数肯定是不一样的（比如数据库链接参数），所以某些时候需要资源文件中的参数根据打包命令进行变更。这个使用会用到<code>&lt;resources&gt;</code>标签（插件）。</p>\n<p>替换参数的过程并不复杂，首先是如下图引入<code>&lt;resources&gt;</code>标签。</p>\n<pre><code class="xml">  <span class="code-tag">&lt;<span class="code-name">build</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">resources</span>&gt;</span>\n      <span class="code-tag">&lt;<span class="code-name">resource</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">directory</span>&gt;</span>src/main/resources<span\n            class="code-tag">&lt;/<span class="code-name">directory</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">filtering</span>&gt;</span>true<span\n            class="code-tag">&lt;/<span class="code-name">filtering</span>&gt;</span>\n      <span class="code-tag">&lt;/<span class="code-name">resource</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">resources</span>&gt;</span>\n  <span class="code-tag">&lt;/<span class="code-name">build</span>&gt;</span>\n</code></pre>\n<p>然后用<code>&lt;directory&gt;</code>表示要进行参数替换的路径位置，这里将会把<code>resource</code>目录中的内容全部替换。</p>\n<p>对应的，在配置文件中使用占位符表示要替换的内容：</p>\n<p>properties：</p>\n<pre><code class="apache"><span class="code-attribute">application</span>.name=<span class="code-variable">${project.name}</span>\n<span class="code-attribute">application</span>.version=<span class="code-variable">${project.version}</span>\n</code></pre>\n<p>yaml：</p>\n<pre><code class="yaml coffeescript">application:\n\tname: @project.name@\n\tversion: @project.version@\n</code></pre>\n<p>配置好之后可以通过<code>mvn process-resources</code>命令来检查文件替换的效果。执行后可以到/target/classses看到替换效果。除了使用<em>project.version</em>之类的固定参数，还可以使用<code>&lt;properties&gt;</code>在<strong>pom.xml</strong>文件中定义全局参数：\n</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">properties</span>&gt;</span>\n\t<span class="code-tag">&lt;<span class="code-name">my.value</span>&gt;</span>hello<span class="code-tag">&lt;/<span\n            class="code-name">my.value</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">properties</span>&gt;</span>\n</code></pre>\n<p>最后，maven还支持系统参数和Java运行时参数，比如：</p>\n<pre><code class="apache"><span class="code-attribute">java</span>.version=<span\n        class="code-variable">${java.version}</span>\n<span class="code-attribute">command</span>.line.prop=<span class="code-variable">${command.line.prop}</span>\n</code></pre>\n<p><code>${java.version}</code>可以获取到操作系统中Java的版本参数。maven本身是一个Java程序，所以<code>mvn process-resources\n    "-Dcommand.line.prop=hello again"</code>命令在启动jvm同时，还传入了<code>command.line.prop</code>的数据。</p>\n<h2 id="h2-8">依赖管理</h2>\n<p><code>&lt;dependencies&gt;</code>和<code>&lt;dependency&gt;</code>组合表示引入依赖。一项依赖通过<code>&lt;groupId&gt;</code>、<code>&lt;artifactId&gt;</code>、<code>&lt;version&gt;</code>引入。<code>&lt;scope&gt;</code>用于确定依赖包的使用范围，与maven的运行生命周期相对应。更多的标签说明参见\n    <a href="http://maven.apache.org/ref/3.6.1/maven-model/maven.html" title="官网Project Descriptor Reference">官网Project\n        Descriptor Reference</a>。</p>\n<h3 id="h3-1">依赖范围</h3>\n<ol>\n    <li>compile：这是默认的范围，引入的包会在mvn的整个生命周期内被用到。</li>\n    <li>provided：在编译和测试的时候都会引入该包，但是到了打包（<code>install</code>）之后的阶段将不会依赖这个包。主要应用场景是使用tomcat之类的容器，在开发和单元测试的时候并不会引入容器，但是需要引用某些包（比如Servlet）完成编译。但是打包放入容器后某些包容器已经提供了，不需要我们带入到classpath中。\n    </li>\n    <li>runtime：除了编译（<code>compile</code>）阶段，其他阶段都会被引入。</li>\n    <li>test：仅用于测试。</li>\n    <li>system：本地操作系统依赖，不会去仓库下载jar包，根据配置的路径（包括网络路径）查找包。</li>\n    <li>import：导入其他pom文件，该标签仅仅能适用于<code>&lt;dependencyManagement&gt;</code>依赖管理标签中。<a\n            href="http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html。"\n            title="参考这篇文章的说明">参考说明</a>。\n    </li>\n</ol>\n<p>关于maven的依赖机制见<a href="http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html"\n                   title="官网关于依赖的说明">官网关于依赖的说明</a>。</p>\n<h3 id="h3-2">包引入过程</h3>\n<p>对于maven而言，一个包最终被引入到项目中有很多层级。首先每个人的操作系统上都有一个本地仓库。在本地执行<code>mvn install</code>命令时都会将对应的包安装到这个仓库中。当其他工程需要这个包时候，maven也是直接到本地仓库获取。\n</p>\n<p>除了自己<code>install</code>的包，更多的时候都是使用第三发提供的包。需要用到某个包时都是先去本地仓路获取，如果不存在maven会到远程仓库去获取。</p>\n<h3 id="h3-3">仓库说明</h3>\n<p>前面已经提及maven的包加载过程涉及到2个仓路：本地仓库（默认位置：<code>${user.home}/.m2/repository</code>）和远程仓库（默认位置：repo.maven.apache.org/maven2/）。\n</p>\n<p>本地仓路可以通过修改<code>${Maven_HOme}/conf/setting.xml</code>的<code>&lt;localRepository&gt;</code>设定，远程仓库通过<code>&lt;mirrors&gt;</code>标签指定。详情见：<a\n        href="http://maven.apache.org/guides/introduction/introduction-to-repositories.html" title="远程仓库介绍">仓库介绍</a>、<a\n        href="http://maven.apache.org/guides/mini/guide-mirror-settings.html"\n        title="远程仓库Mirrors配置说明">远程仓库Mirrors配置说明</a>、<a href="http://maven.apache.org/repository/index.html"\n                                                       title="中央仓库结构">中央仓库结构</a>。</p>\n<h2 id="h2-9">发布到远程仓库</h2>\n<p>发布到远程仓库需要对本地pom.xml以及本机的setting.xml进行配置。\n    pom.xml文件增加：</p>\n<pre><code class="xml">  <span class="code-tag">&lt;<span class="code-name">distributionManagement</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">repository</span>&gt;</span>\n      <span class="code-tag">&lt;<span class="code-name">id</span>&gt;</span>mycompany-repository<span class="code-tag">&lt;/<span\n            class="code-name">id</span>&gt;</span>\n      <span class="code-tag">&lt;<span class="code-name">name</span>&gt;</span>MyCompany Repository<span\n            class="code-tag">&lt;/<span class="code-name">name</span>&gt;</span>\n      <span class="code-tag">&lt;<span class="code-name">url</span>&gt;</span>scp://repository.mycompany.com/repository/maven2<span\n            class="code-tag">&lt;/<span class="code-name">url</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">repository</span>&gt;</span>\n  <span class="code-tag">&lt;/<span class="code-name">distributionManagement</span>&gt;</span>\n</code></pre>\n<p>setting.xml配置：</p>\n<pre><code class="xml"> <span class="code-tag">&lt;<span class="code-name">servers</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">server</span>&gt;</span>\n      <span class="code-comment">&lt;!-- 使用账号密码登录 --&gt;</span>\n      <span class="code-tag">&lt;<span class="code-name">id</span>&gt;</span>mycompany-repository<span class="code-tag">&lt;/<span\n            class="code-name">id</span>&gt;</span>\n      <span class="code-tag">&lt;<span class="code-name">username</span>&gt;</span>jvanzyl<span\n            class="code-tag">&lt;/<span class="code-name">username</span>&gt;</span>\n      <span class="code-comment">&lt;!-- 使用ssh登录 --&gt;</span>\n      <span class="code-tag">&lt;<span class="code-name">privateKey</span>&gt;</span>/path/to/identity<span\n            class="code-tag">&lt;/<span class="code-name">privateKey</span>&gt;</span>\n      <span class="code-tag">&lt;<span class="code-name">passphrase</span>&gt;</span>my_key_passphrase<span\n            class="code-tag">&lt;/<span class="code-name">passphrase</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">server</span>&gt;</span>\n  <span class="code-tag">&lt;/<span class="code-name">servers</span>&gt;</span>\n</code></pre>\n<p>远程服务器的权限有各种各样的规则——<a href="http://maven.apache.org/guides/mini/guide-encryption.html" title="参考文件">参考文件</a>。</p>\n<p>参考资料：<a href="http://maven.apache.org/guides/getting-started/index.html" title="官网介绍">官网介绍</a>。</p>'},349:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<h2 id="h2-1">Niubility的Nodejs &nbsp;&nbsp;</h2>\n<p>关于大名鼎鼎的Nodejs是什么就不用再介绍了，他的牛逼之处数都数不完——让javascript称霸全宇宙、将一个只用于前端的编程语言同时可以制霸前后端、让致力于前端开发的小哥又多了一项事业新增了一门手艺、亮瞎人的全异步事件驱动型架构（event-driven、non-blocking、scalability）。总的来说就是，学好Nodejs必须能够赚大钱迎娶白富美。</p>\n<p>本人一直垂涎与Nodejs的鼎鼎大名，但是由于工作繁忙，一直没时间深入亵玩。最近因为一些机缘，又要着手一些前端开发的工作才觅得一次全面接触的良机。</p>\n<p>看到这里你肯定要说，又是一个要把Nodejs吹上天的文章！NoNo，本文会一步一步的说明我是怎么学会和用上nodejs的，然后结合其我所了解的语言告诉各位我所了解的Nodejs坑和优势。</p>\n\n<h2 id="h2-2">学习基础</h2>\n<p>先说说本人开始学习使用的基础。早期在某外企开发室内3D设计软件，那段时间用已经成为古董的MFC做各种windows事件驱动开发。</p>\n<p>之后就一直在做Java生态的东西、反正就是SSH啦、MVC啦、Dao啦、Entity啦、JNDI啦、JDBC啦等等，相信每个Javaer都懂的。早些年做Java时，前端部分基本就是玩转Jsp，页面清一色的用Jsp动态生成，然后丢给浏览器。现在所属团队几乎已经放弃这种方式，都是用spring-boot等弄前后端分离了。</p>\n<p>随后有幸接到一个自己可以全权负责的全新的项目，于是带着2个人开始尝试抛弃JSP，引入了大量的ajax异步请求的客户端组装数据。那时候这样做其实蛮痛苦的，新项目根本没有真正意义的前端开发人员（都玩JSP呢），所以自己不得不去研究前端的各种前端技术。在随后的许多时光中，深入且大量的学习了前端开发的所有东西，从一穷二白只会用div画画静态页面，到后面自己封装列表、消息通知等组件，通杀jquery、angularjs，了解各种脚手架。所以学习Nodejs开发，我基本上是没有语言障碍的，只是需要跟上它的思路。</p>\n\n<h2 id="h2-3">安装Nodejs</h2>\n<p>要用一样东西之前，当然是要先安装环境。Nodejs的安装网上一搜一大把，这里就简单记录一下流程，方面以后查阅。因为本人用一台windows（windows10）办公、用一台linux（ubuntu16.04）开发，所以2个操作系统都安装了Nodejs，像OSX这样高大上的玩意，暂时没机器去弄（穷）。</p>\n\n<h3 id="h3-1">windows</h3>\n<ol>\n    <li>先去官网（https://nodejs.org或https://nodejs.org/en/download/）下载一个安装包，我下的是长期稳定版。建议下载.msi。</li>\n    <li>然后就是安装了，这没什么好说的。无非就是设定一下安装目录，然后一通Next。</li>\n    <li>安装好之后检查下环境变量，看看path下添加入了Nodejs的运行路径。cmd中输入path可以看到添加了nodejs的安装目录。然后输入node --version可以看到当前的Nodejs版本号。如下图：&nbsp;&nbsp;&nbsp;&nbsp;<img alt="安装NodeJs运行环境" height="175" src="https://file.mahoooo.com/res/file/install_nodejs_runtime_environment_1.png" width="527"></li>\n    <li>Nodejs自带npm，npm和其他未来要使用的组件都存放在“X:\\yourpath\\nodejs\\node_modules”里。所以需要在windows环境变量重增加一个NODE_PATH=X:\\yourpath\\nodejs\\node_modules的参数，保证未来新增的一些模块工具可以正常使用。右键“我的电脑”-&gt;高级系统设置-&gt;环境变量-&gt;然后新建以上参数。</li>\n    <li>再然后就是最后一步了，设置node_cache（用于npm存放一些临时文件）和node_global（全局工具文件夹），当然这里也可以不设置，他会自动放在当前用户的文件夹下，但是有强迫症的我必须要设置。在cmd中输入一下命令：</li>\n</ol>\n<pre class="sql"><code class="language-bash">npm config <span class="code-built_in"><span class="code-keyword">set</span></span> prefix <span class="code-string"><span class="code-string">\'X:\\yourpath\\nodejs\\node-global\'</span></span>\n\nnpm config <span class="code-built_in"><span class="code-keyword">set</span></span> <span class="code-keyword">cache</span> <span class="code-string"><span class="code-string">\'X:\\yourpath\\nodejs\\node_cache\'</span></span></code></pre>\n\n<h3 id="h3-2">linux</h3>\n<p>linux安装和windows安装Nodejs差不多，都是下载包、解压、开用。</p>\n<ol>\n    <li>先去官网下载一个linux版本的安装包（下首页的那个就行）。下载以后发现是 xz后缀，先得用xz命令解压成tar，再用tar完成解压。</li>\n    <li>添加Nodejs运行环境：直接把node的运行目录添加到&amp;PATH里。在profile中添加Node的运行环境： <pre class="bash"><code class="language-bash"><span class="code-comment"><span class="code-comment">#node</span></span>\n<span class="code-built_in"><span class="code-built_in">export</span></span> NODE_HOME=/yourpath/node-v4.5.0-linux-x64\n<span class="code-built_in"><span class="code-built_in">export</span></span> PATH=<span class="code-variable"><span class="code-variable">$NODE_HOME</span></span>/bin:<span class="code-variable"><span class="code-variable">$PATH</span></span></code></pre> <p>然后再任意位置测试了一下运行node命令都可以正常使用。</p> </li>\n    <li> <p>然后我们需要添加node_modules到PATH中，保证npm可以使用：</p> <pre class="bash"><code class="language-apache"><span class="code-comment">#npm</span>\n<span class="code-built_in">export</span> NODE_PATH=<span class="code-variable">$NODE_HOME</span>/node_modules\n</code></pre> <p>配置完之后，就可以使用npm命令了。（修改之后切记注销用户）</p> </li>\n</ol>\n<p>完成以上步奏之后，就可以用node和npm命令干你相干的事了。安装之前按看到很多教程说是要安装python2.2到2.7的版本。但是我解压完nodejs包后在bin下运行了node -v命令居然可以跑，我就没去管python的事，应该是我用的是打包版的原因。</p>\n\n<h3 id="h3-3">Apt安装Nodejs</h3>\n<p>1.设定Nodejs安装源：</p>\n<pre class="nginx"><code class="language-bash"><span class="code-attribute">curl</span> <span class="hljs-_">-s</span>L https://deb.nodesource.com/setup_8.x | sudo -E bash -</code></pre>\n<p>2.安装Nodejs</p>\n<pre class="actionscript"><code class="language-bash">sudo apt-<span class="code-keyword">get</span> install -y nodejs</code></pre>\n\n<h3 id="h3-4">验证安装结果</h3>\n<p>安装完成之后，我在windows和linux都测试了一下。</p>\n<p>测试nodejs：输入node打开REPL，然后使用log打印数据：</p>\n<pre class="javascript"><code class="language-bash">$ node\n&gt; <span class="code-built_in">console</span>.log(<span class="code-string"><span class="code-string">"hello nodejs!"</span></span>);\nhello nodejs!\n<span class="hljs-literal">undefined</span></code></pre>\n<p>然后用npm测试安装grunt-cli：</p>\n<pre class="groovy"><code class="language-bash">$ npm install -g grunt-cli\n<span class="hljs-regexp">/yourpath/</span>node-v4<span class="hljs-number">.5</span><span class="hljs-number">.0</span>-linux-x64<span class="hljs-regexp">/node_global/</span>bin<span class="hljs-regexp">/grunt -&gt; /</span>yourpath<span class="hljs-regexp">/node-v4.5.0-linux-x64/</span>node_global<span class="hljs-regexp">/lib/</span>node_modules<span class="hljs-regexp">/grunt-cli/</span>bin/grunt\ngrunt-cli@<span class="hljs-number">1.2</span><span class="hljs-number">.0</span> <span class="hljs-regexp">/me/</span>soft<span class="hljs-regexp">/node/</span>node-v4<span class="hljs-number">.5</span><span class="hljs-number">.0</span>-linux-x64<span class="hljs-regexp">/node_global/</span>lib<span class="hljs-regexp">/node_modules/</span>grunt-cli\n├── grunt-known-options@<span class="hljs-number">1.1</span><span class="hljs-number">.0</span>\n├── resolve@<span class="hljs-number">1.1</span><span class="hljs-number">.7</span>\n├── nopt@<span class="hljs-number">3.0</span><span class="hljs-number">.6</span> (abbrev@<span class="hljs-number">1.0</span><span class="hljs-number">.9</span>)\n└── findup-sync@<span class="hljs-number">0.3</span><span class="hljs-number">.0</span> (glob@<span class="hljs-number">5.0</span><span class="hljs-number">.15</span>)</code></pre>\n\n<h3 id="h3-5">运行一个Nodejs程序</h3>\n<p>安装好之后，node的命令行和npm的命令行就都可以使用了，随后当然就是要跑跑Nodejs了。像下面这样创建一个创建一个example.js文件，随便放在某个文件：</p>\n<pre class="javascript"><code class="language-javascript"><span class="code-keyword"><span class="code-keyword">const</span></span> http = <span class="code-built_in"><span class="code-built_in">require</span></span>(<span class="code-string"><span class="code-string">\'http\'</span></span>);\n\n<span class="code-keyword"><span class="code-keyword">const</span></span> hostname = <span class="code-string"><span class="code-string">\'127.0.0.1\'</span></span>;\n<span class="code-keyword"><span class="code-keyword">const</span></span> port = <span class="hljs-number"><span class="hljs-number">3000</span></span>;\n\n<span class="code-keyword"><span class="code-keyword">const</span></span> server = http.createServer((req, res) -&gt; {\n  res.statusCode = <span class="hljs-number"><span class="hljs-number">200</span></span>;\n  res.setHeader(<span class="code-string"><span class="code-string">\'Content-Type\'</span></span>, <span class="code-string"><span class="code-string">\'text/plain\'</span></span>);\n  res.end(<span class="code-string"><span class="code-string">\'Hello World Nodejs\\n\'</span></span>);\n});\n\nserver.listen(port, hostname, () =&gt; {\n  <span class="code-built_in"><span class="code-built_in">console</span></span>.log(<span class="code-string"><span class="code-string">`Server running at http://</span><span class="hljs-subst"><span class="code-string"><span class="hljs-subst">${hostname}</span></span></span><span class="code-string">:</span><span class="hljs-subst"><span class="code-string"><span class="hljs-subst">${port}</span></span></span><span class="code-string">/`</span></span>);\n});</code></pre>\n<p>然后在当前文件下打开一个cmd运行以下命令：</p>\n<pre class="css"><code class="language-bash"><span class="code-selector-tag">node</span> <span class="code-selector-tag">example</span><span class="code-selector-class">.js</span></code></pre>\n<p>可以看到输出：</p>\n<pre class="php"><code class="language-bash"><span class="code-variable">$node</span> example.js\n\nServer running at http:<span class="code-comment">//127.0.0.1:3000</span></code></pre>\n'},358:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<h2 id="h2-1">什么叫前后端同构？</h2>\n<p>为了解决某些问题（比如SEO、提升渲染速度等）<strong><em>react</em></strong>\n    提供了2个方法在服务端生成一个HTML文本格式的字符串。在得到了这个HTML格式的字符串之后，通常会将其组装成一个页面直接返回给用户的浏览器。</p>\n<p>到这里，服务端的活已经干完了，然后就是浏览器这边干活。</p>\n<p>浏览器拿到HTML文本后，立刻进行渲染将内容呈现给用户。然后加载页面所需的 .js 文件，然后执行\n    <em><strong>JavaScript&nbsp;</strong></em>脚本，然后开始初始化&nbsp;<em><strong>react</strong></em> 组件…………</p>\n<p>到这里问题就来了。<strong><em>react</em></strong> 初始化组件后会执行组件内所有\n    <em>render&nbsp;() </em>方法，然后生成虚拟DOM的树形结构，然后在适当的时候将虚拟dom<em>写</em>到浏览器的真实dom中。因为 <strong><em>react</em></strong>\n    总是根据虚拟dom来生成真实dom，所以最后会把服务器端渲染好的HTML全部替换掉。</p>\n<p>\n    上面这个事情说不是问题确实也不是问题，无非就是用户看到页面然后“闪现”一下。说是问题还真是个问题，产品会拿着这毛病从用户体验的角度在各种场合和你死磕半个月。磕累了你索性把服务端渲染关了，然后运营又拿着SEO的问题准备和你开始撕逼了。</p>\n<p>聪明如 Facebook 的工程师当然想到了这些问题，所以他们在<em>ReactDOMServer.renderToString(element) 方法</em>中提供了一个\n    <strong><em>checksum</em></strong> 机制。</p>\n<p>关于&nbsp;<strong><em>checksum </em></strong> <a href="https://facebook.github.io/react/docs/react-dom-server.html"\n                                                  rel="nofollow">官网</a> 并没有太多介绍，但是国内外的各路博客介绍了不少。我一直想找&nbsp;<em><strong>react</strong></em>\n    开发者关于这个机制的介绍一直没找到……。</p>\n<p><strong>前后端同构</strong>就是保证前端和后端的dom结构一致，不会发生重复渲染。<em><strong>react</strong></em>\n    使用&nbsp;<strong><em>checksum </em></strong>机制进行保障。</p>\n\n<h2 id="h2-2">什么叫React首屏渲染？</h2>\n<p>简单的说就是 <em><strong>react</strong></em> 在浏览器内存中第一次生成的虚拟 dom 树。<strong>切记是虚拟 dom ，而不是浏览器的dom</strong>。</p>\n<p>了解 <strong><em>react</em></strong> 的应该知道，所有 <em><strong>react</strong></em> 组件都有一个 <em>render()</em>\n    方法（如果使用function方式编写的组件会把function里的所有代码都塞到 <em>render()</em> 方法中去）。当<em>ReactDOM.render( element, container,\n        [callback] )</em>方法执行时，会执行以下步骤：</p>\n<ol>\n    <li>所有组件的会先进行初始化（es6执行构造函数）。</li>\n    <li>所有组件的&nbsp;<em>render</em>&nbsp;<em>()</em> 方法会被调用一次，完成这个过程后会得到一颗虚拟的 dom 树。</li>\n    <li>&nbsp;<em><strong>react</strong></em> 会将虚拟dom转换成浏览器dom，完成后调用组件的&nbsp;<em>componentDidMount()</em>&nbsp;方法告诉你已经装载到浏览器上了。\n    </li>\n</ol>\n<p>在上面这个过程成中，步骤2完成后即为完成 <em><strong>react</strong></em> 的首屏渲染。结合 <strong><em>checksum</em></strong>&nbsp;机制步骤3有可能不会执行。\n</p>\n<p>当组件状态发生变更时（ <em>setState() </em>生命周期函数被调用）或者 父组件渲染时（父组件的 <em>render()</em> 方法被调用），当前组件的 <em>render()</em>\n    方法都会被执行，都有可能会导致虚拟dom变更，但是这些变更和首屏渲染没任何关系了。</p>\n\n<h2 id="h2-3">React前后端同构首屏渲染</h2>\n<p>了解了同构和首屏渲染，就好理解如何解决首屏不重复渲染的问题了。</p>\n<p>首先服务端渲染完之后会有一个 <em><strong>checksum</strong></em> 值写在根元素的属性上：</p>\n<p><img alt="React 前后端同构防止重复渲染" height="70"\n        src="https://file.mahoooo.com/res/file/react_server_render_with_checksum_1.png" width="601"></p>\n<p>这个 <em><strong>checksum</strong></em>&nbsp;是根据服务端生成的HTML内容哈希计算得到的。</p>\n<p>然后在浏览器加载完所有的js文件之后，开始执行前面介绍的&nbsp;<em>ReactDOM.render( element, container, [callback] )</em> &nbsp;初始化渲染的三个步骤。当执行完第二步生成虚拟dom后，<strong><em>react</em></strong>\n    会根虚拟dom用相同的算法计算一个哈希值，如果和 <em><strong>checksum</strong></em> 一致则认为服务器已经完成渲染，不会再执行第三步。</p>\n<p>如果 <strong><em>checksum</em></strong> 比对不一致，在 <strong>开发环境</strong>&nbsp;和 <strong>测试环境</strong>\n    会在浏览器console中输出以下警告内容：</p>\n<p><img alt="React 前后端同构防止重复渲染" height="85"\n        src="https://file.mahoooo.com/res/file/react_server_render_with_checksum_2.png" width="790"></p>\n<p><strong>生产环境不会输出任何警告。</strong></p>\n<p>同构渲染的内容就这么多，原理其实蛮简单的，无非就是保证DOM一致。但是结合代码分片、异步加载、服务端调接口异步组装数据等等功能后，如何保证服务端和浏览器端第一次渲染的dom一致还得花不少功夫。不过原理清楚了，事情总能办成。</p>'},401:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<h2 id="h2-1">TensorFlow入门</h2>\n<p>本文将初步向码农和程序媛们介绍如何使用TensorFlow进行编程。在阅读之前请先 <a href="https://www.chkui.com/article/tensorflow/tensorflow_windows_install" rel="nofollow">安装TensorFlow</a>，此外为了能够更好的理解本文的内容，阅读之前需要了解一点以下知识：\n</p>\n<ol>\n    <li>python基本编程。能看得懂python代码，最好能使用脚本工具或pycharm之类的IDC编写代码。</li>\n    <li>至少有一点数组的概念。</li>\n    <li>最理想的状态是具备机器学习的基础知识。不过如果在阅读之前没有了解过任何机器学习相关的知也无大碍，可以把本文作为了解机器学习的开端。后面会另开一篇用MNIST了解机器学习的基础知识。</li>\n</ol>\n<p>TensorFlow提供种类繁多的API接口，其中TensorFlow Core是最低层级的接口，为开发TensorFlow提供基础支持。官方推荐把TensorFlow\n    Core用作机器学习研究以及相关的数据建模。除了TensorFlow Core之外还有更高抽象的API接口，这些API接口比TensorFlow Core更易于使用、更易于快速实现业务需求。例如&nbsp;tf.contrib.learn\n    接口，它提供管理数据集合、进行数据评估、训练、推演等功能。在使用TensorFlow开发的过程中需要特别注意，以&nbsp;<code>contrib</code>&nbsp;开头的API接口依然还在不断完善中，很有可能在未来某个发行版本中进行调整或者直接取消。\n</p>\n<p>本文首先介绍TensorFlow Core，然后会演示如何使用&nbsp;tf.contrib.learn 实现简单的建模。了解TensorFlow\n    Core是为了让开发者理解在使用抽象接口时底层是如何工作的，以便于在训练数据时创建更合适的模型。</p>\n\n<h2 id="h2-2">TensorFlow</h2>\n<p>\n    TensorFlow的基础数据单元是张量（tensor）。一个张量认为是一组向量的集合，从数据结构的角度来理解这个集合等价于一组数值存储在1到多个队列中（张量没办法几句话说得清楚，想要了解去谷哥或者度妞搜索“张量分析”，可以简单想象成一个多维度的数组）。一个张量的阶表示了张量的维度，下面是一些张量的例子：</p>\n<blockquote> \n <pre class="lua"><code class="lua"><span class="hljs-number"><span class="hljs-number">3</span></span> # <span\n         class="hljs-number"><span class="hljs-number">0</span></span>阶张量，可以用图形[]来表示\n[<span class="hljs-number"><span class="hljs-number">1.</span></span> ,<span class="hljs-number"><span\n             class="hljs-number">2.</span></span>, <span class="hljs-number"><span class="hljs-number">3.</span></span>] # <span\n             class="hljs-number"><span class="hljs-number">1</span></span>阶张量，是一个图形为[<span class="hljs-number"><span\n             class="hljs-number">3</span></span>]的向量\n<span class="code-string"><span class="code-string">[[1., 2., 3.], [4., 5., 6.]]</span></span> # <span\n             class="hljs-number"><span class="hljs-number">2</span></span>阶张量，是一个图形为[<span class="hljs-number"><span\n             class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>]的矩阵\n<span class="code-string"><span class="code-string">[[[1., 2., 3.]]</span></span>, <span class="code-string"><span\n             class="code-string">[[7., 8., 9.]]</span></span>] # 图形为[<span class="hljs-number"><span\n             class="hljs-number">2</span></span>,<span class="hljs-number"><span\n             class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>]的三阶张量</code></pre>\n</blockquote>\n\n<h2 id="h2-3">TensorFlow Core教程</h2>\n\n<h3 id="h3-1">导入TensorFlow</h3>\n<p>下面是导入TensorFlow包的标准方式：</p>\n<pre class="haskell"><code class="language-python"><span class="code-keyword"><span\n        class="code-keyword">import</span></span> tensorflow <span class="code-keyword"><span\n        class="code-keyword">as</span></span> tf</code></pre>\n<p>通过python的方式导入之后，&nbsp;tf 提供了访问所有TensorFlow类、方法和符号的入口。</p>\n\n<h3 id="h3-2">图计算（Computational Graph）</h3>\n<p>TensorFlow Core的编程开发可以看就做2个事：</p>\n<ol>\n    <li>构建计算图。（建模）</li>\n    <li>运行计算图。（执行）</li>\n</ol>\n<blockquote>\n    <p>图（graph，也可以叫连接图）表示由多个点链接而成的图。本文中的图指的是TensorFlow建模后运算的路径，可以使用TensorBoard看到图的整个形态。</p>\n    <p>节点（node）表示图中每一个点，这些点都代表了一项计算任务。</p>\n</blockquote>\n<p><strong>所以简而言之</strong>：编程 <em>TensorFlow Core</em> 就是事先安排好一系列节点的计算任务，然后运行这些任务。</p>\n<p>\n    下面我们先构建一个简单的图，图中的节点（node）有0或多个张量作为输入，并产生一个张量作为输出。一个典型的节点是“常量”（constant）。TensorFlow的常量在构建计算模型时就已经存在，在运行计算时并不需要任何输入。下面的代码创建了2个浮点常量值常量&nbsp;<code>node1</code>&nbsp;和&nbsp;<code>node2</code>：\n</p>\n<pre class="go"><code class="language-python">node1 = tf.constant(<span class="hljs-number"><span class="hljs-number">3.0</span></span>, tf.<span\n        class="code-keyword">float32</span>)\nnode2 = tf.constant(<span class="hljs-number"><span class="hljs-number">4.0</span></span>) <span class="code-comment"># also tf.<span\n            class="code-keyword">float32</span> implicitly</span>\n<span class="code-built_in">print</span>(node1, node2)</code></pre>\n<p>运行后会打印输出：</p>\n<pre class="lisp"><code class="language-python">Tensor(<span class="code-string"><span\n        class="code-string">"Const:0"</span></span>, shape=(), dtype=float32) Tensor(<span class="code-string"><span\n        class="code-string">"Const_1:0"</span></span>, shape=(), dtype=float32)</code></pre>\n<p>观察这个打印的结果会发现，它并不是按照预想的那样输出 <em>3.0</em> 或<em> 4.0 </em>的值。这里输出的是一个节点的对象信息。因为到这里还没有执行第二项工作——运行计算模型图。只有在运行时，才会使用到节点真实的值\n    <em>3.0</em> 和<em>4.0</em>。为了进行图运算需要创建一个会话（session），一个会话封装了TensorFlow运行库的各种控制方法和状态量（context）。</p>\n<p>下面的代码会创建一个会话（session）对象实例，然后执行&nbsp;<code>run</code>&nbsp;方法来进行模型计算：</p>\n<pre class="lua"><code class="language-python">sess = tf.Session()\n<span class="code-built_in">print</span>(sess.run([node1, node2]))</code></pre>\n<p>运行后我们会发现，打印的结果是3.0和4.0：</p>\n<pre class="json"><code class="language-python">[<span class="hljs-number"><span class="hljs-number">3.0</span></span>, <span\n        class="hljs-number"><span class="hljs-number">4.0</span></span>]</code></pre>\n<p>\n    然后，对&nbsp;<code>node1</code>&nbsp;和&nbsp;<code>node2</code>&nbsp;进行和运算，这个和运算就是图中的运算模型。下面的代码是构建一个&nbsp;<code>node1</code>&nbsp;、&nbsp;<code>node2</code>&nbsp;进行和运算，&nbsp;<code>node3</code>&nbsp;代表和运算的模型，构建完毕后使用\n    <code>sess.run</code>&nbsp;运行：</p>\n<pre class="lua"><code class="language-python">node3 = tf.add(node1, node2)\n<span class="code-built_in">print</span>(<span class="code-string"><span class="code-string">"node3: "</span></span>, node3)\n<span class="code-built_in">print</span>(<span class="code-string"><span class="code-string">"sess.run(node3): "</span></span>,sess.run(node3))</code></pre>\n<p>运行后会输出了以下内容：</p>\n<pre class="bash"><code class="language-python">node3:  Tensor(<span class="code-string"><span class="code-string">"Add_2:0"</span></span>, shape=(), dtype=<span\n        class="code-built_in">float</span>32)\nsess.run(node3):  <span class="hljs-number">7.0</span></code></pre>\n<p>到此，完成了TensorFlow创建图和执行图的过程。</p>\n<p>前面提到TensorFlow提供了一个名为TensorBoard的工具，这个工具能够显示图运算的节点。下面是一个TensorBoard可视化看到计算图的例子：</p>\n<p><img alt="TensorFlow 使用入门教程" height="130"\n        src="https://file.mahoooo.com/res/file/tensorflow_get_started_0.png" width="269"></p>\n<p>这样的常量运算结果并没有什么价值，因为他总是恒定的产生固定的结果。图中的节点能够以参数的方式接受外部输入——比如使用占位符。占位符可以等到模型运行时再使用动态计算的数值：</p>\n<pre class="ini"><code class="language-python"><span class="hljs-attr">a</span> = tf.placeholder(tf.float32)\n<span class="hljs-attr">b</span> = tf.placeholder(tf.float32)\n<span class="hljs-attr">adder_node</span> = a + b  <span\n            class="code-comment"># + 可以代替tf.add(a, b)构建模型</span></code></pre>\n<p>上面这3行代码有点像用一个function或者一个lambda表达式来获取参数输入。我们可以在运行时输入各种各样的参数到图中进行计算：</p>\n<pre class="css"><code class="language-python"><span class="code-selector-tag">print</span>(<span\n        class="code-selector-tag">sess</span><span class="code-selector-class">.run</span>(<span\n        class="code-selector-tag">adder_node</span>, {<span class="code-attribute">a</span>: <span\n        class="hljs-number"><span class="hljs-number">3</span></span>, b:<span class="hljs-number"><span\n        class="hljs-number">4.5</span></span>}))\n<span class="code-selector-tag">print</span>(<span class="code-selector-tag">sess</span><span\n            class="code-selector-class">.run</span>(<span class="code-selector-tag">adder_node</span>, {<span\n            class="code-attribute">a</span>: [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span\n            class="hljs-number"><span class="hljs-number">3</span></span>], b: [<span class="hljs-number"><span\n            class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>]}))</code></pre>\n<p>输出结果为：</p>\n<pre class="css"><code class="css">7<span class="code-selector-class"><span class="code-selector-class">.5</span></span>\n<span class="hljs-selector-attr"><span class="hljs-selector-attr">[ 3. &nbsp;7.]</span></span></code></pre>\n<p>在TensorBoard中，显示的计算图为：</p>\n<p><img alt="TensorFlow 使用入门教程" height="207"\n        src="https://file.mahoooo.com/res/file/tensorflow_get_started_1.png" width="243"></p>\n<p>我们可以使用更复杂的表达式来增加计算的内容：</p>\n<pre class="groovy"><code class="language-python">add_and_triple = adder_node * <span class="hljs-number"><span\n        class="hljs-number">3.</span></span>\nprint(sess.run(add_and_triple, {<span class="code-string">a:</span> <span class="hljs-number"><span class="hljs-number">3</span></span>, <span\n            class="code-string">b:</span><span class="hljs-number"><span class="hljs-number">4.5</span></span>}))</code></pre>\n<p>计算输出：</p>\n<pre class="css"><code class="css">22<span class="code-selector-class"><span\n        class="code-selector-class">.5</span></span></code></pre>\n<p>TensorBoard中的显示：</p>\n<p><img alt="TensorFlow 使用入门教程" height="337"\n        src="https://file.mahoooo.com/res/file/tensorflow_get_started_2.png" width="280"></p>\n<p>在机器学习中一个模型通常需要接收各种类型的数据作为输入。为了使得模型可以不断的训练通常需要能够针对相同的输入修改图的模型以获取新的输出。<strong>变量（Variables）</strong>可以增加可训练的参数到图中，他们由指定一个初始类型和初始值来创建：\n</p>\n<pre class="ini"><code class="language-python"><span class="hljs-attr">W</span> = tf.Variable([<span\n        class="hljs-number">.<span class="hljs-number">3</span></span>], tf.float32)\n<span class="hljs-attr">b</span> = tf.Variable([<span class="hljs-number">-.<span class="hljs-number">3</span></span>], tf.float32)\n<span class="hljs-attr">x</span> = tf.placeholder(tf.float32)\n<span class="hljs-attr">linear_model</span> = W * x + b</code></pre>\n<p>前面已经提到在调用&nbsp;<code>tf.constant</code>&nbsp;时会初始化不可变更的常量。 而这里通过调用&nbsp;<code>tf.Variable</code>&nbsp;创建的变量不会被初始化，为了在TensorFlow运行之前（<code>sess.run</code>执行模型运算之前）初始化所有的变量，需要增加一步&nbsp;<code>init</code>&nbsp;操作：\n</p>\n<pre class="swift"><code class="swift"><span class="code-keyword"><span class="code-keyword">init</span></span> = tf.global_variables_initializer()\nsess.run(<span class="code-keyword"><span class="code-keyword">init</span></span>)</code></pre>\n<p>可以通过重载&nbsp;<code>init</code>&nbsp;方式来全局初始化所有TensorFlow图中的变量。在上面的代码中，在我们调用&nbsp;<code>sess.run</code>&nbsp;之前，所有的变量都没有初始化。\n</p>\n<p>下面的&nbsp;<code>x</code>&nbsp;是一个占位符，<code>{x:[1,2,3,4]}</code>&nbsp;&nbsp;表示在运算中把x的值替换为[1,2,3,4]：</p>\n<pre class="css"><code class="language-python"><span class="code-selector-tag">print</span>(<span\n        class="code-selector-tag">sess</span><span class="code-selector-class">.run</span>(<span\n        class="code-selector-tag">linear_model</span>, {<span class="code-attribute">x</span>:[<span\n        class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span\n        class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span\n        class="hljs-number"><span class="hljs-number">4</span></span>]}))</code></pre>\n<p>输出：</p>\n<pre class="json"><code class="language-python">[ <span class="hljs-number"><span class="hljs-number">0.</span></span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span\n        class="hljs-number"><span class="hljs-number">0.30000001</span></span> &nbsp;<span class="hljs-number"><span\n        class="hljs-number">0.60000002</span></span> &nbsp;<span class="hljs-number"><span class="hljs-number">0.90000004</span></span>]</code></pre>\n<p>现在已经创建了一个计算模型，但是并不清晰是否足够有效，为了让他越来越有效，需要对这个模型进行数据训练。下面的代码定义名为&nbsp;<code>y</code>&nbsp;的占位符来提供所需的值，然后编写一个“损益功能”（loss\n    function）。</p>\n<p>一个“损益功能”是用来衡量当前的模型对于想达到的输出目标还有多少距离的工具。下面的例子使用线性回归作为损益模型。回归的过程是：计算模型的输出和损益变量（<code>y</code>）的差值，然后再对这个差值进行平方运算（方差），然后再把方差的结果向量进行和运算。下面的代码中，&nbsp;<code>linear_model\n    - y</code>&nbsp;创建了一个向量，向量中的每一个值表示对应的错误增量。然后调用&nbsp;<code>tf.square</code>&nbsp;对错误增量进行平方运算。最后将所有的方差结果相加创建一个数值的标量来抽象的表示错误差异，使用&nbsp;<code>tf.reduce_sum</code>来完成这一步工作。如下列代码：\n</p>\n<pre class="makefile"><code class="language-python"><span class="code-comment"><span class="code-comment"># 定义占位符</span></span>\ny = tf.placeholder(tf.float32)\n<span class="code-comment"><span class="code-comment"># 方差运算</span></span>\nsquared_deltas = tf.square(linear_model - y)\n<span class="code-comment"><span class="code-comment"># 定义损益模型</span></span>\nloss = tf.reduce_sum(squared_deltas)\n<span class="code-comment"><span class="code-comment"># 输出损益计算结果</span></span>\nprint(sess.run(loss, {x:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span\n            class="hljs-number">3</span>,<span class="hljs-number">4</span>], y:[<span\n            class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-2</span>,<span\n            class="hljs-number">-3</span>]}))</code></pre>\n<p>运算之后的差异值是：</p>\n<pre class="css"><code class="css">23<span class="code-selector-class"><span\n        class="code-selector-class">.66</span></span></code></pre>\n<p>\n    可以通过手动将&nbsp;<code>W</code>&nbsp;和&nbsp;<code>b</code>&nbsp;的值修改为-1和1降低差异结果。TensorFlow中使用&nbsp;<code>tf.Variable</code>&nbsp;创建变量，使用&nbsp;<code>tf.assign</code>&nbsp;修改变量。例如&nbsp;<code>W=-1</code>&nbsp;、<code>b=1</code>&nbsp;才是当前模型最佳的值，可以像下面这样修改他们的值：\n</p>\n<pre class="groovy"><code class="language-python">fixW = tf.assign(W, [<span class="hljs-number"><span\n        class="hljs-number">-1.</span></span>])\nfixb = tf.assign(b, [<span class="hljs-number"><span class="hljs-number">1.</span></span>])\nsess.run([fixW, fixb])\nprint(sess.run(loss, {<span class="code-string">x:</span>[<span class="hljs-number"><span\n            class="hljs-number">1</span></span>,<span class="hljs-number"><span\n            class="hljs-number">2</span></span>,<span class="hljs-number"><span\n            class="hljs-number">3</span></span>,<span class="hljs-number"><span\n            class="hljs-number">4</span></span>], <span class="code-string">y:</span>[<span class="hljs-number"><span\n            class="hljs-number">0</span></span>,<span class="hljs-number"><span\n            class="hljs-number">-1</span></span>,<span class="hljs-number"><span\n            class="hljs-number">-2</span></span>,<span class="hljs-number"><span class="hljs-number">-3</span></span>]}))</code></pre>\n<p>修改之后的最终输出结果为：</p>\n<pre class="css"><code class="css">0<span class="code-selector-class"><span class="code-selector-class">.0</span></span></code></pre>\n\n<h3 id="h3-3">tf.train 接口</h3>\n<p>机器学习的完整过程超出了本文的范围，这里仅说明训练的过程。TensorFlow提供了很多优化器来逐渐（迭代或循环）调整每一个参数，最终实现损益值尽可能的小。最简单的优化器之一是“梯度递减”（<strong>gradient\n    descent</strong>），它会对损益计算模型求导，然后根据求导的结果调整输入变量的值（<code>W</code>和<code>b</code>），最终目的让求导的结果逐渐趋向于0。手工进行编写求导运算非常冗长且容易出错，TensorFlow还提供了函数&nbsp;<code>tf.gradients</code>&nbsp;实现自动求导过程。下面的例子展示了使用梯度递减训练样本的过程：\n</p>\n<pre class="bash"><code class="language-python"><span class="code-comment"><span class="code-comment"># 设定优化器，这里的0.01表示训练时的步进值</span></span>\noptimizer = tf.train.GradientDescentOptimizer(<span class="hljs-number">0.01</span>)\ntrain = optimizer.minimize(loss)\nsess.run(init) <span class="code-comment"><span class="code-comment"># 初始化变量值.</span></span>\n<span class="code-keyword"><span class="code-keyword">for</span></span> i <span class="code-keyword"><span\n            class="code-keyword">in</span></span> range(<span class="hljs-number">1000</span>): <span\n            class="code-comment"><span class="code-comment"># 遍历1000次训练数据，每次都重新设置新的W和b值</span></span>\n  sess.run(train, {x:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span\n            class="hljs-number">3</span>,<span class="hljs-number">4</span>], y:[<span\n            class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-2</span>,<span\n            class="hljs-number">-3</span>]})\n\n<span class="code-built_in">print</span>(sess.run([W, b]))</code></pre>\n<p>这个模式的运算结果是：</p>\n<pre class="json"><code class="json">[array([<span class="hljs-number"><span\n        class="hljs-number">-0.9999969</span></span>], dtype=float32), array([ <span class="hljs-number"><span\n        class="hljs-number">0.99999082</span></span>], dtype=float32)]</code></pre>\n<p>\n    现在我们已经完成机器学习的整个过程。虽然进行简单的线性回归计算并不需要用到太多的TensorFlow代码，但是这仅仅是一个用于实例的案例，在实际应用中往往需要编写更多的代码实现复杂的模型匹配运算。TensorFlow为常见的模式、结构和功能提供了更高级别的抽象接口。</p>\n\n<h3 id="h3-4">一个完整的训练过程</h3>\n<p>下面是根据前文的描述，编写的完整线性回归模型：</p>\n<pre class="makefile"><code class="language-python"><span class="code-keyword">import</span> numpy <span\n        class="code-keyword">as</span> np\n<span class="code-keyword">import</span> tensorflow <span class="code-keyword">as</span> tf\n\n<span class="code-comment"><span class="code-comment"># 模型参数</span></span>\nW = tf.Variable([<span class="hljs-number">.3</span>], tf.float32)\nb = tf.Variable([<span class="hljs-number">-.3</span>], tf.float32)\n<span class="code-comment"><span class="code-comment"># 模型输入</span></span>\nx = tf.placeholder(tf.float32)\n<span class="code-comment"><span class="code-comment"># 模型输出</span></span>\nlinear_model = W * x + b\n<span class="code-comment"><span class="code-comment"># 损益评估参数</span></span>\ny = tf.placeholder(tf.float32)\n<span class="code-comment"><span class="code-comment"># 损益模式</span></span>\nloss = tf.reduce_sum(tf.square(linear_model - y)) <span class="code-comment"># 方差和</span>\n<span class="code-comment"><span class="code-comment"># 优化器</span></span>\noptimizer = tf.train.GradientDescentOptimizer(<span class="hljs-number">0.01</span>)\ntrain = optimizer.minimize(loss)\n<span class="code-comment"><span class="code-comment"># 训练数据</span></span>\nx_train = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span\n            class="hljs-number">3</span>,<span class="hljs-number">4</span>]\ny_train = [<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span\n            class="hljs-number">-2</span>,<span class="hljs-number">-3</span>]\n<span class="code-comment"><span class="code-comment"># 定义训练的循环</span></span>\ninit = tf.global_variables_initializer()\nsess = tf.Session()\nsess.run(init) <span class="code-comment"><span class="code-comment"># reset values to wrong</span></span>\n<span class="code-keyword">for</span> i <span class="code-keyword">in</span> range(<span class="hljs-number">1000</span>):\n  sess.run(train, {x:x_train, y:y_train})\n\n<span class="code-comment"><span class="code-comment"># 评估训练结果的精确性</span></span>\ncurr_W, curr_b, curr_loss  = sess.run([W, b, loss], {x:x_train, y:y_train})\nprint(<span class="code-string">"W: %s b: %s loss: %s"</span>%(curr_W, curr_b, curr_loss))</code></pre>\n<p>运行后会输出：</p>\n<pre class="css"><code class="language-python"><span class="code-selector-tag">W</span>: <span\n        class="hljs-selector-attr">[</span><span class="hljs-number"><span class="hljs-selector-attr">-0.9999969</span></span><span\n        class="hljs-selector-attr">]</span> <span class="code-selector-tag">b</span>: <span\n        class="hljs-selector-attr">[ </span><span class="hljs-number"><span class="hljs-selector-attr">0.99999082</span></span><span\n        class="hljs-selector-attr">]</span> <span class="code-selector-tag">loss</span>: <span\n        class="hljs-number">5<span class="code-selector-class">.69997e-11</span></span></code></pre>\n<p>这个复杂的程序仍然可以在TensorBoard中可视化呈现：</p>\n<p><img alt="TensorFlow 使用入门教程" height="721"\n        src="https://file.mahoooo.com/res/file/tensorflow_get_started_3.png" width="832"></p>\n\n<h2 id="h2-4">tf.contrib.learn</h2>\n<p>前面已经提到，TensorFlow除了TensorFlow Core之外，为了便于业务开发还提供了很多更抽象的接口。<code>tf.contrib.learn</code>&nbsp;是TensorFlow的一个高级库，他提供了更加简化的机器学习机制，包括：\n</p>\n<ol>\n    <li>运行训练循环</li>\n    <li>运行评估循环</li>\n    <li>管理数据集合</li>\n    <li>管理训练数据</li>\n</ol>\n<p>tf.contrib.learn&nbsp;定义了一些通用模块。</p>\n\n<h4 id="h4-1">基本用法</h4>\n<p>先看看使用&nbsp;<code>tf.contrib.learn</code>&nbsp;来实现线性回归的方式。</p>\n<pre class="haskell"><code class="language-python"><span class="code-keyword"><span\n        class="code-keyword">import</span></span> tensorflow <span class="code-keyword"><span\n        class="code-keyword">as</span></span> tf\n<span class="code-comment"><span class="code-meta"># NumPy常用语加载、操作、预处理数据.</span></span>\n<span class="code-keyword"><span class="code-keyword">import</span></span> numpy <span class="code-keyword"><span\n            class="code-keyword">as</span></span> np\n\n<span class="code-comment"><span class="code-meta"># 定义一个特性列表features。</span></span>\n<span class="code-comment"><span class="code-meta"># 这里仅仅使用了real-valued特性。还有其他丰富的特性功能</span></span>\n<span class="code-title">features</span> = [tf.contrib.layers.real_valued_column(<span class="code-string"><span\n            class="code-string">"x"</span></span>, dimension=<span class="hljs-number"><span\n            class="hljs-number">1</span></span>)]\n\n<span class="code-comment"><span class="code-meta"># 一个评估者（estimator）是训练（fitting）与评估（inference）的开端。</span></span>\n<span class="code-comment"><span class="code-meta"># 这里预定于了许多类型的训练评估方式，比如线性回归（linear regression）、</span></span>\n<span class="code-comment"><span class="code-meta"># 逻辑回归（logistic regression）、线性分类（linear classification）和回归（regressors）</span></span>\n<span class="code-comment"><span class="code-meta"># 这里的estimator提供了线性回归的功能</span></span>\n<span class="code-title">estimator</span> = tf.contrib.learn.<span class="code-type">LinearRegressor</span>(feature_columns=features)\n\n<span class="code-comment"><span class="code-meta"># TensorFlow提供了许多帮助类来读取和设置数据集合</span></span>\n<span class="code-comment"><span class="code-meta"># 这里使用了‘numpy_input_fn’。</span></span>\n<span class="code-comment"><span class="code-meta"># 我们必须告诉方法我们许多多少批次的数据，以及每次批次的规模有多大。</span></span>\n<span class="code-title">x</span> = np.array([<span class="hljs-number"><span\n            class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span>, <span\n            class="hljs-number"><span class="hljs-number">3.</span></span>, <span class="hljs-number"><span\n            class="hljs-number">4.</span></span>])\n<span class="code-title">y</span> = np.array([<span class="hljs-number"><span\n            class="hljs-number">0.</span></span>, <span class="hljs-number"><span class="hljs-number">-1.</span></span>, <span\n            class="hljs-number"><span class="hljs-number">-2.</span></span>, <span class="hljs-number"><span\n            class="hljs-number">-3.</span></span>])\n<span class="code-title">input_fn</span> = tf.contrib.learn.io.numpy_input_fn({<span class="code-string"><span\n            class="code-string">"x"</span></span>:x}, y, batch_size=<span class="hljs-number"><span class="hljs-number">4</span></span>,\n                                              num_epochs=<span class="hljs-number"><span class="hljs-number">1000</span></span>)\n\n<span class="code-comment"><span class="code-meta"># ‘fit’方法通过指定steps的值来告知方法要训练多少次数据</span></span>\n<span class="code-title">estimator</span>.fit(input_fn=input_fn, steps=<span class="hljs-number"><span\n            class="hljs-number">1000</span></span>)\n\n<span class="code-comment"><span class="code-meta"># 最后我们评估我们的模型价值。在一个实例中，我们希望使用单独的验证和测试数据集来避免过度拟合。</span></span>\n<span class="code-title">estimator</span>.evaluate(input_fn=input_fn)</code></pre>\n<p>运行后输出：</p>\n<pre class="lua"><code class="language-python">&nbsp; &nbsp; {<span class="code-string"><span class="code-string">\'global_step\'</span></span>: <span\n        class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="code-string"><span\n        class="code-string">\'loss\'</span></span>: <span class="hljs-number"><span\n        class="hljs-number">1.9650059e-11</span></span>}</code></pre>\n\n<h4 id="h4-2">自定义模型</h4>\n<p><code>tf.contrib.learn</code>&nbsp;并不限定只能使用它预设的模型。假设现在需要创建一个未预设到TensorFlow中的模型。我们依然可以使用<code>tf.contrib.learn</code>保留数据集合、训练数据、训练过程的高度抽象。我们将使用我们对较低级别TensorFlow\n    API的了解，展示如何使用LinearRegressor实现自己的等效模型。</p>\n<p>使用&nbsp;<code>tf.contrib.learn</code>&nbsp;创建一个自定义模型需要用到它的子类&nbsp;<code>tf.contrib.learn.Estimator</code>&nbsp;。而&nbsp;<code>tf.contrib.learn.LinearRegressor</code>&nbsp;是&nbsp;&nbsp;<code>tf.contrib.learn.Estimator</code>&nbsp;的子类。下面的代码中为&nbsp;<code>Estimator</code>&nbsp;新增了一个&nbsp;<code>model_fn</code>&nbsp;功能，这个功能将告诉&nbsp;<code>tf.contrib.learn</code>&nbsp;如何进行评估、训练以及损益计算：\n</p>\n<pre class="python"><code class="language-python"><span class="code-keyword"><span\n        class="code-keyword">import</span></span> numpy <span class="code-keyword"><span class="code-keyword">as</span></span> np\n<span class="code-keyword"><span class="code-keyword">import</span></span> tensorflow <span class="code-keyword"><span\n            class="code-keyword">as</span></span> tf\n<span class="code-comment"><span class="code-comment"># 定义一个特征数组，这里仅提供实数特征</span></span>\n<span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">def</span></span></span><span\n        class="hljs-function"> </span><span class="code-title"><span class="hljs-function"><span class="code-title">model</span></span></span><span\n        class="hljs-params"><span class="hljs-function"><span class="hljs-params">(features, labels, mode)</span></span></span><span\n        class="hljs-function">:</span></span>\n  <span class="code-comment"><span class="code-comment"># 构建线性模型和预设值</span></span>\n  W = tf.get_variable(<span class="code-string"><span class="code-string">"W"</span></span>, [<span class="hljs-number"><span\n            class="hljs-number">1</span></span>], dtype=tf.float64)\n  b = tf.get_variable(<span class="code-string"><span class="code-string">"b"</span></span>, [<span class="hljs-number"><span\n            class="hljs-number">1</span></span>], dtype=tf.float64)\n  y = W*features[<span class="code-string"><span class="code-string">\'x\'</span></span>] + b\n  <span class="code-comment"><span class="code-comment"># 损益子图</span></span>\n  loss = tf.reduce_sum(tf.square(y - labels))\n  <span class="code-comment"><span class="code-comment"># 训练子图</span></span>\n  global_step = tf.train.get_global_step()\n  optimizer = tf.train.GradientDescentOptimizer(<span class="hljs-number"><span class="hljs-number">0.01</span></span>)\n  train = tf.group(optimizer.minimize(loss),\n                   tf.assign_add(global_step, <span class="hljs-number"><span class="hljs-number">1</span></span>))\n  <span class="code-comment"><span class="code-comment"># ModelFnOps方法将创建我们自定义的一个抽象模型。</span></span>\n  <span class="code-keyword"><span class="code-keyword">return</span></span> tf.contrib.learn.ModelFnOps(\n      mode=mode, predictions=y,\n      loss=loss,\n      train_op=train)\n\nestimator = tf.contrib.learn.Estimator(model_fn=model)\n<span class="code-comment"><span class="code-comment"># 定义数据集</span></span>\nx = np.array([<span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span\n            class="hljs-number">2.</span></span>, <span class="hljs-number"><span class="hljs-number">3.</span></span>, <span\n            class="hljs-number"><span class="hljs-number">4.</span></span>])\ny = np.array([<span class="hljs-number"><span class="hljs-number">0.</span></span>, <span class="hljs-number"><span\n            class="hljs-number">-1.</span></span>, <span class="hljs-number"><span class="hljs-number">-2.</span></span>, <span\n            class="hljs-number"><span class="hljs-number">-3.</span></span>])\ninput_fn = tf.contrib.learn.io.numpy_input_fn({<span class="code-string"><span class="code-string">"x"</span></span>: x}, y, <span\n            class="hljs-number"><span class="hljs-number">4</span></span>, num_epochs=<span class="hljs-number"><span\n            class="hljs-number">1000</span></span>)\n\n<span class="code-comment"><span class="code-comment"># 训练数据</span></span>\nestimator.fit(input_fn=input_fn, steps=<span class="hljs-number"><span class="hljs-number">1000</span></span>)\n<span class="code-comment"><span class="code-comment"># 评估模型</span></span>\nprint(estimator.evaluate(input_fn=input_fn, steps=<span class="hljs-number"><span class="hljs-number">10</span></span>))</code></pre>\n<p>运行后输出：</p>\n<pre class="lua"><code class="language-python">{<span class="code-string"><span class="code-string">\'loss\'</span></span>: <span\n        class="hljs-number"><span class="hljs-number">5.9819476e-11</span></span>, <span class="code-string"><span\n        class="code-string">\'global_step\'</span></span>: <span class="hljs-number"><span class="hljs-number">1000</span></span>}</code></pre>\n\n<h2 id="h2-5">接下来做什么</h2>\n<p>阅读了到这里，你应该初步了解如何在TensorFlow中进行开发和编码。但是如果你刚踏入机器学习的领域，就算很仔细的看了本文，对于如何使用TensorFlow进行机器学习基本上还是懵逼的。<span\n        style="color:#FF0000">请继续阅读</span><a href="https://my.oschina.net/chkui/blog/888346" rel="nofollow">《MNIST\n    机器学习入门</a>》<span style="color:#FF0000">，文章给出了一个完整的机器学习建模案例，适合零知识入门机器学习。</span></p>'}});