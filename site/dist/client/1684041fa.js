webpackJsonp([1],{328:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<p>JSR330是Jcp给出的官方标准反向依赖注入规范。Java大部分反向依赖注入的工具或者框架目前基本上都满足JSR330规范、例如spring、guice以及Dagger。</p>\n<p>以我们最常用的spring为例。</p>\n<p>JSR中<span style="color:#cc0000">@Inject</span>可以当做<span style="color:#cc0000">@AutoWired</span>来使用。而<span\n        style="color:#cc0000">@Named</span>可以当做<span style="color:#cc0000">@Component</span>来使用。</p>\n<p>使用JSR330首先要引入javax.inject包：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">dependency</span>&gt;</span>  \n    <span class="code-tag">&lt;<span class="code-name">groupId</span>&gt;</span>javax.inject<span class="code-tag">&lt;/<span\n            class="code-name">groupId</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">artifactId</span>&gt;</span>javax.inject<span class="code-tag">&lt;/<span\n            class="code-name">artifactId</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">version</span>&gt;</span>1<span class="code-tag">&lt;/<span\n            class="code-name">version</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">dependency</span>&gt;</span> </code></pre>\n<p>目前Maven中央仓库中就一个inject的jar。</p>\n<p>首先使用xml配置通过注解扫描添加bean。</p>\n<pre><code class="xml"><span class="php"><span class="code-meta">&lt;?</span>xml version=<span\n        class="code-string">"1.0"</span> encoding=<span class="code-string">"UTF-8"</span><span\n        class="code-meta">?&gt;</span></span>\n<span class="code-tag">&lt;<span class="code-name">beans</span> <span class="hljs-attr">xmlns</span>=<span\n        class="code-string">"http://www.springframework.org/schema/beans"</span>\n    <span class="hljs-attr">xmlns:xsi</span>=<span\n            class="code-string">"http://www.w3.org/2001/XMLSchema-instance"</span>\n    <span class="hljs-attr">xmlns:context</span>=<span class="code-string">"http://www.springframework.org/schema/context"</span>  \n    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="code-string">"http://www.springframework.org/schema/beans  \n    http://www.springframework.org/schema/beans/spring-beans-3.1.xsd  \n    http://www.springframework.org/schema/context  \n    http://www.springframework.org/schema/context/spring-context-3.1.xsd"</span>&gt;</span>  \n    <span class="code-tag">&lt;<span class="code-name">context:component-scan</span>  <span class="hljs-attr">base-package</span>=<span\n            class="code-string">"com.demo.jsr330"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span>  </code></pre>\n<p>然后像下面这个添加一个bean</p>\n<pre><code class="java"><span class="code-meta">@Named</span>  \n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">service</span> </span>{\n  <span class="hljs-function"><span class="code-keyword">public</span>  <span class="code-keyword">void</span>   <span\n          class="code-title">print</span><span class="hljs-params">()</span></span>{\n     System.out.println(<span class="code-string">"Service  print  method is invoked"</span>);  \n  }  \n}  </code></pre>\n<p>然后将这个bean注入到其他bean中去使用</p>\n<pre><code class="java"><span class="code-meta">@Named</span>  \n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Faction</span> </span>{\n  <span class="code-meta">@Inject</span>\n  Service service;\n\n  <span class="hljs-function"><span class="code-keyword">public</span>  <span class="code-keyword">void</span>  <span\n          class="code-title">show</span><span class="hljs-params">()</span></span>{\n     service.print()； \n  }  \n}  </code></pre>\n<p>JSR330还定义了<span style="color:#FF0000">@Qualifier</span>和<span style="color:#FF0000">@Provider</span>，对应到spring都给出了标准的实现。\n</p>\n<p>使用JSR330代替原注解的好处是无论使用任何反向依赖注入工具或框架，只要他是支持JSR330的，都可以平滑的切换。</p>'},336:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<h2 id="h2-1">Niubility的Nodejs &nbsp;&nbsp;</h2>\n<p>关于大名鼎鼎的Nodejs是什么就不用再介绍了，他的牛逼之处数都数不完——让javascript称霸全宇宙、将一个只用于前端的编程语言同时可以制霸前后端、让致力于前端开发的小哥又多了一项事业新增了一门手艺、亮瞎人的全异步事件驱动型架构（event-driven、non-blocking、scalability）。总的来说就是，学好Nodejs必须能够赚大钱迎娶白富美。</p>\n<p>本人一直垂涎与Nodejs的鼎鼎大名，但是由于工作繁忙，一直没时间深入亵玩。最近因为一些机缘，又要着手一些前端开发的工作才觅得一次全面接触的良机。</p>\n<p>看到这里你肯定要说，又是一个要把Nodejs吹上天的文章！NoNo，本文会一步一步的说明我是怎么学会和用上nodejs的，然后结合其我所了解的语言告诉各位我所了解的Nodejs坑和优势。</p>\n\n<h2 id="h2-2">学习基础</h2>\n<p>先说说本人开始学习使用的基础。早期在某外企开发室内3D设计软件，那段时间用已经成为古董的MFC做各种windows事件驱动开发。</p>\n<p>之后就一直在做Java生态的东西、反正就是SSH啦、MVC啦、Dao啦、Entity啦、JNDI啦、JDBC啦等等，相信每个Javaer都懂的。早些年做Java时，前端部分基本就是玩转Jsp，页面清一色的用Jsp动态生成，然后丢给浏览器。现在所属团队几乎已经放弃这种方式，都是用spring-boot等弄前后端分离了。</p>\n<p>随后有幸接到一个自己可以全权负责的全新的项目，于是带着2个人开始尝试抛弃JSP，引入了大量的ajax异步请求的客户端组装数据。那时候这样做其实蛮痛苦的，新项目根本没有真正意义的前端开发人员（都玩JSP呢），所以自己不得不去研究前端的各种前端技术。在随后的许多时光中，深入且大量的学习了前端开发的所有东西，从一穷二白只会用div画画静态页面，到后面自己封装列表、消息通知等组件，通杀jquery、angularjs，了解各种脚手架。所以学习Nodejs开发，我基本上是没有语言障碍的，只是需要跟上它的思路。</p>\n\n<h2 id="h2-3">安装Nodejs</h2>\n<p>要用一样东西之前，当然是要先安装环境。Nodejs的安装网上一搜一大把，这里就简单记录一下流程，方面以后查阅。因为本人用一台windows（windows10）办公、用一台linux（ubuntu16.04）开发，所以2个操作系统都安装了Nodejs，像OSX这样高大上的玩意，暂时没机器去弄（穷）。</p>\n\n<h3 id="h3-1">windows</h3>\n<ol>\n    <li>先去官网（https://nodejs.org或https://nodejs.org/en/download/）下载一个安装包，我下的是长期稳定版。建议下载.msi。</li>\n    <li>然后就是安装了，这没什么好说的。无非就是设定一下安装目录，然后一通Next。</li>\n    <li>安装好之后检查下环境变量，看看path下添加入了Nodejs的运行路径。cmd中输入path可以看到添加了nodejs的安装目录。然后输入node --version可以看到当前的Nodejs版本号。如下图：&nbsp;&nbsp;&nbsp;&nbsp;<img alt="安装NodeJs运行环境" height="175" src="https://file.mahoooo.com/res/file/install_nodejs_runtime_environment_1.png" width="527"></li>\n    <li>Nodejs自带npm，npm和其他未来要使用的组件都存放在“X:\\yourpath\\nodejs\\node_modules”里。所以需要在windows环境变量重增加一个NODE_PATH=X:\\yourpath\\nodejs\\node_modules的参数，保证未来新增的一些模块工具可以正常使用。右键“我的电脑”-&gt;高级系统设置-&gt;环境变量-&gt;然后新建以上参数。</li>\n    <li>再然后就是最后一步了，设置node_cache（用于npm存放一些临时文件）和node_global（全局工具文件夹），当然这里也可以不设置，他会自动放在当前用户的文件夹下，但是有强迫症的我必须要设置。在cmd中输入一下命令：</li>\n</ol>\n<pre class="sql"><code class="language-bash">npm config <span class="code-built_in"><span class="code-keyword">set</span></span> prefix <span class="code-string"><span class="code-string">\'X:\\yourpath\\nodejs\\node-global\'</span></span>\n\nnpm config <span class="code-built_in"><span class="code-keyword">set</span></span> <span class="code-keyword">cache</span> <span class="code-string"><span class="code-string">\'X:\\yourpath\\nodejs\\node_cache\'</span></span></code></pre>\n\n<h3 id="h3-2">linux</h3>\n<p>linux安装和windows安装Nodejs差不多，都是下载包、解压、开用。</p>\n<ol>\n    <li>先去官网下载一个linux版本的安装包（下首页的那个就行）。下载以后发现是 xz后缀，先得用xz命令解压成tar，再用tar完成解压。</li>\n    <li>添加Nodejs运行环境：直接把node的运行目录添加到&amp;PATH里。在profile中添加Node的运行环境： <pre class="bash"><code class="language-bash"><span class="code-comment"><span class="code-comment">#node</span></span>\n<span class="code-built_in"><span class="code-built_in">export</span></span> NODE_HOME=/yourpath/node-v4.5.0-linux-x64\n<span class="code-built_in"><span class="code-built_in">export</span></span> PATH=<span class="code-variable"><span class="code-variable">$NODE_HOME</span></span>/bin:<span class="code-variable"><span class="code-variable">$PATH</span></span></code></pre> <p>然后再任意位置测试了一下运行node命令都可以正常使用。</p> </li>\n    <li> <p>然后我们需要添加node_modules到PATH中，保证npm可以使用：</p> <pre class="bash"><code class="language-apache"><span class="code-comment">#npm</span>\n<span class="code-built_in">export</span> NODE_PATH=<span class="code-variable">$NODE_HOME</span>/node_modules\n</code></pre> <p>配置完之后，就可以使用npm命令了。（修改之后切记注销用户）</p> </li>\n</ol>\n<p>完成以上步奏之后，就可以用node和npm命令干你相干的事了。安装之前按看到很多教程说是要安装python2.2到2.7的版本。但是我解压完nodejs包后在bin下运行了node -v命令居然可以跑，我就没去管python的事，应该是我用的是打包版的原因。</p>\n\n<h3 id="h3-3">Apt安装Nodejs</h3>\n<p>1.设定Nodejs安装源：</p>\n<pre class="nginx"><code class="language-bash"><span class="code-attribute">curl</span> <span class="hljs-_">-s</span>L https://deb.nodesource.com/setup_8.x | sudo -E bash -</code></pre>\n<p>2.安装Nodejs</p>\n<pre class="actionscript"><code class="language-bash">sudo apt-<span class="code-keyword">get</span> install -y nodejs</code></pre>\n\n<h3 id="h3-4">验证安装结果</h3>\n<p>安装完成之后，我在windows和linux都测试了一下。</p>\n<p>测试nodejs：输入node打开REPL，然后使用log打印数据：</p>\n<pre class="javascript"><code class="language-bash">$ node\n&gt; <span class="code-built_in">console</span>.log(<span class="code-string"><span class="code-string">"hello nodejs!"</span></span>);\nhello nodejs!\n<span class="hljs-literal">undefined</span></code></pre>\n<p>然后用npm测试安装grunt-cli：</p>\n<pre class="groovy"><code class="language-bash">$ npm install -g grunt-cli\n<span class="hljs-regexp">/yourpath/</span>node-v4<span class="hljs-number">.5</span><span class="hljs-number">.0</span>-linux-x64<span class="hljs-regexp">/node_global/</span>bin<span class="hljs-regexp">/grunt -&gt; /</span>yourpath<span class="hljs-regexp">/node-v4.5.0-linux-x64/</span>node_global<span class="hljs-regexp">/lib/</span>node_modules<span class="hljs-regexp">/grunt-cli/</span>bin/grunt\ngrunt-cli@<span class="hljs-number">1.2</span><span class="hljs-number">.0</span> <span class="hljs-regexp">/me/</span>soft<span class="hljs-regexp">/node/</span>node-v4<span class="hljs-number">.5</span><span class="hljs-number">.0</span>-linux-x64<span class="hljs-regexp">/node_global/</span>lib<span class="hljs-regexp">/node_modules/</span>grunt-cli\n├── grunt-known-options@<span class="hljs-number">1.1</span><span class="hljs-number">.0</span>\n├── resolve@<span class="hljs-number">1.1</span><span class="hljs-number">.7</span>\n├── nopt@<span class="hljs-number">3.0</span><span class="hljs-number">.6</span> (abbrev@<span class="hljs-number">1.0</span><span class="hljs-number">.9</span>)\n└── findup-sync@<span class="hljs-number">0.3</span><span class="hljs-number">.0</span> (glob@<span class="hljs-number">5.0</span><span class="hljs-number">.15</span>)</code></pre>\n\n<h3 id="h3-5">运行一个Nodejs程序</h3>\n<p>安装好之后，node的命令行和npm的命令行就都可以使用了，随后当然就是要跑跑Nodejs了。像下面这样创建一个创建一个example.js文件，随便放在某个文件：</p>\n<pre class="javascript"><code class="language-javascript"><span class="code-keyword"><span class="code-keyword">const</span></span> http = <span class="code-built_in"><span class="code-built_in">require</span></span>(<span class="code-string"><span class="code-string">\'http\'</span></span>);\n\n<span class="code-keyword"><span class="code-keyword">const</span></span> hostname = <span class="code-string"><span class="code-string">\'127.0.0.1\'</span></span>;\n<span class="code-keyword"><span class="code-keyword">const</span></span> port = <span class="hljs-number"><span class="hljs-number">3000</span></span>;\n\n<span class="code-keyword"><span class="code-keyword">const</span></span> server = http.createServer((req, res) -&gt; {\n  res.statusCode = <span class="hljs-number"><span class="hljs-number">200</span></span>;\n  res.setHeader(<span class="code-string"><span class="code-string">\'Content-Type\'</span></span>, <span class="code-string"><span class="code-string">\'text/plain\'</span></span>);\n  res.end(<span class="code-string"><span class="code-string">\'Hello World Nodejs\\n\'</span></span>);\n});\n\nserver.listen(port, hostname, () =&gt; {\n  <span class="code-built_in"><span class="code-built_in">console</span></span>.log(<span class="code-string"><span class="code-string">`Server running at http://</span><span class="hljs-subst"><span class="code-string"><span class="hljs-subst">${hostname}</span></span></span><span class="code-string">:</span><span class="hljs-subst"><span class="code-string"><span class="hljs-subst">${port}</span></span></span><span class="code-string">/`</span></span>);\n});</code></pre>\n<p>然后在当前文件下打开一个cmd运行以下命令：</p>\n<pre class="css"><code class="language-bash"><span class="code-selector-tag">node</span> <span class="code-selector-tag">example</span><span class="code-selector-class">.js</span></code></pre>\n<p>可以看到输出：</p>\n<pre class="php"><code class="language-bash"><span class="code-variable">$node</span> example.js\n\nServer running at http:<span class="code-comment">//127.0.0.1:3000</span></code></pre>\n'},345:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<h2 id="h2-1">什么叫前后端同构？</h2>\n<p>为了解决某些问题（比如SEO、提升渲染速度等）<strong><em>react</em></strong>\n    提供了2个方法在服务端生成一个HTML文本格式的字符串。在得到了这个HTML格式的字符串之后，通常会将其组装成一个页面直接返回给用户的浏览器。</p>\n<p>到这里，服务端的活已经干完了，然后就是浏览器这边干活。</p>\n<p>浏览器拿到HTML文本后，立刻进行渲染将内容呈现给用户。然后加载页面所需的 .js 文件，然后执行\n    <em><strong>JavaScript&nbsp;</strong></em>脚本，然后开始初始化&nbsp;<em><strong>react</strong></em> 组件…………</p>\n<p>到这里问题就来了。<strong><em>react</em></strong> 初始化组件后会执行组件内所有\n    <em>render&nbsp;() </em>方法，然后生成虚拟DOM的树形结构，然后在适当的时候将虚拟dom<em>写</em>到浏览器的真实dom中。因为 <strong><em>react</em></strong>\n    总是根据虚拟dom来生成真实dom，所以最后会把服务器端渲染好的HTML全部替换掉。</p>\n<p>\n    上面这个事情说不是问题确实也不是问题，无非就是用户看到页面然后“闪现”一下。说是问题还真是个问题，产品会拿着这毛病从用户体验的角度在各种场合和你死磕半个月。磕累了你索性把服务端渲染关了，然后运营又拿着SEO的问题准备和你开始撕逼了。</p>\n<p>聪明如 Facebook 的工程师当然想到了这些问题，所以他们在<em>ReactDOMServer.renderToString(element) 方法</em>中提供了一个\n    <strong><em>checksum</em></strong> 机制。</p>\n<p>关于&nbsp;<strong><em>checksum </em></strong> <a href="https://facebook.github.io/react/docs/react-dom-server.html"\n                                                  rel="nofollow">官网</a> 并没有太多介绍，但是国内外的各路博客介绍了不少。我一直想找&nbsp;<em><strong>react</strong></em>\n    开发者关于这个机制的介绍一直没找到……。</p>\n<p><strong>前后端同构</strong>就是保证前端和后端的dom结构一致，不会发生重复渲染。<em><strong>react</strong></em>\n    使用&nbsp;<strong><em>checksum </em></strong>机制进行保障。</p>\n\n<h2 id="h2-2">什么叫React首屏渲染？</h2>\n<p>简单的说就是 <em><strong>react</strong></em> 在浏览器内存中第一次生成的虚拟 dom 树。<strong>切记是虚拟 dom ，而不是浏览器的dom</strong>。</p>\n<p>了解 <strong><em>react</em></strong> 的应该知道，所有 <em><strong>react</strong></em> 组件都有一个 <em>render()</em>\n    方法（如果使用function方式编写的组件会把function里的所有代码都塞到 <em>render()</em> 方法中去）。当<em>ReactDOM.render( element, container,\n        [callback] )</em>方法执行时，会执行以下步骤：</p>\n<ol>\n    <li>所有组件的会先进行初始化（es6执行构造函数）。</li>\n    <li>所有组件的&nbsp;<em>render</em>&nbsp;<em>()</em> 方法会被调用一次，完成这个过程后会得到一颗虚拟的 dom 树。</li>\n    <li>&nbsp;<em><strong>react</strong></em> 会将虚拟dom转换成浏览器dom，完成后调用组件的&nbsp;<em>componentDidMount()</em>&nbsp;方法告诉你已经装载到浏览器上了。\n    </li>\n</ol>\n<p>在上面这个过程成中，步骤2完成后即为完成 <em><strong>react</strong></em> 的首屏渲染。结合 <strong><em>checksum</em></strong>&nbsp;机制步骤3有可能不会执行。\n</p>\n<p>当组件状态发生变更时（ <em>setState() </em>生命周期函数被调用）或者 父组件渲染时（父组件的 <em>render()</em> 方法被调用），当前组件的 <em>render()</em>\n    方法都会被执行，都有可能会导致虚拟dom变更，但是这些变更和首屏渲染没任何关系了。</p>\n\n<h2 id="h2-3">React前后端同构首屏渲染</h2>\n<p>了解了同构和首屏渲染，就好理解如何解决首屏不重复渲染的问题了。</p>\n<p>首先服务端渲染完之后会有一个 <em><strong>checksum</strong></em> 值写在根元素的属性上：</p>\n<p><img alt="React 前后端同构防止重复渲染" height="70"\n        src="https://file.mahoooo.com/res/file/react_server_render_with_checksum_1.png" width="601"></p>\n<p>这个 <em><strong>checksum</strong></em>&nbsp;是根据服务端生成的HTML内容哈希计算得到的。</p>\n<p>然后在浏览器加载完所有的js文件之后，开始执行前面介绍的&nbsp;<em>ReactDOM.render( element, container, [callback] )</em> &nbsp;初始化渲染的三个步骤。当执行完第二步生成虚拟dom后，<strong><em>react</em></strong>\n    会根虚拟dom用相同的算法计算一个哈希值，如果和 <em><strong>checksum</strong></em> 一致则认为服务器已经完成渲染，不会再执行第三步。</p>\n<p>如果 <strong><em>checksum</em></strong> 比对不一致，在 <strong>开发环境</strong>&nbsp;和 <strong>测试环境</strong>\n    会在浏览器console中输出以下警告内容：</p>\n<p><img alt="React 前后端同构防止重复渲染" height="85"\n        src="https://file.mahoooo.com/res/file/react_server_render_with_checksum_2.png" width="790"></p>\n<p><strong>生产环境不会输出任何警告。</strong></p>\n<p>同构渲染的内容就这么多，原理其实蛮简单的，无非就是保证DOM一致。但是结合代码分片、异步加载、服务端调接口异步组装数据等等功能后，如何保证服务端和浏览器端第一次渲染的dom一致还得花不少功夫。不过原理清楚了，事情总能办成。</p>'},363:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<p>在<a href="https://www.chkui.com/article/spring/spring_core_auto_inject_of_annotation" title="注解自动装载">注解自动装载</a>中介绍了通过注解（Annotation）自动向Bean中注入其他Bean的方法，本篇将介绍通过注解（Annotation）向容器添加Bean的方法。\n</p>\n<p>\n    Spring的核心容器提供了@Component和@Bean注解来标记如何向IoC容器添加Bean。在核心包中@Component又派生了@Service、@Controller和@Repository这三个注解（在其他的Spring工程或包中还有更多的派生），本文主要介绍@Component及其派生注解的使用。</p>\n\n<h2 id="h2-1">一个简单的使用例子</h2>\n<p>\n    要想使用@Component等注解来向容器添加Bean，需要向IoC容器指明什么类有这个注解，所以Spring提供了一个扫描机制让使用者指定要检查的路径。配置非常简单，只要使用上下文的component-scan标签即可。我们通过下面的例子来简单说明如何配置。</p>\n<p>例子中的代码仅用于说明问题，并不能运行。源码请到<a href="https://gitee.com/chkui-com/spring-core-sample" rel="nofollow">https://gitee.com/chkui-com/spring-core-sample</a>自行clone，例子在<em>chkui.springcore.example.hybrid.component</em>包中。\n</p>\n<p>有一个接口和一个实现类作为要添加到IoC容器的Bean：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.component.bean;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n            class="code-title">NameService</span> </span>{\n\t<span class="hljs-function">String <span class="code-title">getName</span><span class="hljs-params">()</span></span>;\n}</code></pre>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.component.bean;\n\n<span class="code-meta">@Component</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">NameServiceImpl</span> <span class="code-keyword">implements</span> <span\n            class="code-title">NameService</span></span>{\n\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span\n            class="code-title">getName</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"This is My Component"</span>;\n\t}\n}</code></pre>\n<p>在实现类NameServiceImpl上使用了@Component注解。</p>\n<p>然后XML（/spring-core-sample/src/main/resources/hybrid/component）配置为：</p>\n<pre><code class="xml"><span class="php"><span class="code-meta">&lt;?</span>xml version=<span\n        class="code-string">"1.0"</span> encoding=<span class="code-string">"UTF-8"</span><span\n        class="code-meta">?&gt;</span></span>\n<span class="code-tag">&lt;<span class="code-name">beans</span> <span class="hljs-attr">xmlns</span>=<span\n        class="code-string">"http://www.springframework.org/schema/beans"</span>\n    <span class="hljs-attr">xmlns:xsi</span>=<span\n            class="code-string">"http://www.w3.org/2001/XMLSchema-instance"</span>\n    <span class="hljs-attr">xmlns:context</span>=<span class="code-string">"http://www.springframework.org/schema/context"</span>\n    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="code-string">"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span>\n    \n    <span class="code-tag">&lt;<span class="code-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span\n            class="code-string">"chkui.springcore.example.hybrid.component.bean"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>XML配置文件中没有任何&lt;bean&gt;的声明，仅仅是通过component-scan启用了路径扫描功能，base-package指定了扫描的包路径。</p>\n<p>然后我们加载这个XML运行Spring IoC容器：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.component;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">SimpleScanApp</span> </span>{\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tprint(<span class="code-keyword">new</span> ClassPathXmlApplicationContext(<span class="code-string">"hybrid/component/scanConfig.xml"</span>));\n\t}\n\t\n\t<span class="hljs-function"><span class="code-keyword">private</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">print</span><span class="hljs-params">(ApplicationContext context)</span> </span>{\n    \tNameService service = context.getBean(NameService.class);\n    \tSystem.out.println(service.getName());\n\t}\n}</code></pre>\n<p>运行之后NameServiceImpl就会作为一个Bean添加到IoC容器中。</p>\n<p>在<a href="https://www.chkui.com/article/spring/spring_core_ioc_extension_points" title="IOC功能扩展点">IOC功能扩展点</a>&nbsp;一文中已经介绍通过XML、@Component、@Bean任何一种方式去声明一个Bean都会转化为一个&nbsp;<a\n        href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/config/BeanDefinition.html"\n        rel="nofollow">BeanDefinition</a>的实现类交给BeanFactory来创建实例，所以实际上通过@Component注解和在XML文件中编写一个&lt;bean&gt;标签在结果上并没有什么区别——都是向容器添加了一个Bean实例。但是Spring偏偏提供了@Bean和@Component（以及他的派生注解）2个注解来声名Bean，这当中肯定是有一些差异的。\n</p>\n<p>@Bean在后续的文章会介绍，它就等价与在XML编写一个&lt;bean&gt;标签。而@Component以及他的派生注解除了是一个IoC容器中的Bean还有许多附加的含义。</p>\n\n<h2 id="h2-2">Stereotype与功能分层</h2>\n<p>观察@Bean和@Component两个注解的包，前者是在 <em>org.springframework.context.annotation</em> ，而后者是在&nbsp;<em>org.springframework.stereotype</em>\n    。不仅仅是@Component，他的派生注解@Service、@Controller和@Repository都在这个包中，实际上它就是在告诉使用者这些注解提供<em>stereotype</em>的特性（或者称为功能、作用）。\n</p>\n<p>那什么是<em>stereotype</em>特性呢？这很难通过Stereotype这个词的字面意思（这个词能翻译的意思很多，这里最接近的翻译应该是“旧规矩”或者“使固定”）来理解。</p>\n<p>\n    Stereotype特性最早出现在J2EE6中（忘记是哪个JSR提出的了），可以理解为围绕着“元数据”功能而发展出来的一种设计模式，虽然我很难说清楚他属于23个设计模式中的哪一个，但是这确实已经是一种约定俗成的做法，只要看到Stereotype就应该像看到“Factory——工厂模式”、“Adapter——适配器模式”、“Facade——外观模式”一样，一眼就知道他的作用。</p>\n<p>\n    Stereotype特性的目标就是为“组合模式的分层系统”按层标记一个类的功能。所谓的“组合模式的分层系统”实际上就是我们常用的Controller-Service-Dao这种分层模式，只不过有些系统可能会多几层（比如Controller和Service之间加个RPC框架什么的）。根据<a\n        href="https://docs.oracle.com/javaee/6/api/javax/enterprise/inject/Stereotype.html" rel="nofollow">Stereotype特性的Java官网原文</a>介绍，它是一个用来标记注解的注解（annotating\n    annotation）。一个注解如果被@Stereotype标记证明他提供Stereotype模式的功能，例如下面这样：</p>\n<pre><code class="java"><span class="code-meta">@Stereotype</span> \n<span class="code-meta">@Target</span>(TYPE) \n<span class="code-meta">@Retention</span>(RUNTIME) \n<span class="code-meta">@interface</span> controller {}\n\n<span class="code-meta">@Stereotype</span> \n<span class="code-meta">@Target</span>(TYPE) \n<span class="code-meta">@Retention</span>(RUNTIME) \n<span class="code-meta">@interface</span> service {}</code></pre>\n<p>然后我们在使用时可以为不同层的类打上这些标记，表示他们属于不同的分层：</p>\n<pre><code class="java"><span class="hljs-class"><span class="code-keyword">interface</span> <span class="code-title">UserService</span></span>{}\n\n<span class="code-meta">@Service</span>\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">UserServiceImpl</span> <span\n        class="code-keyword">implements</span> <span class="code-title">UserService</span></span>{\n\t\n}\n\n<span class="code-meta">@Controller</span>\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">UseController</span></span>{\n\t<span class="code-meta">@Autowired</span>\n\tUserService userService;\n\t\n}</code></pre>\n<p>\n    一个类的实例可能会被用于0到多个分层中（比如Spring的一个Bean既可以是Controller也可以是Service，只要标记对应的注解即可），但是通常情况下一个类最多只会用在一个分层中使用。简单的说Stereotype特性就是用注解来告诉框架某个类是属于系统功能中的哪一层。</p>\n<p>\n    Java的文档上要求提供Stereotype特性的注解需要用@Stereotype来标记。但是Spring的开发大神并没有理会这个事，@Component并没有使用@Stereotype来标记，但是他确实提供了Stereotype的模式。</p>\n<p>\n    在Stereotype模式下，Spring核心工程为Controller-Service-Dao的分层模型分别提供了@Controller、@Service、@Repository注解。我们按照Stereotype的模式为对应的类标记3个注解，然后在引入MVC、ORM、JPA相关的框架之后这些注解会告诉框架对应的类扮演着什么样的功能角色，框架就能很清晰的根据注解提供相关的功能服务。</p>\n<p>\n    例如引入Spring-webmvc之后，一个类如果用@Controller注解标记了之后框架就知道他们都是处理前端请求的，MVC框架就会为他提供RequestMapping之类的功能。随后我们需要将框架调整为WebFlux，基本上直接更换依赖的Jar包就可以了，因为大家都是按照一个模式来开发的。</p>\n<p><span style="color:#e74c3c">所以，如果我们的某个类是用于指定的分层功能，那么最好使用<em>org.springframework.stereotype</em>包中的注解来标记他所属的分层。如果类没有明确的功能（例如用于存储配置数据的类，或者Helper类），使用@Bean等其他方式添加到容器中更合适（@Bean会在后续的文章中介绍）。</span>\n</p>\n<p>使用Stereotype特性来标记分层，还有一个好处是即使工程的结构再复杂多样，都可以很轻松的使用注解（Annotation）来实现拦截器或者AOP功能。因为我们能够很清晰的知道每个分层的作用，开发AOP的功能就非常便利。</p>\n\n<h2 id="h2-3">扫描配置</h2>\n<p>本文开篇使用了一个简单的例子说明使用&lt;context:component-scan&gt;扫描功能来自动添加被注解标记的Bean。除了使用base-package属性还有其他的标签来控制扫描的路径。</p>\n<p>&lt;context:include-filter&gt;和&lt;context:exclude-filter&gt;标签用来指定包含和排除的过滤规则。他们提供2个参数——type和expression，用来指定过滤类型和过滤参数，例如:</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span\n            class="code-string">"org.example"</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">context:include-filter</span> <span\n                class="hljs-attr">type</span>=<span class="code-string">"regex"</span>\n                <span class="hljs-attr">expression</span>=<span\n                    class="code-string">".*Stub.*Repository"</span>/&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">context:exclude-filter</span> <span\n                class="hljs-attr">type</span>=<span class="code-string">"annotation"</span>\n                <span class="hljs-attr">expression</span>=<span class="code-string">"org.springframework.stereotype.Repository"</span>/&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">context:component-scan</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>此外还可以使用use-default-filters属性来指定是否扫描默认注解（<code>@Component</code>、<code>@Repository</code>、<code>@Service</code>、<code>@Controller、</code><code>@Configuration</code>），默认值为ture。如果设定成false，需要我们在include-filter中增加对应的annotation。\n</p>\n<p>除了使用XML配置，还可以使用@ComponentScan注解来指定扫描的路径，他提供和XML配置一样的功能。在后续的文章会介绍纯Java配置的功能。</p>\n<p>关于扫描的详细说明见<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-scanning-filters"\n        rel="nofollow">官网的过滤规则说明</a>。</p>\n\n<h2 id="h2-4">组件命名</h2>\n<p>和普通的Bean一样，我们也可以在@Component上添加注解来指定Bean在IoC容器的名称：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.component.bean;\n\n<span class="code-meta">@Service</span>(<span class="code-string">"implementNameService"</span>)\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">NameServiceImpl</span> <span class="code-keyword">implements</span> <span\n            class="code-title">NameService</span></span>{\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span\n            class="code-title">getName</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"This is My Component"</span>;\n\t}\n}</code></pre>\n<p>这样在容器中这个Bean的名称被命名为"implementNameService"。除了直接在注解上添加内容，我们还可以实现&nbsp;BeanNameGenerator 接口来实现全局的命名方法。看下面这个例子。（源码请到<a\n        href="https://gitee.com/chkui-com/spring-core-sample" rel="nofollow">https://gitee.com/chkui-com/spring-core-sample</a>自行clone，例子在<em>chkui.springcore.example.hybrid.component</em>包中。）\n</p>\n<p>首先在XML中使用 "name-generator"&nbsp;指定名称的生成器：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span> <span\n        class="hljs-attr">xmlns</span>=<span class="code-string">"http://www.springframework.org/schema/beans"</span>\n\t<span class="hljs-attr">xmlns:xsi</span>=<span\n            class="code-string">"http://www.w3.org/2001/XMLSchema-instance"</span>\n\t<span class="hljs-attr">xmlns:context</span>=<span class="code-string">"http://www.springframework.org/schema/context"</span>\n\t<span class="hljs-attr">xsi:schemaLocation</span>=<span class="code-string">"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span>\n\n\t<span class="code-tag">&lt;<span class="code-name">context:component-scan</span>\n\t\t<span class="hljs-attr">base-package</span>=<span class="code-string">"chkui.springcore.example.hybrid.component.bean"</span>\n\t\t<span class="hljs-attr">name-generator</span>=<span class="code-string">"chkui.springcore.example.hybrid.component.bean.NameGenerator"</span> /&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>然后编写我们的命名生成规则：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.component.bean;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">NameGenerator</span> <span class="code-keyword">implements</span> <span\n            class="code-title">BeanNameGenerator</span> </span>{\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">generateBeanName</span><span\n            class="hljs-params">(BeanDefinition definition, BeanDefinitionRegistry registry)</span> </span>{\n\t\tAnnotatedBeanDefinition annotdef = AnnotatedBeanDefinition.class.cast(definition);\n\t\tAnnotationMetadata meta = annotdef.getMetadata();\n\t\t<span class="code-comment">//生成规则:如果已经命名不做任何调整，如果未命名则在类名车后面增加”_NoDefinedName“字符串</span>\n\t\t<span class="code-keyword">return</span> Optional.of(meta).map(met -&gt; met.getAnnotationTypes()).map(set -&gt; set.toArray(<span\n            class="code-keyword">new</span> String[] {}))\n\t\t\t\t.map(array -&gt; array[<span class="hljs-number">0</span>]).map(name -&gt; meta.getAnnotationAttributes(name)).map(entry -&gt; entry.get(<span\n            class="code-string">"value"</span>))\n\t\t\t\t.map(obj -&gt; <span class="code-string">""</span>.equals(obj) ? <span class="code-keyword">null</span> : obj).orElse(definition.getBeanClassName() + <span\n            class="code-string">"_NoDefinedName"</span>)\n\t\t\t\t.toString();\n\t}\n}</code></pre>\n\n<h2 id="h2-5">使用索引提升启动速度</h2>\n<p>\n    通常情况下，即使是对整个classpath进行扫描并不会占用太多的时间，但是某些应用对启动时间有极高的要求，对此Spring提供了索引功能。索引功能并不复杂，就是第一次扫描之后生成一个静态文件记录所有的组件，然后下一次扫描就直接读取文件中的内容，而不去执行扫描过程。</p>\n<p>首先引入spring-context-indexer包：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">dependencies</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">dependency</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">groupId</span>&gt;</span>org.springframework<span\n            class="code-tag">&lt;/<span class="code-name">groupId</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">artifactId</span>&gt;</span>spring-context-indexer<span\n            class="code-tag">&lt;/<span class="code-name">artifactId</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">version</span>&gt;</span>5.0.7.RELEASE<span class="code-tag">&lt;/<span\n            class="code-name">version</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">optional</span>&gt;</span>true<span\n            class="code-tag">&lt;/<span class="code-name">optional</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">dependency</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">dependencies</span>&gt;</span></code></pre>\n<pre><code class="json">dependencies {\n    compileOnly(<span class="hljs-attr">"org.springframework:spring-context-indexer:5.0.7.RELEASE"</span>)\n}</code></pre>\n<p>然后在运行后会生成一个&nbsp;META-INF/spring.components\n    的文件，之后只要运行工程发现这个文件都会直接使用他。可以通过环境变量或工程根目录的spring.properties中设置spring.index.ignore=ture来禁用这个功能。</p>\n<p>这个功能如果没有什么明确的需求，慎重使用，会提高工程的管理成本。</p>'},364:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<h2 id="h2-1">3.0新增容器启动方法</h2>\n<p>在3.0之前的Spring核心框架中，我们启动一个Spring容器必须使用一个XML文件。而到了3.X之后的版本Spring为创建容器新增了一个入口类——<strong><em>AnnotationConfigApplicationContext</em></strong>。\n</p>\n<p>\n    AnnotationConfigApplicationContext和过去的ClassPathXmlApplicationContext、FileSystemXmlApplicationContext等方法不同的是他不用再指定任何XML配置文件，而是可以通过指定类向容器添加Bean。我们通过几个简单的例子来说明他的使用。</p>\n<p>（以下例子只用于说明问题，源码<a href="https://gitee.com/chkui-com/spring-core-sample" rel="nofollow">请到 gitee&nbsp;自行 clone</a>，本节的代码在&nbsp;chkui.springcore.example.javabase.simple\n    包中）。</p>\n\n<h3 id="h3-1">直接添加Bean</h3>\n<p>我们可以通过AnnotationConfigApplicationContext直接向容器添加指定的类作为Bean，先定义我们的class：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.simple.pureBean;\n\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">LolBean</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">toString</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"I AM LOL!"</span>;\n\t}\n}\n\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">WowBean</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">toString</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"I AM WOW!"</span>;\n\t}\n}</code></pre>\n<p>然后向容器添加这些Bean：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.simple;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">WithoutAnnotation</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(WowBean.class, LolBean.class);\n\t\tSystem.out.println(ctx.getBean(WowBean.class));\n\t\tSystem.out.println(ctx.getBean(LolBean.class));\n\t}\n}</code></pre>\n<p>这样就启动了一个Spring的容器，并且容器中包含了WowBean和LolBean这两个类的单例。</p>\n\n<h3 id="h3-2">替代&lt;beans&gt;标签</h3>\n<p>@Configuration在之前介绍Spring核心容器的文章中出现过一两次，配合各种注解的使用@Configuration可以替代&lt;beans&gt;配置中的所有功能。基本上AnnotationConfigApplicationContext和@Configuration组合使用就可以实现Spring容器纯Java启动。请看下面的例子。</p>\n<p>我们在前面例子的基础上增加几个类：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.simple.bean;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">DotaBean</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">toString</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"I AM Dota!"</span>;\n\t}\n}\n\n<span class="code-meta">@Component</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">PseBean</span> </span>{\n\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">toString</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"I AM PSE!"</span>;\n\t}\n}</code></pre>\n<p>注意DotaBean上是没有@Component注解的。然后添加@Configuration配置：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.simple.bean;\n\n<span class="code-meta">@Configuration</span>\n<span class="code-meta">@ComponentScan</span>(<span\n            class="code-string">"chkui.springcore.example.javabase.simple.bean"</span>)\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Config</span> </span>{\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> DotaBean <span\n            class="code-title">dotaBean</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> DotaBean();\n\t}\n}</code></pre>\n<p>最后运行他们：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.simple;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">WithScan</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(Config.class, WowBean.class, LolBean.class);\n\t\tSystem.out.println(ctx.getBean(Config.class));\n\t\tSystem.out.println(ctx.getBean(PseBean.class));\n\t\tSystem.out.println(ctx.getBean(WowBean.class));\n\t\tSystem.out.println(ctx.getBean(LolBean.class));\n\t\tSystem.out.println(ctx.getBean(DotaBean.class));\n\t}\n}</code></pre>\n<p>@Component已经在&nbsp;<a href="https://www.chkui.com/article/spring/spring_core_stereotype_component_and_bean_scan"\n                         title="Stereotype组件与Bean扫描">Stereotype组件与Bean扫描</a>&nbsp;这篇文章介绍过，@ComponentScan的作用等价于&lt;context:component-scan/&gt;标签，属性参数都是一一对应的，只不过前者是驼峰命名规则（camelCase）——@ComponentScan(basePackages="...")，后者是短横线命名规则（kebab-case）——&lt;context:component-scan\n    base-package="..."/&gt;。实际上使用Annotation来替换XML配置中的内容，大部分都使用这种转换方式。</p>\n<p>@Configuration和@Bean标签会在后续的内容中详细介绍。@Bean主要用于方法标记，表明这个方法返回一个要添加到容器中的Bean。</p>\n\n<h3 id="h3-3">AnnotationConfigApplicationContext的其他使用方法</h3>\n<p>除了以上常规的使用方法，AnnotationConfigApplicationContext还有其他方式向容器添加Bean。</p>\n<p>可以使用AnnotationConfigApplicationContext::register方法来添加配置和Bean：</p>\n<pre><code class="java"><span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n        class="code-keyword">void</span> <span class="code-title">main</span><span\n        class="hljs-params">(String[] args)</span> </span>{\n    AnnotationConfigApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext();\n    <span class="code-comment">//动态添加配置文件</span>\n    ctx.register(Config1.class, Config2.class);\n    <span class="code-comment">//动态添加Bean</span>\n    ctx.register(Bean1.class);\n    <span class="code-comment">//刷新</span>\n    ctx.refresh();\n}</code></pre>\n<p>\n    注意最后的refresh方法，这个方法来源于ConfigurableApplicationContext接口，然后是在AbstractApplicationContext中实现的。他的过程相当于销毁之前已经创建的资源，然后再重新创建了一个新的容器。这里的代码会执行以下几步：</p>\n<ol>\n    <li><em>new AnnotationConfigApplicationContext()</em>：创建一个新的容器，容器中没有自定义的Bean。</li>\n    <li>AnnotationConfigApplicationContext::register：向容器添加<a\n            href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/config/BeanDefinition.html"\n            rel="nofollow">BeanDefinition</a>，但是这些<a\n            href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/config/BeanDefinition.html"\n            rel="nofollow">BeanDefinition</a>并没有转化为容器中的Bean。\n    </li>\n    <li>ConfigurableApplicationContext::refresh()：纳入新添加的<a\n            href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/config/BeanDefinition.html"\n            rel="nofollow">BeanDefinition</a>重建容器。\n    </li>\n</ol>\n<p>还可以直接使用AnnotationConfigApplicationContext::scan方法扫描指定的路径：</p>\n<pre><code class="java"><span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n        class="code-keyword">void</span> <span class="code-title">main</span><span\n        class="hljs-params">(String[] args)</span> </span>{\n    AnnotationConfigApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext();\n    ctx.scan(<span class="code-string">"com.acme"</span>);\n    ctx.refresh();\n}</code></pre>\n<p>执行原理和上面介绍的一样。</p>\n<p>\n    按照以上介绍的内容。如果你的工程中需要使用AnnotationConfigApplicationContext::register、AnnotationConfigApplicationContext::scan等方法创建容器和其中Bean的依赖关系，最好是所有的Bean都在register或scan中添加。因为重建一批Bean会花费不少时间，尤其是Bean中还有销毁方法要回收资源时。</p>\n\n<h2 id="h2-2">@Bean注解</h2>\n<p>@Bean注解等价于配置文件中的&lt;bean&gt;标签，对应的参数也是将短横线命名切换为驼峰命名——&lt;bean init-method="..."&gt; =&gt;\n    @Bean(initMethod="...")。@Bean注解只能使用在方法上，方法必须是在@Configuration标记的类或者其他Bean中，两者存在的差异会在后续的文章中介绍。下面通过一个例子来说明Bean的使用。</p>\n<p>（以下例子只用于说明问题，源码<a href="https://gitee.com/chkui-com/spring-core-sample" rel="nofollow">请到 gitee&nbsp;自行 clone</a>，本节的代码在&nbsp;chkui.springcore.example.javabase.beanAnnotation\n    包中）。</p>\n<p>定义两个要添加到容器中的Bean：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.beanAnnotation.bean;\n\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">FinalFantasy</span> </span>{\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">toString</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"Final Fantasy 1~15"</span>;\n\t}\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">init</span><span class="hljs-params">()</span> </span>{\n\t\tSystem.out.println(<span class="code-string">"Final Fantasy init!"</span>);\n\t}\n\t\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">destroy</span><span class="hljs-params">()</span> </span>{\n\t\tSystem.out.println(<span class="code-string">"Final Fantasy destroy!"</span>);\n\t}\n}\n\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">DragonQuest</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">toString</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"Dragon Quest 1~11"</span>;\n\t}\n\t\n\t<span class="code-meta">@PostConstruct</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">init</span><span class="hljs-params">()</span> </span>{\n\t\tSystem.out.println(<span class="code-string">"Dragon Quest init!"</span>);\n\t}\n\t\n\t<span class="code-meta">@PreDestroy</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">destroy</span><span class="hljs-params">()</span> </span>{\n\t\tSystem.out.println(<span class="code-string">"Dragon Quest destroy!"</span>);\n\t}\n}\n</code></pre>\n<p>定义一个功能接口及其实现类：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.beanAnnotation.bean;\n\n<span class="hljs-class"><span class="code-keyword">interface</span> <span class="code-title">Support</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">void</span> <span\n            class="code-title">setFinalFantasy</span><span class="hljs-params">(FinalFantasy ff)</span></span>;\n\t<span class="hljs-function">FinalFantasy <span class="code-title">getFinalFantasy</span><span\n            class="hljs-params">()</span></span>;\n}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">SupportImpl</span> <span\n        class="code-keyword">implements</span> <span class="code-title">Support</span> </span>{\n\t<span class="code-keyword">private</span> FinalFantasy ff; \n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setFinalFantasy</span><span class="hljs-params">(FinalFantasy ff)</span> </span>{\n\t\t<span class="code-keyword">this</span>.ff = ff;\n\t}\n\t<span class="hljs-function"><span class="code-keyword">public</span> FinalFantasy <span class="code-title">getFinalFantasy</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> ff;\n\t}\n}</code></pre>\n<p>然后顶一个@Configuration类：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.beanAnnotation.bean;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">BeanAnnotationConfig</span> </span>{\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> Support <span class="code-title">support</span><span\n            class="hljs-params">(FinalFantasy ff)</span> </span>{\n\t\tSupport support = <span class="code-keyword">new</span> SupportImpl();\n\t\tsupport.setFinalFantasy(ff);\n\t\t<span class="code-keyword">return</span> support;\n\t}\n\t\n\t<span class="code-meta">@Bean</span>(initMethod=<span class="code-string">"init"</span>, destroyMethod=<span\n            class="code-string">"destroy"</span>)\n\t<span class="code-meta">@Description</span>(<span class="code-string">"Final Fantasy"</span>)\n\t<span class="hljs-function"><span class="code-keyword">public</span> FinalFantasy <span class="code-title">finalFantasy</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> FinalFantasy();\n\t}\n\t\n\t<span class="code-meta">@Bean</span>(name= {<span class="code-string">"dragon-quest"</span>, <span\n            class="code-string">"DragonQuest"</span>})\n\t<span class="hljs-function"><span class="code-keyword">public</span> DragonQuest <span class="code-title">dragonQuest</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> DragonQuest();\n\t}\n}</code></pre>\n<p>最后运行他们：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">BeanAnnotApp</span> </span>{\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(BeanAnnotationConfig.class);\n\t\tSupport support = ctx.getBean(Support.class);\n\t\tSystem.out.println(support.getFinalFantasy());\n\t\tSystem.out.println(ctx.getBean(DragonQuest.class));\n\t}\n\n}</code></pre>\n<p>在配置类BeanAnnotationConfig中，我们配置了3个Bean。这里的写在方法上的@Bean注解和写在配置文件中的&lt;bean&gt;注解一个效果：</p>\n<ul>\n    <li>\n        <strong><em>@Bean</em></strong>中的<strong><em>initMethod</em></strong>和<strong><em>destroyMethod</em></strong>对应<strong><em>&lt;bean&gt;</em></strong>标签中的<strong><em>init-method</em></strong>和<strong><em>destroy-method</em></strong>属性。\n    </li>\n    <li><strong><em>@Bean</em></strong>中的<strong><em>name</em></strong>参数只有一个值时相当于id，有多个的时候相当于设置了多个别名</li>\n    <li><strong><em>Support support(FinalFantasy ff)</em></strong>：我们可以直接在方法中暴露参数来引入其他Bean，这就类似于配置中<strong><em>ref</em></strong>的功能。\n    </li>\n    <li>如果不指定<strong><em>initMethod</em></strong>和<strong><em>destroyMethod</em></strong>，使用JSR-330的生命周期注解（@PostConstruct、@PreDestroy）同样有效\n    </li>\n</ul>\n'},378:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<p>Vert.x可以使用Zookeeper和Ignite等框架来创建集群，但是首选框架还是Hazelcast。此外，码友们也可以通过<em>ClusterManager</em>接口实现或引入需要的集群管理工具。本文将说明Vert.x是如何利用Hazelcast来创建和管理集群的，同时你也会了解到Vertx如何创建单机实例。</p>\n<h2 id="h2-1"><strong>集群创建</strong></h2>\n<p>在创建Vert.x集调用群时，调用方法和创建单机实例是有差异的。集群需要调<em>Vertx.clusteredVertx</em>异步方法创建。集群可以完全新建和引入已有的Hazelcast实例二种方式来创建。如下：</p>\n<p>1.新建实例</p>\n<blockquote>\n    <p>ClusterManager mgr = new HazelcastClusterManager();</p>\n</blockquote>\n<p>2.引入Hazelcast实例</p>\n<blockquote>\n    <p>ClusterManager mgr = new HazelcastClusterManager(hazelcastInstance);</p>\n</blockquote>\n<p>详情可以参考官方手册<a title="Hazelcast" href="http://vertx.io/docs/vertx-hazelcast/java/" rel="nofollow">http://vertx.io/docs/vertx-hazelcast/java/</a>。</p>\n\n<h2 id="h2-2">新建集群过程</h2>\n<p>调用<em>Vertx.clusteredVertx</em>静态方法后，Vert.x会利用Vertx工厂方法创建Vertx实例。如下</p>\n<p>其中简单直白的使用 <em>new&nbsp;VertxImpl();</em>来创建Vertx实例。</p>\n<pre class="gradle"><code class="gradle">VertxFactoryImpl.clusteredVertx(VertxOptions <span class="code-keyword"><span class="code-keyword">options</span></span>, <span class="code-keyword"><span class="code-keyword">final</span></span> Handler&lt;AsyncResult&lt;Vertx&gt;&gt; resultHandler) {\n    <span class="code-keyword"><span class="code-keyword">options</span></span>.setClustered(<span class="code-keyword"><span class="code-keyword">true</span></span>);<span class="code-comment"><span class="code-comment">//设置参数，启用集群</span></span>\n    <span class="code-keyword"><span class="code-keyword">new</span></span> VertxImpl(<span class="code-keyword"><span class="code-keyword">options</span></span>, resultHandler);<span class="code-comment"><span class="code-comment">//创建Vertx实例</span></span>\n}</code></pre>\n<p style="text-align:center">图1启动集群</p>\n<p>在<em>VertxImpl</em>的构造方法中，若需要创建集群，则执行：</p>\n<pre class="gradle"><code class="gradle">VertxImpl(VertxOptions <span class="code-keyword"><span class="code-keyword">options</span></span>, Handler&lt;AsyncResult&lt;Vertx&gt;&gt; resultHandler) {\n    <span class="code-comment"><span class="code-comment">// some code</span></span>\n    <span class="code-keyword"><span class="code-keyword">if</span></span> (<span class="code-keyword"><span class="code-keyword">options</span></span>.isClustered()) {\n      <span class="code-keyword"><span class="code-keyword">this</span></span>.clusterManager = getClusterManager(<span class="code-keyword"><span class="code-keyword">options</span></span>);<span class="code-comment"><span class="code-comment">//1.获取集群管理对象</span></span>\n      <span class="code-keyword"><span class="code-keyword">this</span></span>.clusterManager.setVertx(<span class="code-keyword"><span class="code-keyword">this</span></span>);<span class="code-comment"><span class="code-comment">//2. 设置实例</span></span>\n      <span class="code-keyword"><span class="code-keyword">this</span></span>.clusterManager.<span class="code-keyword"><span class="code-keyword">join</span></span>(ar -&gt; {<span class="code-comment"><span class="code-comment">//3. 加入集群</span></span>\n        <span class="code-keyword"><span class="code-keyword">if</span></span> (ar.failed()) {\n          log.error(<span class="code-string"><span class="code-string">"Failed to join cluster"</span></span>, ar.cause());\n        } <span class="code-keyword"><span class="code-keyword">else</span></span> {\n          <span class="code-comment"><span class="code-comment">// Provide a memory barrier as we are setting from a different thread</span></span>\n          <span class="code-keyword"><span class="code-keyword">synchronized</span></span> (VertxImpl.<span class="code-keyword"><span class="code-keyword">this</span></span>) {\n            haManager = <span class="code-keyword"><span class="code-keyword">new</span></span> HAManager(<span class="code-keyword"><span class="code-keyword">this</span></span>, deploymentManager, clusterManager, <span class="code-keyword"><span class="code-keyword">options</span></span>.getQuorumSize(),\n                                      <span class="code-keyword"><span class="code-keyword">options</span></span>.getHAGroup(), haEnabled);\n            createAndStartEventBus(<span class="code-keyword"><span class="code-keyword">options</span></span>, resultHandler);\n          }\n        }\n      });\n    } <span class="code-keyword"><span class="code-keyword">else</span></span> {\n      <span class="code-keyword"><span class="code-keyword">this</span></span>.clusterManager = <span class="code-keyword"><span class="code-keyword">null</span></span>;\n      createAndStartEventBus(<span class="code-keyword"><span class="code-keyword">options</span></span>, resultHandler);\n    }\n    <span class="code-comment"><span class="code-comment">// some code</span></span>\n  }</code></pre>\n<p style="text-align:center">图2</p>\n<p>这里会分3部来创建集群，首先调用<em>getClusterManager</em>来获取集群的配置管理实例。如下：</p>\n<pre class="gradle"><code class="language-java">getClusterManager(VertxOptions <span class="code-keyword">options</span>) {\n    <span class="code-keyword"><span class="code-keyword">if</span></span> (<span class="code-keyword">options</span>.isClustered()) {\n      <span class="code-keyword"><span class="code-keyword">if</span></span> (<span class="code-keyword">options</span>.getClusterManager() != <span class="code-keyword"><span class="code-keyword">null</span></span>) {<span class="code-comment"><span class="code-comment">//判断是否已经创建集群管理对方</span></span>\n        <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="code-keyword">options</span>.getClusterManager();<span class="code-comment"><span class="code-comment">//若已创建，直接使用这个对象。</span></span>\n      } <span class="code-keyword"><span class="code-keyword">else</span></span> {<span class="code-comment"><span class="code-comment">//若无创建，执行新建过程。</span></span>\n        ClusterManager mgr;\n        String clusterManagerClassName = System.getProperty(<span class="code-string"><span class="code-string">"vertx.cluster.managerClass"</span></span>);<span class="code-comment"><span class="code-comment">/*通过系统参数设置集群管理对象*/</span></span>\n        <span class="code-keyword"><span class="code-keyword">if</span></span> (clusterManagerClassName != <span class="code-keyword"><span class="code-keyword">null</span></span>) {<span class="code-comment"><span class="code-comment">//clusterManagerClassName变量指定的类名存在，开始加载</span></span>\n          <span class="code-comment"><span class="code-comment">// We allow specify a sys prop for the cluster manager factory which overrides ServiceLoader</span></span>\n          <span class="code-keyword"><span class="code-keyword">try</span></span> {\n            <span class="code-keyword">Class</span>&lt;?&gt; clazz = <span class="code-keyword">Class</span>.forName(clusterManagerClassName);\n            mgr = (ClusterManager)clazz.newInstance();\n          } <span class="code-keyword"><span class="code-keyword">catch</span></span> (Exception e) {\n            <span class="code-keyword"><span class="code-keyword">throw</span></span> <span class="code-keyword"><span class="code-keyword">new</span></span> IllegalStateException(<span class="code-string"><span class="code-string">"Failed to instantiate "</span></span> + clusterManagerClassName, e);\n          }\n        } <span class="code-keyword"><span class="code-keyword">else</span></span> {<span class="code-comment"><span class="code-comment">//clusterManagerClassName指定的变量null,使用默认加载器。</span></span>\n          ServiceLoader&lt;ClusterManager&gt; mgrs = ServiceLoader.load(ClusterManager.<span class="code-keyword">class</span>);\n          <span class="code-keyword"><span class="code-keyword">if</span></span> (!mgrs.iterator().hasNext()) {\n            <span class="code-keyword"><span class="code-keyword">throw</span></span> <span class="code-keyword"><span class="code-keyword">new</span></span> IllegalStateException(<span class="code-string"><span class="code-string">"No ClusterManagerFactory instances found on classpath"</span></span>);\n          }\n          mgr = mgrs.iterator().<span class="code-keyword">next</span>();\n        }\n        <span class="code-keyword"><span class="code-keyword">return</span></span> mgr;\n      }\n    } <span class="code-keyword"><span class="code-keyword">else</span></span> {\n      <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="code-keyword"><span class="code-keyword">null</span></span>;\n    }\n  }</code></pre>\n<p style="text-align:center">图3，获取集群管理类<br> 从源码看，<em><code>getClusterManager</code></em>并没有什么特殊的地方。首先检查用户在创建Vertx实例之前，是否创建了集群的管理对象<code><em>ClusterManager</em>。创建了，则使用这个管理对象，没有创建则自行新建一个。</code></p>\n<p>注意</p>\n<blockquote>\n    <p>String clusterManagerClassName = System.getProperty("vertx.cluster.managerClass");</p>\n</blockquote>\n<p>这行代码 ，这说明可以通过JVM环境参数（<em>-Dvertx.cluster.managerClass=[className]</em>）来指定Vertx加载集群管理对象类。这在官方手册中并没有任何一个地方说明。</p>\n<p>如果指定了managerClass，则会使用默认加载方式加载指定的类，并转换成<em>ClusterManager</em>接口。</p>\n<p>如果没有指定managerClass，则使用默认集群加载类启动集群。</p>\n<blockquote>\n    <p>ServiceLoader&lt;ClusterManager&gt; mgrs = ServiceLoader.load(ClusterManager.class);&nbsp;</p>\n</blockquote>\n<p>ServiceLoader是Java在1.6定义的聚群接口类，有点类似于spring的Ioc容器。其过程也是加载类。详细说明请查阅&nbsp;<a href="http://my.oschina.net/hanzhankang/blog/109794" rel="nofollow">通过ServiceLoader实现链式处理</a>&nbsp;一文，解释得很清楚。</p>\n<p>可以看到在<em>vertx-hazelcast-[vertsion].jar</em>包中，<em>META-INF/services/io.vertx.core.spi.cluster.ClusterManager</em>指定了<em>ClusterManager</em>要<em>ServiceLoader</em>加载<em>HazelcastClusterManager。</em></p>\n<blockquote>\n    <p>io.vertx.spi.cluster.hazelcast.HazelcastClusterManager</p>\n</blockquote>\n<p>回到图2，Vert.x接下来使用</p>\n<blockquote>\n    <p>clusterManager.setVertx(this)</p>\n</blockquote>\n<p>将vertx实例设置到集群管理类中。 随后调用</p>\n<blockquote>\n    <p>clusterManager.join</p>\n</blockquote>\n<p>来加入集群。 下面是<em>clusterManager.join</em>的源码</p>\n<pre class="less"><code class="less"><span class="code-selector-tag"><span class="code-selector-tag">synchronized</span></span> <span class="code-selector-tag"><span class="code-selector-tag">void</span></span> <span class="code-selector-tag"><span class="code-selector-tag">join</span></span>(Handler&lt;AsyncResult&lt;Void&gt;&gt; resultHandler) {\n    <span class="code-selector-tag"><span class="code-selector-tag">vertx</span></span><span class="code-selector-class"><span class="code-selector-class">.executeBlocking</span></span>(fut -&gt; {\n      <span class="code-selector-tag"><span class="code-selector-tag">if</span></span> (!active) {<span class="code-comment"><span class="code-comment">//确保只初始化一次</span></span>\n        active = true;\n        <span class="code-selector-tag"><span class="code-selector-tag">if</span></span> (customHazelcastCluster) {<span class="code-comment"><span class="code-comment">//当使用的是用户自己创建的Hazelcast实例时</span></span>\n          nodeID = hazelcast<span class="code-selector-class"><span class="code-selector-class">.getLocalEndpoint</span></span>()<span class="code-selector-class"><span class="code-selector-class">.getUuid</span></span>();<span class="code-comment"><span class="code-comment">//获取节点编号</span></span>\n          membershipListenerId = hazelcast<span class="code-selector-class"><span class="code-selector-class">.getCluster</span></span>()<span class="code-selector-class"><span class="code-selector-class">.addMembershipListener</span></span>(this);<span class="code-comment"><span class="code-comment">//获取当前节点监听成员变换的事件的ID</span></span>\n          fut<span class="code-selector-class"><span class="code-selector-class">.complete</span></span>();\n          return;\n        }\n        if (conf == null) {<span class="code-comment"><span class="code-comment">//获取Hazelcast的Config</span></span>\n          conf = loadConfigFromClasspath();\n          <span class="code-selector-tag"><span class="code-selector-tag">if</span></span> (conf == null) {\n            log<span class="code-selector-class"><span class="code-selector-class">.warn</span></span>(<span class="code-string"><span class="code-string">"Cannot find cluster configuration on classpath and none specified programmatically. Using default hazelcast configuration"</span></span>);\n          }\n        }\n        <span class="code-comment"><span class="code-comment">//新建hazelcast实例</span></span>\n        hazelcast = Hazelcast.newHazelcastInstance(conf);\n        nodeID = hazelcast.getLocalEndpoint().getUuid();\n        membershipListenerId = hazelcast.getCluster().addMembershipListener(this);\n        fut.complete();\n      }\n    }, resultHandler);\n  }</code></pre>\n<p style="text-align:center">图4，新建hazelcast实例</p>\n<p>如果用户自己创建并传入Hazelcast实例，<em>ClusterManager</em>只是简单的从中获取需要的参数。如果未创建实例，则<em>ClusterManager</em>会自行创建。</p>\n<p>首先，loadConfigFromClasspath会用来加载本地的配置文件。</p>\n<pre class="cs"><code class="language-java"><span class="hljs-function"><span class="hljs-function">Config </span><span class="code-title"><span class="hljs-function"><span class="code-title">loadConfigFromClasspath</span></span></span><span class="hljs-params"><span class="hljs-function">(<span class="hljs-params"></span>)</span></span><span class="hljs-function"> </span></span>{\n    Config cfg = <span class="code-keyword"><span class="hljs-literal">null</span></span>;\n    <span class="code-keyword"><span class="code-keyword">try</span></span> (InputStream <span class="code-keyword">is</span> = getConfigStream();\n         InputStream bis = <span class="code-keyword"><span class="code-keyword">new</span></span> BufferedInputStream(<span class="code-keyword">is</span>)) {\n      <span class="code-keyword"><span class="code-keyword">if</span></span> (<span class="code-keyword">is</span> != <span class="code-keyword"><span class="hljs-literal">null</span></span>) {\n        cfg = <span class="code-keyword"><span class="code-keyword">new</span></span> XmlConfigBuilder(bis).build();<span class="code-comment"><span class="code-comment">//创建HazelcastConfig</span></span>\n      }\n    } <span class="code-keyword"><span class="code-keyword">catch</span></span> (IOException ex) {\n      log.error(<span class="code-string"><span class="code-string">"Failed to read config"</span></span>, ex);\n    }\n    <span class="code-keyword"><span class="code-keyword">return</span></span> cfg;\n  }</code></pre>\n<p style="text-align:center">图5，加载HazelcastConfig</p>\n<p>getConfigStream用来读取配置文件。</p>\n<pre class="kotlin"><code class="language-java"><span class="hljs-function">InputStream <span class="code-title">getConfigStream</span><span class="hljs-params">()</span> </span>{\n    ClassLoader ctxClsLoader = Thread.currentThread().getContextClassLoader();\n    InputStream <span class="code-keyword">is</span> = <span class="code-keyword"><span class="hljs-literal">null</span></span>;\n    <span class="code-keyword"><span class="code-keyword">if</span></span> (ctxClsLoader != <span class="code-keyword"><span class="hljs-literal">null</span></span>) {\n      <span class="code-keyword">is</span> = ctxClsLoader.getResourceAsStream(CONFIG_FILE);\n    }\n    <span class="code-keyword"><span class="code-keyword">if</span></span> (<span class="code-keyword">is</span> == <span class="code-keyword"><span class="hljs-literal">null</span></span>) {\n      <span class="code-keyword">is</span> = getClass().getClassLoader().getResourceAsStream(CONFIG_FILE);\n      <span class="code-keyword"><span class="code-keyword">if</span></span> (<span class="code-keyword">is</span> == <span class="code-keyword"><span class="hljs-literal">null</span></span>) {\n        <span class="code-keyword">is</span> = getClass().getClassLoader().getResourceAsStream(DEFAULT_CONFIG_FILE);\n      }\n    }\n    <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="code-keyword">is</span>;\n  }</code></pre>\n<p style="text-align:center">图6，读取配置文件</p>\n<p>如图5、图6的源码。<em>getConfigStream</em>会先加载classpath下的<em>cluster.xml（CONFIG_FILE）</em>文件。如果不存在，则加载jar包内的<em>default-cluster.xml（DEFAULT_CONFIG_FILE）</em>文件。读取完毕后，<em>loadConfigFromClasspath</em>使用Hazelcast的<em>XmlConfigBuilder</em>来构建<em>HazelcastConfig</em>。而后会用这个Config初始化Hazelcast。</p>\n<p>集群创建成功后， 会初始化一个<em>HAManager</em>实例，用于做verticle迁移。后面在详细说明HA模式。</p>\n<p>最后，在VertxImpl中，会调用<em>createAndStartEventBus</em>方法在集群环境运行的EventBus。</p>'}});