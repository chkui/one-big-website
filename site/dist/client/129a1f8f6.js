webpackJsonp([1],{296:function(s,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<p>在hazelcast的官方文档中，提到了其支持read-through，write-through与write-behind三种模式。查阅资料，最后在oracle的官文中找到了比较靠谱的解释。</p>\n<p>read-throug、write-through、write-behind三个概念都是关于数据缓存管理的。其实这些概念在实际使用的过程中经常接触。</p>\n<h2 id="h2-1"><strong>Read-throug</strong></h2>\n<p>当应用系统向缓存系统请求数据时（例如使用key=x向缓存请求数据）；如果缓存中并没有对应的数据存在（key=x的value不存在），缓存系统将向底层数据源的读取数据。如果数据在缓存中存在（命中key=x），则直接返回缓存中存在的数据。这就是所谓的<strong>Read-throug。</strong></p>\n<p>hazelcast原文：</p>\n<blockquote>\n    <p>If an entry does not exist in the memory when an application asks for it, Hazelcast asks your loader implementation to load that entry from the data store。 &nbsp;If the entry exists there, the loader implementation gets it, hands it to Hazelcast, and Hazelcast puts it into the memory. This is read-through persistence mode。</p>\n</blockquote>\n<p>下图是Oracle官网的<strong>Read-throug</strong>图例。\n    <img alt="Hazelcast read-through、write-through与write-behind模式" src="https://file.mahoooo.com/res/file/read_through_write_through_and_write_behind_1.jpg">\n</p>\n<h2 id="h2-2">Write-Through</h2>\n<p>当应用系统对缓存中的数据进行更新时（例如调用put方法更新或添加条目），缓存系统会同步更新缓存数据和底层数据源。</p>\n<p>下图展示了执行过程：</p>\n<p><img alt="Hazelcast read-through、write-through与write-behind模式" src="https://file.mahoooo.com/res/file/read_through_write_through_and_write_behind_2.jpg"></p>\n<h2 id="h2-3">Write-Behind</h2>\n<p>当应用系统对缓存中的数据进行更新时（例如调用put方法更新或添加条目），缓存系统会在指定的时间后向底层数据源更新数据。</p>\n<p><img alt="Hazelcast read-through、write-through与write-behind模式" src="https://file.mahoooo.com/res/file/read_through_write_through_and_write_behind_3.jpg"></p>'},307:function(s,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<p>使用react到现在，让人头疼的一个问题是安装node-sass。其实导致问题的根源在于安装过程需要下载一个binding.node文件，而因“你懂的”原因，访问不了这个地址。根据这个原因，总结了以下几个解决方案：</p>\n<h2 id="h2-1">翻墙</h2>\n<p>这没什么好说的了，这是最轻松最彪悍的解决方案。只要能翻墙直接一个&nbsp;<span style="background-color:#D3D3D3">&nbsp;npm i&nbsp;</span>命令就完事了，什么都不必去操心。至于怎么翻墙…………\n</p>\n\n<h2 id="h2-2">使用cnpm</h2>\n<p>cnpm是一个强悍的工具，几乎能解决所有npm安装第三方包时遇到的问题。执行如下命令即可：</p>\n<pre class="sql"><code class="language-bash">npm <span class="code-keyword">install</span>\nnpm rm node-sass\ncnpm <span class="code-keyword">install</span> node-sass\nnpm <span class="code-keyword">install</span></code></pre>\n<p>\n    但是我们在使用cnpm时也遇到了一个坑，在ubuntu14.04打出来的包运行报错，不用cnpm下载居然就不会有这问题，由于没有时间，没有详细去了解原因是什么。如果你是Windows开发而使用Linux环境打包或运行，可能会碰到这个问题。</p>\n\n<h2 id="h2-3">下载后编译</h2>\n<p>\n    实际上为了得到binding.node，是可以直接从github上把源码下载下来之后再编译出来的，node-sass自己也会这样做，但是编译要依赖其他工具。在各种发行版的linux下还好，几乎所有需要的环境（python等）都是预安装的，如果是root权限直接<span\n        style="background-color:#A9A9A9"> upm install </span>就搞定了，所以有时候根本感觉不到这个问题。在windows下就得花时间根据install时的错误日志了解还要安装什么。\n</p>\n<p>linux下遇到权限问题请执行：</p>\n<pre class="lua"><code class="language-bash">npm i <span class="code-comment">--unsafe -perm</span></code></pre>\n\n<h2 id="h2-4">附送一个最奇葩的坑</h2>\n<p>这是我用所有的开源工具遇到过最奇葩的坑。我将一个文件命名为“./dropDown.scss”，然后在linux(是ubuntu\n    14.04其他发行版没时间去测试，windows没这毛病)上用webpack打包，打包过程没有任何异常，但是放到服务器上运行打开某个页面就抛出无法找到"./dropDown.scss"的异常，然后node直接停机了········。我前后跟进了2天寻找问题的原因。最后突发奇想将文件名由dropDown.scss修改为pullDown.scss后一切都好了。我强烈的怀疑是某个临时工在node-sass里写了什么“硬编码”对字符串进行判断，发现“/drop[*]”这样的前缀进行一些特殊处理。在此记录下来。</p>'},315:function(s,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<h2 id="h2-1">什么叫前后端同构？</h2>\n<p>为了解决某些问题（比如SEO、提升渲染速度等）<strong><em>react</em></strong>\n    提供了2个方法在服务端生成一个HTML文本格式的字符串。在得到了这个HTML格式的字符串之后，通常会将其组装成一个页面直接返回给用户的浏览器。</p>\n<p>到这里，服务端的活已经干完了，然后就是浏览器这边干活。</p>\n<p>浏览器拿到HTML文本后，立刻进行渲染将内容呈现给用户。然后加载页面所需的 .js 文件，然后执行\n    <em><strong>JavaScript&nbsp;</strong></em>脚本，然后开始初始化&nbsp;<em><strong>react</strong></em> 组件…………</p>\n<p>到这里问题就来了。<strong><em>react</em></strong> 初始化组件后会执行组件内所有\n    <em>render&nbsp;() </em>方法，然后生成虚拟DOM的树形结构，然后在适当的时候将虚拟dom<em>写</em>到浏览器的真实dom中。因为 <strong><em>react</em></strong>\n    总是根据虚拟dom来生成真实dom，所以最后会把服务器端渲染好的HTML全部替换掉。</p>\n<p>\n    上面这个事情说不是问题确实也不是问题，无非就是用户看到页面然后“闪现”一下。说是问题还真是个问题，产品会拿着这毛病从用户体验的角度在各种场合和你死磕半个月。磕累了你索性把服务端渲染关了，然后运营又拿着SEO的问题准备和你开始撕逼了。</p>\n<p>聪明如 Facebook 的工程师当然想到了这些问题，所以他们在<em>ReactDOMServer.renderToString(element) 方法</em>中提供了一个\n    <strong><em>checksum</em></strong> 机制。</p>\n<p>关于&nbsp;<strong><em>checksum </em></strong> <a href="https://facebook.github.io/react/docs/react-dom-server.html"\n                                                  rel="nofollow">官网</a> 并没有太多介绍，但是国内外的各路博客介绍了不少。我一直想找&nbsp;<em><strong>react</strong></em>\n    开发者关于这个机制的介绍一直没找到……。</p>\n<p><strong>前后端同构</strong>就是保证前端和后端的dom结构一致，不会发生重复渲染。<em><strong>react</strong></em>\n    使用&nbsp;<strong><em>checksum </em></strong>机制进行保障。</p>\n\n<h2 id="h2-2">什么叫React首屏渲染？</h2>\n<p>简单的说就是 <em><strong>react</strong></em> 在浏览器内存中第一次生成的虚拟 dom 树。<strong>切记是虚拟 dom ，而不是浏览器的dom</strong>。</p>\n<p>了解 <strong><em>react</em></strong> 的应该知道，所有 <em><strong>react</strong></em> 组件都有一个 <em>render()</em>\n    方法（如果使用function方式编写的组件会把function里的所有代码都塞到 <em>render()</em> 方法中去）。当<em>ReactDOM.render( element, container,\n        [callback] )</em>方法执行时，会执行以下步骤：</p>\n<ol>\n    <li>所有组件的会先进行初始化（es6执行构造函数）。</li>\n    <li>所有组件的&nbsp;<em>render</em>&nbsp;<em>()</em> 方法会被调用一次，完成这个过程后会得到一颗虚拟的 dom 树。</li>\n    <li>&nbsp;<em><strong>react</strong></em> 会将虚拟dom转换成浏览器dom，完成后调用组件的&nbsp;<em>componentDidMount()</em>&nbsp;方法告诉你已经装载到浏览器上了。\n    </li>\n</ol>\n<p>在上面这个过程成中，步骤2完成后即为完成 <em><strong>react</strong></em> 的首屏渲染。结合 <strong><em>checksum</em></strong>&nbsp;机制步骤3有可能不会执行。\n</p>\n<p>当组件状态发生变更时（ <em>setState() </em>生命周期函数被调用）或者 父组件渲染时（父组件的 <em>render()</em> 方法被调用），当前组件的 <em>render()</em>\n    方法都会被执行，都有可能会导致虚拟dom变更，但是这些变更和首屏渲染没任何关系了。</p>\n\n<h2 id="h2-3">React前后端同构首屏渲染</h2>\n<p>了解了同构和首屏渲染，就好理解如何解决首屏不重复渲染的问题了。</p>\n<p>首先服务端渲染完之后会有一个 <em><strong>checksum</strong></em> 值写在根元素的属性上：</p>\n<p><img alt="React 前后端同构防止重复渲染" height="70"\n        src="https://file.mahoooo.com/res/file/react_server_render_with_checksum_1.png" width="601"></p>\n<p>这个 <em><strong>checksum</strong></em>&nbsp;是根据服务端生成的HTML内容哈希计算得到的。</p>\n<p>然后在浏览器加载完所有的js文件之后，开始执行前面介绍的&nbsp;<em>ReactDOM.render( element, container, [callback] )</em> &nbsp;初始化渲染的三个步骤。当执行完第二步生成虚拟dom后，<strong><em>react</em></strong>\n    会根虚拟dom用相同的算法计算一个哈希值，如果和 <em><strong>checksum</strong></em> 一致则认为服务器已经完成渲染，不会再执行第三步。</p>\n<p>如果 <strong><em>checksum</em></strong> 比对不一致，在 <strong>开发环境</strong>&nbsp;和 <strong>测试环境</strong>\n    会在浏览器console中输出以下警告内容：</p>\n<p><img alt="React 前后端同构防止重复渲染" height="85"\n        src="https://file.mahoooo.com/res/file/react_server_render_with_checksum_2.png" width="790"></p>\n<p><strong>生产环境不会输出任何警告。</strong></p>\n<p>同构渲染的内容就这么多，原理其实蛮简单的，无非就是保证DOM一致。但是结合代码分片、异步加载、服务端调接口异步组装数据等等功能后，如何保证服务端和浏览器端第一次渲染的dom一致还得花不少功夫。不过原理清楚了，事情总能办成。</p>'},327:function(s,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<p>本文将解释如何在Windows下安装TensorFlow。</p>\n\n<h2 id="h2-1">确定安装哪类TensorFlow</h2>\n<p>需要先确定哪种类型的TensorFlow：</p>\n<ul>\n    <li><strong>仅支持CUP运算版本：</strong>如果电脑的系统没有&nbsp;NVIDIA®的GPU，那么必须安装这个版本。这个版本的TensorFlow安装非常简单（安装仅需一个命令，5到10分钟），所以即使系统中有满足要求的NVIDIA®\n        GPU官方还是建议在学习阶段安装这个版本。\n    </li>\n    <li><strong>支持GPU运算的版本：</strong>TensorFlow程序在GPU下运行比在CPU下运行明显快很多。如果系统中包含&nbsp;NVIDIA®的GPU满足下一个小节所示的条件并且程序对性能要求很高，建议安装此版本。\n    </li>\n</ul>\n\n<h2 id="h2-2">运行TensorFlow所需要的GPU配置</h2>\n<p>如果在系统中安装使用GPU运行的TensorFlow，需要确保下面介绍的NVIDIA软件已经安装到系统中。</p>\n<ul>\n    <li>CUDA® Toolkit 8.0。请看 <a\n            href="http://docs.nvidia.com/cuda/cuda-installation-guide-microsoft-windows/#axzz4eDEVDKkM" rel="nofollow">NVIDIA安装cuda</a>\n        的文档，根据文档中的描述确保已经将CUDA相关的路径增加到&nbsp;<code>%PATH%</code>&nbsp;环境变量中。\n    </li>\n    <li>NVIDIA的驱动关联&nbsp;CUDA Toolkit 8.0。</li>\n    <li>cuDNN v5.1。请查看 <a href="https://developer.nvidia.com/cudnn" rel="nofollow">NVIDIA&nbsp;cudnn</a>\n        文档。需要注意的是cuDNN通常安装在与其他CUDA动态链接库（dll）不同的位置。确保已经将cuDNN的 动态链接库（dll）的地址添加到系统的&nbsp;&nbsp;<code>%PATH%</code>&nbsp;环境变量中。\n    </li>\n    <li>GPU显卡必须拥有3.0以上版本的CUDA计算能力，查看 <a href="https://developer.nvidia.com/cuda-gpus" rel="nofollow">NVIDIA显卡支持列表</a>\n        了解支持情况。\n    </li>\n</ul>\n<p>如果系统中已经安装了以前的相关包，请更新到所指定的版本。</p>\n\n<h2 id="h2-3">如何安装TensorFlow</h2>\n<p>在安装TensorFlow之前必须选定一个安装机制。目前提供2种机制：</p>\n<ul>\n    <li>"native"app</li>\n    <li>Anaconda</li>\n</ul>\n<p>\n    Native的安装（以下简称本地安装）方式会将TensorFlow直接安装在当前的系统中，不会在系统和TensorFlow之间搭建任何的虚拟环境，所以本地安装不会额外安装一个独立的容器。需要注意的是本地安装可能会干扰系统中其他基于python安装的程序。如果事先已经安装配置了满足需要的python环境，本地安装通常只需要一个命令就可以完成。使用本地安装，用户可以在系统中任何位置运行TensorFlow。</p>\n<p>在Anaconda模式下，需要使用conda创建一个虚拟环境。官方优先推荐使用&nbsp;<code>pip install</code>&nbsp;命令来安装TensorFlow，其次再考虑anaconda的&nbsp;<code>conda\n    install</code>&nbsp;命令。conda包是第三方社区提供的（非TensorFlow官方），TensorFlow团队从始至终都不会去测试在conda中运行的情况，在使用时需考虑这个风险。</p>\n\n<h3 id="h3-1">本地安装</h3>\n<p>首先，需要安装以下版本的python：</p>\n<ul>\n    <li><a href="https://www.python.org/downloads/release/python-352/" rel="nofollow">Python 3.5.x from python.org</a>\n    </li>\n</ul>\n<p>TensorFlow在windows操作系统中仅仅支持3.5.x版本的python。Python 3.5.x附带pip3软件包管理器，这是用于安装TensorFlow的程序。</p>\n<p>安装TensorFlow需要启动一个终端（terminal），然后在该终端中输入对应的pip3 install命令。安装仅支持CPU版本的TensorFlow，输入以下命令：</p>\n<pre class="lua"><code class="language-bash">C:\\&gt; pip3 install <span class="code-comment">--upgrade tensorflow</span></code></pre>\n<p>安装GPU版本的TensorFlow，使用以下命令：</p>\n<pre class="lua"><code class="language-bash">C:\\&gt; pip3 install <span\n        class="code-comment">--upgrade tensorflow-gpu</span></code></pre>\n<p>Anaconda模式安装</p>\n<p><span style="color:#FF0000">再次强调，Anaconda安装是有第三方社区提供的，非官方。</span></p>\n<p>在Anaconda环境中安装TensorFlow分为以下几个步骤：</p>\n<ol>\n    <li>按照&nbsp;<a href="https://www.continuum.io/downloads" rel="nofollow">Anaconda download site</a>&nbsp;的说明进行下载和安装操作。\n    </li>\n    <li>调用以下命令来创建一个名为tensorflow的conda环境：\n        <pre class="groovy"><code class="language-bash"><span class="code-string">C:</span>&gt; conda create -n tensorflow </code></pre>\n        <p></p></li>\n    <li><p>键入以下命令来启用conda环境：</p>\n        <pre class="yaml"><code class="language-bash"><span class="hljs-attr">C:</span>&gt; activate tensorflow\n (tensorflow)C:&gt;  <span class="code-comment"><span\n                    class="code-comment"># Your prompt should change </span></span></code></pre>\n        <p></p></li>\n    <li><p>键入以下命令在conda环境中安装TensorFlow。这里 安装CPU版本的命令：</p>\n        <pre class="groovy"><code class="language-bash">(tensorflow)<span class="code-string">C:</span>&gt; pip install --ignore-installed --upgrade <span\n                class="code-string">https:</span><span class="code-comment">//storage.googleapis.com/tensorflow/windows/cpu/tensorflow-1.0.1-cp35-cp35m-win_amd64.whl </span>\n</code></pre>\n        <p>这是GPU版本的命令：</p>\n        <pre class="groovy"><code class="language-bash">(tensorflow)<span class="code-string">C:</span>&gt; pip install --ignore-installed --upgrade <span\n                class="code-string">https:</span><span class="code-comment">//storage.googleapis.com/tensorflow/windows/gpu/tensorflow_gpu-1.0.1-cp35-cp35m-win_amd64.whl </span></code></pre>\n        <p></p></li>\n</ol>\n\n<h3 id="h3-2">验证安装&nbsp;</h3>\n<ol>\n    <li>通过以下步骤来验证TensorFlow是否安装成功：</li>\n    <li>启动一个终端（比如CMD）</li>\n    <li>如果通过Anaconda安装，先启动Anaconda环境。</li>\n    <li>在终端运行python</li>\n    <li>\n        <pre class="groovy"><code class="language-bash"><span class="code-string">C:</span>&gt; python </code></pre>\n    </li>\n    <li>在python的交互环境中输入以下脚本代码：</li>\n    <li> <pre class="python"><code class="python"><span class="code-meta"><span\n            class="code-meta">&gt;&gt;&gt; </span></span><span class="code-keyword"><span\n            class="code-keyword">import</span></span> tensorflow <span class="code-keyword"><span class="code-keyword">as</span></span> tf\n\n\n\n\nhello = tf.constant(<span class="code-string"><span class="code-string">\'Hello, TensorFlow!\'</span></span>)\nsess = tf.Session()\nprint(sess.run(hello))\n </code></pre>\n        <p>如果python输出以下内容，则表明TensorFlow已经安装成功然后就可以写TensorFlow的程序了：</p></li>\n    <li>\n        <pre class=""><code class="language-bash">Hello, TensorFlow!</code></pre>\n        <p>如果收到了一些异常信息，请继续向下看。</p></li>\n</ol>\n\n<h3 id="h3-3">常见的安装问题</h3>\n<p>TensorFlow通过Stack Overflow网站来记录错误信息以及处理方法。下面的列表包含一些跳转的到&nbsp;Stack Overflow的连接。如果在安装过程中遇到的问题没有在下面中，请到Stack\n    Overflow去搜索相关的关键字。若还是搜索不到，请直接提出新问题并标记&nbsp;<code>tensorflow</code>&nbsp;的标签。</p>\n<table>\n    <tbody>\n    <tr>\n        <th>Stack Overflow Link</th>\n        <th>Error Message</th>\n    </tr>\n    <tr>\n        <td><a href="https://stackoverflow.com/q/41007279" rel="nofollow">41007279</a></td>\n        <td>\n            [...\\stream_executor\\dso_loader.cc] Couldn\'t open CUDA library nvcuda.dll\n        </td>\n    </tr>\n    <tr>\n        <td><a href="https://stackoverflow.com/q/41007279" rel="nofollow">41007279</a></td>\n        <td>\n            [...\\stream_executor\\cuda\\cuda_dnn.cc] Unable to load cuDNN DSO\n        </td>\n    </tr>\n    <tr>\n        <td><a href="http://stackoverflow.com/q/42006320" rel="nofollow">42006320</a></td>\n        <td>\n            ImportError: Traceback (most recent call last): File "...\\tensorflow\\core\\framework\\graph_pb2.py", line 6,\n            in from google.protobuf import descriptor as _descriptor ImportError: cannot import name \'descriptor\'\n        </td>\n    </tr>\n    <tr>\n        <td><a href="https://stackoverflow.com/q/42011070" rel="nofollow">42011070</a></td>\n        <td>\n            No module named "pywrap_tensorflow"\n        </td>\n    </tr>\n    </tbody>\n</table>'},330:function(s,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<p>Vert.x可以使用Zookeeper和Ignite等框架来创建集群，但是首选框架还是Hazelcast。此外，码友们也可以通过<em>ClusterManager</em>接口实现或引入需要的集群管理工具。本文将说明Vert.x是如何利用Hazelcast来创建和管理集群的，同时你也会了解到Vertx如何创建单机实例。</p>\n<h2 id="h2-1"><strong>集群创建</strong></h2>\n<p>在创建Vert.x集调用群时，调用方法和创建单机实例是有差异的。集群需要调<em>Vertx.clusteredVertx</em>异步方法创建。集群可以完全新建和引入已有的Hazelcast实例二种方式来创建。如下：</p>\n<p>1.新建实例</p>\n<blockquote>\n    <p>ClusterManager mgr = new HazelcastClusterManager();</p>\n</blockquote>\n<p>2.引入Hazelcast实例</p>\n<blockquote>\n    <p>ClusterManager mgr = new HazelcastClusterManager(hazelcastInstance);</p>\n</blockquote>\n<p>详情可以参考官方手册<a title="Hazelcast" href="http://vertx.io/docs/vertx-hazelcast/java/" rel="nofollow">http://vertx.io/docs/vertx-hazelcast/java/</a>。</p>\n\n<h2 id="h2-2">新建集群过程</h2>\n<p>调用<em>Vertx.clusteredVertx</em>静态方法后，Vert.x会利用Vertx工厂方法创建Vertx实例。如下</p>\n<p>其中简单直白的使用 <em>new&nbsp;VertxImpl();</em>来创建Vertx实例。</p>\n<pre class="gradle"><code class="gradle">VertxFactoryImpl.clusteredVertx(VertxOptions <span class="code-keyword"><span class="code-keyword">options</span></span>, <span class="code-keyword"><span class="code-keyword">final</span></span> Handler&lt;AsyncResult&lt;Vertx&gt;&gt; resultHandler) {\n    <span class="code-keyword"><span class="code-keyword">options</span></span>.setClustered(<span class="code-keyword"><span class="code-keyword">true</span></span>);<span class="code-comment"><span class="code-comment">//设置参数，启用集群</span></span>\n    <span class="code-keyword"><span class="code-keyword">new</span></span> VertxImpl(<span class="code-keyword"><span class="code-keyword">options</span></span>, resultHandler);<span class="code-comment"><span class="code-comment">//创建Vertx实例</span></span>\n}</code></pre>\n<p style="text-align:center">图1启动集群</p>\n<p>在<em>VertxImpl</em>的构造方法中，若需要创建集群，则执行：</p>\n<pre class="gradle"><code class="gradle">VertxImpl(VertxOptions <span class="code-keyword"><span class="code-keyword">options</span></span>, Handler&lt;AsyncResult&lt;Vertx&gt;&gt; resultHandler) {\n    <span class="code-comment"><span class="code-comment">// some code</span></span>\n    <span class="code-keyword"><span class="code-keyword">if</span></span> (<span class="code-keyword"><span class="code-keyword">options</span></span>.isClustered()) {\n      <span class="code-keyword"><span class="code-keyword">this</span></span>.clusterManager = getClusterManager(<span class="code-keyword"><span class="code-keyword">options</span></span>);<span class="code-comment"><span class="code-comment">//1.获取集群管理对象</span></span>\n      <span class="code-keyword"><span class="code-keyword">this</span></span>.clusterManager.setVertx(<span class="code-keyword"><span class="code-keyword">this</span></span>);<span class="code-comment"><span class="code-comment">//2. 设置实例</span></span>\n      <span class="code-keyword"><span class="code-keyword">this</span></span>.clusterManager.<span class="code-keyword"><span class="code-keyword">join</span></span>(ar -&gt; {<span class="code-comment"><span class="code-comment">//3. 加入集群</span></span>\n        <span class="code-keyword"><span class="code-keyword">if</span></span> (ar.failed()) {\n          log.error(<span class="code-string"><span class="code-string">"Failed to join cluster"</span></span>, ar.cause());\n        } <span class="code-keyword"><span class="code-keyword">else</span></span> {\n          <span class="code-comment"><span class="code-comment">// Provide a memory barrier as we are setting from a different thread</span></span>\n          <span class="code-keyword"><span class="code-keyword">synchronized</span></span> (VertxImpl.<span class="code-keyword"><span class="code-keyword">this</span></span>) {\n            haManager = <span class="code-keyword"><span class="code-keyword">new</span></span> HAManager(<span class="code-keyword"><span class="code-keyword">this</span></span>, deploymentManager, clusterManager, <span class="code-keyword"><span class="code-keyword">options</span></span>.getQuorumSize(),\n                                      <span class="code-keyword"><span class="code-keyword">options</span></span>.getHAGroup(), haEnabled);\n            createAndStartEventBus(<span class="code-keyword"><span class="code-keyword">options</span></span>, resultHandler);\n          }\n        }\n      });\n    } <span class="code-keyword"><span class="code-keyword">else</span></span> {\n      <span class="code-keyword"><span class="code-keyword">this</span></span>.clusterManager = <span class="code-keyword"><span class="code-keyword">null</span></span>;\n      createAndStartEventBus(<span class="code-keyword"><span class="code-keyword">options</span></span>, resultHandler);\n    }\n    <span class="code-comment"><span class="code-comment">// some code</span></span>\n  }</code></pre>\n<p style="text-align:center">图2</p>\n<p>这里会分3部来创建集群，首先调用<em>getClusterManager</em>来获取集群的配置管理实例。如下：</p>\n<pre class="gradle"><code class="language-java">getClusterManager(VertxOptions <span class="code-keyword">options</span>) {\n    <span class="code-keyword"><span class="code-keyword">if</span></span> (<span class="code-keyword">options</span>.isClustered()) {\n      <span class="code-keyword"><span class="code-keyword">if</span></span> (<span class="code-keyword">options</span>.getClusterManager() != <span class="code-keyword"><span class="code-keyword">null</span></span>) {<span class="code-comment"><span class="code-comment">//判断是否已经创建集群管理对方</span></span>\n        <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="code-keyword">options</span>.getClusterManager();<span class="code-comment"><span class="code-comment">//若已创建，直接使用这个对象。</span></span>\n      } <span class="code-keyword"><span class="code-keyword">else</span></span> {<span class="code-comment"><span class="code-comment">//若无创建，执行新建过程。</span></span>\n        ClusterManager mgr;\n        String clusterManagerClassName = System.getProperty(<span class="code-string"><span class="code-string">"vertx.cluster.managerClass"</span></span>);<span class="code-comment"><span class="code-comment">/*通过系统参数设置集群管理对象*/</span></span>\n        <span class="code-keyword"><span class="code-keyword">if</span></span> (clusterManagerClassName != <span class="code-keyword"><span class="code-keyword">null</span></span>) {<span class="code-comment"><span class="code-comment">//clusterManagerClassName变量指定的类名存在，开始加载</span></span>\n          <span class="code-comment"><span class="code-comment">// We allow specify a sys prop for the cluster manager factory which overrides ServiceLoader</span></span>\n          <span class="code-keyword"><span class="code-keyword">try</span></span> {\n            <span class="code-keyword">Class</span>&lt;?&gt; clazz = <span class="code-keyword">Class</span>.forName(clusterManagerClassName);\n            mgr = (ClusterManager)clazz.newInstance();\n          } <span class="code-keyword"><span class="code-keyword">catch</span></span> (Exception e) {\n            <span class="code-keyword"><span class="code-keyword">throw</span></span> <span class="code-keyword"><span class="code-keyword">new</span></span> IllegalStateException(<span class="code-string"><span class="code-string">"Failed to instantiate "</span></span> + clusterManagerClassName, e);\n          }\n        } <span class="code-keyword"><span class="code-keyword">else</span></span> {<span class="code-comment"><span class="code-comment">//clusterManagerClassName指定的变量null,使用默认加载器。</span></span>\n          ServiceLoader&lt;ClusterManager&gt; mgrs = ServiceLoader.load(ClusterManager.<span class="code-keyword">class</span>);\n          <span class="code-keyword"><span class="code-keyword">if</span></span> (!mgrs.iterator().hasNext()) {\n            <span class="code-keyword"><span class="code-keyword">throw</span></span> <span class="code-keyword"><span class="code-keyword">new</span></span> IllegalStateException(<span class="code-string"><span class="code-string">"No ClusterManagerFactory instances found on classpath"</span></span>);\n          }\n          mgr = mgrs.iterator().<span class="code-keyword">next</span>();\n        }\n        <span class="code-keyword"><span class="code-keyword">return</span></span> mgr;\n      }\n    } <span class="code-keyword"><span class="code-keyword">else</span></span> {\n      <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="code-keyword"><span class="code-keyword">null</span></span>;\n    }\n  }</code></pre>\n<p style="text-align:center">图3，获取集群管理类<br> 从源码看，<em><code>getClusterManager</code></em>并没有什么特殊的地方。首先检查用户在创建Vertx实例之前，是否创建了集群的管理对象<code><em>ClusterManager</em>。创建了，则使用这个管理对象，没有创建则自行新建一个。</code></p>\n<p>注意</p>\n<blockquote>\n    <p>String clusterManagerClassName = System.getProperty("vertx.cluster.managerClass");</p>\n</blockquote>\n<p>这行代码 ，这说明可以通过JVM环境参数（<em>-Dvertx.cluster.managerClass=[className]</em>）来指定Vertx加载集群管理对象类。这在官方手册中并没有任何一个地方说明。</p>\n<p>如果指定了managerClass，则会使用默认加载方式加载指定的类，并转换成<em>ClusterManager</em>接口。</p>\n<p>如果没有指定managerClass，则使用默认集群加载类启动集群。</p>\n<blockquote>\n    <p>ServiceLoader&lt;ClusterManager&gt; mgrs = ServiceLoader.load(ClusterManager.class);&nbsp;</p>\n</blockquote>\n<p>ServiceLoader是Java在1.6定义的聚群接口类，有点类似于spring的Ioc容器。其过程也是加载类。详细说明请查阅&nbsp;<a href="http://my.oschina.net/hanzhankang/blog/109794" rel="nofollow">通过ServiceLoader实现链式处理</a>&nbsp;一文，解释得很清楚。</p>\n<p>可以看到在<em>vertx-hazelcast-[vertsion].jar</em>包中，<em>META-INF/services/io.vertx.core.spi.cluster.ClusterManager</em>指定了<em>ClusterManager</em>要<em>ServiceLoader</em>加载<em>HazelcastClusterManager。</em></p>\n<blockquote>\n    <p>io.vertx.spi.cluster.hazelcast.HazelcastClusterManager</p>\n</blockquote>\n<p>回到图2，Vert.x接下来使用</p>\n<blockquote>\n    <p>clusterManager.setVertx(this)</p>\n</blockquote>\n<p>将vertx实例设置到集群管理类中。 随后调用</p>\n<blockquote>\n    <p>clusterManager.join</p>\n</blockquote>\n<p>来加入集群。 下面是<em>clusterManager.join</em>的源码</p>\n<pre class="less"><code class="less"><span class="code-selector-tag"><span class="code-selector-tag">synchronized</span></span> <span class="code-selector-tag"><span class="code-selector-tag">void</span></span> <span class="code-selector-tag"><span class="code-selector-tag">join</span></span>(Handler&lt;AsyncResult&lt;Void&gt;&gt; resultHandler) {\n    <span class="code-selector-tag"><span class="code-selector-tag">vertx</span></span><span class="code-selector-class"><span class="code-selector-class">.executeBlocking</span></span>(fut -&gt; {\n      <span class="code-selector-tag"><span class="code-selector-tag">if</span></span> (!active) {<span class="code-comment"><span class="code-comment">//确保只初始化一次</span></span>\n        active = true;\n        <span class="code-selector-tag"><span class="code-selector-tag">if</span></span> (customHazelcastCluster) {<span class="code-comment"><span class="code-comment">//当使用的是用户自己创建的Hazelcast实例时</span></span>\n          nodeID = hazelcast<span class="code-selector-class"><span class="code-selector-class">.getLocalEndpoint</span></span>()<span class="code-selector-class"><span class="code-selector-class">.getUuid</span></span>();<span class="code-comment"><span class="code-comment">//获取节点编号</span></span>\n          membershipListenerId = hazelcast<span class="code-selector-class"><span class="code-selector-class">.getCluster</span></span>()<span class="code-selector-class"><span class="code-selector-class">.addMembershipListener</span></span>(this);<span class="code-comment"><span class="code-comment">//获取当前节点监听成员变换的事件的ID</span></span>\n          fut<span class="code-selector-class"><span class="code-selector-class">.complete</span></span>();\n          return;\n        }\n        if (conf == null) {<span class="code-comment"><span class="code-comment">//获取Hazelcast的Config</span></span>\n          conf = loadConfigFromClasspath();\n          <span class="code-selector-tag"><span class="code-selector-tag">if</span></span> (conf == null) {\n            log<span class="code-selector-class"><span class="code-selector-class">.warn</span></span>(<span class="code-string"><span class="code-string">"Cannot find cluster configuration on classpath and none specified programmatically. Using default hazelcast configuration"</span></span>);\n          }\n        }\n        <span class="code-comment"><span class="code-comment">//新建hazelcast实例</span></span>\n        hazelcast = Hazelcast.newHazelcastInstance(conf);\n        nodeID = hazelcast.getLocalEndpoint().getUuid();\n        membershipListenerId = hazelcast.getCluster().addMembershipListener(this);\n        fut.complete();\n      }\n    }, resultHandler);\n  }</code></pre>\n<p style="text-align:center">图4，新建hazelcast实例</p>\n<p>如果用户自己创建并传入Hazelcast实例，<em>ClusterManager</em>只是简单的从中获取需要的参数。如果未创建实例，则<em>ClusterManager</em>会自行创建。</p>\n<p>首先，loadConfigFromClasspath会用来加载本地的配置文件。</p>\n<pre class="cs"><code class="language-java"><span class="hljs-function"><span class="hljs-function">Config </span><span class="code-title"><span class="hljs-function"><span class="code-title">loadConfigFromClasspath</span></span></span><span class="hljs-params"><span class="hljs-function">(<span class="hljs-params"></span>)</span></span><span class="hljs-function"> </span></span>{\n    Config cfg = <span class="code-keyword"><span class="hljs-literal">null</span></span>;\n    <span class="code-keyword"><span class="code-keyword">try</span></span> (InputStream <span class="code-keyword">is</span> = getConfigStream();\n         InputStream bis = <span class="code-keyword"><span class="code-keyword">new</span></span> BufferedInputStream(<span class="code-keyword">is</span>)) {\n      <span class="code-keyword"><span class="code-keyword">if</span></span> (<span class="code-keyword">is</span> != <span class="code-keyword"><span class="hljs-literal">null</span></span>) {\n        cfg = <span class="code-keyword"><span class="code-keyword">new</span></span> XmlConfigBuilder(bis).build();<span class="code-comment"><span class="code-comment">//创建HazelcastConfig</span></span>\n      }\n    } <span class="code-keyword"><span class="code-keyword">catch</span></span> (IOException ex) {\n      log.error(<span class="code-string"><span class="code-string">"Failed to read config"</span></span>, ex);\n    }\n    <span class="code-keyword"><span class="code-keyword">return</span></span> cfg;\n  }</code></pre>\n<p style="text-align:center">图5，加载HazelcastConfig</p>\n<p>getConfigStream用来读取配置文件。</p>\n<pre class="kotlin"><code class="language-java"><span class="hljs-function">InputStream <span class="code-title">getConfigStream</span><span class="hljs-params">()</span> </span>{\n    ClassLoader ctxClsLoader = Thread.currentThread().getContextClassLoader();\n    InputStream <span class="code-keyword">is</span> = <span class="code-keyword"><span class="hljs-literal">null</span></span>;\n    <span class="code-keyword"><span class="code-keyword">if</span></span> (ctxClsLoader != <span class="code-keyword"><span class="hljs-literal">null</span></span>) {\n      <span class="code-keyword">is</span> = ctxClsLoader.getResourceAsStream(CONFIG_FILE);\n    }\n    <span class="code-keyword"><span class="code-keyword">if</span></span> (<span class="code-keyword">is</span> == <span class="code-keyword"><span class="hljs-literal">null</span></span>) {\n      <span class="code-keyword">is</span> = getClass().getClassLoader().getResourceAsStream(CONFIG_FILE);\n      <span class="code-keyword"><span class="code-keyword">if</span></span> (<span class="code-keyword">is</span> == <span class="code-keyword"><span class="hljs-literal">null</span></span>) {\n        <span class="code-keyword">is</span> = getClass().getClassLoader().getResourceAsStream(DEFAULT_CONFIG_FILE);\n      }\n    }\n    <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="code-keyword">is</span>;\n  }</code></pre>\n<p style="text-align:center">图6，读取配置文件</p>\n<p>如图5、图6的源码。<em>getConfigStream</em>会先加载classpath下的<em>cluster.xml（CONFIG_FILE）</em>文件。如果不存在，则加载jar包内的<em>default-cluster.xml（DEFAULT_CONFIG_FILE）</em>文件。读取完毕后，<em>loadConfigFromClasspath</em>使用Hazelcast的<em>XmlConfigBuilder</em>来构建<em>HazelcastConfig</em>。而后会用这个Config初始化Hazelcast。</p>\n<p>集群创建成功后， 会初始化一个<em>HAManager</em>实例，用于做verticle迁移。后面在详细说明HA模式。</p>\n<p>最后，在VertxImpl中，会调用<em>createAndStartEventBus</em>方法在集群环境运行的EventBus。</p>'}});