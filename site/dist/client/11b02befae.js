webpackJsonp([11],{381:function(s,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.content='<p>在<a href="https://www.chkui.com/article/spring/spring_core_ioc_extension_points" title="IoC功能扩展点">IoC功能扩展点</a>这篇文章中介绍了BeanFactoryPostProcessor及其使用方法，本篇介绍Spring官方提供的典型BeanFactoryPostProcessor。\n</p>\n\n<h2 id="h2-1">占位符参数替换——PropertyPlaceholderConfigurer</h2>\n<p>\n    如果你的工程有很多配置内容放置到Java的标准配置文件*.properties中，当把Properties的内容整合到Spring中时就会用到PropertyPlaceholderConfigurer。PropertyPlaceholderConfigurer3个功能：</p>\n<ol>\n    <li>将配置中${property-name}格式的占位符换为加载的*.properties文件中的内容。</li>\n    <li>将配置中${property-name}格式的占位符替换为环境变量systemProperties（System.getProperty(key)）中的内容。</li>\n    <li>如果文件和环境中有相同的key，按照规则对数据进行合并。</li>\n</ol>\n\n<h3 id="h3-1">基本使用方法</h3>\n<p>PropertyPlaceholderConfigurer继承了配置BeanFactoryPostProcessor接口，在IoC开始初始化Bean之前修改对应<a\n        href="https://www.chkui.com/article/spring/spring_core_ioc_extension_points" title="IoC功能扩展点">BeanDefinition</a>。在使用时我们直接向容器添加一个PropertyPlaceholderConfigurer即可：\n</p>\n<pre><code class="xml"><span class="code-comment">&lt;!-- 启用占位符替换需要引入PropertyPlaceholderConfigurer --&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n        class="code-string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span>\n    <span class="code-comment">&lt;!-- 指定*.properties文件的路径 --&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"locations"</span> <span class="hljs-attr">value</span>=<span class="code-string">"classpath:project/config.properties"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n\n<span class="code-comment">&lt;!-- 替换Bean中的内容 --&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"A"</span> <span class="hljs-attr">class</span>=<span\n        class="code-string">"x.y.z.User"</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"name"</span> <span class="hljs-attr">value</span>=<span class="code-string">"${user.name}"</span>/&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"address"</span> <span class="hljs-attr">value</span>=<span class="code-string">"${user.address}"</span>/&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"age"</span> <span class="hljs-attr">value</span>=<span class="code-string">"${user.age}"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span></code></pre>\n<p>对应的config.properties文件中的内容：</p>\n<pre><code class="json">user.name=\'Alice\'\nuser.address=\'China\'\nuser.age=<span class="hljs-number">20</span></code></pre>\n<p>除了直接引入一个Bean，可以通过全局上下文配置启动这一项功能：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">context:property-placeholder</span> <span\n        class="hljs-attr">location</span>=<span\n        class="code-string">"classpath:project/config.properties"</span>/&gt;</span></code></pre>\n\n<h3 id="h3-2">设置环境变量加载行为</h3>\n<p>\n    前面说了PropertyPlaceholderConfigurer除了会用*.properties文件中的参数去替换占位符的内容，还会使用环境变量（System.getProperty(key)）中的参数去替换。如果一个参数在配置文件中和系统环境变量中都存在，那么默认会使用*.properties中的参数来替换配置中的占位符。可以使用PropertyPlaceholderConfigurer::systemPropertiesMode来修改这个行为。他接受3个参数：</p>\n<ul>\n    <li>PropertyPlaceholderConfigurer.SYSTEM_PROPERTIES_MODE_NEVER(0)：从不加载环境变量中的参数。</li>\n    <li>PropertyPlaceholderConfigurer.SYSTEM_PROPERTIES_MODE_FALLBACK(1)：优先使用*.properties文件中的变量，如果不存在再使用环境变量中的。</li>\n    <li>PropertyPlaceholderConfigurer.SYSTEM_PROPERTIES_MODE_OVERRIDE(2)：优先使用环境变量中的参数。</li>\n</ul>\n<p>可以这样设置：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span\n        class="hljs-attr">class</span>=<span class="code-string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span>\n    <span class="code-comment">&lt;!-- 优先使用环境变量中的参数 --&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"systemPropertiesMode"</span> <span class="hljs-attr">value</span>=<span\n            class="code-string">"2"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span></code></pre>\n\n<h3 id="h3-3">动态设置参数&amp;动态替换类</h3>\n<p>除了通过环境变量和*.properties配置文件引入参数，还可以直接写在XML的配置上：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span\n        class="hljs-attr">class</span>=<span class="code-string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span>\n    <span class="code-comment">&lt;!-- 加载资源文件位置 --&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"locations"</span>&gt;</span>\n        <span class="code-tag">&lt;<span\n                class="code-name">value</span>&gt;</span>classpath:myProject/config.properties<span class="code-tag">&lt;/<span\n            class="code-name">value</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">property</span>&gt;</span>\n    <span class="code-comment">&lt;!-- 动态添加配置参数 --&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"properties"</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">value</span>&gt;</span>define.runtime.class=x.y.z.A<span\n            class="code-tag">&lt;/<span class="code-name">value</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">property</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n<span class="code-comment">&lt;!-- 动态加载一个类 --&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span class="code-string">"${define.runtime.class}"</span>/&gt;</span></code></pre>\n<p>上面XML配置还展示了一个动态装载类的方法。</p>\n\n<h2 id="h2-2">按命名规则注入——PropertyOverrideConfigurer</h2>\n<p>\n    PropertyOverrideConfigurer就是在PropertyPlaceholderConfigurer的基础上扩展了一些功能节约一些写配置文件的时间。他可以让你不必在XML文件写占位符而直接注入数据。看下面的例子：</p>\n<p>通过&lt;bean&gt;标签引入了PropertyOverrideConfigurer类，然后有一个独立的User单例，以及将Cpu、Ram、Graphics单例组合到Pc中。</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span>&gt;</span>\n    <span class="code-comment">&lt;!-- 引入PropertyOverrideConfigurer --&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"org.springframework.beans.factory.config.PropertyOverrideConfigurer"</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"locations"</span> <span class="hljs-attr">value</span>=<span class="code-string">"classpath:xml/configoverride/config.properties"</span>/&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n    <span class="code-comment">&lt;!-- 配置Bean之间的组合关系 --&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n            class="code-string">"user"</span> <span class="hljs-attr">class</span>=<span class="code-string">"chkui.springcore.example.xml.configoverride.User"</span> /&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n            class="code-string">"cpu"</span> <span class="hljs-attr">class</span>=<span class="code-string">"chkui.springcore.example.xml.configoverride.entity.Cpu"</span> /&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n            class="code-string">"ram"</span> <span class="hljs-attr">class</span>=<span class="code-string">"chkui.springcore.example.xml.configoverride.entity.Ram"</span> /&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n            class="code-string">"graphics"</span> <span class="hljs-attr">class</span>=<span class="code-string">"chkui.springcore.example.xml.configoverride.entity.Graphics"</span> /&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n            class="code-string">"pc"</span> <span class="hljs-attr">class</span>=<span class="code-string">"chkui.springcore.example.xml.configoverride.entity.Pc"</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"cpu"</span> <span class="hljs-attr">ref</span>=<span\n                class="code-string">"cpu"</span>/&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"ram"</span> <span class="hljs-attr">ref</span>=<span\n                class="code-string">"ram"</span>/&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"graphics"</span> <span class="hljs-attr">ref</span>=<span class="code-string">"graphics"</span>/&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>对应的*.properties配置是这样的：</p>\n<pre><code class="bash">user.name=Alice\nuser.address=china\nuser.age=20\n\npc.cpu.brand=AMD\npc.graphics.brand=Nvdia\npc.ram.brand=Kingston</code></pre>\n<p>Cpu类的结构：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.xml.configoverride.entity;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Cpu</span> </span>{\n\t<span class="code-keyword">private</span> String brand;\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">getBrand</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> brand;\n\t}\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setBrand</span><span class="hljs-params">(String brand)</span> </span>{\n\t\t<span class="code-keyword">this</span>.brand = brand;\n\t}\n}</code></pre>\n<p>这个时候PropertyOverrideConfigurer会根据容器中Bean的id或name来注入数据，比如*.properties配置中的"pc"就对应XML中的&lt;bean id="pc"&gt;，接着pc中有一个域（成员变量）名为cpu那么它对应*.properties配置文件中"pc.cpu."，所以pc.cpu.brand=AMD的配置会告诉PropertyOverrideConfigurer向pc单例中的cpu实例的"brand"域注入数据"AMD"。</p>\n<p>所以使用PropertyOverrideConfigurer运行之后，不需要在XML使用${property-name}这样的参数它会按照id或name的结构注入数据，此时user.getName() ==\n    "Alice"。如果类的关系是这个多层的结构一样可以根据Properties的结构注入数据，例如 pc.getPc().getBrand() == "AMD"。</p>\n<p>例子的可执行代码见<strong><a\n        href="https://gitee.com/chkui-com/spring-core-sample/tree/master/src/main/java/chkui/springcore/example/xml/configoverride"\n        rel="nofollow">本人码云库中configoverride包</a>。</strong></p>'},388:function(s,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.content='<p>在<a href="https://www.chkui.com/article/spring/spring_core_environment_management_of_profile" title="Profile管理环境">Profile管理环境</a>一文中介绍了环境的概念以及Spring\n    Profile特性控制Bean的添加。本文将进一步介绍Spring管理和控制操作系统变量、JVM变量和Java标准资源（properties文件）的相关功能。</p>\n<p>文章的代码仅仅用于说明问题，<a href="https://gitee.com/chkui-com/spring-core-sample" rel="nofollow">可执行代码请到我的gitee库clone</a>，本文的代码在<em>chkui.springcore.example.hybrid.propertsource</em>包中。\n</p>\n\n<h2 id="h2-1">PropertySource与优先级</h2>\n<p>在整个Jvm运行期间，我们可以随时随地获取到2个与环境相关的参数：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.propertsource;\n\n<span class="code-comment">//env是与操作系统相关的参数</span>\nMap&lt;String, String&gt; env = System.getenv();\n<span class="code-comment">//properties中是Jvm相关的参数</span>\nProperties p = System.getProperties();\nSystem.out.println(<span class="code-string">"env :"</span> + env);\nSystem.out.println(<span class="code-string">"properties :"</span> +  p);</code></pre>\n<p>如果没有人为的添加额外信息，<em>System::getEnv</em>获取的数据都与当前的操作系统相关（以下称为“操作系统参数”），而<em>System::getProperties</em>获取的内容都与Jvm相关（以下称为“JVM参数”）。\n</p>\n<p>Spring会将操作系统参数和Jvm参数都整合到自己的环境管理接口Environment中，例如下面的代码：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.propertsource;\n\n<span class="code-comment">//向系统级的properties设置一个参数</span>\nSystem.setProperty(<span class="code-string">"wow"</span>, <span class="code-string">"World of Warcraft"</span>);\nApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(PropertySourcesApp.class);\n<span class="code-comment">//通过spring的Environment获取参数</span>\nEnvironment springEnv = ctx.getEnvironment();\nSystem.out.println(springEnv.getProperty(<span class="code-string">"wow"</span>));\nSystem.out.println(springEnv.getProperty(<span class="code-string">"PATH"</span>));\n</code></pre>\n<p>除了我们自定义的"wow"，操作系统参数"PATH"也可以在Spring的<em>Environment</em>中获取。</p>\n<p>通常情况下，在<em>Environment</em>内部维护了2个<a\n        href="https://docs.spring.io/spring-framework/docs/5.0.8.RELEASE/javadoc-api/org/springframework/core/env/PropertySource.html"\n        rel="nofollow">PropertySources</a>的实例：一个是操作系统参数，另外一个是JVM参数。如果2者有同样的参数，那么我们在调用<em>Environment::getProperty</em>方法时，得到的是JVM参数（<em>System::getProperties</em>）,也就是说&nbsp;Jvm参数具有更高的优先级。\n</p>\n<p>除了通过外部设置，我们也可以直接使用Spring提供的接口来设置：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.propertsource;\n\n<span class="code-comment">//我们要对环境进行配置，需要使用ConfigurableApplicationContext接口</span>\nConfigurableApplicationContext configAbleCtx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(PropertySourcesApp.class);\n\n<span class="code-comment">//ConfigurableApplicationContext接口提供对应的可编辑Environment和PropertySources</span>\nMutablePropertySources ps = configAbleCtx.getEnvironment().getPropertySources();\nMap&lt;String, Object&gt; map = <span class="code-keyword">new</span> HashMap&lt;String, Object&gt;();\nmap.put(<span class="code-string">"wow"</span>, <span class="code-string">"Origin = World of Warcraft!But Edit it already!"</span>);\n<span class="code-comment">//添加到Spring的环境参数中</span>\nps.addFirst(<span class="code-keyword">new</span> MapPropertySource(<span class="code-string">"myPropertySource"</span>, map));\nSystem.out.println(springEnv.getProperty(<span class="code-string">"wow"</span>));</code></pre>\n<p>代码添加到<em>PropertySource</em>中，Environment会额外维护一个<a\n        href="https://docs.spring.io/spring-framework/docs/5.0.8.RELEASE/javadoc-api/org/springframework/core/env/PropertySource.html"\n        rel="nofollow">PropertySources</a>，而自己添加的<a\n        href="https://docs.spring.io/spring-framework/docs/5.0.8.RELEASE/javadoc-api/org/springframework/core/env/PropertySource.html"\n        rel="nofollow">PropertySources</a>优先级是最高的，所以最后Environment::getProperty获取到的值是最后设置的值。</p>\n<p>如果需要添加多个<a\n        href="https://docs.spring.io/spring-framework/docs/5.0.8.RELEASE/javadoc-api/org/springframework/core/env/PropertySource.html"\n        rel="nofollow">PropertySources</a>，可以通过<em>MutablePropertySources::addFirst</em>或<em>MutablePropertySources::addLast</em>方法来控制他们之间的优先级。\n</p>\n\n<h2 id="h2-2">引入资源文件</h2>\n<p><em>*.properties</em>是Java的标准资源文件，在Java的各种项目中常用来记录各种配置参数。Spring提供了注解和XML配置将<em>*.properties</em>文件中的数据整合到Spring的环境参数（Environment）中。\n</p>\n\n<h3 id="h3-1">@PropertySource</h3>\n<p>在<em>@Configuration</em>标记的类上使用<em>@PropertySource</em>注解可以引入0~n个<em>*.properties</em>配置文件。如下面的例子：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.propertsource;\n\n<span class="code-meta">@Configuration</span>\n<span class="code-meta">@PropertySource</span>(<span class="code-string">"classpath:/hybrid/propertysource/config.properties"</span>)\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">PropertySourcesApp</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(PropertySourcesApp.class); \n\t\tSystem.out.println(<span class="code-string">"Properties file params: "</span> + springEnv.getProperty(<span\n            class="code-string">"Gdi"</span>));\n\t}\n}</code></pre>\n<p>对应的<em>config.properties</em>文件：</p>\n<pre><code class="bash"><span class="code-comment">#hybrid.propertysource.config.properties</span>\n\nGdi=StarCraft</code></pre>\n<p>\n    同一个工程中支持使用多个@PropertySource注解来引入配置文件，也支持Ant风格（Ant-style，例如"classpath:a/b/**/config.properties"）以及Spring扩展的（比如"classpath*:"）的路径规则，资源路径控制会在后续的文章中介绍。</p>\n\n<h3 id="h3-2">XML配置</h3>\n<p>XML配置在之前介绍容器后置处理器——<a href="https://www.chkui.com/article/spring/spring_core_factory_post_processor_of_official"\n                         title="BeanFactoryPostProcessor">BeanFactoryPostProcessor</a>的文章中已经介绍了，他就是&nbsp;<em>PropertyPlaceholderConfigurer</em>&nbsp;，我们在XML配置文件中进行一下设置即可。\n</p>\n<p>引入Bean：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span\n        class="hljs-attr">class</span>=<span class="code-string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span>\n    <span class="code-comment">&lt;!-- 指定*.properties文件的路径 --&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"locations"</span> <span class="hljs-attr">value</span>=<span class="code-string">"classpath:/hybrid/propertysource/config.properties"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span></code></pre>\n<p>直接使用context进行全局设置：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">context:property-placeholder</span> <span\n        class="hljs-attr">location</span>=<span\n        class="code-string">"classpath:/hybrid/propertysource/config.properties"</span>/&gt;</span></code></pre>\n\n<h2 id="h2-3">占位符替换</h2>\n<p><em>PropertyPlaceholderConfigurer</em>继承了抽象类<em>PropertyPlaceholderConfigurer，</em>而<em>*.properties</em>文件的读写就是在<em>PropertyResourceConfigurer</em>类中实现的。<em>PropertyPlaceholderConfigurer</em>进一步实现了配置文件中占位符<em>（${...}）</em>替换功能<em>。</em>\n</p>\n<p>在Spring IoC容器执行Bean的扫描、加载之前添加一个环境变量（也可以动态添加然后再执行<em>ConfigurableApplicationContext::refresh</em>方法），就可以在很多资源路径的位置使用这个占位符，对上面的例子进行一些修改：\n</p>\n<pre><code class="java"><span class="code-meta">@Configuration</span>\n<span class="code-comment">//通过占位符来设置路径</span>\n<span class="code-meta">@PropertySource</span>(<span class="code-string">"classpath:${resource.propertiesPath}/config.properties"</span>)\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">PropertySourcesApp</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n        <span class="code-comment">//容器启动之前设置环境变量</span>\n\t\tSystem.setProperty(<span class="code-string">"resource.propertiesPath"</span>, <span class="code-string">"/hybrid/propertysource"</span>);\n\t\tApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(PropertySourcesApp.class);\n\t\t<span class="code-comment">//获取环境对象实例</span>\n\t\tEnvironment springEnv = ctx.getEnvironment();\n\t\tSystem.out.println(<span class="code-string">"Properties : "</span> + springEnv.getProperty(<span\n            class="code-string">"Gdi"</span>));\n\t}\n}</code></pre>\n<p>同样的，只要环境变量存在，也可以使用占位符替换配置文件中的数据，例如：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">context:property-placeholder</span> <span\n        class="hljs-attr">location</span>=<span class="code-string">"classpath:${resource.propertiesPath:/config}/config.properties"</span>/&gt;</span></code></pre>\n<p>XML中的占位符使用的格式是<em>${resource.propertiesPath:/config}</em>，它表示使用环境变量<em>resource.propertiesPath</em>进行替换，如果<em>resource.propertiesPath</em>不存在则使用值"/config"。\n</p>\n\n<h2 id="h2-4">@Value</h2>\n<p>我们可以在任何Bean中使用@Value注解来获取环境变量。如下面的例子：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.propertsource;\n\n<span class="code-meta">@Configuration</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">PropertySourcesApp</span> </span>{\n\t<span class="code-meta">@Value</span>(<span class="code-string">"${resource.propertiesPath}"</span>)\n\t<span class="code-keyword">private</span> String value;\n\t<span class="code-meta">@Value</span>(<span\n            class="code-string">"#{systemProperties[\'resource.propertiesPath\']}"</span>)\n\t<span class="code-keyword">private</span> String elValue;\n\t<span class="code-meta">@Value</span>(<span class="code-string">"Resource PropertiesPath"</span>)\n\t<span class="code-keyword">private</span> String staticValue;\n\t\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tSystem.setProperty(<span class="code-string">"resource.propertiesPath"</span>, <span class="code-string">"/hybrid/propertysource"</span>);\n\n\t\tApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(PropertySourcesApp.class);\n\t\t\n\t\tPropertySourcesApp app = ctx.getBean(PropertySourcesApp.class);\n\t\tSystem.out.println(<span class="code-string">"Value: "</span> + app.value);\n\t\tSystem.out.println(<span class="code-string">"EL Value: "</span> + app.elValue);\n\t\tSystem.out.println(<span class="code-string">"Static Value: "</span> + app.staticValue);\n\t}\n}</code></pre>\n<p>\n    @Value可以注入一个纯字面量，如上面示例代码中的staticValue，也可以使用占位符使用环境变量中的任何值。除了使用占位符${}，@Value还支持"#{systemProperties[\'resource.propertiesPath\']}"这样具备代码执行功能的复杂表达式来获取数据，这部分功能会在后续介绍EL表达式的文章中进行分享。</p>'},403:function(s,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.content='<p>在<a href="https://www.chkui.com/article/spring/spring_batch_introduction" title="Spring batch由上至下的结构">Spring\n    batch由上至下的结构</a>中<a href="https://www.chkui.com/article/spring/spring_batch_job">Job</a>、<a\n        href="https://www.chkui.com/article/spring/spring_batch_step">Step</a>都是属于框架级别的的功能，大部分时候都是提供一些配置选项给开发人员使用，而<a\n        href="https://www.chkui.com/article/spring/spring_batch_item_and_code_case"\n        title="Item">Item</a>中的<code>Reader</code>、<code>Processor</code>和<code>Writer</code>是属于业务级别的，它开放了一些业务切入的接口。\n    但是文件的读写过程中有很多通用一致的功能Spring Batch为这些相同的功能提供了一致性实现类。</p>\n<h2 id="h2-1">扁平结构文件</h2>\n<p><strong>扁平结构文件</strong>（也称为矩阵结构文件，后文简称为文件）是最常见的一种文件类型。他通常以一行表示一条记录，字段数据之间用某种方式分割。与标准的格式数据（xml、json等）主要差别在于他没有结构性描述方案（SXD、JSON-SCHEME），进而没有结构性分割规范。因此在读写此类文件之前需要先设定好字段的分割方法。\n</p>\n<p>文件的字段数据分割方式通常有两种：<strong>使用分隔符</strong>或<strong>固定字段长度</strong>。前者通常使用逗号（<code>，</code>）之类的符号对字段数据进行划分，后者的每一列字段数据长度是固定的。\n    框架为文件的读取提供了<code>FieldSet</code>用于将文件结构中的信息映射到一个对象。<code>FieldSet</code>的作用是将文件的数据与类的<code>field</code>进行绑定（field是Java中常见的概念，不清楚的可以了解Java反射）。\n</p>\n<h2 id="h2-2">数据读取</h2>\n<p>Spring Batch为文件读取提供了<code>FlatFileItemReader</code>类，它为文件中的数据的读取和转换提供了基本功能。在<code>FlatFileItemReader</code>中有2个主要的功能接口，一是<code>Resource</code>、二是<code>LineMapper</code>。\n    <code>Resource</code>用于外部文件获取，详情请查看<a href="https://www.chkui.com/article/spring/spring_core_resources_management"\n                                          title="Spring核心——资源管理">Spring核心——资源管理</a>部分的内容，下面是一个例子：</p>\n<pre><code class="Java">Resource resource = <span class="code-keyword">new</span> FileSystemResource(<span\n        class="code-string">"resources/trades.csv"</span>); \n</code></pre>\n<p>在复杂的生产环境中，文件通常由中心化、或者流程式的基础框架来管理（比如EAI）。因此文件往往需要使用FTP等方式从其他位置获取。如何迁移文件已经超出了Spring Batch框架的范围，在Spring的体系中可以参考<code>Spring\n    Integration</code>项目。</p>\n<p>下面是<code>FlatFileItemReader</code>的属性，每一个属性都提供了Setter方法。</p>\n<table>\n    <thead>\n    <tr>\n        <th>属性名</th>\n        <th>参数类型</th>\n        <th>说明</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n        <td>comments</td>\n        <td>String[]</td>\n        <td>指定文件中的注释前缀，用于过滤注释内容行</td>\n    </tr>\n    <tr>\n        <td>encoding</td>\n        <td>String</td>\n        <td>指定文件的编码方式，默认为<em>Charset.defaultCharset()</em></td>\n    </tr>\n    <tr>\n        <td>lineMapper</td>\n        <td>LineMapper</td>\n        <td>利用LineMapper接口将一行字符串转换为对象</td>\n    </tr>\n    <tr>\n        <td>linesToSkip</td>\n        <td>int</td>\n        <td>跳过文件开始位置的行数，用于跳过一些字段的描述行</td>\n    </tr>\n    <tr>\n        <td>recordSeparatorPolicy</td>\n        <td>RecordSeparatorPolicy</td>\n        <td>用于判断数据是否结束</td>\n    </tr>\n    <tr>\n        <td>resource</td>\n        <td>Resource</td>\n        <td>指定外部资源文件位置</td>\n    </tr>\n    <tr>\n        <td>skippedLinesCallback</td>\n        <td>LineCallbackHandler</td>\n        <td>当配置linesToSkip，每执行一次跳过都会被回调一次，会传入跳过的行数据内容</td>\n    </tr>\n    </tbody>\n</table>\n<p>每个属性都为文件的解析提供了某方面的功能，下面是结构的说明。</p>\n<h3 id="h3-1">LineMapper</h3>\n<p>这个接口的作用是将字符串转换为对象：</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">LineMapper</span> </span>{ <span class="hljs-function">T <span\n        class="code-title">mapLine</span><span class="hljs-params">(String line, <span class="code-keyword">int</span> lineNumber)</span> <span\n        class="code-keyword">throws</span> Exception</span>; }\n</code></pre>\n<p>接口的基本处理逻辑是聚合类（<code>FlatFileItemReader</code>）传递一行字符串以及行号给<code>LineMapper::mapLine</code>，方法处理后返回一个映射的对象。</p>\n<h3 id="h3-2">LineTokenizer</h3>\n<p>这个接口的作用是将一行数据转换为一个<code>FieldSet</code>结构。对于Spring Batch而言，扁平结构文件的到Java实体的映射都通过<code>FieldSet</code>来控制，因此读写文件的过程需要完成字符串到<code>FieldSet</code>的转换：\n</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">LineTokenizer</span> </span>{ <span class="hljs-function">FieldSet <span class="code-title">tokenize</span><span\n        class="hljs-params">(String line)</span></span>; }\n</code></pre>\n<p>这个接口的含义是：传递一行字符串数据，然后获取一个<code>FieldSet</code>。</p>\n<p>框架为<code>LineTokenizer</code>提供三个实现类：</p>\n<ul>\n    <li>\n        <p><code>DelimitedLineTokenizer</code>：利用分隔符将数据转换为<code>FieldSet</code>。最常见的分隔符是逗号<code>,</code>，类提供了分隔符的配置和解析方法。\n        </p>\n    </li>\n    <li>\n        <p><code>FixedLengthTokenizer</code>：根据字段的长度来解析出<code>FieldSet</code>结构。必须为记录定义字段宽度。</p>\n    </li>\n    <li>\n        <p><code>PatternMatchingCompositeLineTokenizer</code>：使用一个匹配机制来动态决定使用哪个<code>LineTokenizer</code>。</p>\n    </li>\n</ul>\n<h3 id="h3-3">FieldSetMapper</h3>\n<p>该接口是将<code>FieldSet</code>转换为对象：</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">FieldSetMapper</span> </span>{ <span class="hljs-function">T <span class="code-title">mapFieldSet</span><span\n        class="hljs-params">(FieldSet fieldSet)</span> <span class="code-keyword">throws</span> BindException</span>; }\n</code></pre>\n<p><code>FieldSetMapper</code>通常和<code>LineTokenizer</code>联合在一起使用：<em>String-&gt;FieldSet-&gt;Object</em>。</p>\n<h3 id="h3-4">DefaultLineMapper</h3>\n<p><code>DefaultLineMapper</code>是<code>LineMapper</code>的实现，他实现了从文件到Java实体的映射：</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">DefaultLineMapper</span> <span class="code-keyword">implements</span> <span\n        class="code-title">LineMapper</span>&lt;&gt;, <span class="code-title">InitializingBean</span> </span>{\n\t<span class="code-keyword">private</span> LineTokenizer tokenizer;\n\t<span class="code-keyword">private</span> FieldSetMapper fieldSetMapper;\n\t<span class="hljs-function"><span class="code-keyword">public</span> T <span class="code-title">mapLine</span><span\n            class="hljs-params">(String line, <span class="code-keyword">int</span> lineNumber)</span> <span\n            class="code-keyword">throws</span> Exception </span>{\n\t\t<span class="code-keyword">return</span> fieldSetMapper.mapFieldSet(tokenizer.tokenize(line));\n\t}\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setLineTokenizer</span><span class="hljs-params">(LineTokenizer tokenizer)</span> </span>{\n\t\t<span class="code-keyword">this</span>.tokenizer = tokenizer;\n\t}\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setFieldSetMapper</span><span class="hljs-params">(FieldSetMapper fieldSetMapper)</span> </span>{\n\t\t<span class="code-keyword">this</span>.fieldSetMapper = fieldSetMapper;\n\t}\n}\n</code></pre>\n<p>在解析文件时数据是按行解析的：</p>\n<ol>\n    <li>传入一行字符串。</li>\n    <li><code>LineTokenizer</code>将字符串解析为<code>FieldSet</code>结构。</li>\n    <li><code>FieldSetMapper</code>继续解析为一个Java实体对象返回给调用者。</li>\n</ol>\n<p><code>DefaultLineMapper</code>是框架提供的默认实现类，看似非常简单，但是利用组合模式可以扩展出很多功能。</p>\n<h3 id="h3-5">数据自动映射</h3>\n<p>在转换过程中如果将<code>FieldSet</code>的<code>names</code>属性与目标类的<code>field</code>绑定在一起，那么可以直接使用反射实现数据转换，为此框架提供了<code>BeanWrapperFieldSetMapper</code>来实现。\n</p>\n<pre><code class="Java">DefaultLineMapper&lt;WeatherEntity&gt; lineMapper = <span class="code-keyword">new</span> DefaultLineMapper&lt;&gt;(); <span\n        class="code-comment">//创建LineMapper</span>\n\nDelimitedLineTokenizer tokenizer = <span class="code-keyword">new</span> DelimitedLineTokenizer(); <span\n            class="code-comment">//创建LineTokenizer</span>\ntokenizer.setNames(<span class="code-keyword">new</span> String[] { <span class="code-string">"siteId"</span>, <span\n            class="code-string">"month"</span>, <span class="code-string">"type"</span>, <span class="code-string">"value"</span>, <span\n            class="code-string">"ext"</span> }); <span class="code-comment">//设置Field名称</span>\n\nBeanWrapperFieldSetMapper&lt;WeatherEntity&gt; wrapperMapper \n\t= <span class="code-keyword">new</span> BeanWrapperFieldSetMapper&lt;&gt;(); <span class="code-comment">//创建FieldSetMapper</span>\nwrapperMapper.setTargetType(WeatherEntity.class); <span\n            class="code-comment">//设置实体，实体的field名称必须和tokenizer.names一致。</span>\n\n<span class="code-comment">// 组合lineMapper</span>\nlineMapper.setLineTokenizer(tokenizer);\nlineMapper.setFieldSetMapper(wrapperMapper);\n</code></pre>\n<h3 id="h3-6">文件读取总结</h3>\n<p>上面提到了各种接口和实现，实际上都是围绕着<code>FlatFileItemReader</code>的属性在介绍，虽然内容很多但是实际上就以下几点：</p>\n<ul>\n    <li>\n        <p>首先要定位文件，Spring Batch提供了<code>Resource</code>相关的定位方法。</p>\n    </li>\n    <li>\n        <p>其次是将文件中的行字符串数据转换为对象，<code>LineMapper</code>的功能就是完成这个功能。</p>\n    </li>\n    <li>\n        <p>\n            框架为<code>LineMapper</code>提供了<code>DefaultLineMapper</code>作为默认实现方法，在<code>DefaultLineMapper</code>中需要组合使用<code>LineTokenizer</code>和<code>FieldSetMapper</code>。前者将字符串转为为一个<code>Field</code>，后者将<code>Field</code>转换为目标对象。\n        </p>\n    </li>\n    <li>\n        <p>\n            <code>LineTokenizer</code>有3个实现类可供使用、<code>FieldSetMapper</code>有一个默认实现类<code>BeanWrapperFieldSetMapper</code>。\n        </p>\n    </li>\n</ul>\n<h3 id="h3-7">文件读取可执行源码</h3>\n<p>可执行的源码在下列地址的<em>items</em>子工程中：</p>\n<ul>\n    <li>Gitee：<a\n            href="https://gitee.com/chkui-com/spring-batch-sample">https://gitee.com/chkui-com/spring-batch-sample</a>\n    </li>\n    <li>Github：<a href="https://github.com/chkui/spring-batch-sample">https://github.com/chkui/spring-batch-sample</a>\n    </li>\n</ul>\n<p>运行之前需要配置数据库链接，参看源码库中的README.md。</p>\n<p>文件读取的主要逻辑在<code>org.chenkui.spring.batch.sample.items.FlatFileReader</code>类：</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">FlatFileReader</span> </span>{\n    <span class="code-comment">// FeildSet的字段名，设置字段名之后可以直接使用名字作为索引获取数据。也可以使用索引位置来获取数据</span>\n    <span class="code-keyword">public</span> <span class="code-keyword">final</span> <span\n            class="code-keyword">static</span> String[] Tokenizer = <span\n            class="code-keyword">new</span> String[] { <span class="code-string">"siteId"</span>, <span\n            class="code-string">"month"</span>, <span class="code-string">"type"</span>, <span class="code-string">"value"</span>, <span\n            class="code-string">"ext"</span> };\n    <span class="code-keyword">private</span> <span class="code-keyword">boolean</span> userWrapper = <span\n            class="code-keyword">false</span>;\n\n    <span class="code-meta">@Bean</span>\n    <span class="code-comment">//定义FieldSetMapper用于FieldSet-&gt;WeatherEntity</span>\n    <span class="hljs-function"><span class="code-keyword">public</span> FieldSetMapper&lt;WeatherEntity&gt; <span\n            class="code-title">fieldSetMapper</span><span class="hljs-params">()</span> </span>{\n        <span class="code-keyword">return</span> <span class="code-keyword">new</span> FieldSetMapper&lt;WeatherEntity&gt;() {\n            <span class="code-meta">@Override</span>\n            <span class="hljs-function"><span class="code-keyword">public</span> WeatherEntity <span class="code-title">mapFieldSet</span><span\n                    class="hljs-params">(FieldSet fieldSet)</span> <span class="code-keyword">throws</span> BindException </span>{\n                <span class="code-keyword">if</span> (<span class="code-keyword">null</span> == fieldSet) {\n                    <span class="code-keyword">return</span> <span class="code-keyword">null</span>; <span\n            class="code-comment">// fieldSet不存在则跳过该行处理</span>\n                } <span class="code-keyword">else</span> {\n                    WeatherEntity observe = <span class="code-keyword">new</span> WeatherEntity();\n                    observe.setSiteId(fieldSet.readRawString(<span class="code-string">"siteId"</span>));\n                    <span class="code-comment">//Setter</span>\n                    <span class="code-keyword">return</span> observe;\n                }\n            }\n        };\n    }\n\n    <span class="code-meta">@Bean</span>\n    <span class="code-comment">// 配置 Reader</span>\n    <span class="hljs-function"><span class="code-keyword">public</span> ItemReader&lt;WeatherEntity&gt; <span\n            class="code-title">flatFileReader</span><span class="hljs-params">(\n                           @Qualifier(<span class="code-string">"fieldSetMapper"</span>)</span> FieldSetMapper&lt;WeatherEntity&gt; fieldSetMapper) </span>{\n        FlatFileItemReader&lt;WeatherEntity&gt; reader = <span class="code-keyword">new</span> FlatFileItemReader&lt;&gt;();\n        reader.setResource(<span class="code-keyword">new</span> FileSystemResource(<span class="code-string">"src/main/resources/data.csv"</span>)); <span\n            class="code-comment">// 读取资源文件</span>\n        DefaultLineMapper&lt;WeatherEntity&gt; lineMapper = <span class="code-keyword">new</span> DefaultLineMapper&lt;&gt;(); <span\n            class="code-comment">// 初始化 LineMapper实现类</span>\n        DelimitedLineTokenizer tokenizer = <span class="code-keyword">new</span> DelimitedLineTokenizer(); <span\n            class="code-comment">// 创建LineTokenizer接口实现</span>\n\n        tokenizer.setNames(Tokenizer); <span class="code-comment">// 设定每个字段的名称，如果不设置需要使用索引获取值</span>\n        lineMapper.setLineTokenizer(tokenizer); <span class="code-comment">// 设置tokenizer工具</span>\n\n        <span class="code-keyword">if</span> (userWrapper) { <span class="code-comment">//使用 BeanWrapperFieldSetMapper 使用反射直接转换</span>\n            BeanWrapperFieldSetMapper&lt;WeatherEntity&gt; wrapperMapper = <span class="code-keyword">new</span> BeanWrapperFieldSetMapper&lt;&gt;();\n            wrapperMapper.setTargetType(WeatherEntity.class);\n            fieldSetMapper = wrapperMapper;\n        }\n\n        lineMapper.setFieldSetMapper(fieldSetMapper);\n        reader.setLineMapper(lineMapper);\n        reader.setLinesToSkip(<span class="hljs-number">1</span>); <span class="code-comment">// 跳过的初始行，用于过滤字段行</span>\n        reader.open(<span class="code-keyword">new</span> ExecutionContext());\n        <span class="code-keyword">return</span> reader;\n    }\n}\n</code></pre>\n<h3 id="h3-8">按字段长度格读取文件</h3>\n<p>除了按照分隔符，有些文件可以字段数据的占位长度来提取数据。按照前面介绍的过程，实际上只要修改LineTokenizer接口即可，框架提供了<code>FixedLengthTokenizer</code>类：</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> FixedLengthTokenizer <span class="code-title">fixedLengthTokenizer</span><span\n        class="hljs-params">()</span> </span>{\n    FixedLengthTokenizer tokenizer = <span class="code-keyword">new</span> FixedLengthTokenizer();\n\n    tokenizer.setNames(<span class="code-string">"ISIN"</span>, <span class="code-string">"Quantity"</span>, <span\n            class="code-string">"Price"</span>, <span class="code-string">"Customer"</span>);\n    <span class="code-comment">//Range用于设定数据的长度。</span>\n    tokenizer.setColumns(<span class="code-keyword">new</span> Range(<span class="hljs-number">1</span>-<span\n            class="hljs-number">12</span>),\n                        <span class="code-keyword">new</span> Range(<span class="hljs-number">13</span>-<span\n            class="hljs-number">15</span>),\n                        <span class="code-keyword">new</span> Range(<span class="hljs-number">16</span>-<span\n            class="hljs-number">20</span>),\n                        <span class="code-keyword">new</span> Range(<span class="hljs-number">21</span>-<span\n            class="hljs-number">29</span>));\n\t<span class="code-keyword">return</span> tokenizer;\n}\n</code></pre>\n<h2 id="h2-3">写入扁平结构文件</h2>\n<p>将数据写入到文件与读取的过程正好相反：将对象转换为字符串。</p>\n<h3 id="h3-9">LineAggregator</h3>\n<p>与<code>LineMapper</code>相对应的是<code>LineAggregator</code>，他的功能是将实体转换为字符串：</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">LineAggregator</span>&lt;<span class="code-title">T</span>&gt; </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> String <span\n            class="code-title">aggregate</span><span class="hljs-params">(T item)</span></span>;\n}\n</code></pre>\n<h3 id="h3-10">PassThroughLineAggregator</h3>\n<p>\n    框架为<code>LineAggregator</code>接口提供了一个非常简单的实现类——<code>PassThroughLineAggregator</code>，其唯一实现就是使用对象的<code>toString</code>方法：\n</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">PassThroughLineAggregator</span>&lt;<span class="code-title">T</span>&gt; <span\n        class="code-keyword">implements</span> <span class="code-title">LineAggregator</span>&lt;<span\n        class="code-title">T</span>&gt; </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> String <span\n            class="code-title">aggregate</span><span class="hljs-params">(T item)</span> </span>{\n        <span class="code-keyword">return</span> item.toString();\n    }\n}\n</code></pre>\n<h3 id="h3-11">DelimitedLineAggregator</h3>\n<p><code>LineAggregator</code>的另外一个实现类是<code>DelimitedLineAggregator</code>。与<code>PassThroughLineAggregator</code>简单直接使用<code>toString</code>方法不同的是，<code>DelimitedLineAggregator</code>需要一个转换接口<code>FieldExtractor</code>：\n</p>\n<pre><code class="Java">DelimitedLineAggregator&lt;CustomerCredit&gt; lineAggregator = <span\n        class="code-keyword">new</span> DelimitedLineAggregator&lt;&gt;();\nlineAggregator.setDelimiter(<span class="code-string">","</span>);\nlineAggregator.setFieldExtractor(fieldExtractor);\n</code></pre>\n<h3 id="h3-12">FieldExtractor</h3>\n<p><code>FieldExtractor</code>用于实体类到<code>collection</code>结构的转换。它可以和<code>LineTokenizer</code>进行类比，前者是将实体类转换为扁平结构的数据，后者是将<code>String</code>转换为一个<code>FieldSet</code>结构。\n</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">FieldExtractor</span>&lt;<span class="code-title">T</span>&gt; </span>{\n    Object[] extract(T item);\n}\n</code></pre>\n<p>框架为<code>FieldExtractor</code>接口提供了一个基于反射的实现类<code>BeanWrapperFieldExtractor</code>，其过程就是将实体对象转换为列表：</p>\n<pre><code class="Java">BeanWrapperFieldExtractor&lt;CustomerCredit&gt; fieldExtractor = <span\n        class="code-keyword">new</span> BeanWrapperFieldExtractor&lt;&gt;();\nfieldExtractor.setNames(<span class="code-keyword">new</span> String[] {<span class="code-string">"field1"</span>, <span\n            class="code-string">"field2"</span>});\n</code></pre>\n<p><code>setName</code>方法用于指定要转换的<code>field</code>列表。</p>\n<h3 id="h3-13">输出文件处理</h3>\n<p>文件读取的逻辑非常简单：文件存在打开文件并写入数据，当文件不存在抛出异常。但是写入文件明显不能这么简单粗暴。新建一个<code>JobInstance</code>时最直观的操作是：存在同名文件就抛出异常，不存在则创建文件并写入数据。但是这样做显然有很大的问题，当批处理过程中出现问题需要<code>restart</code>，此时并不会从头开始处理所有的数据，而是要求文件存在并接着继续写入。为了确保这个过程<code>FlatFileItemWriter</code>默认会在新<code>JobInstance</code>运行时删除已有文件，而运行重启时继续在文件末尾写入。<code>FlatFileItemWriter</code>可以使用<code>shouldDeleteIfExists</code>、<code>appendAllowed</code>、<code>shouldDeleteIfEmpty</code>来有针对性的控制文件。\n</p>\n<h3 id="h3-14">文件写入可执源码</h3>\n<p>文件写入主要代码在<code>org.chenkui.spring.batch.sample.items.FlatFileWriter</code>：</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">FlatFileWriter</span> </span>{\n\n    <span class="code-keyword">private</span> <span class="code-keyword">boolean</span> useBuilder = <span\n            class="code-keyword">true</span>;\n\n    <span class="code-meta">@Bean</span>\n    <span class="hljs-function"><span class="code-keyword">public</span> ItemWriter&lt;MaxTemperatureEntiry&gt; <span\n            class="code-title">flatFileWriter</span><span class="hljs-params">()</span> </span>{\n        BeanWrapperFieldExtractor&lt;MaxTemperatureEntiry&gt; fieldExtractor = <span class="code-keyword">new</span> BeanWrapperFieldExtractor&lt;&gt;();\n        fieldExtractor.setNames(<span class="code-keyword">new</span> String[] { <span\n            class="code-string">"siteId"</span>, <span class="code-string">"date"</span>, <span class="code-string">"temperature"</span> }); <span\n            class="code-comment">//设置映射field</span>\n        fieldExtractor.afterPropertiesSet(); <span class="code-comment">//参数检查</span>\n\n        DelimitedLineAggregator&lt;MaxTemperatureEntiry&gt; lineAggregator = <span class="code-keyword">new</span> DelimitedLineAggregator&lt;&gt;();\n        lineAggregator.setDelimiter(<span class="code-string">","</span>); <span class="code-comment">//设置输出分隔符</span>\n        lineAggregator.setFieldExtractor(fieldExtractor); <span class="code-comment">//设置FieldExtractor处理器</span>\n\n        FlatFileItemWriter&lt;MaxTemperatureEntiry&gt; fileWriter = <span class="code-keyword">new</span> FlatFileItemWriter&lt;&gt;();\n        fileWriter.setLineAggregator(lineAggregator);\n        fileWriter.setResource(<span class="code-keyword">new</span> FileSystemResource(<span class="code-string">"src/main/resources/out-data.csv"</span>)); <span\n            class="code-comment">//设置输出文件位置</span>\n        fileWriter.setName(<span class="code-string">"outpufData"</span>);\n\n        <span class="code-keyword">if</span> (useBuilder) {<span class="code-comment">//使用builder方式创建</span>\n            fileWriter = <span class="code-keyword">new</span> FlatFileItemWriterBuilder&lt;MaxTemperatureEntiry&gt;().name(<span\n            class="code-string">"outpufData"</span>)\n                .resource(<span class="code-keyword">new</span> FileSystemResource(<span class="code-string">"src/main/resources/out-data.csv"</span>)).lineAggregator(lineAggregator)\n                .build();\n        }\n        <span class="code-keyword">return</span> fileWriter;\n    }\n}\n</code></pre>\n<p>文件的写入过程与读取过程完全对称相反：先用<code>FieldExtractor</code>将对象转换为一个<code>collection</code>结构（列表），然后用<code>lineAggregator</code>将<code>collection</code>转化为带分隔符的字符串。\n</p>\n<h2 id="h2-4">代码说明</h2>\n<ul>\n    <li>\n        <p>代码中的测试数据来自数据分析交流项目<a href="https://github.com/chkui/bi-process-example">bi-process-example</a>，是NOAA的2015年全球天气监控数据。为了便于源码存储进行了大量的删减，原始数据有百万条，如有需要使用下列方式下载：\n        </p>\n        <pre><code class="ruby">\tcurl -O <span class="hljs-symbol">ftp:</span>/<span class="hljs-regexp">/ftp.ncdc.noaa.gov/pub</span><span\n                class="hljs-regexp">/data/ghcn</span><span class="hljs-regexp">/daily/by</span>_year/<span\n                class="hljs-number">2015</span>.csv.gz <span class="code-comment">#数据文件</span>\n\tcurl -O <span class="hljs-symbol">ftp:</span>/<span class="hljs-regexp">/ftp.ncdc.noaa.gov/pub</span><span\n                    class="hljs-regexp">/data/ghcn</span><span\n                    class="hljs-regexp">/daily/ghcnd</span>-stations.txt <span class="code-comment"># 文件结构及类型说明</span>\n</code></pre>\n    </li>\n    <li>\n        <p>代码实现了读取文件、处理文件、写入文件的整个过程。处理文件的过程是只获取监控的最高温度信息（<code>Type=TMAX</code>），其他都过滤。</p>\n    </li>\n    <li>\n        <p>本案例的代码使用<code>org.chenkui.spring.batch.sample.flatfile.FlatFileItemApplication::main</code>方法运行，使用的是Command\n            Runner的方式执行（运行方式的说明见<a href="https://www.chkui.com/article/spring/spring_batch_item_and_code_case">Item概念及使用代码</a>的<em>命令行方式运行</em>、<em>Java内嵌运行</em>）。\n        </p>\n    </li>\n</ul>'}});