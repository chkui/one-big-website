webpackJsonp([16],{344:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h2 id="h2-1">从一个类开始</h2>\n<p>我们从一个简单类开始说起：</p>\n<pre><code class="java"><span class="code-keyword">package</span> example.classLifecicle;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">SimpleClass</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tSimpleClass ins = <span class="code-keyword">new</span> SimpleClass();\n\t}\n}</code></pre>\n<p>这是一段平凡得不能再平凡的Java代码，稍微有点编程语言入门知识的人都能理解它表达的意思：</p>\n<ol>\n    <li>创建一个名为SimpleClass的类；</li>\n    <li>定义一个入口main方法；</li>\n    <li>在main方法中创建一个SimpleClass类实例；</li>\n    <li>退出。</li>\n</ol>\n\n<h2 id="h2-2">什么是Java bytecode</h2>\n<p>那么这一段代码是怎么在机器（JVM）里运行的呢？在向下介绍之前先说清几个概念。</p>\n<p>首先，Java语言和JVM完全可以看成2个完全不相干的体系。虽然JVM全称叫Java Virtual\n    Machine，最开始也是为了能够实现Java的设计思想而制定开发的。但是时至今日他完全独立于Java语言成为一套生命力更为强悍的体系工具。他有整套规范，根据这个规范它有上百个应用实现，其中包括我们最熟悉的hotspot、jrockit等。还有一些知名的变种版本——harmony和android\n    dalvik，严格意义上变种版本并不能叫java虚拟机，因为其并未按照jvm规范开发，但是从设计思想、API上看又有大量的相似之处。</p>\n<p>其次，JVM并不能理解Java语言，他所理解的是称之为Java bytecode的"语言"。Java\n    bytecode从形式上来说是面向过程的，目前包含130多个指令，他更像可以直接用于CPU计算的一组指令集。所以无论什么语言，最后只要按照规范编译成java\n    bytecode（以下简称为"字节码"）都可以在JVM上运行。这也是scala、groovy、kotlin等各具特色的语言虽然在语法规则上不一致，但是最终都可以在JVM上平稳运行的原因。</p>\n\n<h2 id="h2-3">Java bytecode的规范和存储形式</h2>\n<p>前面代码保存成 <em>.java</em> 文件然后用下面的命令编译过后就可以生成.class字节码了：</p>\n<pre><code class="bash">$ javac SimpleClass.java <span class="code-comment">#SimpleClass.class</span></code></pre>\n<p>字节码是直接使用2进制的方式存储的，每一段数据都定义了具体的作用。下面是<em>SimpleClass.class</em> 的16进制数据（使用<em>vim + xxd</em>打开）：</p>\n<p><img alt="Jvm与字节码——类的方法区模型" height="315"\n        src="https://file.mahoooo.com/res/file/java_jvm_class_compile_in_the_method_area_2.png" width="500"></p>\n<p>一个 <em>.class</em> 文件的字节码分为10个部分：</p>\n<p>0~4字节：文件头，用于表示这是一个<em>Java bytecode</em>文件，值固定为0xCAFEBABE。</p>\n<p>2+2字节：编译器的版本信息。</p>\n<p>2+n字节：常量池信息。</p>\n<p>2字节：入口权限标记。</p>\n<p>2字节：类符号名称。</p>\n<p>2字节：父类符号名称。</p>\n<p>2+n字节：接口。</p>\n<p>2+n字节：域（成员变量）。</p>\n<p>2+n字节：方法。</p>\n<p>2+n字节：属性。</p>\n<p>每个部分的前2个字节都是该部分的标识位。</p>\n<p>本篇的目的是说明字节码的作用以及JVM如何使用字节码运转的，想要详细了解2进制意义的请看这里：http://www.jianshu.com/p/252f381a6bc4。</p>\n\n<h2 id="h2-4">反汇编及字节码解析</h2>\n<p>我们可以使用 <strong><em>javap</em></strong> 命令将字节码反汇编成我们容易阅读的格式化了的指令集编码:</p>\n<pre><code class="bash">$ javap -p SimpleClass.class <span class="code-comment">#查看类和成员</span>\n$ javap -s SimpleClass.class <span class="code-comment">#查看方法签名</span>\n$ javap -c SimpleClass.class <span class="code-comment">#反汇编字节码</span>\n$ javap -v SimpleClass.class <span class="code-comment">#返汇编查看所有信息</span></code></pre>\n<p><strong><em>javap</em></strong> 还有很多的参数，可以使用 <strong><em>javap --help</em></strong> 来了解。下面是使用<strong><em>javap\n    -v</em></strong> 命令输出的内容，输出了常量池信息、方法签名、方法描述、堆栈数量、本地内存等信息：</p>\n<pre><code class="apache"><span class="code-attribute">public</span> class example.classLifecicle.SimpleClass\n  <span class="code-attribute">flags</span>: ACC_PUBLIC, ACC_SUPER\n<span class="code-attribute">Constant</span> pool:\n   <span class="code-comment">#1 = Methodref          #4.#13         // java/lang/Object."&lt;init&gt;":()V</span>\n   <span class="code-comment">#2 = Class              #14            // example/classLifecicle/SimpleClass</span>\n   <span class="code-comment">#3 = Methodref          #2.#13         // example/classLifecicle/SimpleClass."&lt;init&gt;":()V</span>\n   <span class="code-comment">#4 = Class              #15            // java/lang/Object</span>\n   <span class="code-comment">#5 = Utf8               &lt;init&gt;</span>\n   <span class="code-comment">#6 = Utf8               ()V</span>\n   <span class="code-comment">#7 = Utf8               Code</span>\n   <span class="code-comment">#8 = Utf8               LineNumberTable</span>\n   <span class="code-comment">#9 = Utf8               main</span>\n  <span class="code-comment">#10 = Utf8               ([Ljava/lang/String;)V</span>\n  <span class="code-comment">#11 = Utf8               SourceFile</span>\n  <span class="code-comment">#12 = Utf8               SimpleClass.java</span>\n  <span class="code-comment">#13 = NameAndType        #5:#6          // "&lt;init&gt;":()V</span>\n  <span class="code-comment">#14 = Utf8               example/classLifecicle/SimpleClass</span>\n  <span class="code-comment">#15 = Utf8               java/lang/Object</span>\n{\n  <span class="code-attribute">public</span> example.classLifecicle.SimpleClass();\n    <span class="code-attribute">descriptor</span>: ()V\n    <span class="code-attribute">flags</span>: ACC_PUBLIC\n    <span class="code-attribute">Code</span>:\n      <span class="code-attribute">stack</span>=1, locals=1, args_size=1\n         <span class="code-attribute">0</span>: aload_0\n         <span class="code-attribute">1</span>: invokespecial #1                  // Method java/lang/Object.<span\n            class="code-string">"&lt;init&gt;"</span>:()V\n         <span class="code-attribute">4</span>: return\n      <span class="code-attribute">LineNumberTable</span>:\n        <span class="code-attribute">line</span> 3: 0\n\n  <span class="code-attribute">public</span> static void main(java.lang.String[]);\n    <span class="code-attribute">descriptor</span>: ([Ljava/lang/String;)V\n    <span class="code-attribute">flags</span>: ACC_PUBLIC, ACC_STATIC\n    <span class="code-attribute">Code</span>:\n      <span class="code-attribute">stack</span>=2, locals=2, args_size=1\n         <span class="code-attribute">0</span>: new           #2                  // class example/classLifecicle/SimpleClass\n         <span class="code-attribute">3</span>: dup\n         <span class="code-attribute">4</span>: invokespecial #3                  // Method <span class="code-string">"&lt;init&gt;"</span>:()V\n         <span class="code-attribute">7</span>: astore_1\n         <span class="code-attribute">8</span>: return\n      <span class="code-attribute">LineNumberTable</span>:\n        <span class="code-attribute">line</span> 5: 0\n        <span class="code-attribute">line</span> 6: 8\n}\n</code></pre>\n<p>下面是关于字节码格式的描述：</p>\n<p><strong><em>public class example.classLifecicle.SimpleClass</em></strong></p>\n<p>这一段表示这个类的符号。</p>\n<p><em><strong>flags: ACC_PUBLIC, ACC_SUPER</strong></em></p>\n<p>该类的标记。例如是否是public类等等，实际上就是将一些Java关键字转译成对应的Java bytecode。</p>\n<p><em><strong>Constant pool:</strong></em></p>\n<p><em>constant pool:</em> 之后的内容一直到<em> { </em>符号，都是我们所说的"常量池"。在对java类进行编译之后就会产生这个常量池。通常我们所说的类加载，就是加载器将字节码描述的常量信息转换成实际存储在运行时常量池中的一些内存数据（当然每个方法中的指令集也会随之加载到方法指向的某个内存空间中）。\n</p>\n<p>"#1"可以理解为常量的ID。可以把常量池看作一个Table，每一个ID都指向一个常量，而在使用时都直接用"#1"这样的ID来引用常量。</p>\n<p>常量池中的包含了运行这个类中方法所有需要用到的所有常量信息，Methodref、Class、Utf8、NameAndType等表示常量的类型，后面跟随的参数表示这个常量的引用位置或者数值。</p>\n<p><em><strong>{}:</strong></em></p>\n<p>常量池之后的{}之间是方法。每一个方法分为符号（名称）、标记、描述以及指令集。descriptor：描述。flags：入口权限标记。Code：指令集。</p>\n<p>Code中，stack表示这一段指令集堆栈的最大深度, locals表示本地存储的最大个数, args_size表述传入参数的个数。</p>\n\n<h2 id="h2-5">字节码如何驱动机器运行</h2>\n<p>\n    在往下说之前，先说下JVM方法区的内容。方法区顾名思义就是存储各种方法的地方。但是从实际应用来看，以Hotspot为例——方法区在实现时通常分为class常量池、运行常量池。在大部分书籍中，运行时常量池被描述为包括类、方法的所有描述信息以及常量数据,（<a\n        href="https://www.chkui.com/article/java/java_jvm_method_area_and_constant_pool" rel="nofollow">详情请看这篇文章</a>。</p>\n<p>对于机器来说并不存在什么类的感念的。到了硬件层面，他所能了解的内容就是：1）我要计算什么（cpu），2）我要存储什么（缓存、主存、磁盘等，我们统称内存）？</p>\n<p>\n    按照分层模型来说JVM只是一个应用进程，是不可能直接和机器打交道的（这话也不是绝对的，有些虚拟机还真直接当作操作系统在特有硬件设备上用）。在JVM到硬件之间还隔着一层操作系统，在本地运行时是直接调用操作系统接口的（windows和linux都是C/C++）。不过为了JVM虚拟机更高效，字节码设计为更接近机器逻辑行为的方式来运行。不然也没必要弄一个字节码来转译Java语言，像nodejs用的V8引擎那样实时编译Javascript不是更直接？这也是过去C/C++唾弃Java效率低下，到了如今Java反而去吐槽其他解释型编译环境跑得慢的原因（不过这也不见得100%正确。比如某些情况下Java在JVM上处理JSON不见得比JavaScript在nodejs上快，而且写起代码来也挺费劲的）。</p>\n<p>\n    我们回到硬件计算和存储的问题。CPU的计算过程实质上就是操作系统的线程不断给CPU传递指令集。线程就像传送带一样，把一系列指令排好队然后一个一个交给CPU去处理。每一个指令告诉CPU干一件事，而干事的前后总得有个依据（输入）和结果（输出），这就是各种缓存、内存、磁盘的作用——提供依据、保存结果。JVM线程和操作系统线程是映射关系（mapping），而JVM的堆（heap）和非堆（Non-heap）就是一个内存管理的模型。所以我们跳出分层的概念，将字节码理解为直接在驱动cpu和内存运行的汇编码更容易理解。</p>\n<p>最后，我们回到方法区（Method\n    Area）这个规范概念。CPU只关心一堆指令，而JVM中所有的指令都是放置在方法区中的。JVM的首要任务是把这些指令有序的组织起来，按照编程好的逻辑将指令一个一个交给CPU去运行。而CPU都是靠线程来组织指令运算的，所以JVM中每个线程都有一个线程栈，通过他将指令组织起来一个一个的交给CPU去运算——这就是计数器（Counter\n    Register，用以指示当前应该执行什么字节码指令）、线程栈（Stacks，线程的运算模型——先进后出） 和 栈帧（Stacks\n    Frame，方法执行的本地变量）&nbsp;的概念。所以无论多复杂的设计，方法区可以简单的理解为：<strong>有序的将指令集组织起来，并在使用的时候可以通过某些方法找到对应的指令集合</strong>。</p>\n<p><strong>解析常量池</strong></p>\n<p><img alt="Jvm与字节码——类的方法区模型" height="339"\n        src="https://file.mahoooo.com/res/file/java_jvm_class_compile_in_the_method_area_1.png" width="563"></p>\n<p>先看 <em><strong>SimpleClass</strong></em>&nbsp;字节码中常量池中的一些数据，上图中每一个方框表示一个常量。方框中第一行的 <em><strong>#1</strong></em>\n    表示当前常量的ID，第二行 <strong><em>Methodref</em></strong> 表示这个这个常量的类型，第三行 <em><strong>#4,#13</strong></em> 表示常量的值。</p>\n<p>我们从 <em><strong>#1</strong></em> 开始跟着每个常量的值向下延伸可以展开一根以 <strong><em>Utf8</em></strong>&nbsp;类型作为叶节点的树，每一个叶节点都是一个值。所有的方法我们都可以通过树的方式展开得到下面的查询字段：\n</p>\n<pre><code class="apache"><span class="code-attribute">class</span> = java/lang/Object //属于哪个类\n<span class="code-attribute">method</span> = <span class="code-string">"&lt;init&gt;"</span> //方法名称\n<span class="code-attribute">params</span> = NaN //参数\n<span class="code-attribute">return</span> = V //返回类型</code></pre>\n<p>所有的方法都会以 <em><strong>package.class.name:(params)return&nbsp;</strong></em>的形式存储在方法区中，通过上面的参数很快可以定位到方法，例如&nbsp; <em>java.lang.Object."&lt;init&gt;":()V</em>，这里"&lt;init&gt;"是构造方法专用的名称。\n</p>\n<p><strong>解析方法中的指令集</strong></p>\n<p>方法除了用于定位的标识符外就是指令集，下面解析main方法的指令集：</p>\n<pre><code class="http"><span class="code-attribute">0</span>: new &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// class example/classLifecicle/SimpleClass\n<span class="code-attribute">3</span>: dup\n<span class="code-attribute">4</span>: invokespecial #3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Method "&lt;init&gt;":()V\n<span class="code-attribute">7</span>: astore_1\n<span class="code-attribute">8</span>: return</code></pre>\n<p>1)）new 表示新建一个ID为#2的对象即SimpleClass(#2-&gt;#15="<em><strong>example/classLifecicle/SimpleClass"</strong></em>)。此时JVM会在堆上创建一个能放置<strong><em>SimpleClass</em></strong>类的空间并将引用地址返回写到栈顶。这里仅仅完成在堆中分配空间，没执行初始化。\n</p>\n<p>2）dup表示复制栈顶数据。此时栈中有2个指向同一内存区域的<em><strong>SimpleClass</strong></em>引用。</p>\n<p>3）invokespecial\n    #3表示执行#3的方法。通过解析常量池#3就是<em><strong>SimpleClass</strong></em>的构造方法。此后会将<em><strong>SimpleClass</strong></em>构造方法中的指令压入栈中执行。\n</p>\n<p>4）接下来来是<em><strong>SimpleClass</strong></em>的构造方法部分： a）aload_0 表示将本地内存的第一个数据压入栈顶，本地内存的第一个数据就是this。b）invokespecial #1\n    表示执行 <em><strong>Object</strong></em> 的构造方法。c）退出方法。这样就完成了实例的构造过程。</p>\n<p>5）完成上述步骤后，线程栈上还剩下一个指向<em><strong>SimpleClass</strong></em>实例的引用，astore_1 表示将引用存入本地缓存第二个位置。</p>\n<p>6）return -&gt; 退出 <em>main</em> 方法。</p>\n\n<h2 id="h2-6">方法区结构</h2>\n<p><strong>那么在方法区中所有的类是如何组织存放的呢？</strong></p>\n<p>我们用一个关系型数据库常的结构就可以解释他。在数据库中我们常用的对象有3个——表、字段、数据。每一个类对应的字节码我们都可以看成会生成2张数据库表——常量池表、方法表。通过字节码的解析，在内存中产生了如下结构的表：</p>\n<p>常量池表:example.classLifecicle.SimpleClass_Constant</p>\n<table border="1" cellpadding="1" cellspacing="1" style="width:500px">\n    <tbody>\n    <tr>\n        <td><strong><em>id</em></strong></td>\n        <td><strong><em>type</em></strong></td>\n        <td><strong><em>value</em></strong></td>\n    </tr>\n    <tr>\n        <td>#1</td>\n        <td>Methodref</td>\n        <td>#4,#13</td>\n    </tr>\n    <tr>\n        <td>…</td>\n        <td>……</td>\n        <td>……</td>\n    </tr>\n    <tr>\n        <td>#4</td>\n        <td>Class</td>\n        <td>#15</td>\n    </tr>\n    <tr>\n        <td>#15</td>\n        <td>Utf8</td>\n        <td>java/lang/Object</td>\n    </tr>\n    </tbody>\n</table>\n<p>方法表:example.classLifecicle.SimpleClass_Method</p>\n<table border="1" cellpadding="1" cellspacing="1" style="width:500px">\n    <tbody>\n    <tr>\n        <td>name</td>\n        <td>params</td>\n        <td>return</td>\n        <td>flag</td>\n        <td>code</td>\n    </tr>\n    <tr>\n        <td>&lt;init&gt;</td>\n        <td>&nbsp; &nbsp; NaN</td>\n        <td>V</td>\n        <td>static,public</td>\n        <td>……</td>\n    </tr>\n    <tr>\n        <td>…&nbsp;</td>\n        <td>……</td>\n        <td>……</td>\n        <td>……</td>\n        <td>……</td>\n    </tr>\n    </tbody>\n</table>\n<p>然后在运行过程中当计数器遇到&nbsp;<strong><em>invokespecial #3</em></strong>&nbsp;这样的指令时就会根据指令后面的ID去本类的常量表中查询并组装数据。当组装出&nbsp;class\n    = java/lang/Object、method = "&lt;init&gt;"、params = NaN、return = V这样的数据后，就会去名为java.lang.Object的表中根据&nbsp;<em>method、params、return&nbsp;</em>字段的数据查询对应的code，找到后为该code创建一个本地内存，随后线程计数器逐个执行code中的指令。\n</p>\n<p>这里仅仅用关系型数据库表的概念来解释方法区中如何将指令执行和字节码对应起来，真正的JVM运行方式比这复杂得多。不过这样很容易理解方法区到底是怎么一回事。</p>'},376:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<p><a href="https://www.chkui.com/article/spring/spring_core_bean_post_processors" title="Spring核心——IOC处理器扩展">上一篇文章</a>介绍了非侵入式的框架的概念以及IOC的功能扩展点之一——BeanPostProcessor，我们接下来的内容继续说明IoC更多的扩展方法。\n</p>\n\n<h2 id="h2-1">BeanFactoryPostProcessor</h2>\n<p>BeanFactoryPostProcessor是针对整个容器的后置处理器。他的使用也非常简单，只要向容器中添加一个继承BeanFactoryPostProcessor的Bean即可。</p>\n\n<h3 id="h3-1">如何使用</h3>\n<p>继承了BeanFactoryPostProcessor接口的类PostProcessors：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.xml.beanfactorypostprocessor;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">PostProcessors</span> <span class="code-keyword">implements</span> <span\n            class="code-title">BeanFactoryPostProcessor</span></span>{\n<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span\n            class="code-keyword">throws</span> BeansException </span>{\n         <span class="code-comment">//DO</span>\n    }\n}</code></pre>\n<p>然后再向容器中添加这个Bean就增加了一个BeanFactoryPostProcessor。</p>\n<pre><code class="xml"><span class="php"><span class="code-meta">&lt;?</span>xml version=<span\n        class="code-string">"1.0"</span> encoding=<span class="code-string">"UTF-8"</span><span\n        class="code-meta">?&gt;</span></span>\n<span class="code-comment">&lt;!-- xml.beanfactorypostprocessor --&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">beans</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"chkui.springcore.example.xml.beanfactorypostprocessor.PostProcessors"</span> /&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>BeanFactoryPostProcessor主要用于处理容器相关的内容，他被触发时机是在IoC容器加载完各种配置后，还没执行Bean的初始化之前。这个时候除了PostProcessors这个Bean，其他任何Bean都没有被创建。&nbsp;所以在BeanFactoryPostProcessor处理Bean是不合适的，Bean应该要到BeanPostProcessor中去处理，2者的区别就是前者面向容器，后者面向Bean。接下来将通过一个详细例子来说明BeanFactoryPostProcessor和BeanPostProcessor的区别以及使用方式。期间还会介绍BeanDefinitio相关的内容。</p>\n\n<h3 id="h3-2">BeanFactoryPostProcessor与BeanPostProcessor使用</h3>\n<p><span style="color:#e74c3c">（文中仅仅是示例代码，无法运行，源码在</span><a href="https://gitee.com/chkui-com/spring-core-sample"\n                                                            rel="nofollow"><span style="color:#e74c3c">https://gitee.com/chkui-com/spring-core-sample</span></a><span\n        style="color:#e74c3c">，如需下载请自行clone）</span></p>\n\n<h4 id="h4-1"><span style="color:null">建造者模式</span></h4>\n<p>下面将会通过一个例子介绍2者的使用方式和使用场景。例子使用建造者模式模拟组装一台个人电脑，分为一下3步：</p>\n<ol>\n    <li>&nbsp;容器启动之后，会将电脑的所有“配件”（Cpu、Graphics、Ram）都添加到容器中。</li>\n    <li>&nbsp;在PostProcessorS实现BeanFactoryPostProcessor接口，它的功能是向容器添加一个Pc对象。</li>\n    <li>&nbsp;在PostProcessor实现BeanPostProcessor接口。他的工作是组装电脑——每一个Bean都会检查域上的@Autowired注解，并注入对应的部件，部件也会标记自己所属的电脑。</li>\n</ol>\n<p>下面是XML配置文件，它负责将Cpu、显卡、内存等电脑常用品牌的部件放置到容器中等待组装。此外它还添加了PostProcessorS和PostProcessor两个后置处理器用于装载电脑。</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"chkui.springcore.example.xml.beanfactorypostprocessor.bean.Cpu"</span>&gt;</span>\n     \t<span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"brand"</span> <span class="hljs-attr">value</span>=<span\n                class="code-string">"Amd"</span>/&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n    \n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"chkui.springcore.example.xml.beanfactorypostprocessor.bean.Graphics"</span>&gt;</span>\n     \t<span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"brand"</span> <span class="hljs-attr">value</span>=<span class="code-string">"Nvdia"</span>/&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n    \n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"chkui.springcore.example.xml.beanfactorypostprocessor.bean.Ram"</span>&gt;</span>\n     \t<span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"brand"</span> <span class="hljs-attr">value</span>=<span class="code-string">"Kingston"</span>/&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n    \n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"chkui.springcore.example.xml.beanfactorypostprocessor.PostProcessor"</span> /&gt;</span>\n    \n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"chkui.springcore.example.xml.beanfactorypostprocessor.PostProcessors"</span> /&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>下面是一个Cpu对象的结构，他标记了品牌和所属电脑。Graphics和Ram的结构和它一模一样。</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.xml.beanfactorypostprocessor.bean;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Cpu</span> </span>{\n\t<span class="code-keyword">private</span> String brand;\n\t\n\t<span class="code-meta">@Autowired</span>\n\t<span class="code-keyword">private</span> Pc belong;\n}</code></pre>\n<p>注意这里的@Autowired注解，我们的配置文件并没有开启Spring的自动装配功能，我们将在PostProcessor实现自动装配。</p>\n<p>PostProcessorS的作用是向容器动态添加一个之前未定义的Bean——Pc。</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.xml.beanfactorypostprocessor;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">PostProcessors</span> <span class="code-keyword">implements</span> <span\n            class="code-title">BeanFactoryPostProcessor</span></span>{\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span\n            class="code-keyword">throws</span> BeansException </span>{\n\t\t<span class="code-comment">//获取容器的注册接口</span>\n\t\tBeanDefinitionRegistry registry = (BeanDefinitionRegistry)beanFactory;\n\t\t<span class="code-comment">//新建一个BeanDefinition用于动态装配Bean</span>\n\t\tGenericBeanDefinition defininition = <span class="code-keyword">new</span> GenericBeanDefinition();\n\t\t<span class="code-comment">//设置要添加的类</span>\n\t\tdefininition.setBeanClass(Pc.class);\n\t\t<span class="code-comment">//注册BeanDefinition</span>\n\t\tregistry.registerBeanDefinition(<span class="code-string">"postBean"</span>, defininition);\n\t}\n}</code></pre>\n<p>如果看过 <a href="https://www.chkui.com/article/spring/spring_core_context_and_ioc" title="Spring核心——上下文与IoC">Ioc结构介绍的这篇文章</a>，你就会知道BeanFactory经过层层派生，实际上大部分接口都在一个类实现——DefaultListableBeanFactory，它除了实现ConfigurableListableBeanFactory接口，还实现了BeanDefinitionRegistry接口。BeanDefinitionRegistry提供了BeanDefinition的管理功能。\n</p>\n\n<h4 id="h4-2">BeanDefinition与适配器模式</h4>\n<p>\n    在上面的代码中出现了BeanDefinition接口，这里就顺道说一说这个有趣的小玩意。关于他如何使用Spring的官网并没有太详细的介绍（至少我没找到），网上倒是有各路大神的博客在解读他的源码，不过代码只是表象，要理解他的整套设计思路才能提升。</p>\n<p>关于BeanDefinition的使用模式，官网将其称呼为<em>configuration metadata</em>，直译过来叫“配置元数据”。&nbsp;他的作用有点类似于<a\n        href="https://www.chkui.com/article/spring/spring_core_context_and_ioc" title="Spring核心——上下文与IoC">Context分层应用的效果（见Spring核心——上下文与IoC&nbsp;关于\n    ApplicationContext的说明）</a>，目的就是将Bean的配置和初始化工作分成2个互不干扰的部分。</p>\n<p>我们知道 Spring现在支持各种各样的方式来添加Bean，比如在XML配置文件中使用&lt;bean&gt;标签、使用@Component以及他的派生类注解、可以在@Configuration类中生成、甚至还可以通过RMI实现远程配置等等。如果所有的这些配置来源直接和IoC容器产生关系生成Bean，那么耦合度、代码复杂度会越来越高，而且以后指不定什么时候又会加入什么新的配置方式。</p>\n<p>\n    为了解决这个问题Spring的大神们引入了适配器模式——IoC容器只接受BeanDefinition接口，IoC如何初始化一个Bean是仅仅是看BeanDefinition里的信息。而各种配置方式都有自己的适配器，所有的适配器都会根据他所需要处理的内容来生成一个BeanDefinition的实现类。这样，如果新增一个新的配置方式，增加一个适配器就可以搞定。</p>\n<p><img align="left" alt="Spring核心——IOC功能扩展点" height="381"\n        src="https://file.mahoooo.com/res/file/spring_core_ioc_extension_points.png" width="600"></p>\n<p>所以，我们也可以利用BeanDefinitionRegistry接口向容器添加一个BeanDefinition，进而在随后的执行过程中IoC容器会根据 这个BeanDefinition创建一个对应的Bean。</p>\n<h4 id="h4-3">BeanPostProcessor</h4>\n<p>\n    前面已经提到，BeanFactoryPostProcessor用于处理容器级别的问题，而BeanPostProcessor用来处理每一个Bean。我们前面已经用BeanFactoryPostProcessor向容器添加了一个Pc对象的Bean，接下来我们在BeanPostProcessor中处理每一个Bean的自动注入注解。</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.xml.beanfactorypostprocessor;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">PostProcessor</span> <span class="code-keyword">implements</span> <span\n            class="code-title">BeanPostProcessor</span>, <span class="code-title">BeanFactoryAware</span> </span>{\n\t<span class="code-keyword">private</span> ConfigurableListableBeanFactory beanFactory;\n\t<span class="hljs-function"><span class="code-keyword">public</span> Object <span class="code-title">postProcessBeforeInitialization</span><span\n            class="hljs-params">(Object bean, String beanName)</span> </span>{\n        <span class="code-keyword">return</span> autowiredImplement(bean);\n    }\n\t<span class="hljs-function"><span class="code-keyword">public</span> Object <span class="code-title">postProcessAfterInitialization</span><span\n            class="hljs-params">(Object bean, String beanName)</span> </span>{\n        <span class="code-keyword">return</span> bean;\n    }\n\t\n\t<span class="code-comment">//自定义实现autowired功能</span>\n\t<span class="hljs-function"><span class="code-keyword">private</span> Object <span class="code-title">autowiredImplement</span><span\n            class="hljs-params">(<span class="code-keyword">final</span> Object bean)</span> </span>{\n\t\t<span class="code-keyword">for</span>(Field field : bean.getClass().getDeclaredFields()) {\n\t\t\tAutowired value = field.getAnnotation(Autowired.class);\n\t\t\t<span class="code-keyword">if</span>(<span class="code-keyword">null</span> != value) {\n\t\t\t\tObject obj = beanFactory.getBean(field.getType());\n\t\t\t\tfield.setAccessible(<span class="code-keyword">true</span>);\n\t\t\t\tfield.set(bean, obj);\n\t\t\t}\n\t\t}\n\t\t<span class="code-keyword">return</span> bean;\n\t}\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setBeanFactory</span><span class="hljs-params">(BeanFactory beanFactory)</span> <span\n            class="code-keyword">throws</span> BeansException </span>{\n\t\t<span class="code-keyword">this</span>.beanFactory = (ConfigurableListableBeanFactory)beanFactory;\n\t}\n}</code></pre>\n<p>这里的PostProcessor实现BeanFactoryAware接口来获取&nbsp;BeanFactory。自动注入的处理逻辑都在autowiredImplement方法中，它会扫描Bean的每一个域检查是否有@Autowired注解，如果有则根据这个域的Class类型到BeanFactory去获取对应的Bean，然后反射注入。</p>\n<p>最后我们创建一个ApplicationContext来运行他们：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">SampleApp</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n    \tApplicationContext context = <span class="code-keyword">new</span> ClassPathXmlApplicationContext(<span\n            class="code-string">"xml/beanfactorypostprocessor/config.xml"</span>);\n    \tPc pc = context.getBean(Pc.class);\n        <span class="code-comment">/**\n        Pc Info: Graphics=Nvdia, Cpu=Amd, Ram=Kingston]\n        */</span>\n        System.out.println(pc);\n    }\n}</code></pre>\n<p>本文介绍了BeanFactoryPostProcessor和BeanPostProcessor的使用方式，以及IoC容易是如何通过BeanDefinition装载各种配置的。后续还会持续介绍Spring\n    IoC容器的各种功能扩展点。</p>'},379:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h2 id="h2-1">从配置上扩展</h2>\n<p>之前的文章介绍了Spring的IoC容器配置管理方面的详细内容，需要了解的可以从<a\n        href="https://www.chkui.com/article/spring/spring_core_design_pattern_and_ioc" rel="nofollow">IoC容器的设计模式</a>开始阅读。在介绍基于注解配置的配置之前我们再重复一下在之前提到的基本认识：\n</p>\n<ol>\n    <li>Spring的基本工作单位是Bean，所有的高级功能都是在Bean的基础上扩展而来的。Bean可以理解成Java类的一个实例。</li>\n    <li>Bean只是一个个体，Spring用一个名为IoC（Inversion of Control控制反转）的容器来管理所有的Bean。</li>\n    <li>Spring的核心功能就是管理Bean与Bean之间、IoC容器与Bean之间的依赖、组合关系。这些关系通过XML配置来定义。</li>\n</ol>\n<p>基于以上3点，对XML配置有清晰的理解对Spring核心框架的使用至关重要。在Spring没有<strong>注解（Annotation）</strong>之前，我们都是通过XML配置来实现Spring的功能，而在3.x版本之后，我们可以仅使用注解而无需XML即可运行Spring。注解并没有扩展Spring的核心功能，他仅仅是将原来XML上的配置迁移到Java源码中以“元数据”（bytecode\n    metadata）的方式提供非侵入式（non-invasive）的框架服务。所以无论XML配置还是注解的方式，或者两者混合使用都可以实现Spring提供的所有功能。</p>\n<p>在之前<a href="https://www.chkui.com/article/spring/spring_core_ioc_extension_points" title="IOC功能扩展点">IOC功能扩展点</a>一文中介绍了BeanDefinition的适配器模式。如下图，了解BeanDefinition的作用之后就能明白无论是注解还是XML配置，最后都会转化为一个BeanDefinition结构让IoC容器来执行初始化。\n</p>\n<p style="text-align:center"><img alt="Spring核心——注解自动装载" height="381"\n                                  src="https://file.mahoooo.com/res/file/spring_core_ioc_extension_points.png" width="600"></p>\n<p>Spring的注解相关的功能是在2.x版本开始出现然后到3.x才全部完善的，支持JCP制定的JSR-250和<a href="https://www.chkui.com/article/java/java_jsr330"\n                                                            title="JSR-330">JSR-330</a>。所以在使用注解的时候需要注意版本号。</p>\n\n<h2 id="h2-2">启用Annotation配置功能</h2>\n<p>在使用注解功能之前要告诉IoC现在需要启用注解相关的功能，通过上下文级别的配置即可开启所有注解相关的功能：</p>\n<pre><code class="xml"><span class="php"><span class="code-meta">&lt;?</span>xml version=<span\n        class="code-string">"1.0"</span> encoding=<span class="code-string">"UTF-8"</span><span\n        class="code-meta">?&gt;</span></span>\n<span class="code-tag">&lt;<span class="code-name">beans</span> <span class="hljs-attr">xmlns</span>=<span\n        class="code-string">"http://www.springframework.org/schema/beans"</span>\n    <span class="hljs-attr">xmlns:xsi</span>=<span\n            class="code-string">"http://www.w3.org/2001/XMLSchema-instance"</span>\n    <span class="hljs-attr">xmlns:context</span>=<span class="code-string">"http://www.springframework.org/schema/context"</span>\n    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="code-string">"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span>\n\n    <span class="code-tag">&lt;<span class="code-name">context:annotation-config</span>/&gt;</span>\n\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<ol>\n</ol>\n<p>在<a href="https://www.chkui.com/article/spring/spring_core_post_processor_of_official" title="spring-官配后置处理器">官配后置处理器</a>一文已经介绍了注解的处理都是通过后置处理器实现的，所以添加了&lt;context:annotation-config/&gt;这个配置之后在实现层面会向IoC容器增加<a\n        href="https://docs.spring.io/spring-framework/docs/5.0.7.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.html"\n        rel="nofollow">AutowiredAnnotationBeanPostProcessor</a>,<a\n        href="https://docs.spring.io/spring-framework/docs/5.0.7.RELEASE/javadoc-api/org/springframework/context/annotation/CommonAnnotationBeanPostProcessor.html"\n        rel="nofollow">CommonAnnotationBeanPostProcessor</a>,<a\n        href="https://docs.spring.io/spring-framework/docs/5.0.7.RELEASE/javadoc-api/org/springframework/orm/jpa/support/PersistenceAnnotationBeanPostProcessor.html"\n        rel="nofollow">PersistenceAnnotationBeanPostProcessor</a>、<a\n        href="https://docs.spring.io/spring-framework/docs/5.0.7.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/RequiredAnnotationBeanPostProcessor.html"\n        rel="nofollow">RequiredAnnotationBeanPostProcessor</a>这几个后设置处理器。每个处理器都针对某一个或者某些注解进行处理。</p>\n<p>还有，如果在工程中混合使用注解和XML配置，如果同一个Bean同时在XML和注解都进行了配置，那么最终生效的是XML上的配置，因为Spring容器会先处理注解再处理XML配置。</p>\n<p>下面是关于自动装载的注解介绍：</p>\n\n<h2 id="h2-3">@Autowired</h2>\n<p>\n    这个注解应该是使用spring最常用的注解，也是IoC容器反向依赖注入的极致体现。基本上容器里有什么实现我们根本不必操心，之需要声明一个接口加一个@Autowired就可以获得对应的接口功能。如果不使用参数的话@Autowired的效果就相当于BeanFactory.getBean(Class&lt;T&gt;\n    )。</p>\n\n<h3 id="h3-1">多种方法注入数据</h3>\n<p>@Autowired可以直接写在域（成员变量）上、可以用在一般的方法和构造方法上：</p>\n<pre><code class="java"><span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">A</span> </span>{}\n<span class="hljs-class"><span class="code-keyword">interface</span> <span class="code-title">B</span> </span>{}\n<span class="hljs-class"><span class="code-keyword">interface</span> <span class="code-title">C</span> </span>{}\n\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MyClass</span> </span>{\n\t<span class="code-meta">@Autowired</span> <span class="code-comment">//从成员变量注入</span>\n\t<span class="code-keyword">private</span> A a;\n\t<span class="code-keyword">private</span> B b;\n\t<span class="code-keyword">private</span> C c;\n\n\t<span class="code-meta">@Autowired</span> <span class="code-comment">//从构造方法注入</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-title">MyClass</span><span\n            class="hljs-params">(C c)</span> </span>{\n\t\t<span class="code-keyword">this</span>.c = c;\n\t}\n\t<span class="hljs-function"><span class="code-keyword">public</span> A <span class="code-title">getA</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> a;\n\t}\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setA</span><span class="hljs-params">(A a)</span> </span>{\n\t\t<span class="code-keyword">this</span>.a = a;\n\t}\n\t<span class="hljs-function"><span class="code-keyword">public</span> B <span class="code-title">getB</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> b;\n\t}\n\t<span class="code-meta">@Autowired</span> <span class="code-comment">//从普通方法注入</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setB</span><span class="hljs-params">(B b)</span> </span>{\n\t\t<span class="code-keyword">this</span>.b = b;\n\t}\n\t<span class="hljs-function"><span class="code-keyword">public</span> C <span class="code-title">getC</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> c;\n\t}\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setC</span><span class="hljs-params">(C c)</span> </span>{\n\t\t<span class="code-keyword">this</span>.c = c;\n\t}\n}</code></pre>\n\n<h3 id="h3-2">获取同一个接口的多个实现</h3>\n<p>如果容器中同一个接口有相同的实现，我们可以用数据、列表或Map结构来获取多个Bean：</p>\n<pre><code class="java"><span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">A</span> </span>{}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">implA1</span> <span\n        class="code-keyword">implements</span> <span class="code-title">A</span></span>{}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">implA2</span> <span\n        class="code-keyword">implements</span> <span class="code-title">A</span></span>{}\n\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MyClass</span> </span>{\n\t<span class="code-meta">@Autowired</span>\n\t<span class="code-keyword">private</span> A[] a;\n\t<span class="code-meta">@Autowired</span>\n\t<span class="code-keyword">private</span> Set&lt;A&gt; set;\n\t<span class="code-meta">@Autowired</span>\n\t<span class="code-keyword">private</span> Map&lt;String, A&gt; map;\n}</code></pre>\n<p>使用Map时，key必须声明为String，在运行时会key是注入Bean的name/id。</p>\n\n<h3 id="h3-3">声明非必要数据</h3>\n<p>当我们使用@Autowired时，如果容器中没有我们所需的Bean会抛出异常。当这个Bean并不是必要数据时可以使用@Autowired的required参数：</p>\n<pre><code class="java"><span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">A</span> </span>{}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MyClass</span> </span>{\n\t<span class="code-meta">@Autowired</span>(required=<span class="code-keyword">false</span>)\n\t<span class="code-keyword">private</span> A a;\n}</code></pre>\n\n<h3 id="h3-4">自动空指针处理</h3>\n<p>在Java8之后专门为空指针处理添加了<a href="https://www.chkui.com/article/java/java_lambda_optional_for_null" title="Optional空指针处理">Optional这个工具类</a>。在4.x之后Spring在注入数据阶段会根据目标对象自动进行包装：\n</p>\n<pre><code class="java"><span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">A</span> </span>{}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">impl</span> <span\n        class="code-keyword">implements</span> <span class="code-title">A</span></span>{}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MyClass</span> </span>{\n\t<span class="code-meta">@Autowired</span>(required=<span class="code-keyword">false</span>)\n\t<span class="code-keyword">private</span> Optional&lt;A&gt; a;\n}</code></pre>\n<p>这个时候在容器中存放的是接口A的实现类，但是会自定根据注入对象的声明新建一个Optional包装的Bean。</p>\n<p>在5.x版本之后还可以使用JSR-305提出的@NullAble告诉IoC这里可以注入一个空指针数据或什么也不需要。</p>\n<pre><code class="java"><span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">A</span> </span>{}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">impl</span> <span\n        class="code-keyword">implements</span> <span class="code-title">A</span></span>{}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MyClass</span> </span>{\n\t<span class="code-keyword">private</span> A a;\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setA</span><span class="hljs-params">(@Nullable A a)</span> </span>{\n\t\t<span class="code-keyword">this</span>.a = a;\n\t}\n}</code></pre>\n\n<h3 id="h3-5">获取容器中的所有资源</h3>\n<p>除了我们自己声明的接口、类，@Autowired还可以获取Spring定义的所有Bean，凡是只要在IoC容器中的Bean都可以通过它来获取：</p>\n<pre><code class="java"><span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MyClass</span> </span>{\n\t<span class="code-meta">@Autowired</span>\n\t<span class="code-keyword">private</span> ApplicationContext context;\n}</code></pre>\n<p>\n    不过需要注意的是，这些注解（Annotation）支持的功能都是由后置处理器实现的，所以无法自动注入后置处理器（<code>BeanPostProcessor或</code><code>BeanFactoryPostProcessor</code>&nbsp;）。\n</p>\n\n<h3 id="h3-6">JSR-330支持</h3>\n<p>\n    JSR-330提出了反向依赖注入的相关内容，主要是关于@Inject、@ManagedBean、@Singleton的作用和实现方式。使用@Inject可以替换@Autowired的绝大部分功能，但是还有些许的差异。使用JSR-330要引入javax.inject包，maven的配置如下：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">dependency</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">groupId</span>&gt;</span>javax.inject<span class="code-tag">&lt;/<span\n            class="code-name">groupId</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">artifactId</span>&gt;</span>javax.inject<span class="code-tag">&lt;/<span\n            class="code-name">artifactId</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">version</span>&gt;</span>1<span class="code-tag">&lt;/<span\n            class="code-name">version</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">dependency</span>&gt;</span></code></pre>\n<p>然后可以用@Inject注解任何使用@Autowired的地方，唯一的区别是@Inject没有required参数，如果要实现对应的功能只能通过注入Optional&lt;Class&lt;T&gt;&gt;的方式实现。</p>\n\n<h2 id="h2-4">对自动装配的控制</h2>\n<p>@Autowired虽然好用，但是也会遇到一些问题，比如当容器中有2个类实现同一个接口的时候在运行时注入就会抛出异常，针对这个问题Spring提供了一些针对自动装配更细节的操作——Primary和Qualifiers。</p>\n\n<h3 id="h3-7">Primary控制自动装配</h3>\n<p>Primary字面意思就是主要的，意思是告诉容器这个Bean是“主”Bean。实现Primary有两种方式，通过在@Configuration中注解实现或在XML配置中实现。</p>\n<p>首先是配置方式。有一个接口A、有2个A的实现类ImplFirst和ImplSecond，然后在功能类MyClass中自动装配了接口A：</p>\n<pre><code class="java"><span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">A</span> </span>{}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">ImplFirst</span> <span\n        class="code-keyword">implements</span> <span class="code-title">A</span></span>{}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">ImplSecond</span> <span\n        class="code-keyword">implements</span> <span class="code-title">A</span></span>{}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MyClass</span> </span>{\n\t<span class="code-meta">@Autowired</span>\n\t<span class="code-keyword">private</span> A a;\n}</code></pre>\n<p>在配置文件中我们可以使用primary属性来控制注入哪一个实现类。</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">context:annotation-config</span>/&gt;</span>\n    <span class="code-comment">&lt;!-- 自动装配时会使用这个Bean --&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"x.y.ImplFirst"</span> <span class="hljs-attr">primary</span>=<span class="code-string">"true"</span>/&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"x.y.ImplSecond"</span>/&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"x.y.MyClass"</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>此外，我们还可是使用Java配置功能（@Configuration相关的Java配置内容后续篇幅会介绍）指明“主”Bean。将XML配置文件替换为下面的Java配置形式：</p>\n<pre><code class="java"><span class="code-meta">@Configuration</span>\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MyClassConfig</span> </span>{\n\t<span class="code-meta">@Bean</span>\n\t<span class="code-meta">@Primary</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> A <span\n            class="code-title">firstImpl</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> ImplFirst();\n\t}\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> A <span\n            class="code-title">secondImpl</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> ImplSecond();\n\t}\n}</code></pre>\n\n<h3 id="h3-8">Qualifiers控制自动装配</h3>\n<p>Primary是类的实现者决定使用那个一个类，而Qualifiers是让类的使用者来确定使用哪一个类。先看一个最基本的用法：</p>\n<pre><code class="java"><span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">A</span> </span>{}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">ImplFirst</span> <span\n        class="code-keyword">implements</span> <span class="code-title">A</span> </span>{}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">ImplSecond</span> <span\n        class="code-keyword">implements</span> <span class="code-title">A</span> </span>{}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MyClass</span> </span>{\n\t<span class="code-meta">@Autowired</span>\n\t<span class="code-meta">@Qualifier</span>(<span class="code-string">"implSecond"</span>)\n\t<span class="code-keyword">private</span> A a;\n}</code></pre>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">context:annotation-config</span>/&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n            class="code-string">"implFirst"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.ImplFirst"</span>/&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n            class="code-string">"implSecond"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.ImplSecond"</span>/&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"x.y.MyClass"</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>这样通过@Qualifiers注解就制定加载了ImplFIrst这个类。不过Spring官方并不建议这样去使用Qualifiers。主要的原因是失去了@Autowired的使用初衷——在使用的时候还需要去了解&lt;bean&gt;的定义结构。官方建议通过别名的形式告知每一个类的作用，然后通过Qualifiers来使用。例如我们还是用组装电脑的例子：</p>\n<pre><code class="java"><span class="hljs-class"><span class="code-keyword">interface</span> <span class="code-title">Cpu</span> </span>{}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">Athlon</span> <span\n        class="code-keyword">implements</span> <span class="code-title">Cpu</span> </span>{\n\t<span class="code-keyword">private</span> String brand = <span class="code-string">"Amd"</span>;\n}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">Celeron</span> <span\n        class="code-keyword">implements</span> <span class="code-title">Cpu</span> </span>{\n\t<span class="code-keyword">private</span> String brand = <span class="code-string">"Intel"</span>;\n}\n\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MyPc</span> </span>{\n\t<span class="code-meta">@Autowired</span>\n\t<span class="code-meta">@Qualifier</span>(<span class="code-string">"Intel"</span>)\n\t<span class="code-keyword">private</span> Cpu a;\n}\n\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">YourPc</span> </span>{\n\t<span class="code-meta">@Autowired</span>\n\t<span class="code-meta">@Qualifier</span>(<span class="code-string">"Amd"</span>)\n\t<span class="code-keyword">private</span> Cpu a;\n}</code></pre>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">context:annotation-config</span>/&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n            class="code-string">"athlon"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.Athlon"</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">qualifier</span> <span class="hljs-attr">value</span>=<span\n                class="code-string">"Amd"</span>/&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n            class="code-string">"celeron"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.Celeron"</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">qualifier</span> <span class="hljs-attr">value</span>=<span\n                class="code-string">"Intel"</span>/&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"x.y.MyPc"</span>/&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"x.y.YourPc"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>&lt;qualifier value="Intel"/&gt;可以声名当前的Bean对应的Qualifier的名称。这样完全就将Id和Qualifer定义的名称隔离开，我们可以使用规范来约定使用的功能内容。</p>\n<p>还可以通过继承@Qualifier来实现我们更细节的控制和管理，我们将上面的代码进行如下修改：</p>\n<pre><code class="java"><span class="code-meta">@Target</span>({ ElementType.FIELD, ElementType.PARAMETER })\n<span class="code-meta">@Retention</span>(RetentionPolicy.RUNTIME)\n<span class="code-meta">@Qualifier</span>\n<span class="code-meta">@interface</span> CpuType {\n\t<span class="hljs-function">String <span class="code-title">value</span><span class="hljs-params">()</span></span>;\n}\n<span class="hljs-class"><span class="code-keyword">interface</span> <span class="code-title">Cpu</span> </span>{\n}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">Athlon</span> <span\n        class="code-keyword">implements</span> <span class="code-title">Cpu</span> </span>{\n\t<span class="code-keyword">private</span> String brand = <span class="code-string">"Amd"</span>;\n}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">Celeron</span> <span\n        class="code-keyword">implements</span> <span class="code-title">Cpu</span> </span>{\n\t<span class="code-keyword">private</span> String brand = <span class="code-string">"Intel"</span>;\n}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MyPc</span> </span>{\n\t<span class="code-meta">@Autowired</span>\n\t<span class="code-meta">@CpuType</span>(<span class="code-string">"Intel"</span>)\n\t<span class="code-keyword">private</span> Cpu a;\n}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">YourPc</span> </span>{\n\t<span class="code-meta">@Autowired</span>\n\t<span class="code-meta">@CpuType</span>(<span class="code-string">"Amd"</span>)\n\t<span class="code-keyword">private</span> Cpu a;\n}</code></pre>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">context:annotation-config</span>/&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n            class="code-string">"athlon"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.Athlon"</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">qualifier</span> <span class="hljs-attr">type</span>=<span\n                class="code-string">"CpuType"</span> <span class="hljs-attr">value</span>=<span class="code-string">"Amd"</span>/&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n            class="code-string">"celeron"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.Celeron"</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">qualifier</span> <span class="hljs-attr">type</span>=<span\n                class="code-string">"x.y.CpuType"</span> <span class="hljs-attr">value</span>=<span class="code-string">"Intel"</span>/&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"x.y.MyPc"</span>/&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"x.y.YourPc"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>在&lt;qualifier&gt;中type指向的注解类可以是全限定名，也可以用短编码。</p>\n<p>我们还可以在继承的注解中使用自定义参数。例如：</p>\n<pre><code class="java"><span class="code-meta">@Target</span>({ ElementType.FIELD, ElementType.PARAMETER })\n<span class="code-meta">@Retention</span>(RetentionPolicy.RUNTIME)\n<span class="code-meta">@Qualifier</span>\n<span class="code-meta">@interface</span> CpuType {\n\t<span class="hljs-function">String <span class="code-title">brand</span><span class="hljs-params">()</span></span>;\n    <span class="hljs-function">String <span class="code-title">ver</span><span class="hljs-params">()</span></span>;\n}</code></pre>\n<p>配置：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">context:annotation-config</span>/&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n            class="code-string">"athlon"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.Athlon"</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">qualifier</span> <span class="hljs-attr">type</span>=<span\n                class="code-string">"CpuType"</span>&gt;</span>\n            <span class="code-tag">&lt;<span class="code-name">attribute</span> <span class="hljs-attr">key</span>=<span\n                    class="code-string">"brand"</span> <span class="hljs-attr">value</span>=<span class="code-string">"Amd"</span>/&gt;</span>\n            <span class="code-tag">&lt;<span class="code-name">attribute</span> <span class="hljs-attr">key</span>=<span\n                    class="code-string">"ver"</span> <span class="hljs-attr">value</span>=<span class="code-string">"4321"</span>/&gt;</span>\n        <span class="code-tag">&lt;/<span class="code-name">qualifier</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"x.y.MyPc"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>'}});