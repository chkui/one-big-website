webpackJsonp([14],{378:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<p>在<a href="https://www.chkui.com/article/java/java_bean_validation" title="Java数据校验详解">Java数据校验详解</a>中详细介绍了Java数据校验相关的功能（简称<em>Bean\n    Validation，</em>涵盖<em>JSR-303、JSR-349、JSR-380</em>）,本文将在<em>Bean Validation</em>的基础上介绍Spring框架提供的数据校验功能。</p>\n<p>Spring提供的数据校验功能分为2个部分，一个是Spring自定义的数据校验功能（以下称为<em>Spring Validation</em>），一个是符合<em>Bean Validation</em>规范的数据校验功能。</p>\n\n<h2 id="h2-1">Spring Validation数据校验</h2>\n<p>Spring的自行开发的数据校验功能由3个部分组成：</p>\n<ol>\n    <li>校验器——Validator，他会运行校验代码。</li>\n    <li>校验对象，实际上就是一个JavaBean，Validator会对其进行校验。</li>\n    <li>校验结果——Errors，一次校验的结果都存放在Errors实例中。</li>\n</ol>\n<p>这是Spring在<em>Bean Validation</em>规范制定之前就实现的数据校验功能，ValidationUtils的注释中@since标签是2003年5月6号，而JSR-303定稿时间已经是6年之后（2009年）的事了。\n</p>\n<p>（文中仅为示例代码，可执行代码请到本人<a href="https://gitee.com/chkui-com/spring-core-sample" rel="nofollow">gitee库获取</a>，本文代码在<em>chkui.springcore.example.hybrid.springvalidation</em>包中。）\n</p>\n<p>Spring的数据校验功能就是实现检验器、校验对象、校验结果三个对象。先声明个一个校验对象（实体）：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.springvalidation.entity;\n<span class="code-comment">//车辆信息</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Vehicle</span> </span>{\n\t<span class="code-keyword">private</span> String name;\n\t<span class="code-keyword">private</span> String type;\n\t<span class="code-keyword">private</span> String engine;\n\t<span class="code-keyword">private</span> String manufacturer;\n\t<span class="code-keyword">private</span> Calendar productionDate; \n\n    <span class="code-comment">/**Getter Setter*/</span>\n}</code></pre>\n<p>然后针对这个实体声明一个校验器。校验器要实现<em>org.springframework.validation.Validator</em>接口：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.springvalidation.validator;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">VehicleValidator</span> <span class="code-keyword">implements</span> <span\n            class="code-title">Validator</span> </span>{\n\t<span class="code-keyword">private</span> List&lt;String&gt; _TYPE = Arrays.asList(<span\n            class="code-keyword">new</span> String[] { <span class="code-string">"CAR"</span>, <span\n            class="code-string">"SUV"</span>, <span class="code-string">"MPV"</span> });\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">boolean</span> <span\n            class="code-title">supports</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> </span>{\n        <span class="code-comment">//将验证器和实体类进行绑定，如果这里返回false在验证过程中会抛出类型不匹配的异常</span>\n\t\t<span class="code-keyword">return</span> Vehicle.class.isAssignableFrom(clazz);\n\t}\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">validate</span><span\n            class="hljs-params">(Object target, Errors errors)</span> </span>{ <span class="code-comment">//验证数据</span>\n\t\tVehicle vehicle = Vehicle.class.cast(target);\n\t\t<span class="code-keyword">if</span> (<span class="code-keyword">null</span> == vehicle.getName()) {\n            <span class="code-comment">//使用验证工具绑定结果</span>\n\t\t\tValidationUtils.rejectIfEmpty(errors, <span class="code-string">"name"</span>, <span class="code-string">"name.empty"</span>, <span\n            class="code-string">"车辆名称为空"</span>);\n\t\t}\n\t\t<span class="code-keyword">if</span> (!_TYPE.contains(vehicle.getType())) {\n            <span class="code-comment">//向Error添加验证错误信息</span>\n\t\t\t&lt;<span class="hljs-number">2</span>&gt; errors.rejectValue(<span class="code-string">"type"</span>, <span\n            class="code-string">"type.error"</span>, <span class="code-string">"汽车类型必须是"</span> + _TYPE);\n\t\t}\n        <span class="code-comment">//More validate ......</span>\n\t}\n}</code></pre>\n<p>有了验证对象（JavaBean）和对应的验证器（Validator）就完成了一组验证功能。注意<em>VehicleValidator::validate</em>方法传递的errors参数，验证工具会将错误实例传递进来交给开发者去组装验证结果。\n</p>\n<p>代码中的ValidationUtils就是数据校验工具，他提供了2个功能：</p>\n<ol>\n    <li>执行校验（接下来会马上介绍）。</li>\n    <li>提供错误信息绑定的功能，例如<em>ValidationUtils.rejectIfEmpty</em>这一行代码。会将对应的信息写入到Errors中。</li>\n</ol>\n<p>有了验证对象和验证器就可以执行验证：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">SpringValidationApp</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">private</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">springValidation</span><span class="hljs-params">(ApplicationContext ctx)</span> </span>{\n\t\tVehicleValidator vehicleValidator = <span class="code-keyword">new</span> VehicleValidator();<span\n            class="code-comment">//创建验证器</span>\n\t\tVehicle vehicle = <span class="code-keyword">new</span> Vehicle();<span class="code-comment">//创建验证对象</span>\n\t\t&lt;<span class="hljs-number">1</span>&gt; ValidationError error = <span class="code-keyword">new</span> ValidationError(<span\n            class="code-string">"Vehicle"</span>);<span class="code-comment">//创建错误信息</span>\n\t\tValidationUtils.invokeValidator(vehicleValidator, vehicle, error);<span class="code-comment">//执行验证</span>\n\t\tList&lt;FieldError&gt; list = error.getFieldErrors();\n\t\t<span class="code-keyword">int</span> count = <span class="hljs-number">1</span>;\n        <span class="code-comment">//输出验证结果</span>\n\t\t<span class="code-keyword">for</span>(FieldError res : list) {\n\t\t\tprint(<span class="code-string">"Error Info "</span>, count++ , <span class="code-string">"."</span>);\n\t\t\tprint(<span class="code-string">"Entity:"</span>, res.getObjectName());\n\t\t\tprint(<span class="code-string">"Field:"</span>, res.getField());\n\t\t\tprint(<span class="code-string">"Code:"</span>, res.getCode());\n\t\t\tprint(<span class="code-string">"Message:"</span>, res.getDefaultMessage());\n\t\t\tprint(<span class="code-string">"-"</span>);\n\t\t}\n\t}\n}</code></pre>\n<p>执行完毕后，ValidationError中记录了所有校验错误信息。错误信息分为4个部分：</p>\n<ul>\n    <li>验证的对象的名称：在执行验证器的代码中&lt;1&gt;部分创建错误对象时指定。Vehicle就是验证对象的名称。</li>\n    <li>错误的域、错误code和错误信息：每一个错误都有对应的域、错误编码以及错误信息，在验证器&lt;2&gt;位置的代码就是指定错误信息。</li>\n</ul>\n<p>以上错误信息可以通过<em>error.getFieldErrors();</em>来获取。</p>\n<p>如果JavaBean有嵌套的结构，可以在校验器中调用其他的校验器来实现嵌套检验。先为Vehicle类增加一个Gearbox（变速箱）域：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.springvalidation.entity;\n<span class="code-comment">//车辆信息</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Vehicle</span> </span>{\n\t<span class="code-keyword">private</span> String name;\n\t<span class="code-keyword">private</span> String type;\n\t<span class="code-keyword">private</span> String engine;\n\t<span class="code-keyword">private</span> String manufacturer;\n    <span class="code-keyword">private</span> Gearbox gearbox; <span class="code-comment">//Gearbox是另外一个实例</span>\n\t<span class="code-keyword">private</span> Calendar productionDate; \n\n    <span class="code-comment">/**Getter Setter*/</span>\n}</code></pre>\n<pre><code class="java"><span class="code-comment">//变速箱</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Gearbox</span> </span>{\n\t<span class="code-keyword">private</span> String name;\n\t<span class="code-keyword">private</span> String manufacturer;\n\n    <span class="code-comment">/**Getter Setter*/</span>\n}</code></pre>\n<p>在校验器VehicleValidator::validate中增加对Gearbox验证：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">VehicleValidator</span> <span class="code-keyword">implements</span> <span\n        class="code-title">Validator</span> </span>{\n\t<span class="code-meta">@Autowired</span>\n\tGearboxValidator gearboxValidator; <span class="code-comment">//用于校验Gearbox的校验器</span>\n\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">validate</span><span class="hljs-params">(Object target, Errors errors)</span> </span>{\n\t\tVehicle vehicle = Vehicle.class.cast(target);\n\n\t\t<span class="code-comment">//some code ......</span>\n        \n\t\t}\n\t\t<span class="code-keyword">if</span>(<span class="code-keyword">null</span> == vehicle.getGearbox()) {\n\t\t\terrors.rejectValue(<span class="code-string">"gearbox"</span>, <span\n            class="code-string">"gearbox.error"</span>, <span class="code-string">"变速箱信息为空"</span>);\n\t\t}<span class="code-keyword">else</span> {\n            <span class="code-comment">//指定子实体的名称</span>\n\t\t\terrors.pushNestedPath(<span class="code-string">"gearbox"</span>);\n            <span class="code-comment">//执行对Gearbox的校验</span>\n            ValidationUtils.invokeValidator(gearboxValidator, vehicle.getGearbox(), errors);\n\t\t}\n\t}\n}</code></pre>\n\n<h2 id="h2-2"><em>Bean Validation</em>数据校验</h2>\n<p>Spring现在推荐使用<em>Bean Validation</em>来进行数据校验，而且已经整合到Spring MVC框架中。</p>\n<p>在Spring中使用<em>Bean Validation</em>和<a href="https://www.chkui.com/article/java/java_bean_validation" title="Java数据校验详解">Java数据校验详解</a>一文中介绍的内容差不多——也是注解和校验器组成一个约束，通过注解来控制校验的过程。\n</p>\n<p>Spring核心部分没有提供<em>Bean Validation相关的实现类，所以需要引入对应的实现框架。本文引入的是</em><a href="http://hibernate.org/validator/"\n                                                                       rel="nofollow">Hibernate Validator</a>，他包括验证器和el，详情可以看源码根目录的build.gradle文件。\n</p>\n<p>首先我们向IoC容器中添加全局校验器：</p>\n<pre><code class="java"><span class="code-meta">@Configuration</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">SpringValidationConfig</span> </span>{\n\n\t<span class="code-meta">@Bean</span>(<span class="code-string">"validator"</span>)\n\t<span class="hljs-function"><span class="code-keyword">public</span> Validator <span\n            class="code-title">validator</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> LocalValidatorFactoryBean();\n}</code></pre>\n<p>这一段添加Bean的代码非常简单，就是新建了一个<em>LocalValidatorFactoryBean</em>实例。LocalValidatorFactoryBean实现了javax.validation.Validator接口，并且会自动使用已经引入的<em>Bean\n    Validation</em>框架。</p>\n<p>然后向Vehicle增加<em>Bean Validation相关的</em>注解：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">Vehicle</span> </span>{\n\t<span class="code-meta">@NotBlank</span>\n\t<span class="code-keyword">private</span> String name;\n\t<span class="code-meta">@NotBlank</span>\n\t<span class="code-meta">@VehicleType</span>\n\t<span class="code-keyword">private</span> String type;\n\t<span class="code-meta">@NotBlank</span>\n\t<span class="code-keyword">private</span> String engine;\n\t<span class="code-meta">@NotBlank</span>\n\t<span class="code-keyword">private</span> String manufacturer;\n\t&lt;<span class="hljs-number">3</span>&gt; <span class="code-meta">@Valid</span> <span class="code-comment">//@Valid的作用是对嵌套的解构进行校验</span>\n\t<span class="code-keyword">private</span> Gearbox gearbox;\n\t<span class="code-meta">@Valid</span>\n\t<span class="code-keyword">private</span> Tyre tyre;\n\t<span class="code-meta">@VehicleProductionDate</span>\n\t<span class="code-keyword">private</span> Calendar productionDate;\n\n    <span class="code-comment">/**Getter Setter*/</span>\n\n}</code></pre>\n<p>在上面的代码中，除了常规的@NotBlank等注解，还有@VehicleType这个自定义注解。在代码&lt;3&gt;的位置<em><a href="https://my.oschina.net/u/3652407"\n                                                                         class="referer" target="_blank">@Valid</a></em>是告诉校验器还要对gearbox的实例进行校验，相当于前面介绍的嵌套校验功能。最后我们使用检验器来对<em>Vehicle</em>的实例进行校验：\n</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">SpringValidationApp</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(SpringValidationConfig.class);\n\t\tBeanValidation(ctx);<span class="code-comment">//JSR规范验证</span>\n\t}\n\n\t<span class="hljs-function"><span class="code-keyword">private</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">BeanValidation</span><span class="hljs-params">(ApplicationContext ctx)</span> </span>{\n\t\tValidator validator = ctx.getBean(Validator.class);<span class="code-comment">//获取校验器</span>\n\t\tVehicle vehicle = <span class="code-keyword">new</span> Vehicle();<span class="code-comment">//新建要校验的对象</span>\n\t\tvalidator.validate(vehicle).forEach(err -&gt; { <span class="code-comment">//执行校验</span>\n\t\t\tprint(<span class="code-string">"Field: "</span>, err.getPropertyPath());\n\t\t\tprint(<span class="code-string">"Error: "</span>, err.getMessage());\n\t\t});\n\t}\n}</code></pre>\n<p>关于<em>Bean Validation的详细使用方法已经在</em>&nbsp;<a href="https://www.chkui.com/article/java/java_bean_validation"\n\t\t\t\t\t\t\t\t\t\t\t\ttitle="Java数据校验详解">Java数据校验详解</a>介绍。</p>\n\n<h2 id="h2-3">兼容Bean Validation和Spring Validation</h2>\n<p>一些相对比较久远的项目可能会遇见在<em>Spring Validation</em>的基础上新增<em>Bean Validation</em>功能的情况。可以使用SpringValidatorAdapter适配器来解决这个问题：\n</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">SpringValidationApp</span> </span>{\n\n\t<span class="hljs-function"><span class="code-keyword">private</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">adapterValidation</span><span class="hljs-params">(ApplicationContext ctx)</span> </span>{\n\t\t<span class="code-comment">// 获取校验器</span>\n\t\t<span class="code-comment">// LocalValidatorFactoryBean继承了SpringValidatorAdapter</span>\n        <span class="code-comment">// 所以这里就是获取LocalValidatorFactoryBean</span>\n\t\tSpringValidatorAdapter adapter = ctx.getBean(SpringValidatorAdapter.class);\n\n\t\tVehicle vehicle = <span class="code-keyword">new</span> Vehicle();<span class="code-comment">// 检验对象</span>\n\t\tValidationError error = <span class="code-keyword">new</span> ValidationError(<span class="code-string">"Vehicle"</span>);\n\t\t\n\t\t<span class="code-comment">// Spring Validation</span>\n\t\tValidationUtils.invokeValidator(adapter, vehicle, error);<span class="code-comment">//执行校验</span>\n\t\tList&lt;FieldError&gt; list = error.getFieldErrors();<span class="code-comment">//检验信息</span>\n\n\t\t<span class="code-comment">// Bean Validation 校验</span>\n\t\tadapter.validate(vehicle).forEach(err -&gt; { <span class="code-comment">// 执行检验&amp;输出校验结果</span>\n\t\t\tprint(<span class="code-string">"Field: "</span>, err.getPropertyPath());\n\t\t\tprint(<span class="code-string">"Error: "</span>, err.getMessage());\n\t\t});\n\t}\n}</code></pre>\n<p>上面的代码使用SpringValidatorAdapter分别执行了<em>Bean Validation</em>和<em>Spring\n    Validation</em>。可以将SpringValidatorAdapter看作一个<em>org.springframework.validation.Validator</em>的实现类用ValidationUtils来执行校验，而验证的过程完全是按照Bean\n    Validation的规范来执行的。</p>\n\n<h2 id="h2-4">方法参数校验</h2>\n<p>除了校验一个实体类，Spring在<em>Bean Validation</em>的基础上使用<a\n        href="https://www.chkui.com/article/spring/spring_core_bean_post_processors" title="IOC处理器扩展">后置处理器</a>和AOP实现了方法参数的检验。例如下面的方法：\n</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">PersonService</span> </span>{\n\t<span class="code-keyword">public</span> <span class="code-meta">@NotBlank</span> <span class="hljs-function">String <span\n            class="code-title">execute</span><span class="hljs-params">(@NotBlank(message = <span class="code-string">"必须设置人员名称"</span>)</span> String name,\n\t\t\t@<span class="code-title">Min</span><span class="hljs-params">(value = <span class="hljs-number">18</span>, message = <span\n                class="code-string">"年龄必须大于18"</span>)</span> <span class="code-keyword">int</span> age)</span>;\n}</code></pre>\n<p>他表示返回数据不能为空字符串，传入的2个参数name不能为空字符串、age必须大于18。</p>\n<p>要启用方法参数校验关键点是引入MethodValidationPostProcessor并在需要验证的Bean上增加一个@Validated注解。</p>\n<p>先通过@Configuration引入后置处理器：</p>\n<pre><code class="java"><span class="code-meta">@Configuration</span>\n<span class="code-meta">@ComponentScan</span>(<span class="code-string">"chkui.springcore.example.hybrid.springvalidation.service"</span>)\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">SpringValidationConfig</span> </span>{\n\t<span class="code-meta">@Bean</span>(<span class="code-string">"validator"</span>)\n\t<span class="hljs-function"><span class="code-keyword">public</span> Validator <span\n            class="code-title">validator</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> LocalValidatorFactoryBean();\n\t}\n\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> MethodValidationPostProcessor <span\n            class="code-title">methodValidationPostProcessor</span><span\n            class="hljs-params">(Validator validator)</span> </span>{\n\t\tMethodValidationPostProcessor postProcessor = <span class="code-keyword">new</span> MethodValidationPostProcessor();\n\t\tpostProcessor.setValidator(validator);\n\t\t<span class="code-keyword">return</span> postProcessor;\n\t}\n}</code></pre>\n<p>然后实现上面的PersonService接口并标记@Validated表示这个类中的方法要进行参数校验：</p>\n<pre><code class="java"><span class="code-meta">@Service</span>\n<span class="code-meta">@Validated</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">PersonServiceImpl</span> <span class="code-keyword">implements</span> <span\n            class="code-title">PersonService</span> </span>{\n\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span\n            class="code-title">execute</span><span class="hljs-params">(String name, <span\n            class="code-keyword">int</span> age)</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"I\'m "</span> + name + <span\n            class="code-string">". "</span> + age + <span class="code-string">" years old."</span>;\n\t}\n}</code></pre>\n<p>最后使用这个Service：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">SpringValidationApp</span> </span>{\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(SpringValidationConfig.class);\n\t\tmethodValidation(ctx);<span class="code-comment">//方法参数校验</span>\n\t}\n\t\n\t<span class="hljs-function"><span class="code-keyword">private</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">methodValidation</span><span class="hljs-params">(ApplicationContext ctx)</span> </span>{\n\t\t<span class="code-comment">//对方法进行参数校验</span>\n\t\t<span class="code-keyword">try</span> {\n\t\t\tPersonService personService = ctx.getBean(PersonService.class);\n\t\t\tpersonService.execute(<span class="code-keyword">null</span>, <span class="hljs-number">1</span>);<span\n            class="code-comment">//传递参数</span>\n\t\t} <span class="code-keyword">catch</span> (ConstraintViolationException error) {\n\t\t\terror.getConstraintViolations().forEach(err -&gt; {<span class="code-comment">//输出校验错误信息</span>\n\t\t\t\tprint(<span class="code-string">"Field: "</span>, err.getPropertyPath());\n\t\t\t\tprint(<span class="code-string">"Error: "</span>, err.getMessage());\n\t\t\t});\n\t\t}\n\t}\n}</code></pre>\n<p>在运行的过程中，如果参数或返回数据不符合验证规则会抛出ConstraintViolationException异常，可以从中获取校验错误的信息。</p>'},379:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<p>笼统的说一个系统主要是由3个部分组成的：</p>\n<ol>\n    <li>执行程序：主要负责处理业务逻辑，对接用户操作。</li>\n    <li>内部数据：嵌套在源码中的数据，用于指导程序运行。</li>\n    <li>外部数据：业务数据，外部配置数据。</li>\n</ol>\n<p>\n    内部数据本身就是程序的一部分，在Java中这些数据通常停留在类的静态成员变量中。而外部数据往往与代码无关，所以对于程序而言要“读懂”它们需要进行一些前置处理。例如用户在前端页面提交的数据我们从RequestContext中获取的数据类型都是字符串，而我们的业务需要将字符串转换成数字、列表、对象等等，这就引入了我们接下来要介绍的内容——数据类型转换。</p>\n<p>JavaBean对于J2SE或者J2EE而言有着非常重要的意义，ORACLE为了统一各个组织对JavaBean的使用方式制定了详尽的JavaBean规范，包括<code><a\n        href="https://docs.oracle.com/javase/8/docs/api/java/beans/BeanInfo.html" target="_blank" rel="nofollow">BeanInfo</a>、<a\n        href="https://docs.oracle.com/javase/8/docs/api/java/beans/PropertyEditor.html" target="_blank" rel="nofollow">PropertyEditor</a>、</code><code><a\n        href="https://docs.oracle.com/javase/8/docs/api/java/beans/PropertyEditorSupport.html" target="_blank"\n        rel="nofollow">PropertyEditorSupport</a></code>等方面的内容。本文会涉及到JavaBean的一些规范，但是重点是介绍Spring的数据管理。</p>\n<p>（可执行代码请到本人gitee库下载，本文的代码在<em>chkui.springcore.example.hybrid.beanmanipulation</em>包）</p>\n\n<h2 id="h2-1">Properties结构转换为实体</h2>\n<p>标准资源文件*.properties是Java程序常用的数据存储文件，Spring提供了BeanWrapper接口将*.properties文件中的数据转换成一个标准的JavaBean对象。看下面的例子：</p>\n<p>有一个实体类Person：</p>\n<pre><code class="java"><span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">Person</span> </span>{\n\t<span class="code-keyword">private</span> String name;\n\t<span class="code-keyword">private</span> <span class="code-keyword">int</span> age;\n\t<span class="code-keyword">private</span> <span class="code-keyword">boolean</span> license;\n\t<span class="code-keyword">private</span> Date birtday;\n\t<span class="code-keyword">private</span> Address address;\n\t<span class="code-keyword">private</span> Map&lt;String, String&gt; otherInfo;\n\n    <span class="code-comment">// Getter &amp; Setter ......</span>\n}\n</code></pre>\n<p>然后可以通过BeanWrapper将Properties对象中的数据设置到对象中：</p>\n<pre><code class="java">   <span class="hljs-function"><span class="code-keyword">private</span> <span\n        class="code-keyword">void</span> <span class="code-title">simpleDataBind</span><span\n        class="hljs-params">()</span> </span>{\n\t\tBeanWrapper wrapper = <span class="code-keyword">new</span> BeanWrapperImpl(<span\n            class="code-keyword">new</span> Person());\n\t\t\n\t\t<span class="code-comment">//使用 BeanWrapper::setPropertyValue 接口设置数据</span>\n\t\twrapper.setPropertyValue(<span class="code-string">"name"</span>, <span class="code-string">"niubility"</span>);\n\t\twrapper.setPropertyValue(<span class="code-string">"age"</span>, <span class="hljs-number">18</span>);\n\t\twrapper.setPropertyValue(<span class="code-string">"license"</span>, <span class="code-keyword">true</span>);\n\t\tprint(wrapper.getWrappedInstance());\n\n\t\t<span class="code-comment">//使用 Properties对象设置数据，Properties实例可以来源于*.properties文件</span>\n\t\tProperties p = <span class="code-keyword">new</span> Properties();\n\t\tp.setProperty(<span class="code-string">"name"</span>, <span class="code-string">"From Properties"</span>);\n\t\tp.setProperty(<span class="code-string">"age"</span>, <span class="code-string">"25"</span>);\n\t\tp.setProperty(<span class="code-string">"license"</span>, <span class="code-string">"false"</span>);\n\t\tp.setProperty(<span class="code-string">"otherInfo[birthday]"</span>, <span\n            class="code-string">"2000-01-01"</span>);\n\t\twrapper.setPropertyValues(p);\n\t\tprint(wrapper.getWrappedInstance());\n\t}</code></pre>\n<p>这样，使用Spring的BeanWrapper接口，可以快速的将Properties数据结构转换为一个JavaBean实体。</p>\n<p>除了配置单个实体的数据，BeanWrapper还可以为嵌套结构的实体设置数据。现在增加一个实体Vehicle：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">Vehicle</span> </span>{\n\t<span class="code-keyword">private</span> String name;\n\t<span class="code-keyword">private</span> String manufacturer;\n\t<span class="code-keyword">private</span> Person person; <span class="code-comment">//Person对象</span>\n\n    <span class="code-comment">// Getter &amp; Setter ......</span>\n\n}</code></pre>\n<p>在Vehicle中有一个Person类型的成员变量（person域），我们可以利用下面具备嵌套结构的语法来设置数据：</p>\n<pre><code class="java">   <span class="hljs-function"><span\n        class="code-keyword">private</span> BeanManipulationApp <span class="code-title">nestedDataBind</span><span\n        class="hljs-params">()</span> </span>{\n\t\t<span class="code-comment">// 数据嵌套转换</span>\n\t\tBeanWrapper wrapper = <span class="code-keyword">new</span> BeanWrapperImpl(<span\n            class="code-keyword">new</span> Vehicle(<span class="code-keyword">new</span> Person()));\n\n\t\tProperties p = <span class="code-keyword">new</span> Properties();\n\t\tp.setProperty(<span class="code-string">"name"</span>, <span class="code-string">"Envision"</span>);\n\t\tp.setProperty(<span class="code-string">"manufacturer"</span>, <span class="code-string">"Buick"</span>);\n\t\t\n\t\t<span class="code-comment">//person.name表示设置person域的name变量数值</span>\n\t\tp.setProperty(<span class="code-string">"person.name"</span>, <span class="code-string">"Alice"</span>);\n\t\tp.setProperty(<span class="code-string">"person.age"</span>, <span class="code-string">"25"</span>);\n\t\tp.setProperty(<span class="code-string">"person.license"</span>, <span class="code-string">"true"</span>);\n\t\tp.setProperty(<span class="code-string">"person.otherInfo[license code]"</span>, <span class="code-string">"123456789"</span>);\n\t\twrapper.setPropertyValues(p);\n\t\tprint(wrapper.getWrappedInstance());\n\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>;\n\t}</code></pre>\n<p>在*.properties文件中，经常使用<em>path.name=param</em>的的语法来指定一个嵌套结构（比如LOG4J的配置文件），这里也使用类似的方式来指定嵌套结构。person.name在程序执行时会调用Vehicle::getPerson::setName方法来设定数据。\n</p>\n<p>除了设定单个数据BeanWrapper还提供了更丰富的方法来设置数据，以上面的Vehicle、person为例：</p>\n<table border="1" cellpadding="1" cellspacing="1" style="width:500px">\n    <tbody>\n    <tr>\n        <th>表达式</th>\n        <th>效果</th>\n    </tr>\n    </tbody>\n    <tbody>\n    <tr>\n        <td><em>p.setProperty("name", "Envision")</em></td>\n        <td>name域的数据设置为"Envision"</td>\n    </tr>\n    <tr>\n        <td><em>p.setProperty("person.name", "Alice")</em></td>\n        <td>将嵌套的person域下的name数据设置为"Alice"</td>\n    </tr>\n    <tr>\n        <td><em>p.setProperty("list[1]", "Step2")</em></td>\n        <td>list域是一个列表，将第二个数据设置为"Step2"</td>\n    </tr>\n    <tr>\n        <td><em>p.setProperty("otherInfo[birthday]", "2000-01-01")</em></td>\n        <td>otherInfo域是一个Map，将key=birthday、value="2000-01-01"的数据添加到Map中。</td>\n    </tr>\n    </tbody>\n</table>\n<p>上面这4条规则可以组合使用，比如<em>p.setProperty("person.otherInfo[license code]", "123456789")。</em></p>\n<p>关于在Java如何使用Properties有很多讨论（<a href="https://stackoverflow.com/questions/70471/no-properties-in-java" target="_blank" rel="nofollow">比如这篇stackoverflow的问答</a>），BeanWrapper不仅仅是针对资源文件，他还衍生扩展了数据类型转换等等功能。\n</p>\n\n<h2 id="h2-2">PropertyEditor转换数据</h2>\n<p>在JavaBean规范中定义了<em>java.beans.PropertyEditor，</em>他的作用简单的说就是将字符串转换为任意对象结构。</p>\n<blockquote>\n    <p>PropertyEditor最早是用来支持java.awt中的可视化接口编辑数据的（详情见<a\n            href="https://docs.oracle.com/javase/tutorial/javabeans/advanced/customization.html" target="_blank" rel="nofollow">Oracle关于IDE数据定制化的介绍</a>）。但是在Spring或其他应用场景中更多的仅仅是用来做字符串到特定数据格式的转换（毕竟java.awt应用不多），所以PropertyEditor提供的BeanWrapper::paintValue之类的支持awt的方法不用太去关心他，主要聚焦在BeanWrapper::setAsText方法上。\n    </p>\n</blockquote>\n<p>BeanWrapper继承了PropertyEditorRegistry接口用于注册PropertyEditor。BeanWrapperImpl已经预设了很多有价值的PropertyEditor，比如上面的例子的代码<em>p.setProperty("age",\n    "25");</em>，age域是一个数字整型，而Properties中的数据都是字符串，在设置数据时会自动启用CustomNumberEditor将字符串转换为数字。</p>\n<p>Spring已经提供的PropertyEditor可以看这里的<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-beans-conversion" target="_blank"\n        rel="nofollow">清单</a>。需要注意的是，这些PropertyEditor并不是每一个都默认启用，比如CustomDateEditor必须由开发者提供DateFormat才能使用，所以需要像下面这样将其添加注册到BeanWrapper中：\n</p>\n<pre><code class="java"><span class="hljs-function"><span class="code-keyword">private</span> <span\n        class="code-keyword">void</span> <span class="code-title">propertyEditor</span><span\n        class="hljs-params">()</span> </span>{\n\tBeanWrapper wrapper = <span class="code-keyword">new</span> BeanWrapperImpl(<span class="code-keyword">new</span> Person());\n\n\t<span class="code-comment">// 设定日期转换格式</span>\n\tDateFormat df = <span class="code-keyword">new</span> java.text.SimpleDateFormat(<span class="code-string">"yyyy-MM-dd"</span>);\n\t\t\n\t<span class="code-comment">// 将Editor与DateFormat进行帮顶，使用指定的格式</span>\n\tCustomDateEditor dateEditor = <span class="code-keyword">new</span> CustomDateEditor(df, <span class="code-keyword">false</span>);\n\t\t\n\t<span class="code-comment">// 注册dateEditor，将其与Date类进行绑定</span>\n\twrapper.registerCustomEditor(Date.class, dateEditor);\n\n\t<span class="code-comment">// CustomNumberEditor执行转换</span>\n\twrapper.setPropertyValue(<span class="code-string">"age"</span>, <span class="code-string">"18"</span>);\n\t<span class="code-comment">// CustomBooleanEditor执行转换</span>\n\twrapper.setPropertyValue(<span class="code-string">"license"</span>, <span class="code-string">"false"</span>);\n\t<span class="code-comment">// dateEditor执行转换</span>\n\twrapper.setPropertyValue(<span class="code-string">"birtday"</span>, <span class="code-string">"1999-01-30"</span>);\n\tprint(wrapper.getWrappedInstance());\n}</code></pre>\n<p>添加之后，设定<em>setPropertyValue("birtday", "1999-01-30")</em>时会自动使用指定的DateFormat转换日期。</p>\n\n<h2 id="h2-3">自定义PropertyEditor</h2>\n<p>除了预设的各种PropertyEditor，我们还可以开发自定义的PropertyEditor。Person中有一个类型为Address的成员变量：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">Address</span> </span>{\n\t<span class="code-keyword">private</span> String province; <span class="code-comment">//省</span>\n\t<span class="code-keyword">private</span> String city;  <span class="code-comment">//市</span>\n\t<span class="code-keyword">private</span> String district;  <span class="code-comment">//区</span>\n\n    <span class="code-comment">// Getter &amp; Setter</span>\n}</code></pre>\n<p>我们为Address实体添加一个PropertyEditor，将特定格式的字符串转换为Address结构：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">AddressEditor</span> <span class="code-keyword">extends</span> <span class="code-title">PropertyEditorSupport</span> </span>{\n\t<span class="code-keyword">private</span> String[] SPLIT_FLAG = { <span class="code-string">","</span>, <span\n            class="code-string">"-"</span>, <span class="code-string">";"</span>, <span class="code-string">":"</span> };\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setAsText</span><span class="hljs-params">(String text)</span> </span>{\n\t\t<span class="code-keyword">int</span> pos = -<span class="hljs-number">1</span>;\n\t\tAddress address = <span class="code-keyword">new</span> Address();\n\t\t<span class="code-keyword">for</span> (String flag : SPLIT_FLAG) {\n\t\t\tpos = text.indexOf(flag);\n\t\t\t<span class="code-keyword">if</span> (-<span class="hljs-number">1</span> &lt; pos) {\n\t\t\t\tString[] split = text.split(flag);\n\t\t\t\taddress.setProvince(split[<span class="hljs-number">0</span>]);\n\t\t\t\taddress.setCity(split[<span class="hljs-number">1</span>]);\n\t\t\t\taddress.setDistrict(split[<span class="hljs-number">2</span>]);\n\t\t\t\t<span class="code-keyword">break</span>;\n\t\t\t}\n\t\t}\n\t\t<span class="code-keyword">if</span> (-<span class="hljs-number">1</span> == pos) {\n\t\t\t<span class="code-keyword">throw</span> <span class="code-keyword">new</span> IllegalArgumentException(<span\n            class="code-string">"地址格式错误"</span>);\n\t\t}\n\t\tsetValue(address);<span class="code-comment">//设定Address实例</span>\n\t}\n}</code></pre>\n<p>\n    通过AddressEditor::setAsText方法，可以将输入的字符串最红转换为一个Address实例。通常情况下开发一个Editor转换器不会直接去实现PropertyEditor接口，而是继承PropertyEditorSupport。</p>\n<p>然后我们使用AddressEditor来将字符串转换为Address对象：</p>\n<pre><code class="java"><span class="hljs-function"><span class="code-keyword">private</span> BeanManipulationApp <span\n        class="code-title">propertyEditor</span><span class="hljs-params">()</span> </span>{\n\t<span class="code-comment">//使用预设转换工具和自定义转换工具</span>\n\tBeanWrapper wrapper = <span class="code-keyword">new</span> BeanWrapperImpl(<span class="code-keyword">new</span> Person());\n\n\t<span class="code-comment">// 创建AddressEditor实例</span>\n\tAddressEditor addressEditor = <span class="code-keyword">new</span> AddressEditor();\n\t\t\n\t<span class="code-comment">// 注册addressEditor，将其与Address类进行绑定</span>\n\twrapper.registerCustomEditor(Address.class, addressEditor);\n\n    <span class="code-comment">// 设置值自动进行转化</span>\n\twrapper.setPropertyValue(<span class="code-string">"address"</span>, <span class="code-string">"广东-广州-白云"</span>);\n\tprint(wrapper.getWrappedInstance());\n}</code></pre>\n<p>按照JavaBean规范，PropertyEditor和对应的JavaBean可以使用命名规则来表示绑定关系，而无需显式的调用注册方法。</p>\n<p>\n    绑定的规则是：有一个JavaBean命名为Tyre，在相同的包下（package）有一个实现了PropertyEditor接口并且命名为TyreEditor的类，那么框架认为TyreEditor就是Tyre的Editor，无需调用BeanWrapper::registerCustomEditor方法来声明Tyre和TyreEditor的绑定关系，详情请看源码中chkui.springcore.example.hybrid.beanmanipulation.bean.Tyre的使用。</p>\n\n<h2 id="h2-4">IoC与数据转换整合</h2>\n<p>对于Spring的ApplicationContext而言，BeanWrapper、PropertyEditor都是相对比较底层的功能，在使用Spring\n    Ioc容器的时候可以直接将这些功能嵌入到Bean初始化中或MVC的requestContext的数据转换中。</p>\n<p>从框架使用者的角度来看，Spring的XML配置数据或者通过MVC接口传递数据都是字符串，因此PropertyEditor在处理这些数据时有极大的用武之地。IoC容器使用<a\n        href="https://www.chkui.com/article/spring/spring_core_bean_post_processors" title="IOC处理器扩展">后置处理器</a>CustomEditorConfigurer来管理Bean初始化相关的PropertyEditor。通过CustomEditorConfigurer可以使用所有预设的Editor，还可以增加自定义的Editor，下面是使用@Configurable启用CustomEditorConfigurer的例子：\n</p>\n<pre><code class="java"><span class="code-meta">@Configurable</span>\n<span class="code-meta">@ImportResource</span>(<span\n            class="code-string">"classpath:hybrid/beanmanipulation/config.xml"</span>)\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">BeanManipulationConfig</span> </span>{\n\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function">CustomEditorConfigurer <span class="code-title">customEditorConfigurer</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-comment">// 构建CustomEditorConfigurer</span>\n\t\tCustomEditorConfigurer configurer = <span class="code-keyword">new</span> CustomEditorConfigurer();\n\t\t\n\t\tMap&lt;Class&lt;?&gt;, Class&lt;? extends PropertyEditor&gt;&gt; customEditors = <span\n            class="code-keyword">new</span> HashMap&lt;&gt;();\n\t\t\n\t\t<span class="code-comment">// 添加AddressEditor和Address的绑定</span>\n\t\tcustomEditors.put(Address.class, AddressEditor.class);\n\t\t\n\t\t<span class="code-comment">// 添加绑定列表</span>\n\t\tconfigurer.setCustomEditors(customEditors);\n\t\t\n\t\t<span class="code-comment">// 通过PropertyEditorRegistrar注册PropertyEditor</span>\n\t\tconfigurer.setPropertyEditorRegistrars(<span class="code-keyword">new</span> PropertyEditorRegistrar[] { <span\n            class="code-keyword">new</span> DateFormatRegistrar() });\n\t\t<span class="code-keyword">return</span> configurer;\n\t}\n}</code></pre>\n<p><em>CustomEditorConfigurer::setCustomEditors</em>和<em>CustomEditorConfigurer::setPropertyEditorRegistrars</em>都可以向容器中添加PropertyEditor，最主要区别在于：\n</p>\n<ol>\n    <li>前者是直接申明一对绑定关系的类对象（Class&lt;?&gt;），例如<em>customEditors.put(Address.class, AddressEditor.class);</em>\n        这行代码并没有实例化AddressEditor，而是将实例化交给后置处理器。\n    </li>\n    <li>\n        而后者是提供一个实例化的PropertyEditor，比前者更能实现更复杂的功能。比如下面的DateFormatRegistrar代码，由于需要组装DateFormat和CustomDateEditor，所以使用PropertyEditorRegistrar来实现这个过程更加合理，后置处理器会在某个时候调用这个注册方法。\n    </li>\n</ol>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">DateFormatRegistrar</span> <span class="code-keyword">implements</span> <span\n        class="code-title">PropertyEditorRegistrar</span> </span>{\n\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">registerCustomEditors</span><span\n            class="hljs-params">(PropertyEditorRegistry registry)</span> </span>{\n\t\tDateFormat df = <span class="code-keyword">new</span> java.text.SimpleDateFormat(<span class="code-string">"yyyy-MM-dd"</span>);\n\t\tCustomDateEditor editor = <span class="code-keyword">new</span> CustomDateEditor(df, <span class="code-keyword">false</span>);\n\t\tregistry.registerCustomEditor(Date.class, editor);\n\t}\n}</code></pre>\n<p>配置好CustomEditorConfigurer之后，就可以直接在配置Bean的时候直接使用预定的格式了，比如：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span>&gt;</span>\n\t<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n            class="code-string">"person"</span> <span class="hljs-attr">class</span>=<span class="code-string">"chkui.springcore.example.hybrid.beanmanipulation.bean.Person"</span>&gt;</span>\n\t\t<span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"name"</span> <span class="hljs-attr">value</span>=<span\n                class="code-string">"XML"</span> /&gt;</span>\n\t\t<span class="code-comment">&lt;!-- 使用CustomNumberEditor转换 --&gt;</span>\n\t\t<span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"age"</span> <span class="hljs-attr">value</span>=<span\n                class="code-string">"20"</span> /&gt;</span>\n\t\t<span class="code-comment">&lt;!-- 使用CustomBooleanEditor转换 --&gt;</span>\n\t\t<span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"license"</span> <span class="hljs-attr">value</span>=<span\n                class="code-string">"1"</span> /&gt;</span>\n\t\t<span class="code-comment">&lt;!-- 使用CustomDateEditor转换 --&gt;</span>\n\t\t<span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"birtday"</span> <span class="hljs-attr">value</span>=<span class="code-string">"1998-12-30"</span> /&gt;</span>\n\t\t<span class="code-comment">&lt;!-- 使用AddressEditor转换 --&gt;</span>\n\t\t<span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"address"</span> <span class="hljs-attr">value</span>=<span class="code-string">"广东,深圳,南山"</span> /&gt;</span>\n\t<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n\t\n\t<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"chkui.springcore.example.hybrid.beanmanipulation.bean.Vehicle"</span>&gt;</span>\n\t\t<span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"name"</span> <span class="hljs-attr">value</span>=<span class="code-string">"Mercedes-Benz C-Class"</span> /&gt;</span>\n\t\t<span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"manufacturer"</span> <span class="hljs-attr">value</span>=<span\n                class="code-string">"Mercedes-Benz"</span> /&gt;</span>\n\t\t<span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"person"</span> <span class="hljs-attr">ref</span>=<span class="code-string">"person"</span> /&gt;</span>\n\t<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>此外，在Spring MVC中，可以SimpleFormController::initBinder方法将外部传入的数据和某个Bean进行绑定：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="code-keyword">final</span> <span\n        class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MyController</span> <span\n        class="code-keyword">extends</span> <span class="code-title">SimpleFormController</span> </span>{\n\n    <span class="code-comment">// 通过任何方式获取PropertyEditorRegistrar</span>\n    <span class="code-meta">@Autowired</span>\n    <span class="code-keyword">private</span> MyPropertyEditorRegistrar editorRegistrar;\n\n    <span class="hljs-function"><span class="code-keyword">protected</span> <span class="code-keyword">void</span> <span\n            class="code-title">initBinder</span><span class="hljs-params">(HttpServletRequest request,\n            ServletRequestDataBinder binder)</span> <span class="code-keyword">throws</span> Exception </span>{\n        <span class="code-comment">// 将Editor与当前Controller进行绑定</span>\n        <span class="code-keyword">this</span>.editorRegistrar.registerCustomEditors(binder);\n    }\n}</code></pre>\n<p>Spring MVC并不属于Sring核心功能范畴，这里就不展开了，需要了解的话看看SimpleFormController的JavaDoc文档即可。</p>\n'}});