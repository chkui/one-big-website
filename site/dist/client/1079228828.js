webpackJsonp([10],{334:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h2 id="h2-1">Hazelcast是什么</h2>\n<p>“分布式”、“集群服务”、“网格式内存数据”、“分布式缓存“、“弹性可伸缩服务”——这些牛逼闪闪的名词拿到哪都是ITer装逼的不二之选。在Javaer的世界，有这样一个开源项目，只需要引入一个jar包、只需简单的配置和编码即可实现以上高端技能，他就是 <em>Hazelcast</em>。</p>\n<p><em>Hazelcast </em>是由Hazelcast公司（没错，这公司也叫Hazelcast！）开发和维护的开源产品，可以为基于jvm环境运行的各种应用提供分布式集群和分布式缓存服务。Hazelcast可以嵌入到任何使用Java、C++、.NET开发的产品中（C++、.NET只提供客户端接入）。Hazelcast目前已经更新到3.X版本，Java中绝大部分数据结构都被其以为分布式的方式实现。比如Javaer熟悉的Map接口，当通过Hazelcast创建一个Map实例后，在节点A调用&nbsp;<em>Map::put("A","A_DATA")&nbsp;</em>方法添加数据，节点B使用&nbsp;<em>Map::get("A")&nbsp;</em>可以获到值为<em>"A_DATA" </em>的数据<em>。Hazelcast </em>提供了 <em>Map、Queue、MultiMap、Set、List、Semaphore、Atomic&nbsp;</em>等接口的分布式实现；提供了基于<em>Topic&nbsp;</em>实现的消息队列或订阅\\发布模式；提供了分布式id生成器（<em>IdGenerator</em>）；提供了分布式事件驱动（<em>Distributed Events</em>）；提供了分布式计算（<em>Distributed Computing</em>）；提供了分布式查询（<em>Distributed Query</em>）。总的来说在独立jvm经常使用数据结果或模型&nbsp;<em>Hazelcast </em>都提供了分布式集群的实现。</p>\n<p><em>Hazelcast </em>有开源版本和商用版本。开源版本遵循 <em>Apache License 2.0&nbsp;</em>开源协议免费使用。商用版本需要获取特定的License，两者之间最大的区别在于：商用版本提供了数据高密度存储。我们都知道jvm有自己特定的GC机制，无论数据是在堆还是栈中，只要发现无效引用的数据块，就有可能被回收。而<em>Hazelcast</em>的分布式数据都存放在jvm的内存中，频繁的读写数据会导致大量的GC开销。使用商业版的<em>Hazelcast</em>会拥有高密度存储的特性，大大降低Jvm的内存开销，从而降低GC开销。</p>\n<p>很多开源产品都使用Hazelcast 来组建微服务集群，例如咱们的Vert.x，首选使用Hazelcast来组建分布式服务。有兴趣可以看我的这篇分享——<a title="Vert.x 如何创建集群" href="https://www.chkui.com/article/vertx/vertx_source_code_how_to_create_cluster" >Vert.x 如何创建集群</a> ，文中说明了Vert.x如何使用Hazelcast组建集群。</p>\n<p>附：</p>\n<ul>\n    <li>Hazelcast源码：<a title="Hazelcast开源项目源码" href="https://github.com/hazelcast/hazelcast" rel="nofollow">https://github.com/hazelcast/hazelcast</a></li>\n    <li>关于Hazelcast的问题可以到<a title="Hazelcast问题Github提交" href="https://github.com/hazelcast/hazelcast/issues" rel="nofollow">https://github.com/hazelcast/hazelcast/issues</a>或<a title="Hazelcast问题stackoverflow" href="http://stackoverflow.com" rel="nofollow">http://stackoverflow.com</a>。</li>\n</ul>\n<h2 id="h2-2">Hazelcast的特性</h2>\n<h3 id="h3-1">自治集群（无中心化）</h3>\n<p><em>Hazelcast </em>没有任何中心节点（文中的节点可以理解为运行在任意服务器的独立jvm，下同），或者说<em>Hazelcast </em>不需要特别指定一个中心节点。在运行的过程中，它自己选定集群中的某个节点作为中心点来管理所有的节点。</p>\n<h3 id="h3-2">数据按应用分布式存储</h3>\n<p><em>Hazelcast </em>的数据是分布式存储的。他会将数据尽量存储在需要使用该项数据的节点上，以实现数据去中心化的目的。在传统的数据存储模型中（<em>MySql、MongDB、Redis&nbsp;</em>等等）数据都是独立于应用单独存放，当需要提升数据库的性能时，需要不断加固单个数据库应用的性能。即使是现在大量的数据库支持集群模式或读写分离，但是基本思路都是某几个库支持写入数据，其他的库不断的拷贝更新数据副本。这样做的坏处一是会产生大量脏读的问题，二是消耗大量的资源来传递数据——从数据源频繁读写数据会耗费额外资源，当数据量增长或创建的主从服务越来越多时，这个消耗呈指数级增长。</p>\n<p>使用 <em>Hazelcast </em>可以有效的解决数据中心化问题。他将数据分散的存储在每个节点中，节点越多越分散。每个节点都有各自的应用服务，而Hazelcast集群会根据每个应用的数据使用情况分散存储这些数据，在应用过程中数据会尽量“靠近”应用存放。这些在集群中的数据共享整个集群的存储空间和计算资源。</p>\n<h3 id="h3-3">抗单点故障</h3>\n<p>集群中的节点是无中心化的，每个节点都有可能随时退出或随时进入。因此，在集群中存储的数据都会有一个备份（可以配置备份的个数，也可以关闭数据备份）。这样的方式有点类似于 <em>hadoop</em>，某项数据存放在一个节点时，在其他节点必定有至少一个备份存在。当某个节点退出时，节点上存放的数据会由备份数据替代，而集群会重新创建新的备份数据。</p>\n<h3 id="h3-4">简易性</h3>\n<p>所有的 <em>Hazelcast </em>功能只需引用一个jar包，除此之外，他不依赖任何第三方包。因此可以非常便捷高效的将其嵌入到各种应用服务器中，而不必担心带来额外的问题（jar包冲突、类型冲突等等）。他仅仅提供一系列分布式功能，而不需要绑定任何框架来使用，因此适用于任何场景。</p>\n<p>除了以上特性，<em>Hazelcast </em>还支持服务器/客户端模型，支持脚本管理、能够和 <em>Docker </em>快速整合等等。</p>\n<h2 id="h2-3">简单使用例子</h2>\n<p>前面说了那么多概念，必须要来一点干货了。下面是一个使用 <em>Hazelcast </em>的极简例子。文中的所有代码都在github上：<a title="随风溜达的向日葵github-Hazelcast" href="https://github.com/chkui/hazelcast-demo" rel="nofollow">https://github.com/chkui/hazelcast-demo</a>。</p>\n<p>首先引入<em>Hazelcast</em>的jar包。</p>\n<p><em>Maven（pom.xml）</em>：</p>\n<pre class="dust"><code class="language-xml"><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">dependency</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n    </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">groupId</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">com.hazelcast</span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">groupId</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n    </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">artifactId</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">hazelcast</span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">artifactId</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n\t</span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">version</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">$</span><span class="code-template-variable">{hazelcast.vertsion}</span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">version</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n</span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">dependency</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span></code></pre>\n<p><em>Gradle（build.gradle）</em>：</p>\n<pre class="nginx"><code class="language-xml"><span class="code-attribute">compile</span> com.hazelcast:hazelcast:<span class="code-variable">${hazelcast.vertsion}</span></code></pre>\n<p>先创一个建 <em>Hazelcast </em>节点：</p>\n<pre class="javascript"><code class="language-java"><span class="code-comment"><span class="code-comment">//org.palm.hazelcast.getstart.HazelcastGetStartServerMaster </span></span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">HazelcastGetStartServerMaster</span></span></span><span class="hljs-class"> </span></span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword"><span class="code-keyword">static</span></span> <span class="code-keyword"><span class="code-keyword">void</span></span> <span class="code-title">main</span><span class="hljs-params">(<span class="code-built_in">String</span>[] args)</span> </span>{\n\t\t<span class="code-comment"><span class="code-comment">// 创建一个 hazelcastInstance实例</span></span>\n\t\tHazelcastInstance instance = Hazelcast.newHazelcastInstance();\n\t\t<span class="code-comment"><span class="code-comment">// 创建集群Map</span></span>\n\t\t<span class="code-built_in">Map</span>&lt;Integer, <span class="code-built_in">String</span>&gt; clusterMap = instance.getMap(<span class="code-string"><span class="code-string">"MyMap"</span></span>);\n\t\tclusterMap.put(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="code-string"><span class="code-string">"Hello hazelcast map!"</span></span>);\n\n\t\t<span class="code-comment"><span class="code-comment">// 创建集群Queue</span></span>\n\t\tQueue&lt;<span class="code-built_in">String</span>&gt; clusterQueue = instance.getQueue(<span class="code-string"><span class="code-string">"MyQueue"</span></span>);\n\t\tclusterQueue.offer(<span class="code-string"><span class="code-string">"Hello hazelcast!"</span></span>);\n\t\tclusterQueue.offer(<span class="code-string"><span class="code-string">"Hello hazelcast queue!"</span></span>);\n\t}\n}</code></pre>\n<p>上面的代码使用&nbsp;<em>Hazelcast </em>实例创建了一个节点。然后通过这个实例创建了一个分布式的Map和分布式的Queue，并向这些数据结构中添加了数据。运行这个main方法，会在console看到以下内容：</p>\n<blockquote>\n    <p>Members [1] {<br> &nbsp;&nbsp; &nbsp;Member [192.168.1.103]:5701 this<br> }</p>\n</blockquote>\n<p>随后再创建另外一个节点：</p>\n<pre class="cs"><code class="language-java"><span class="code-comment"><span class="code-comment">// org.palm.hazelcast.getstart.HazelcastGetStartServerSlave</span></span>\n<span class="code-keyword"><span class="code-keyword">public</span></span> <span class="hljs-class"><span class="code-keyword"><span class="code-keyword">class</span></span> <span class="code-title"><span class="code-title">HazelcastGetStartServerSlave</span></span> </span>{\n\t<span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">public</span></span></span><span class="hljs-function"> </span><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">static</span></span></span><span class="hljs-function"> </span><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">void</span></span></span><span class="hljs-function"> </span><span class="code-title"><span class="hljs-function"><span class="code-title">main</span></span></span><span class="hljs-params"><span class="hljs-function">(<span class="hljs-params">String[] args</span>)</span></span><span class="hljs-function"> </span></span>{\n\t\t<span class="code-comment"><span class="code-comment">//创建一个 hazelcastInstance实例</span></span>\n\t\tHazelcastInstance instance = Hazelcast.newHazelcastInstance();\n\t\tMap&lt;Integer, String&gt; clusterMap = instance.getMap(<span class="code-string"><span class="code-string">"MyMap"</span></span>);\n\t\tQueue&lt;String&gt; clusterQueue = instance.getQueue(<span class="code-string"><span class="code-string">"MyQueue"</span></span>);\n\t\t\n\t\tSystem.<span class="code-keyword">out</span>.println(<span class="code-string"><span class="code-string">"Map Value:"</span></span> + clusterMap.<span class="code-keyword">get</span>(<span class="hljs-number"><span class="hljs-number">1</span></span>));\n\t\tSystem.<span class="code-keyword">out</span>.println(<span class="code-string"><span class="code-string">"Queue Size :"</span></span> + clusterQueue.size());\n\t\tSystem.<span class="code-keyword">out</span>.println(<span class="code-string"><span class="code-string">"Queue Value 1:"</span></span> + clusterQueue.poll());\n\t\tSystem.<span class="code-keyword">out</span>.println(<span class="code-string"><span class="code-string">"Queue Value 2:"</span></span> + clusterQueue.poll());\n\t\tSystem.<span class="code-keyword">out</span>.println(<span class="code-string"><span class="code-string">"Queue Size :"</span></span> + clusterQueue.size());\n\t}\n}</code></pre>\n<p>该节点的作用是从<em>Map、Queue</em>中读取数据并输出。运行会看到以下输出</p>\n<blockquote>\n    <p>Members [2] {<br> &nbsp;&nbsp; &nbsp;Member [192.168.1.103]:5701<br> &nbsp;&nbsp; &nbsp;Member [192.168.1.103]:5702 this<br> }</p>\n    <p>八月 06, 2016 11:33:29 下午 com.hazelcast.core.LifecycleService<br> 信息: [192.168.1.103]:5702 [dev] [3.6.2] Address[192.168.1.103]:5702 is STARTED<br> Map Value:Hello hazelcast map!<br> Queue Size :2<br> Queue Value 1:Hello hazelcast!<br> Queue Value 2:Hello hazelcast queue!<br> Queue Size :0</p>\n</blockquote>\n<p>至此，2个节点的集群创建完毕。第一个节点向map实例添加了{key:1,value:"Hello hazelcast map!"}，向queue实例添加[“Hello hazelcast!”,“Hello hazelcast queue!”]，第二个节点读取并打印这些数据。</p>\n<p>除了直接使用Hazelcast服务来组建集群，Hazelcast还提供了区别于服务端的客户端应用包。客户端与服务端最大的不同是：他不会存储数据也不能修改集群中的数据。目前客户端有C++、.Net、Java多种版本。</p>\n<p>使用客户端首先要引入客户端jar包。</p>\n<p><em>Maven（pom.xml）</em>：</p>\n<pre class="dust"><code class="language-xml"><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">dependency</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n    </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">groupId</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">com.hazelcast</span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">groupId</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n    </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">artifactId</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">hazelcast-client</span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">artifactId</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n    </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">version</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">$</span><span class="code-template-variable">{hazelcast.version}</span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">version</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n</span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">dependency</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span></code></pre>\n<p><em>Gradle（build.gradle）</em>：</p>\n<pre class="nginx"><code class="nginx"><span class="code-attribute"><span class="code-attribute">compile</span></span> com.hazelcast:hazelcast-client:<span class="code-variable"><span class="code-variable">${hazelcast.vertsion}</span></span></code></pre>\n<p>创建一个client节点。</p>\n<pre class="cs"><code class="language-java"><span class="code-keyword"><span class="code-keyword">public</span></span> <span class="hljs-class"><span class="code-keyword"><span class="code-keyword">class</span></span> <span class="code-title"><span class="code-title">HazelcastGetStartClient</span></span> </span>{\n\t<span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">public</span></span></span><span class="hljs-function"> </span><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">static</span></span></span><span class="hljs-function"> </span><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">void</span></span></span><span class="hljs-function"> </span><span class="code-title"><span class="hljs-function"><span class="code-title">main</span></span></span><span class="hljs-params"><span class="hljs-function">(<span class="hljs-params">String[] args</span>)</span></span><span class="hljs-function"> </span></span>{\n\t\tClientConfig clientConfig = <span class="code-keyword"><span class="code-keyword">new</span></span> ClientConfig();\n\t\tHazelcastInstance instance = HazelcastClient.newHazelcastClient(clientConfig);\n\t\tMap&lt;Integer, String&gt; clusterMap = instance.getMap(<span class="code-string"><span class="code-string">"MyMap"</span></span>);\n\t\tQueue&lt;String&gt; clusterQueue = instance.getQueue(<span class="code-string"><span class="code-string">"MyQueue"</span></span>);\n\t\t\n\t\tSystem.<span class="code-keyword">out</span>.println(<span class="code-string"><span class="code-string">"Map Value:"</span></span> + clusterMap.<span class="code-keyword">get</span>(<span class="hljs-number"><span class="hljs-number">1</span></span>));\n\t\tSystem.<span class="code-keyword">out</span>.println(<span class="code-string"><span class="code-string">"Queue Size :"</span></span> + clusterQueue.size());\n\t\tSystem.<span class="code-keyword">out</span>.println(<span class="code-string"><span class="code-string">"Queue Value 1:"</span></span> + clusterQueue.poll());\n\t\tSystem.<span class="code-keyword">out</span>.println(<span class="code-string"><span class="code-string">"Queue Value 2:"</span></span> + clusterQueue.poll());\n\t\tSystem.<span class="code-keyword">out</span>.println(<span class="code-string"><span class="code-string">"Queue Size :"</span></span> + clusterQueue.size());\n\t}\n}</code></pre>\n<p>然后先启动 <em>HazelcastGetStartServerMaster::main</em>，再启动 <em>HazelcastGetStartClient::main</em>。可以看到客户端输出：</p>\n<blockquote>\n    <p>Members [1] {<br> &nbsp;&nbsp; &nbsp;Member [192.168.197.54]:5701<br> }</p>\n    <p>八月 08, 2016 10:54:22 上午 com.hazelcast.core.LifecycleService<br> 信息: HazelcastClient[hz.client_0_dev][3.6.2] is CLIENT_CONNECTED<br> Map Value:Hello hazelcast map!<br> Queue Size :2<br> Queue Value 1:Hello hazelcast!<br> Queue Value 2:Hello hazelcast queue!<br> Queue Size :0</p>\n</blockquote>\n<p>至此，客户端功能也创建完毕&nbsp;。可以看到客户端的console输出内容比服务端少了很多，这是因为客户端不必承载服务端的数据处理功能，也不必维护各种节点信息。</p>\n\n<h2 id="h2-4">例子运行解析</h2>\n<p>下面我们根据console的输出来看看 <em>Hazelcast </em>启动时到底干了什么事。（下面的输出因环境或IDE不同，可能会有差异）</p>\n<blockquote>\n    <p><span style="color:#FF0000">class: com.hazelcast.config.XmlConfigLocator<br> info:&nbsp;Loading \'hazelcast-default.xml\' from classpath.&nbsp;</span></p>\n</blockquote>\n<p>这里输出的内容表示<em>Hazelcast</em>启动时加载的配置文件。如果用户没有提供有效的配置文件，<em>Hazelcast</em>会使用默认配置文件。后续的文章会详细说明 <em>Hazelcast </em>的配置。</p>\n<blockquote>\n    <p><span style="color:#FF0000">class: com.hazelcast.instance.DefaultAddressPicker<br> info: Prefer IPv4 stack is true.<br> class: com.hazelcast.instance.DefaultAddressPicker<br> info:&nbsp;Picked Address[192.168.197.54]:5701, using socket ServerSocket[addr=/0:0:0:0:0:0:0:0,localport=5701], bind any local is true</span></p>\n</blockquote>\n<p>这一段输出说明了当前 <em>Hazelcast </em>的网络环境。首先是检测IPv4可用且检查到当前的IPv4地址是192.168.197.54。然后使用IPv6启用socket。在某些无法使用IPv6的环境上，需要强制指定使用IPv4，增加jvm启动参数：<em>-Djava.net.preferIPv4Stack=true</em> 即可。</p>\n<blockquote>\n    <p><span style="color:#FF0000">class: com.hazelcast.system<br> info:&nbsp;Hazelcast 3.6.2 (20160405 - 0f88699) starting at Address[192.168.197.54]:5701<br> class: com.hazelcast.system<br> info: [192.168.197.54]:5701 [dev] [3.6.2] Copyright (c) 2008-2016, Hazelcast, Inc. All Rights Reserved.</span></p>\n</blockquote>\n<p>这一段输出说明了当前实例的初始化端口号是5701。<em>Hazelcast&nbsp;</em>默认使用5701端口。如果发现该端口被占用，会+1查看5702是否可用，如果还是不能用会继续向后探查直到5800。<em>Hazelcast&nbsp;</em>默认使用5700到5800的端口，如果都无法使用会抛出启动异常。</p>\n<blockquote>\n    <p><span style="color:#FF0000">class: com.hazelcast.system<br> info: [192.168.197.54]:5701 [dev] [3.6.2] Configured Hazelcast Serialization version : 1<br> class: com.hazelcast.spi.OperationService<br> info: [192.168.197.54]:5701 [dev] [3.6.2] Backpressure is disabled<br> class: com.hazelcast.spi.impl.operationexecutor.classic.ClassicOperationExecutor<br> info: [192.168.197.54]:5701 [dev] [3.6.2] Starting with 2 generic operation threads and 4 partition operation threads.</span></p>\n</blockquote>\n<p>这一段说明了数据的序列化方式和启用的线程。<em>Hazelcast </em>在节点间传递数据有2种序列化方式，在后续的文章中国会详细介绍。<em>Hazelcast&nbsp;</em>会控制多个线程执行不同的工作，有负责维持节点连接的、有负责数据分区管理的。</p>\n<blockquote>\n    <p><span style="color:#FF0000">class: com.hazelcast.instance.Node<br> info: [192.168.197.54]:5701 [dev] [3.6.2] Creating MulticastJoiner<br> class: com.hazelcast.core.LifecycleService<br> info: [192.168.197.54]:5701 [dev] [3.6.2] Address[192.168.197.54]:5701 is STARTING<br> class: com.hazelcast.nio.tcp.nonblocking.NonBlockingIOThreadingModel<br> info: [192.168.197.54]:5701 [dev] [3.6.2] TcpIpConnectionManager configured with Non Blocking IO-threading model: 3 input threads and 3 output threads<br> class: com.hazelcast.cluster.impl.MulticastJoiner<br> info: [192.168.197.54]:5701 [dev] [3.6.2]&nbsp;</span></p>\n</blockquote>\n<p>上面这一段输出中，<span style="color:#000000">Creating MulticastJoiner表示使用组播协议来组建集群。还创建了6个用于维护非拥塞信息输出\\输出。</span></p>\n<blockquote>\n    <p><span style="color:#FF0000">Members [1] {</span><br> <span style="color:#FF0000">&nbsp;&nbsp;&nbsp;&nbsp;Member [192.168.197.54]:5701<br> &nbsp;&nbsp;&nbsp;&nbsp;Member [192.168.197.54]:5702&nbsp;this<br> }</span></p>\n    <p><span style="color:#FF0000">class: com.hazelcast.core.LifecycleService<br> info: [192.168.197.54]:5701 [dev] [3.6.2] Address[192.168.197.54]:5701 is STARTED</span><br> <span style="color:#FF0000">class: com.hazelcast.partition.InternalPartitionService<br> info: [192.168.197.54]:5701 [dev] [3.6.2] Initializing cluster partition table arrangement...</span></p>\n</blockquote>\n<p><span style="color:#000000">&nbsp;&nbsp;&nbsp;&nbsp;Members[2]表示当前集群只有2个节点。2个节点都在ip为</span>192.168.197.54<span style="color:#000000">的这台设备上，2个节点分别占据了5701端口和5702端口。端口后面的this说明这是当前节点，而未标记this的是其他接入集群的节点。最后InternalPartitionService输出的信息表示集群初始化了“数据分片”，后面会介绍“数据分片”的概念和原理。</span></p>\n<p><span style="color:#000000">&nbsp; &nbsp; 上面就是Hazelcast在默认情况下执行的启动过程，可以看出在初始化的过程中我们可以有针对性的修改一些Hazelcast的行为：</span></p>\n<ol>\n    <li>使用默认配置文档 <em>hazelcast-default.xml </em>来启动集群。<span style="color:#FF0000">因此我们可以自定义这个配置文件来影响<em>Hazelcast&nbsp;</em>的行为</span>。</li>\n    <li>启用IPv4或IPv6来建立集群，因此可以知道Hazelcast集群的通信是基于TCP、UDP，需要打开socket支持集群交互。<span style="color:#FF0000">因此我们可以指定使用的通讯方案</span>。</li>\n    <li><em>Hazelcast</em>会启动多个线程来执行不同的工作，有些负责维护数据、有些负责集群通信、有些负责一些基础操作。<span style="color:#FF0000">因此我们可以配置和管理这些线程</span>。</li>\n    <li><em>Hazelcast</em>默认使用<em>MulitCast</em>（组播协议）来组建集群，因此在局域网环境他可以无需配置自己完成集群组建。<span style="color:#FF0000">因此我们可以指定使用TCP/IP或其他通讯协议</span>。</li>\n    <li><em>Hazelcast</em>会自己探寻可以使用的端口，默认情况下会使用5700到5800间没有被占用的端口。<span style="color:#FF0000">因此我们可以配置这些端口如何使用</span>。</li>\n    <li><em>Hazelcast</em>初始化一个名为“数据分片”的方案来管理和存储数据。<span style="color:#FF0000">因此我们可以调整和控制这些数据分片</span>。</li>\n</ol>\n<p>以上所有红色字体的部分都可以通过配置文件来影响。在后续的文章中会详细介绍相关的 配置说明（待续）。</p>\n<p>-----------------------------------亮瞎人的分割线-----------------------------------</p>\n<p>如果对Hazelcast的基本原理没什么兴趣，就不用向下看“运行结构“和“数据分片原理”了，直接去 <a title="Hazelcast基本配置" href="https://www.chkui.com/article/hazelcast/hazelcast_configuration_management">Hazelcast基本配置</a>了解如何使用Hazelcast吧。</p>\n<h2 id="h2-5">Hazelcast运行结构</h2>\n<p>Hazelcast的官网上列举了2种运行模式，一种是p2p（点对点）模式、一种是在点对点模式上扩展的C/S模式。下图是p2p模式的拓补结构。</p>\n<p style="text-align:center"><img alt="" height="249" src="https://file.mahoooo.com/res/file/hazelcast_get_started_and_code_sample_1.png" width="334"></p>\n<p>在p2p模式中，所有的节点（Node）都是集群中的服务节点，提供相同的功能和计算能力。每个节点都分担集群的总体性能，每增加一个节点都可以线性增加集群能力。</p>\n<p>在p2p服务集群的基础上，我们可以增加许多客户端接入到集群中，这样就形成了集群的C/S模式，提供服务集群视作S端，接入的客户端视作C端。这些客户端不会分担集群的性能，但是会使用集群的各种资源。下图的结构就是客户端接入集群的情况。</p>\n<p style="text-align:center"><img alt="" height="257" src="https://file.mahoooo.com/res/file/hazelcast_get_started_and_code_sample_2.png" width="507"></p>\n<p>可以为客户端提供特别的缓存功能，告知集群让那些它经常要使用的数存放在“离它最近”的节点。</p>\n<h2 id="h2-6">Hazelcast分片概念与原理</h2>\n<p><em>Hazelcast</em>通过分片来存储和管理所有进入集群的数据，采用分片的方案目标是保证数据可以快速被读写、通过冗余保证数据不会因节点退出而丢失、节点可线性扩展存储能力。下面将从理论上说明<em>Hazelcast</em>是如何进行分片管理的。</p>\n<h3 id="h3-5">分片</h3>\n<p><em>Hazelcast</em>的每个数据分片（shards）被称为一个分区（Partitions）。分区是一些内存段，根据系统内存容量的不同，每个这样的内存段都包含了几百到几千项数据条目，默认情况下，<em>Hazelcast</em>会把数据划分为271个分区，并且每个分区都有一个备份副本。当启动一个集群成员时，这271个分区将会一起被启动。</p>\n<p>下图展示了集群只有一个节点时的分区情况。</p>\n<p><img alt="" height="234" src="https://file.mahoooo.com/res/file/hazelcast_get_started_and_code_sample_3.png" width="99"></p>\n<p>从一个节点的分区情况可以看出，当只启动一个节点时，所有的271个分区都存放在一个节点中。然后我们启动第二个节点。会出现下面这样的分区方式。</p>\n<p><img alt="" height="259" src="https://file.mahoooo.com/res/file/hazelcast_get_started_and_code_sample_4.png" width="214"></p>\n<p>二个节点的图中，用黑色文字标记的表示主分区，用蓝色文字标记的表示复制分区（备份分区）。第一个成员有135个主分区（黑色部分），所有的这些分区都会在第二个成员中有一个副本（蓝色部分），同样的，第一个成员也会有第二个成员的数据副本。</p>\n<p>当增加更多的成员时，<em>Hazelcast</em>会将主数据和备份数据一个接一个的迁移到新成员上，最终达成成员之间数据均衡且相互备份。当<em>Hazelcast</em>发生扩展的时候，只有最小数量的分区被移动。下图呈现了4个成员节点的分区分布情况。</p>\n<p><img alt="" height="258" src="https://file.mahoooo.com/res/file/hazelcast_get_started_and_code_sample_5.png" width="445"></p>\n<p>上面的几个图说明了的Hazelcast是如何执行分区的。通常情况下，分区的分布情况是无序的，他们会随机分布在集群中的各个节点中。最重要的是，Hazelcast会平均分配成员之前的分区，并均匀在的成员之间创建备份。</p>\n<p>在Hazelcast 3.6版本中，新增了一种集群成员：“精简成员”（lite members），他的特点是不拥有任何分区。“精简成员”的目标是用于“高密度运算”任务（computationally-heavy task executions。估计是指CPU密集型运算）或者注册监听（listener） 。虽然“精简成员”没有自己的分区，但是他们同样可以访问集群中其他成员的分区。</p>\n<p>总的来说，当集群中的节点发送变动时（进入或退出），都会导致分区在节点中移动并再平衡，以确保数据均匀存储。但若是“精简节点”的进入或退出，并不会出现重新划分分区情况，因为精简节点并不会保存任何分区。</p>\n\n<h3 id="h3-6">数据分区管理</h3>\n<p>创建了分区以后，Hazelcast会将所有的数据存放到每个分区中。它通过哈希运算将数据分布到每个分区中。获取存储数据Key值（例如map）或value值（例如topic、list），然后进行以下处理：</p>\n<ol>\n    <li>将设定的key或value转换成byte[]；</li>\n    <li>对转换后的byte[]进行哈希计算；</li>\n    <li>将哈希计算的结果和分区的数量（271）进行模运算（同余运算、mod运算、%运算）。</li>\n</ol>\n<p>因为byte[]是和271进行同模运算，因此计算结果一定会在0~270之间，根据这个值可以指定到用于存放数据的分区。</p>\n<h3 id="h3-7">分区表</h3>\n<p>当创建分区以后，集群中的所有成员必须知道每个分区被存储到了什么节点。因此集群还需要维护一个分区表来追踪这些信息。</p>\n<p>当启动第一个节点时，一个分区表将随之创建。表中包含分区的ID和标记了他所属的集群节点。分区表的目标就是让集群中所有节点（包括“精简节点”）都能获取到数据存储信息，确保每个节点都知道数据在哪。集群中最老的节点（通常情况下是第一个启动的成员）定期发送分区表给所有的节点。以这种方式，当分区的所有权发生变动时，集群中的所有节点都会被通知到。分区的所有权发生变动有很多种情况，比如，新加入一个节点、或节点离开集群等。如果集群中最早启动的节点被关闭，那么随后启动的节点将会继承发送分区表的任务，继续将分区表发送给所有成员。</p>'},349:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<p>使用apt安装好处在于统一升级方便，不用单独手工安装。默认情况下nginx已经支持apt-get安装，但是安装的包是比较老旧的10.x版本。我们可以通过添加nginx\n    deb安装源的方式来使用最新稳定版的nginx，还可以实时通过update和upgrade命令保持最新的未定版nginx。</p>\n\n<h2 id="h2-1">添加apt-key</h2>\n<pre class="css"><code class="language-bash"><span class="code-selector-tag">sudo</span> <span\n        class="code-selector-tag">apt-key</span> <span class="code-selector-tag">add</span> <span\n        class="code-selector-tag">nginx_signing</span><span class="code-selector-class">.key</span></code></pre>\n<p>由于需要使用nginx官方指定的deb源下载最新稳定版本的nginx，所以需要先添加一个信任公钥（PGP）。可以将下列公钥复制保存为一个名为nginx_signing.key的文件（也可到<a\n        href="http://nginx.org/keys/nginx_signing.key" rel="nofollow">官网</a>去下载）：</p>\n<pre class="groovy"><code class="groovy">-----BEGIN PGP PUBLIC KEY BLOCK-----\n<span class="code-string"><span class="code-string">Version:</span></span> GnuPG v2<span class="hljs-number"><span\n            class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.22</span></span> (GNU/Linux)\n\nmQENBE5OMmIBCAD+FPYKGriGGf7NqwKfWC83cBV01gabgVWQmZbMcFzeW+hMsgxH\nW6iimD0RsfZ9oEbfJCPG0CRSZ7ppq5pKamYs2+EJ8Q2ysOFHHwpGrA2C8zyNAs4I\nQxnZZIbETgcSwFtDun0XiqPwPZgyuXVm9PAbLZRbfBzm8wR/<span class="hljs-number"><span class="hljs-number">3</span></span>SWygqZBBLdQk5TE\nfDR+Eny<span class="hljs-regexp"><span class="hljs-regexp">/M1RVR4xClECONF9UBB2ejFdI1LD45APbP2hsN/</span></span>piFByU1t7yK2gpFyRt\n<span class="hljs-number"><span class="hljs-number">97</span></span>WzGHn9MV5/TL7AmRPM4pcr3JacmtCnxXeCZ8nLqedoSuHFuhwyDnlAbu8I16O5\nXRrfzhrHRJFM1JnIiGmzZi6zBvH0ItfyX6ttABEBAAG0KW5naW54IHNpZ25pbmcg\na2V5IDxzaWduaW5nLWtleUBuZ2lueC5jb20+iQE+BBMBAgAoAhsDBgsJCAcDAgYV\nCAIJCgsEFgIDAQIeAQIXgAUCV2K1+AUJGB4fQQAKCRCr9b2Ce9m<span class="hljs-regexp"><span\n            class="hljs-regexp">/YloaB/</span></span><span class="hljs-number"><span class="hljs-number">9</span></span>XGrol\nkocm7l<span class="hljs-regexp"><span class="hljs-regexp">/tsVjaBQCteXKuwsm4XhCuAQ6YAwA1L1UheGOG/</span></span>aa2xJvrXE8X32tgcTjr\nKoYoXWcdxaFjlXGTt6jV85qRguUzvMOxxSEM2Dn115etN9piPl0Zz+<span class="hljs-number"><span\n            class="hljs-number">4</span></span>rkx8+<span class="hljs-number"><span class="hljs-number">2</span></span>vJG\nF+eMlruPXg/zd88NvyLq5gGHEsFRBMVufYmHtNfcp4okC1klWiRIRSdp4QY1wdrN\n<span class="hljs-number"><span class="hljs-number">1</span></span>O+<span class="hljs-regexp"><span\n            class="hljs-regexp">/oCTl8Bzy6hcHjLIq3aoumcLxMjtBoclc/</span></span><span class="hljs-number"><span\n            class="hljs-number">5</span></span>OTioLDwSDfVx7rWyfRhcBzVbwD\noe<span class="hljs-regexp"><span class="hljs-regexp">/PD08AoAA6fxXvWjSxy+dGhEaXoTHjkCbz/</span></span>l6NxrK3JFyauDgU4K4MytsZ1HDi\nMgMW8hZXxszoICTTiQEcBBABAgAGBQJOTkelAAoJEKZP1bF62zmo79oH/<span class="hljs-number"><span\n            class="hljs-number">1</span></span>XDb29S\nYtWp+MTJTPFEwlWRiyRuDXy3wBd/BpwBRIWfWzMs1gnCjNjk0EVBVGa2grvy9Jtx\nJKMd6l<span class="hljs-regexp"><span class="hljs-regexp">/PWXVucSt+U/</span></span>+GO8rBkw14SdhqxaS2l14v6gyMeUrSbY3XfToGfwHC4sa/\nThn8X4jFaQ2XN5dAIzJGU1s5JA0tjEzUwCnmrKmyMlXZaoQVrmORGjCuH0I0aAFk\nRS0UtnB9HPpxhGVbs24xXZQnZDNbUQeulFxS4uP3OLDBAeCHl+v4t/uotIad8v6J\nSO93vc1evIje6lguE81HHmJn9noxPItvOvSMb2yPsE8mH4cJHRTFNSEhPW6ghmlf\nWa9ZwiVX5igxcvaIRgQQEQIABgUCTk5b0gAKCRDs8OkLLBcgg1G+AKCnacLb/+W6\ncflirUIExgZdUJqoogCeNPVwXiHEIVqithAM1pdY/gcaQZmIRgQQEQIABgUCTk5f\nYQAKCRCpN2E5pSTFPnNWAJ9gUozyiS+<span class="hljs-number"><span class="hljs-number">9</span></span>jf2rJvqmJSeWuCgVRwCcCUFhXRCpQO2Y\nVa3l3WuB+rgKjsQ=\n=EWWI\n-----END PGP PUBLIC KEY BLOCK-----</code></pre>\n<p>然后执行以下命令：</p>\n<pre class="css"><code class="language-bash"><span class="code-selector-tag">sudo</span> <span\n        class="code-selector-tag">apt-key</span> <span class="code-selector-tag">add</span> <span\n        class="code-selector-tag">nginx_signing</span><span class="code-selector-class">.key</span></code></pre>\n\n<h2 id="h2-2">设置apt的deb源</h2>\n<p>首先需要明确当前的ubuntu版本，在安装nginx时不同的ubuntu版本对应不同的nginx安装包。对照如下：</p>\n<table border="1" cellpadding="1" cellspacing="1" style="width:500px">\n    <tbody>\n    <tr>\n        <td>版本</td>\n        <td>安装包别名</td>\n        <td>适用平台</td>\n    </tr>\n    <tr>\n        <td>14.04</td>\n        <td>trusty</td>\n        <td>x86_64, i386, aarch64/arm64</td>\n    </tr>\n    <tr>\n        <td>16.04</td>\n        <td>xenial</td>\n        <td>x86_64, i386, ppc64el, aarch64/arm64</td>\n    </tr>\n    <tr>\n        <td>17.10</td>\n        <td>artful</td>\n        <td>x86_64, i386</td>\n    </tr>\n    </tbody>\n</table>\n<p>打开apt的安装源配置文件——/etc/apt/sources.list。在文件尾部添加：</p>\n<ul>\n    <li>deb http://nginx.org/packages/ubuntu/ <span style="color:#FF0000">code</span> nginx</li>\n    <li>deb-src http://nginx.org/packages/ubuntu/ <span style="color:#FF0000">code</span> nginx</li>\n</ul>\n<p>注意标红的code需要根据ubuntu的版本号按照上面的表替换对应的别名。</p>\n<p>设置好之后使用checklog命令可以看到现在已经切换到最新的稳定版本了。（不会输出日志，只有一个版本号）</p>\n\n<h2 id="h2-3">安装nginx</h2>\n<p>最后更新安装源列表，然后安装nginx。</p>\n<pre class="sql"><code class="language-bash">apt-get <span class="code-keyword">update</span>\napt-<span class="code-keyword">get</span> <span class="code-keyword">install</span> nginx</code></pre>\n\n<h2 id="h2-4">安装最新发布版本</h2>\n<p>除了稳定版本，也可以通过apt的方式安装最新发布版本（Mainline）。只需要修改安装源头的路径即可——将/etc/apt/sources.list中的deb源修改为：</p>\n<ul>\n    <li>deb http://nginx.org/packages/mainline/ubuntu/ <span style="color:#FF0000"><em>code</em></span> nginx</li>\n    <li>deb-src http://nginx.org/packages/mainline/ubuntu/ <span style="color:#FF0000"><em>code</em></span> nginx</li>\n</ul>\n<p>更多的安装方式详见<a href="http://nginx.org/en/docs/install.html" rel="nofollow">官网</a></p>'},384:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<p>使用spring的这几个配置，可以将旧&lt;xml&gt;配置形式完全使用Java实现，也可以和&lt;xml&gt;嵌套使用。</p>\n<p>@Configuration和@Bean可以配合使用,案例：</p>\n<p>传统XML配置：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n                class="code-string">"classA"</span> <span class="hljs-attr">class</span>=<span class="code-string">"com.ClassA"</span>&gt;</span>\n                <span class="code-tag">&lt;<span class="code-name">constructor-arg</span> <span\n                        class="hljs-attr">ref</span>=<span class="code-string">"ClassB"</span>/&gt;</span>\n        <span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n                class="code-string">"classB"</span> <span class="hljs-attr">class</span>=<span class="code-string">"com.ClassB"</span>&gt;</span>\n                <span class="code-tag">&lt;<span class="code-name">constructor-arg</span> <span\n                        class="hljs-attr">ref</span>=<span class="code-string">"c"</span>/&gt;</span>\n        <span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n                class="code-string">"classC"</span> <span class="hljs-attr">class</span>=<span class="code-string">"com.ClassC"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>对应的可以使用@Configuration和@Bean来实现：</p>\n<pre><code class="java"><span class="code-meta">@Configuration</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">config</span></span>{\n        <span class="code-keyword">public</span> <span class="code-meta">@Bean</span> <span class="hljs-function">ClassA <span\n            class="code-title">classA</span><span class="hljs-params">()</span> </span>{\n                <span class="code-keyword">return</span> <span class="code-keyword">new</span> ClassA(classB());\n        }\n        <span class="code-keyword">public</span> <span class="code-meta">@Bean</span> <span class="hljs-function">ClassB <span\n            class="code-title">classB</span><span class="hljs-params">()</span> </span>{\n                <span class="code-keyword">return</span> <span class="code-keyword">new</span> ClassB(c());\n        }\n        <span class="code-keyword">public</span> <span class="code-meta">@Bean</span> <span class="hljs-function">ClassC <span\n            class="code-title">classC</span><span class="hljs-params">()</span> </span>{\n\n        }\n}</code></pre>\n<p>@DependsOn注解类似于&lt;xml&gt;的depends-on元素，案例如下：</p>\n<pre><code class="java"><span class="code-meta">@DependsOn</span>({<span class="code-string">"classA"</span>,<span\n        class="code-string">"classB"</span>})\n<span class="code-meta">@Component</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">ClassC</span></span>{\n   <span class="code-comment">//codes here</span>\n}</code></pre>\n<p>这样，在初始化ClassC之前，一定会先初始化ClassA和ClassB。</p>\n<p>@Import是导入通过@Configuration配置的Bean。</p>\n<p>先通过@Configuration声明配置类</p>\n<pre><code class="java"><span class="code-meta">@Configuration</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Config</span> </span>{\n    <span class="code-keyword">public</span> <span class="code-meta">@Bean</span> <span\n            class="hljs-function">ClassA <span class="code-title">classA</span> <span\n            class="hljs-params">()</span> </span>{\n        <span class="code-keyword">return</span> <span class="code-keyword">new</span> ClassA();\n    }\n}</code></pre>\n<p>然后使用@Import导入配置类</p>\n<pre><code class="java"><span class="code-meta">@Configuration</span>\n<span class="code-meta">@Import</span>(Config.class)  <span class="code-comment">//导入CDConfig的配置</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">ConfigExt</span> </span>{\n    <span class="code-meta">@Bean</span>(name = <span class="code-string">"classB"</span>)\n    <span class="hljs-function"><span class="code-keyword">public</span> ClassB <span\n            class="code-title">classB</span><span class="hljs-params">(ClassA classA)</span> </span>{\n        <span class="code-comment">// 注入ClassA类型的bean</span>\n        <span class="code-keyword">return</span> <span class="code-keyword">new</span> ClassB(classA);\n    }\n}</code></pre>\n<p>@ImportResource类似于XML配置的&lt;import&gt;元素，如：&lt;import resource="importxml.xml" /&gt;。</p>\n<p>使用方式如下：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"classA"</span> <span class="hljs-attr">class</span>=<span\n        class="code-string">"com.ClassA"</span>&gt;</span>\n       <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n               class="code-string">"classB"</span> <span class="hljs-attr">ref</span>=<span\n               class="code-string">"classB"</span> /&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"classB"</span> <span class="hljs-attr">class</span>=<span\n        class="code-string">"com.ClassB"</span>/</span></code></pre>\n<p>Java类注入：</p>\n<pre><code class="java"><span class="code-meta">@Configuration</span>\n<span class="code-meta">@Import</span>(Config.class)  \n<span class="code-meta">@ImportResource</span>(<span class="code-string">"classpath:importxml.xml"</span>) <span\n            class="code-comment">//导入xml配置项</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">ConfigExt</span></span>{\n\n}</code></pre>'},406:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h2 id="h2-1">问题</h2>\n<ol>\n    <li>\n        在一组相同类型的数据中（对象、数组、字符串、整形等任意类型的数据结构）请用时间空间最优的方式查找缺失的一项。例如有一组数据["A","B","C","D","E","F","G"]，现在给到["B","D","A","F"."G"]，需要找到缺失数据"C"？数据的个数不定。\n    </li>\n    <li>扩展上面的问题，用最优的方式查找缺失的多项。</li>\n</ol>\n<h2 id="h2-2">解决</h2>\n<h3 id="h3-1">2层循环逐个比对查找</h3>\n<p>最简单的办法当然是逐项比对，几乎所有语言都提供对象实例、字符串、数字的比对方法。</p>\n<p>但是这样做有2个问题：</p>\n<ol>\n    <li>少量数据可行，但是海量数据肯定会非常慢，因为时间复杂度是O(n^2)。而且第一层循环是全遍历，第二层循要遍历n/2。</li>\n    <li>在比对过程中如果是字符串比对，效率会非常差。</li>\n</ol>\n<h3 id="h3-2">编码2叉树查找</h3>\n<p>可以对所有的事物进行有序编码，然后通过编码索引到对应的元素。编码也没有什么特别的要求，只要每增加一项将编码加一即可。例如上面的例子["A","B","C","D","E","F","G"]，对其编码建立索引：</p>\n<pre><code class="json">{1:<span class="code-string">"A"</span>,2:<span class="code-string">"B"</span>,3:<span\n        class="code-string">"C"</span>,4:<span class="code-string">"D"</span>,5:<span\n        class="code-string">"E"</span>,6:<span class="code-string">"F"</span>,7:<span class="code-string">"G"</span>}\n</code></pre>\n<p>这是一个标准的dict结构（Java中的map结构）。任何时候增加新的项目只要编码加一即可：</p>\n<pre><code class="json">{1:<span class="code-string">"A"</span>,2:<span class="code-string">"B"</span>,3:<span\n        class="code-string">"C"</span>,4:<span class="code-string">"D"</span>,5:<span\n        class="code-string">"E"</span>,6:<span class="code-string">"F"</span>,7:<span\n        class="code-string">"G"</span>,8:<span class="code-string">"ADD ITEM"</span>}\n</code></pre>\n<p>使用编码还有一个好处是还可以查找一组不同类型的数据。</p>\n<p>建立编码之后实际上就转换为一个数字查询问题。</p>\n<p>如果仅仅是查找一个缺失项，实际上有一个非常简便的算法——求和计算差值：</p>\n<pre><code class="python">    <span class="code-comment"># origin_numbers是所有编码的列表，例如[1,2,3,4,5,6,7,8,9,10]。</span>\n    <span class="code-comment"># random_numbers是缺失了一项的编码无序表，例如[6,2,5,4,7,8,9,10,1]。</span>\n    <span class="code-keyword">for</span> _num <span class="code-keyword">in</span> origin_numbers:\n        total_sum = total_sum + _num\n\n    <span class="code-keyword">for</span> _num <span class="code-keyword">in</span> random_numbers:\n        without_sum = without_sum + _num\n</code></pre>\n<p>差值正好是缺失的项目索引值。</p>\n<p>但是如果是查找多个缺失项，只能用2叉树：</p>\n<pre><code class="python"><span class="code-keyword">import</span> copy\n<span class="code-keyword">import</span> random <span class="code-keyword">as</span> rand\n<span class="code-keyword">import</span> datetime\n<span class="code-keyword">import</span> time\n\n\n<span class="code-comment"># 2叉树结构</span>\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">Link</span>:</span>\n    <span class="hljs-function"><span class="code-keyword">def</span> <span class="code-title">__init__</span><span\n            class="hljs-params">(self, value)</span>:</span>\n        self.value = value\n        self.left = <span class="code-keyword">None</span>\n        self.right = <span class="code-keyword">None</span>\n\n    <span class="hljs-function"><span class="code-keyword">def</span> <span class="code-title">insert</span><span\n            class="hljs-params">(self, value)</span>:</span>\n        <span class="code-keyword">if</span> value &lt; self.value:\n            self.__addLeftLeaf__(value)\n        <span class="code-keyword">else</span>:\n            self.__addRightLeaf__(value)\n\n    <span class="hljs-function"><span class="code-keyword">def</span> <span\n            class="code-title">__addLeftLeaf__</span><span class="hljs-params">(self, value)</span>:</span>\n        <span class="code-keyword">if</span> self.left <span class="code-keyword">is</span> <span class="code-keyword">not</span> <span\n            class="code-keyword">None</span>:\n            self.left.insert(value)\n        <span class="code-keyword">else</span>:\n            self.left = Link(value)\n\n    <span class="hljs-function"><span class="code-keyword">def</span> <span\n            class="code-title">__addRightLeaf__</span><span class="hljs-params">(self, value)</span>:</span>\n        <span class="code-keyword">if</span> self.right <span class="code-keyword">is</span> <span class="code-keyword">not</span> <span\n            class="code-keyword">None</span>:\n            self.right.insert(value)\n        <span class="code-keyword">else</span>:\n            self.right = Link(value)\n\n    <span class="hljs-function"><span class="code-keyword">def</span> <span class="code-title">traversal</span><span\n            class="hljs-params">(self, _list, _without)</span>:</span>\n        <span class="code-keyword">if</span> self.left <span class="code-keyword">is</span> <span class="code-keyword">not</span> <span\n            class="code-keyword">None</span>:\n            self.left.traversal(_list, _without)\n\n        length = len(_list)\n        <span class="code-keyword">if</span> <span class="hljs-number">0</span> &lt; length:\n            tail = _list[length - <span class="hljs-number">1</span>]\n            diff = self.value - (tail + <span class="hljs-number">1</span>)\n            <span class="code-keyword">if</span> <span class="hljs-number">0</span> &lt; diff:\n                <span class="code-keyword">for</span> _d <span class="code-keyword">in</span> range(<span\n            class="hljs-number">1</span>, diff + <span class="hljs-number">1</span>):\n                    _without.append(self.value - _d)\n\n        _list.append(self.value)\n\n        <span class="code-keyword">if</span> self.right <span class="code-keyword">is</span> <span class="code-keyword">not</span> <span\n            class="code-keyword">None</span>:\n            self.right.traversal(_list, _without)\n\n\n<span class="code-comment"># 从队列中移除项目</span>\n<span class="hljs-function"><span class="code-keyword">def</span> <span class="code-title">remove_number</span><span\n        class="hljs-params">(without_size, numbers)</span>:</span>\n    <span class="code-keyword">for</span> count <span class="code-keyword">in</span> range(without_size):\n        <span class="code-keyword">del</span> numbers[rand.randrange(len(numbers))]\n    <span class="code-keyword">return</span> numbers\n\n\n<span class="code-comment"># 使用有序数组生成随机数组</span>\n<span class="hljs-function"><span class="code-keyword">def</span> <span class="code-title">generation_random</span><span\n        class="hljs-params">(without_size, origin_numbers)</span>:</span>\n    origin_numbers_options = copy.copy(origin_numbers)\n    length = len(origin_numbers)\n    random_numbers = []\n\n    <span class="code-comment"># 随机</span>\n    <span class="code-keyword">while</span> <span class="hljs-number">0</span> &lt; length:\n        rand_number = rand.randrange(length)\n        random_numbers.append(origin_numbers_options[rand_number])\n        <span class="code-keyword">del</span> origin_numbers_options[rand_number]\n        length = len(origin_numbers_options)\n\n    <span class="code-keyword">return</span> remove_number(without_size, random_numbers)\n\n\n<span class="code-comment"># </span>\n<span class="hljs-function"><span class="code-keyword">def</span> <span\n        class="code-title">generation_origin_numbers</span><span class="hljs-params">(without_size=<span\n        class="hljs-number">1</span>, total=<span class="hljs-number">10000</span>)</span>:</span>\n    origin_numbers = list(range(total))\n    <span class="code-keyword">return</span> origin_numbers, generation_random(without_size, origin_numbers)\n\n\n<span class="hljs-function"><span class="code-keyword">def</span> <span class="code-title">tree_2_leaf</span><span\n        class="hljs-params">(numbers)</span>:</span>\n    root = Link(numbers[<span class="hljs-number">0</span>])\n    <span class="code-keyword">for</span> pos <span class="code-keyword">in</span> range(<span\n            class="hljs-number">1</span>, len(numbers)):\n        root.insert(numbers[pos])\n\n    <span class="code-comment"># 使用二叉树</span>\n    _list = []\n    _without = []\n\n    root.traversal(_list=_list, _without=_without)\n\n    <span class="code-keyword">return</span> _without\n\n\n<span class="hljs-function"><span class="code-keyword">def</span> <span\n        class="code-title">without_one_number</span><span\n        class="hljs-params">(origin_numbers, random_numbers)</span>:</span>\n    print(<span class="code-string">"=============== without_one_number start =================="</span>)\n    sum_search_start = time.time()\n    total_sum = <span class="hljs-number">0</span>\n    without_sum = <span class="hljs-number">0</span>\n    print(<span class="code-string">"Sum Search Begin.({})"</span>.format(datetime.datetime.now().strftime(<span\n            class="code-string">\'%H:%M:%S\'</span>)))\n    <span class="code-keyword">for</span> _num <span class="code-keyword">in</span> origin_numbers:\n        total_sum = total_sum + _num\n\n    <span class="code-keyword">for</span> _num <span class="code-keyword">in</span> random_numbers:\n        without_sum = without_sum + _num\n    tree_search_start = sum_search_end = time.time()\n    print(<span class="code-string">"Sum Search Complete.({})"</span>.format(datetime.datetime.now().strftime(<span\n            class="code-string">\'%H:%M:%S\'</span>)))\n    print(<span class="code-string">"Timer:{} S"</span>.format(sum_search_end - sum_search_start))\n    print(<span class="code-string">"Total Sum:{}"</span>.format(total_sum))\n    print(<span class="code-string">"Without One Number Sum:{}"</span>.format(without_sum))\n    print(<span class="code-string">"Without Number:{}"</span>.format(total_sum - without_sum))\n    print(<span class="code-string">"---"</span>)\n    print(<span class="code-string">"2 Tree Search Begin.({})"</span>.format(datetime.datetime.now().strftime(<span\n            class="code-string">\'%H:%M:%S\'</span>)))\n    without_number = tree_2_leaf(random_numbers)\n    print(<span class="code-string">"2 Tree Complete.({})"</span>.format(datetime.datetime.now().strftime(<span\n            class="code-string">\'%H:%M:%S\'</span>)))\n    print(<span class="code-string">"Timer:{} S"</span>.format(time.time() - tree_search_start))\n    print(<span class="code-string">"Without Element:{}"</span>.format(without_number))\n    print(<span class="code-string">"=============== without_one_number end =================="</span>)\n\n\n<span class="hljs-function"><span class="code-keyword">def</span> <span\n        class="code-title">without_multi_number</span><span class="hljs-params">(random_numbers)</span>:</span>\n    print(<span class="code-string">"=============== without_multi_number start =================="</span>)\n    start = time.time()\n    print(<span class="code-string">"Search Begin.({})"</span>.format(datetime.datetime.now().strftime(<span\n            class="code-string">\'%H:%M:%S\'</span>)))\n    without_number = tree_2_leaf(random_numbers)\n    print(<span class="code-string">"Search End.({})"</span>.format(datetime.datetime.now().strftime(<span\n            class="code-string">\'%H:%M:%S\'</span>)))\n    print(<span class="code-string">"Timer:{} S"</span>.format(time.time() - start))\n    print(<span class="code-string">"Without Element:{}"</span>.format(without_number))\n    print(<span class="code-string">"=============== without_multi_number end =================="</span>)\n\n\n<span class="code-keyword">if</span> __name__ == <span class="code-string">\'__main__\'</span>:\n    print(<span class="code-string">"Generation Numbers Begin.({})"</span>.format(datetime.datetime.now().strftime(<span\n            class="code-string">\'%H:%M:%S\'</span>)))\n    generation_number_start = time.time()\n    origin, random = generation_origin_numbers()\n    print(<span\n            class="code-string">"Generation Numbers Complete.({})"</span>.format(datetime.datetime.now().strftime(<span\n            class="code-string">\'%H:%M:%S\'</span>)))\n    generation_number_end = time.time()\n    print(<span class="code-string">"Timer:{} S"</span>.format(generation_number_end - generation_number_start))\n\n    without_one_number(origin, random)\n    without_multi_number(remove_number(<span class="hljs-number">4</span>, random))\n</code></pre>'}});