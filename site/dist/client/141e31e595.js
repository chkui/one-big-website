webpackJsonp([14],{363:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<p>在16.x版本之后React提供了Protals功能来解决模式对话框不在Dom根节点导致的一些BUG。除了Protal还有更多的方法去解决这些问题，本文来自David\n    Gilbertson的博客，详细解释了React中模式对话框的一些问题，以及他给出的解决方案，在了解Protals之前阅读这篇内容，能让你更加明白Protal的重要性。</p>\n<p>对于React的模式对话框，有很多方法可以实现但是并没有一个绝对正确的方法。这句话怎么理解呢？让我们先看看一个模式对话框的特性：</p>\n<ol>\n    <li>能够浮现在最上层，阻止用户的其他操作。</li>\n    <li>能够处理鼠标和键盘事件，例如关闭窗口事件。</li>\n    <li>接受外部传入一个回调函数，当用户进行某些操作的时候调用他，例如点击“确定”或“取消”按钮。</li>\n    <li>接受外部参数，可以设定大小、文字、处理器等等。</li>\n</ol>\n\n<h2 id="h2-1">模式对话框的实现思路</h2>\n<p>下面的这些图片是常见模式对话框的例子：</p>\n<p><img alt="React中的模式对话框" src="https://file.mahoooo.com/res/file/modals_in_react_2018_5_15_2.png"></p>\n<p><img alt="React中的模式对话框" src="https://file.mahoooo.com/res/file/modals_in_react_2018_5_15_3.png"></p>\n<p><img alt="React中的模式对话框" src="https://file.mahoooo.com/res/file/modals_in_react_2018_5_15_4.png"></p>\n<p>这些模式对话框都有一个全局的背景遮罩层、有头部或描述内容、有一些功能按钮、可以随意设定的宽度和高度、位置居中。</p>\n<p>在React中有三种方式实现模式对话框：</p>\n<ol>\n    <li>使用一个常规的组件作为一个模式对话框的包装组件，然后将我们自定义的内容作为子组件传递给模式对话框。例如这个项目：<a href="https://github.com/reactjs/react-modal"\n                                                                   rel="nofollow">https://github.com/reactjs/react-modal</a>。\n    </li>\n    <li>将模式对话框放置到HTML结构的顶层，将其设置为 <em>document.body </em>的子元素。例如：<a href="https://github.com/tajo/react-portal"\n                                                                   rel="nofollow">https://github.com/tajo/react-portal</a>\n    </li>\n    <li>将模式对话框作为整个组件结构中的顶层组件（根元素的子组件），通过全局的数据来控制他显示或隐藏。</li>\n</ol>\n<p>那这三种实现方式有什么问题呢：</p>\n<p>第一种方式有定位问题。如果你用这种方式实现模式对话框，你的HTML上下文会影响当前模式对话框的展示效果，所以这种方式很有可能会出现一些意向不到的问题。你真的认为&nbsp;<strong>position:\n    fixed</strong>&nbsp;可以让某个元素相对与浏览器窗口绝对定位吗？请看这个例子：&nbsp;<a href="https://output.jsbin.com/fepime/" rel="nofollow">https://output.jsbin.com/fepime/</a>，使用开发人员工具看看\n    <em>.top-div</em> 和 <em>.fixed-div</em> 的样式你就懂了。</p>\n<p>\n    第二种方式首先对于单元测试不友好，因为我们不得不把对话框作为body的子元素（或者其他某个真实DOM的子元素）来显示，那么得有浏览器的真实DOM才能看到效果。而且这种方式看起来挺“骇客”的，我们按照单向数据流的思路开发了整套个标准合理的React组件，最后不得不用&nbsp;<strong>ReactDOM.unstable_renderSubtreeIntoContainer() </strong>方法装载一个组件到body元素中，最终可能会导致虚拟DOM与真实DOM不一致或者服务端渲染遇到问题。‘unstable’前缀的含义是React官方明确告诉你：这玩意有坑，踩上了别怪我。详情请看React官方对<strong>unstable_renderSubtreeIntoContainer</strong>的说明。\n</p>\n<p>第三种方式在笔者看来是最合理最优秀的，下面就谈谈这种实现方式的思路。</p>\n\n<h2 id="h2-2">全局数据流控制模式对话框</h2>\n<p>实际上就是用flux或redux的方式去控制对话框显示或关闭。如果之前用过flux之类思路的工具，后面的内容分分钟就理解了。</p>\n<p>先看下模式对话框的组件结构：</p>\n<p><img alt="React中的模式对话框" src="https://file.mahoooo.com/res/file/modals_in_react_2018_5_15_1.png"></p>\n<p></p>\n<ul>\n    <li><strong>App.jsx</strong>——整个工程的根组件，通常不会在这里有什么特殊的处理。它首先会渲染其他所有的顶层组件，然后再最后渲染模式对话框组件。</li>\n    <li><strong>ModalConductor.jsx</strong>——模式框的管理组件，由他来控制当前应该渲染哪个模式框。</li>\n    <li><strong>SignIn.jsx、EditScreen.jsx等组件</strong>——具体样式的模式对话框。</li>\n</ul>\n<p>在这些组件之外，还有store来存储全局模式对话框的相关数据。<strong>store.currentModal </strong>用于指示显示哪个模式框的字符串，如果为 null\n    则表示没有任何模式框要显示，所以整个工程一次只显示一个模式框。</p>\n<p>下面我们看看组件实现过程。</p>\n<p>首先我们在任何位置都可以修改 <strong>store</strong> 。当我们通过某种方式将&nbsp;<strong>store.currentModal </strong>的值修改为<strong>&nbsp;signIn\n    后，ModalConductor </strong>会触发重新渲染并在内部判断要渲染<strong>&nbsp;SignIn </strong>组件。</p>\n<p>这是 <strong>ModalConductor</strong>&nbsp;的示意代码，通过switch语句判断要显示的组件：</p>\n<pre class="typescript"><code class="language-javascript"><span class="code-keyword"><span\n        class="code-keyword">import</span></span> React <span class="code-keyword">from</span> <span\n        class="code-string"><span class="code-string">\'react\'</span></span>;\n\n<span class="code-keyword"><span class="code-keyword">import</span></span> ExportDataModal <span class="code-keyword">from</span> <span\n            class="code-string"><span class="code-string">\'./ExportDataModal.jsx\'</span></span>;\n<span class="code-keyword"><span class="code-keyword">import</span></span> SignInModal <span\n            class="code-keyword">from</span> <span class="code-string"><span\n            class="code-string">\'./SignInModal.jsx\'</span></span>;\n<span class="code-keyword"><span class="code-keyword">import</span></span> FeedbackModal <span\n            class="code-keyword">from</span> <span class="code-string"><span\n            class="code-string">\'./FeedbackModal.jsx\'</span></span>;\n<span class="code-keyword"><span class="code-keyword">import</span></span> BoxDetailsModal <span class="code-keyword">from</span> <span\n            class="code-string"><span class="code-string">\'./BoxDetailsModal.jsx\'</span></span>;\n\n<span class="code-keyword"><span class="code-keyword">const</span></span> ModalConductor = props =&gt; {\n  <span class="code-keyword"><span class="code-keyword">switch</span></span> (props.currentModal) {\n    <span class="code-keyword"><span class="code-keyword">case</span></span> <span class="code-string"><span\n            class="code-string">\'EXPORT_DATA\'</span></span>:\n      <span class="code-keyword"><span class="code-keyword">return</span></span> &lt;ExportDataModal {...props}/&gt;;\n\n    <span class="code-keyword">case</span> <span class="code-string">\'SOCIAL_SIGN_IN\'</span>:\n      <span class="code-keyword">return</span> &lt;SignInModal {...props}/&gt;;\n\n    <span class="code-keyword">case</span> <span class="code-string">\'FEEDBACK\'</span>:\n      <span class="code-keyword">return</span> &lt;FeedbackModal {...props}/&gt;;\n\n    <span class="code-keyword">case</span> <span class="code-string">\'EDIT_BOX\'</span>:\n      <span class="code-keyword">return</span> &lt;BoxDetailsModal {...props}/&gt;;\n\n    <span class="code-keyword">default</span>:\n      <span class="code-keyword">return</span> <span class="hljs-literal">null</span>;\n  }\n};\n\n<span class="code-keyword">export</span> <span class="code-keyword">default</span> ModalConductor;</code></pre>\n<p>下面模式对话框组件的代码结构：</p>\n<pre class="javascript"><code class="language-javascript"><span class="code-keyword"><span\n        class="code-keyword">import</span></span> React <span class="code-keyword"><span\n        class="code-keyword">from</span></span> <span class="code-string"><span\n        class="code-string">\'react\'</span></span>;\n\n<span class="code-keyword"><span class="code-keyword">import</span></span> ModalWrapper <span class="code-keyword"><span\n            class="code-keyword">from</span></span> <span class="code-string"><span class="code-string">\'../ModalWrapper.jsx\'</span></span>;\n\n<span class="code-keyword"><span class="code-keyword">const</span></span> SignIn = props =&gt; {\n  <span class="code-keyword"><span class="code-keyword">const</span></span> signIn = provider =&gt; {\n    props.hideModal();\n    props.signIn(provider);\n  };\n\n  <span class="code-keyword"><span class="code-keyword">return</span></span> (\n    <span class="xml"><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span\n            class="code-name">ModalWrapper</span></span></span></span><span class="xml"><span class="code-tag">\n      {</span></span><span class="hljs-attr"><span class="xml"><span class="code-tag"><span\n            class="hljs-attr">...props</span></span></span></span><span class="xml"><span class="code-tag">}\n      </span></span><span class="hljs-attr"><span class="xml"><span class="code-tag"><span\n            class="hljs-attr">title</span></span></span></span><span class="xml"><span\n            class="code-tag">=</span></span><span class="code-string"><span class="xml"><span class="code-tag"><span\n            class="code-string">"Sign in"</span></span></span></span><span class="xml"><span class="code-tag">\n      </span></span><span class="hljs-attr"><span class="xml"><span class="code-tag"><span\n            class="hljs-attr">width</span></span></span></span><span class="xml"><span\n            class="code-tag">=</span></span><span class="code-string"><span class="xml"><span class="code-tag"><span\n            class="code-string">{400}</span></span></span></span><span class="xml"><span class="code-tag">\n      </span></span><span class="hljs-attr"><span class="xml"><span class="code-tag"><span\n            class="hljs-attr">showOk</span></span></span></span><span class="xml"><span class="code-tag">=</span></span><span\n            class="code-string"><span class="xml"><span class="code-tag"><span class="code-string">{false}</span></span></span></span><span\n            class="xml"><span class="code-tag">\n    &gt;</span></span></span><span class="xml">\n      </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span\n            class="code-name">p</span></span></span></span><span class="xml"><span\n            class="code-tag">&gt;</span></span></span><span class="xml">Choose your flavor</span><span class="code-tag"><span\n            class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span class="xml"><span\n            class="code-tag"><span class="code-name">p</span></span></span></span><span class="xml"><span\n            class="code-tag">&gt;</span></span></span><span class="xml">\n      </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span\n            class="code-name">button</span></span></span></span><span class="xml"><span class="code-tag"> </span></span><span\n            class="hljs-attr"><span class="xml"><span class="code-tag"><span\n            class="hljs-attr">onClick</span></span></span></span><span class="xml"><span\n            class="code-tag">=</span></span><span class="code-string"><span class="xml"><span class="code-tag"><span\n            class="code-string">{()</span></span></span></span><span class="xml"><span\n            class="code-tag"> =&gt;</span></span></span><span class="xml"> signIn(\'facebook\')}&gt;Facebook</span><span\n            class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span\n            class="xml"><span class="code-tag"><span class="code-name">button</span></span></span></span><span\n            class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n      </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span\n            class="code-name">button</span></span></span></span><span class="xml"><span class="code-tag"> </span></span><span\n            class="hljs-attr"><span class="xml"><span class="code-tag"><span\n            class="hljs-attr">onClick</span></span></span></span><span class="xml"><span\n            class="code-tag">=</span></span><span class="code-string"><span class="xml"><span class="code-tag"><span\n            class="code-string">{()</span></span></span></span><span class="xml"><span\n            class="code-tag"> =&gt;</span></span></span><span class="xml"> signIn(\'google\')}&gt;Google</span><span\n            class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span\n            class="xml"><span class="code-tag"><span class="code-name">button</span></span></span></span><span\n            class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n      </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span\n            class="code-name">button</span></span></span></span><span class="xml"><span class="code-tag"> </span></span><span\n            class="hljs-attr"><span class="xml"><span class="code-tag"><span\n            class="hljs-attr">onClick</span></span></span></span><span class="xml"><span\n            class="code-tag">=</span></span><span class="code-string"><span class="xml"><span class="code-tag"><span\n            class="code-string">{()</span></span></span></span><span class="xml"><span\n            class="code-tag"> =&gt;</span></span></span><span class="xml"> signIn(\'twitter\')}&gt;Twitter</span><span\n            class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span\n            class="xml"><span class="code-tag"><span class="code-name">button</span></span></span></span><span\n            class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n    </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span\n            class="code-name">ModalWrapper</span></span></span></span><span class="xml"><span\n            class="code-tag">&gt;</span></span></span></span>\n  );\n};\n\n<span class="code-keyword"><span class="code-keyword">export</span></span> <span class="code-keyword"><span\n            class="code-keyword">default</span></span> SignIn;</code></pre>\n<p>他内部使用了一个名为&nbsp;<strong>ModalWrapper </strong>的包装组件，用来显示模式对话框的效果，可以直接使用<a\n        href="https://github.com/reactjs/react-modal" rel="nofollow">https://github.com/reactjs/react-modal</a>或者自己实现，如下是一个模式框的包装组件：\n</p>\n<pre class="javascript"><code class="language-javascript"><span class="code-keyword"><span\n        class="code-keyword">import</span></span> React <span class="code-keyword"><span\n        class="code-keyword">from</span></span> <span class="code-string"><span\n        class="code-string">\'react\'</span></span>;\n<span class="code-keyword"><span class="code-keyword">const</span></span> {PropTypes} = React;\n\n<span class="code-keyword"><span class="code-keyword">const</span></span> ModalWrapper = props =&gt; {\n  <span class="code-keyword"><span class="code-keyword">const</span></span> handleBackgroundClick = e =&gt; {\n    <span class="code-keyword"><span class="code-keyword">if</span></span> (e.target === e.currentTarget) props.hideModal();\n  };\n\n  <span class="code-keyword"><span class="code-keyword">const</span></span> onOk = () =&gt; {\n    props.onOk();\n    props.hideModal();\n  };\n\n  <span class="code-keyword"><span class="code-keyword">const</span></span> okButton = props.showOk\n    ? (\n      <span class="xml"><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n              class="code-name"><span class="xml"><span class="code-tag"><span\n              class="code-name">button</span></span></span></span><span class="xml"><span class="code-tag">\n        </span></span><span class="hljs-attr"><span class="xml"><span class="code-tag"><span\n              class="hljs-attr">onClick</span></span></span></span><span class="xml"><span\n              class="code-tag">=</span></span><span class="code-string"><span class="xml"><span class="code-tag"><span\n              class="code-string">{onOk}</span></span></span></span><span class="xml"><span class="code-tag">\n        </span></span><span class="hljs-attr"><span class="xml"><span class="code-tag"><span\n              class="hljs-attr">disabled</span></span></span></span><span class="xml"><span\n              class="code-tag">=</span></span><span class="code-string"><span class="xml"><span class="code-tag"><span\n              class="code-string">{props.okDisabled}</span></span></span></span><span class="xml"><span\n              class="code-tag">\n      &gt;</span></span></span><span class="xml">\n        {props.okText}\n      </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span\n              class="xml"><span class="code-tag"><span class="code-name">button</span></span></span></span><span\n              class="xml"><span class="code-tag">&gt;</span></span></span></span>\n    ) : <span class="hljs-literal"><span class="hljs-literal">null</span></span>;\n\n  <span class="code-keyword"><span class="code-keyword">return</span></span> (\n    <span class="xml"><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">div</span></span></span></span><span\n            class="xml"><span class="code-tag"> </span></span><span class="hljs-attr"><span class="xml"><span\n            class="code-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span\n            class="code-tag">=</span></span><span class="code-string"><span class="xml"><span class="code-tag"><span\n            class="code-string">{handleBackgroundClick}</span></span></span></span><span class="xml"><span\n            class="code-tag">&gt;</span></span></span><span class="xml">\n      </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span\n            class="code-name">header</span></span></span></span><span class="xml"><span\n            class="code-tag">&gt;</span></span></span><span class="xml">\n        </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span\n            class="code-name">h1</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span\n            class="xml">{props.title}</span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span\n            class="code-name">h1</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span\n            class="xml">\n\n        </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span\n            class="code-name">button</span></span></span></span><span class="xml"><span class="code-tag"> </span></span><span\n            class="hljs-attr"><span class="xml"><span class="code-tag"><span\n            class="hljs-attr">onClick</span></span></span></span><span class="xml"><span\n            class="code-tag">=</span></span><span class="code-string"><span class="xml"><span class="code-tag"><span\n            class="code-string">{props.hideModal}</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span\n            class="xml">Close</span><span class="code-tag"><span class="xml"><span\n            class="code-tag">&lt;/</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span\n            class="code-name">button</span></span></span></span><span class="xml"><span\n            class="code-tag">&gt;</span></span></span><span class="xml">\n      </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span\n            class="xml"><span class="code-tag"><span class="code-name">header</span></span></span></span><span\n            class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n\n      {props.children}\n\n      {okButton}\n    </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">div</span></span></span></span><span\n            class="xml"><span class="code-tag">&gt;</span></span></span></span>\n  );\n};\n\nModalWrapper.defaultProps = {\n  title: <span class="code-string"><span class="code-string">\'\'</span></span>,\n  showOk: <span class="hljs-literal"><span class="hljs-literal">true</span></span>,\n  okText: <span class="code-string"><span class="code-string">\'OK\'</span></span>,\n  okDisabled: <span class="hljs-literal"><span class="hljs-literal">false</span></span>,\n  width: <span class="hljs-number"><span class="hljs-number">400</span></span>,\n  onOk: () =&gt; {}\n};\n\n<span class="code-keyword"><span class="code-keyword">export</span></span> <span class="code-keyword"><span\n            class="code-keyword">default</span></span> ModalWrapper;</code></pre>'},376:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h3 id="h3-1">使用PropTypes进行类型检查</h3>\n<p>当应用不断增长时，可以用过类型检查发现很多bug。对于某些应用，可以使用JavaScript扩展工具来完成，比如使用&nbsp;\n    <a title="flow类型检查工具" href="https://chkui.com/article/react/react_static_type_check_with_flow">Flow </a>或\n    <a title="Typescript官网" href="https://www.typescriptlang.org/" rel="nofollow">TypeScript </a>来检查整个工程。除了引入外部工具之外，React也提供了参数类型检查的功能，只需要为每一个属性指定一个&nbsp;<code>propTypes</code>&nbsp;即可：\n</p>\n<pre class="scala"><code class="language-javascript"><span class="code-comment"><span class="code-comment">// 15.5之后，需要单独引入依赖才能使用类型检查</span></span>\n<span class="code-keyword"><span class="code-keyword">import</span></span> <span\n            class="code-type">PropTypes</span> <span class="code-keyword">from</span> <span class="code-string"><span\n            class="hljs-symbol">\'prop</span>-types\'</span>;\n<span class="code-comment"><span class="code-comment">//定义组件</span></span>\n<span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span\n        class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Greeting</span></span></span><span class="hljs-class"> </span><span\n        class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> (\n      <span class="xml"><span class="code-tag">&lt;<span class="code-name">h1</span>&gt;</span><span class="code-type">Hello</span>, {<span\n              class="code-keyword">this</span>.props.name}<span class="code-tag">&lt;/<span class="code-name">h1</span>&gt;</span></span>\n    );\n  }\n}\n\n<span class="code-comment"><span class="code-comment">//指定类型检查</span></span>\n<span class="code-type">Greeting</span>.propTypes = {\n  name: <span class="code-type">React</span>.<span class="code-type">PropTypes</span>.string\n};</code></pre>\n<p> PropTypes将会设定一系列验证器，这些验证器用于确保组件接受到的参数（props）是指定的类型。比如上面的例子，当一个错误的类型被组件接收到，会有一段警告内容使通过console输出。<span\n        style="color:#FF0000">propsTypes仅仅在开发模式下使用</span>。</p>\n\n<h3 id="h3-2">PropTypes</h3>\n<p>以下是各种验证器的示例：</p>\n<pre class="javascript"><code class="language-javascript">MyComponent.propTypes = {\n  <span class="code-comment"><span class="code-comment">// 指明每个传入参数的具体类型，传递的参数仅限于这些JavaScript的内置类型</span></span>\n  optionalArray: PropTypes.array,\n  optionalBool: PropTypes.bool,\n  optionalFunc: PropTypes.func,\n  optionalNumber: PropTypes.number,\n  optionalObject: PropTypes.object,\n  optionalString: PropTypes.string,\n  optionalSymbol: PropTypes.symbol,\n\n  <span class="code-comment"><span class="code-comment">// number、string、element或者一个列表都是允许的</span></span>\n  optionalNode: PropTypes.node,\n\n  <span class="code-comment"><span class="code-comment">// 接收一个React组件</span></span>\n  optionalElement: PropTypes.element,\n\n  <span class="code-comment"><span class="code-comment">// 声明这个参数只接收某个对象(class)的实例，适用于传递一个对象作为配置参数的</span></span>\n  optionalMessage: PropTypes.instanceOf(Message),\n\n  <span class="code-comment"><span class="code-comment">// 指定参数限定在多个对象之内</span></span>\n  optionalEnum: PropTypes.oneOf([<span class="code-string"><span class="code-string">\'News\'</span></span>, <span\n            class="code-string"><span class="code-string">\'Photos\'</span></span>]),\n\n  <span class="code-comment"><span class="code-comment">// 指定参数允许多个类型</span></span>\n  optionalUnion: PropTypes.oneOfType([\n    PropTypes.string,\n    PropTypes.number,\n    PropTypes.instanceOf(Message)\n  ]),\n\n  <span class="code-comment"><span class="code-comment">// 指定类型的列表</span></span>\n  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),\n\n  <span class="code-comment"><span class="code-comment">// 指定传递某个类型，是一个对象不是数据本身</span></span>\n  optionalObjectOf: PropTypes.objectOf(PropTypes.number),\n\n  <span class="code-comment"><span class="code-comment">// 指定传递参数的结构，适用于传递一个对象时限定对象的结构</span></span>\n  optionalObjectWithShape: PropTypes.shape({\n    color: PropTypes.string,\n    fontSize: PropTypes.number\n  }),\n\n  <span class="code-comment"><span class="code-comment">// 表明这个参数是必须要传递的参数，在使用这个组件时，这个参数必须传入数据</span></span>\n  requiredFunc: PropTypes.func.isRequired,\n\n  <span class="code-comment"><span class="code-comment">// 允许任何类型的数据。</span></span>\n  requiredAny: PropTypes.any.isRequired,\n\n  <span class="code-comment"><span class="code-comment">// 指定一个自定义的检查器，当检查失败时需要返回一个Error对象来指明错误。</span></span>\n  <span class="code-comment"><span class="code-comment">// 错误只需要返回，切记不能使用throw或console.warn输出</span></span>\n  <span class="code-comment"><span class="code-comment">// 不适用于 oneOfType 类型。</span></span>\n  customProp: <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">function</span></span></span><span class="hljs-function">(</span><span\n            class="hljs-params"><span class="hljs-function"><span\n            class="hljs-params">props, propName, componentName</span></span></span><span class="hljs-function">) </span></span>{\n    <span class="code-keyword"><span class="code-keyword">if</span></span> (!<span class="hljs-regexp"><span\n            class="hljs-regexp">/matchme/</span></span>.test(props[propName])) {\n      <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="code-keyword"><span\n            class="code-keyword">new</span></span> <span class="code-built_in"><span class="code-built_in">Error</span></span>(\n        <span class="code-string"><span class="code-string">\'Invalid prop `\'</span></span> + propName + <span\n            class="code-string"><span class="code-string">\'` supplied to\'</span></span> +\n        <span class="code-string"><span class="code-string">\' `\'</span></span> + componentName + <span\n            class="code-string"><span class="code-string">\'`. Validation failed.\'</span></span>\n      );\n    }\n  },\n\n  <span class="code-comment"><span class="code-comment">// 用于检测一个数组传递的自定义检查器，适用于arrayOf和objectOf类型。</span></span>\n  <span class="code-comment"><span class="code-comment">// 当出现检查错误时需要返回Error</span></span>\n  customArrayProp: PropTypes.arrayOf(<span class="hljs-function"><span class="code-keyword"><span\n            class="hljs-function"><span class="code-keyword">function</span></span></span><span\n            class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span\n            class="hljs-params">propValue, key, componentName, location, propFullName</span></span></span><span\n            class="hljs-function">) </span></span>{\n    <span class="code-keyword"><span class="code-keyword">if</span></span> (!<span class="hljs-regexp"><span\n            class="hljs-regexp">/matchme/</span></span>.test(propValue[key])) {\n      <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="code-keyword"><span\n            class="code-keyword">new</span></span> <span class="code-built_in"><span class="code-built_in">Error</span></span>(\n        <span class="code-string"><span class="code-string">\'Invalid prop `\'</span></span> + propFullName + <span\n            class="code-string"><span class="code-string">\'` supplied to\'</span></span> +\n        <span class="code-string"><span class="code-string">\' `\'</span></span> + componentName + <span\n            class="code-string"><span class="code-string">\'`. Validation failed.\'</span></span>\n      );\n    }\n  })\n};</code></pre>\n\n<h4 id="h4-1">限定至少接收一个子元素</h4>\n<p>可以使用&nbsp;<code>PropTypes.element</code>&nbsp;来指明组件必须接收一个子元素：</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span\n        class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span\n        class="code-title"><span class="hljs-class"><span class="code-title">MyComponent</span></span></span><span\n        class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  render() {\n    <span class="code-comment"><span\n            class="code-comment">// This must be exactly one element or it will warn.</span></span>\n    <span class="code-keyword">const</span> children = <span class="code-keyword"><span class="code-keyword">this</span></span>.props.children;\n    <span class="code-keyword"><span class="code-keyword">return</span></span> (\n      <span class="xml"><span class="code-tag">&lt;<span class="code-name">div</span>&gt;</span>\n        {children}\n      <span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>\n    );\n  }\n}\n\n<span class="code-type">MyComponent</span>.propTypes = {\n  children: <span class="code-type">React</span>.<span class="code-type">PropTypes</span>.element.isRequired\n};</code></pre>\n\n<h4 id="h4-2">设定props默认值</h4>\n<p>还可以使用&nbsp;<code>defaultProps</code>来指定默认值：</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span\n        class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span\n        class="code-title"><span class="hljs-class"><span class="code-title">Greeting</span></span></span><span\n        class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> (\n      <span class="xml"><span class="code-tag">&lt;<span class="code-name">h1</span>&gt;</span><span class="code-type">Hello</span>, {<span\n              class="code-keyword">this</span>.props.name}<span class="code-tag">&lt;/<span class="code-name">h1</span>&gt;</span></span>\n    );\n  }\n}\n\n<span class="code-comment"><span class="code-comment">// 指定props.name的默认值:</span></span>\n<span class="code-type">Greeting</span>.defaultProps = {\n  name: <span class="code-string"><span class="hljs-symbol">\'Strange</span>r\'</span>\n};\n\n<span class="code-type">ReactDOM</span>.render(\n  <span class="xml"><span class="code-tag">&lt;<span class="code-name"><span class="code-type">Greeting</span></span> /&gt;</span>,\n  document.getElementById(<span class="hljs-symbol">\'exampl</span>e\')\n);</span></code></pre>\n\n<h3 id="h3-3">Refs和真实Dom</h3>\n<p>\n    在典型的React数据流中，props参数传递的唯一接口。当需要修改参数时，必须修改props值并重新渲染（render）。然而，有很多场景需要在单向数据流之外修改子组件，React提供“Refs”特性来直接修改真实Dom元素。</p>\n\n<h4 id="h4-3">什么时候需要使用Refs</h4>\n<p>当遇到以下情况时，建议使用Refs特性：</p>\n<ul>\n    <li>需要管理聚（focus）、文档选择或媒体回放等真实Dom事件时。</li>\n    <li>触发需要马上执行的动画。</li>\n    <li>引入第三方库时。</li>\n</ul>\n<p>避免将Refs用于任何声明性的工作，如使用一个props.isOpen参数来代替Dialog的open()和close()接口。</p>\n\n<h4 id="h4-4">将Ref添加到Dom元素中</h4>\n<p>React支持在任何组件上使用ref。ref属性提供一个回调方法，当组件被渲染或被移除后，这个回调方法会被调用。</p>\n<p>当ref属性用于一个HTML元素时，ref的回调方法会获取Dom的实例。例如，下面的例子获取到input标签的Dom实例并保存到this.textInput变量中，这个变量一直指向Dom节点。</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span\n        class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span\n        class="code-title"><span class="hljs-class"><span class="code-title">CustomTextInput</span></span></span><span\n        class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  <span class="code-keyword">constructor</span>(props) {\n    <span class="code-keyword"><span class="code-keyword">super</span></span>(props);\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.focus = <span class="code-keyword"><span\n            class="code-keyword">this</span></span>.focus.bind(<span class="code-keyword"><span class="code-keyword">this</span></span>);\n  }\n\n  <span class="code-comment"><span class="code-comment">// 定义一个focus方法</span></span>\n  focus() {\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.textInput.focus();\n  }\n\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> (\n      &lt;div&gt;\n        &lt;input\n          <span class="hljs-class"><span class="code-keyword">type</span></span>=<span class="code-string">"text"</span>\n          ref={(input) =&gt; { <span class="code-keyword">this</span>.textInput = input; }} /&gt;\n        &lt;input\n          <span class="hljs-class"><span class="code-keyword">type</span></span>=<span\n            class="code-string">"button"</span>\n          value=<span class="code-string">"Focus the text input"</span>\n          onClick={<span class="code-keyword">this</span>.focus}\n        /&gt;\n      &lt;/div&gt;\n    );\n  }\n}</code></pre>\n<p>当Dom元素被渲染后，React会回调ref指定的方法，并传递当前Dom的实例作为参数，当Dom被移除时，ref指向的方法也会被调用，传入的参数为null。</p>\n<p>使用ref回调方法来设置class的属性是获取真实Dom对象的常用方法，上面的例子给出了一个编写方式，只要语法正确你可以用各种方式来编写，如更简短的：&nbsp;<code>ref={input =&gt;\n    this.textInput = input}</code>。</p>\n\n<h4 id="h4-5">给class组件增加一个Ref属性</h4>\n<p>当ref用于一个由class关键字声明的自定义组件时，ref指向的回调方法会在组件完成渲染后被回调，传递的参数是组件的实例。例如下面的例子，在&nbsp;<code>CustomTextInput</code>&nbsp;组件完成渲染后立即模拟一次focus事件：\n</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span\n        class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span\n        class="code-title"><span class="hljs-class"><span\n        class="code-title">AutoFocusTextInput</span></span></span><span class="hljs-class"> </span><span\n        class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  componentDidMount() {<span class="code-comment"><span class="code-comment">//完成渲染后被回调</span></span>\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.textInput.focus();<span\n            class="code-comment"><span class="code-comment">//聚焦到当前组件</span></span>\n  }\n\n  render() {\n    <span class="code-comment"><span class="code-comment">// CustomTextInput 已经在上一段代码中声明</span></span>\n    <span class="code-keyword"><span class="code-keyword">return</span></span> (\n      <span class="xml"><span class="code-tag">&lt;<span class="code-name"><span\n              class="code-type">CustomTextInput</span></span>\n        <span class="hljs-attr">ref</span>=<span class="code-string">{(input)</span> =&gt;</span> { <span\n              class="code-keyword">this</span>.textInput = input; }} /&gt;\n    );\n  }\n}</span></code></pre>\n<p>必须用class来定义&nbsp;<code>CustomTextInput</code>&nbsp;组件才会生效。</p>\n\n<h4 id="h4-6">给Function声明的组件设定Refs</h4>\n<p>不能再function定义的组件直接使用ref，因为在声明时他并没有实例化：</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-function"><span\n        class="code-keyword">function</span> <span class="code-title"><span\n        class="code-type">MyFunctionalComponent</span></span>(<span class="hljs-params"></span>) </span>{\n  <span class="code-keyword"><span class="code-keyword">return</span></span> &lt;input /&gt;;\n}\n\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">Parent</span> <span\n        class="code-keyword">extends</span> <span class="code-title">React</span>.<span\n        class="code-title">Component</span> </span>{\n  render() {\n    <span class="code-comment">// 错误，这里的ref不会有任何效果。</span>\n    <span class="code-keyword">return</span> (\n      &lt;<span class="code-type">MyFunctionalComponent</span>\n        ref={(input) =&gt; { <span class="code-keyword">this</span>.textInput = input; }} /&gt;\n    );\n  }\n}</code></pre>\n<p>最合理的方式是将function定义的组件转换为class，这和我们需要使用state来控制状态是一个道理。不过在function组件中，如果内部引用的是另一个class组件也是可以使用Refs特性的：</p>\n<pre class="php"><code class="language-javascript"><span class="hljs-function"><span class="code-keyword"><span\n        class="hljs-function"><span class="code-keyword">function</span></span></span><span\n        class="hljs-function"> </span><span class="code-title"><span class="hljs-function"><span class="code-title">CustomTextInput</span></span></span><span\n        class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-params"><span\n        class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function"><span\n        class="hljs-params">)</span> </span></span>{\n  <span class="code-comment"><span class="code-comment">// 在这里声明textInput，每次重新渲染时，都会新生成一个本地变量</span></span>\n  <span class="code-keyword">let</span> textInput = <span class="hljs-literal"><span\n            class="code-keyword">null</span></span>;\n\n  <span class="code-comment"><span class="code-comment">// 每次重新渲染时，都会新生成一个回调方法</span></span>\n  <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span\n          class="code-keyword">function</span></span></span><span class="hljs-function"> </span><span\n          class="code-title"><span class="hljs-function"><span class="code-title">handleClick</span></span></span><span\n          class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-params"></span><span\n          class="hljs-function"><span class="hljs-params">)</span> </span></span>{\n    textInput.focus();\n  }\n\n  <span class="code-keyword"><span class="code-keyword">return</span></span> (\n    &lt;div&gt;\n      &lt;input\n        type=<span class="code-string">"text"</span>\n        ref={(input) =&gt; { textInput = input; }} /&gt;\n      &lt;input\n        type=<span class="code-string">"button"</span>\n        value=<span class="code-string">"Focus the text input"</span>\n        onClick={handleClick}\n      /&gt;\n    &lt;/div&gt;\n  );  \n}</code></pre>\n\n<h4 id="h4-7">切勿过度使用Refs特性</h4>\n<p>\n    可能在了解Refs的机制后，某些开发人员更倾向于在代码中使用Refs这种“操作即发生”特性来实现功能。但是在使用之前最好多花点时间来思考为什么状态需要由不同的组件层次来控制，通常情况下组件之间的状态最好由他们共同的祖先来控制：\n    <a title="React 状态、事件与动态渲染" href="/article/react/react_state_event_and_render" rel="nofollow">React 状态、事件与动态渲染</a>\n</p>\n<h4 id="h4-8">*使用警告</h4>\n<p>\n    如果ref的回调方法被定义为一个内联方法，它在更新之前会发生2次调用，第一调用时会传递一个null值，第二次会赋予真正的Dom对象。这是因为在每次渲染时都会有一个新的方法实例被创建所以React必须清除已有的ref并创建一个的ref。可以通过将ref回调方法定义为类的绑定方法来避免这种情况，但请注意，在大多数情况下，这并不会导致什么问题。</p>'},403:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<p>在 <a href="https://www.chkui.com/article/spring/spring_batch_introduction" title="批处理概念">批处理概念</a> 中介绍一个标准的批处理分为 <a\n        href="https://www.chkui.com/article/spring/spring_batch_job" title="Job">Job</a> 和 <a\n        href="https://www.chkui.com/article/spring/spring_batch_step">Step</a>。本文将结合代码介绍在<code>Step</code>中<code>Reader</code>、<code>Processor</code>、<code>Writer</code>的实际使用。\n</p>\n<h2 id="h2-1">Reader</h2>\n<p><code>Reader</code>是指从各种各样的外部输入中获取数据，框架为获取各种类型的文件已经预定义了常规的<code>Reader</code>实现类。<code>Reader</code>通过<code>ItemReader</code>接口实现：\n</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">ItemReader</span>&lt;<span class="code-title">T</span>&gt; </span>{\n    <span class="hljs-function">T <span class="code-title">read</span><span class="hljs-params">()</span> <span\n            class="code-keyword">throws</span> Exception, UnexpectedInputException, ParseException, NonTransientResourceException</span>;\n}\n</code></pre>\n<p><code>read</code>方法的作用就是读取一条数据，数据以泛型T的实体结构返回，<strong>当read返回null时表示所有数据读取完毕</strong>。返回的数据可以是任何结构，比如文件中的一行字符串，数据库的一行数据，或者xml文件中的一系列元素，只要是一个Java对象即可。\n</p>\n<h2 id="h2-2">Writer</h2>\n<p><code>Writer</code>通过<code>ItemWriter</code>接口实现：</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">ItemWriter</span>&lt;<span class="code-title">T</span>&gt; </span>{\n    <span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">write</span><span\n            class="hljs-params">(List&lt;? extends T&gt; items)</span> <span class="code-keyword">throws</span> Exception</span>;\n}\n</code></pre>\n<p><code>Writer</code>是<code>Reader</code>的反向操作，是将数据写入到特定的数据源中。在<a\n        href="https://www.chkui.com/article/spring/spring_batch_step" title="Step控制">Step控制</a>一文已经介绍<code>Writer</code>是根据<code>chunk</code>属性设定的值按列表进行操作的，所以传入的是一个<code>List</code>结构。<code>chunk</code>用于表示批处理的事物分片，因此需要注意的是，在<code>writer</code>方法中进行完整数据写入事物操作。例如向数据库写入<code>List</code>中的数据，在写入完成之后再提交事物。\n</p>\n<h2 id="h2-3">读写的组合模式</h2>\n<p>无论是读还是写，有时会需要从多个不同的来源获取文件，或者写入到不同的数据源，或者是需要在读和写之间处理一些业务。可以使用组合模式来实现这个目的：</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">CompositeItemWriter</span>&lt;<span class="code-title">T</span>&gt; <span\n        class="code-keyword">implements</span> <span class="code-title">ItemWriter</span>&lt;<span\n        class="code-title">T</span>&gt; </span>{\n    ItemWriter&lt;T&gt; itemWriter;\n    <span class="hljs-function"><span class="code-keyword">public</span> <span\n            class="code-title">CompositeItemWriter</span><span\n            class="hljs-params">(ItemWriter&lt;T&gt; itemWriter)</span> </span>{\n        <span class="code-keyword">this</span>.itemWriter = itemWriter;\n    }\n\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">write</span><span class="hljs-params">(List&lt;? extends T&gt; items)</span> <span\n            class="code-keyword">throws</span> Exception </span>{\n        <span class="code-comment">//Add business logic here</span>\n       itemWriter.write(items);\n    }\n\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setDelegate</span><span\n            class="hljs-params">(ItemWriter&lt;T&gt; itemWriter)</span></span>{\n        <span class="code-keyword">this</span>.itemWriter = itemWriter;\n    }\n}\n</code></pre>\n<h2 id="h2-4">Processor</h2>\n<p>除了使用组合模式，直接使用<code>Processor</code>是一种更优雅的方法。<code>Processor</code>是<code>Step</code>中的可选项，但是批处理大部分时候都需要对数据进行处理，因此框架提供了<code>ItemProcessor</code>接口来满足<code>Processor</code>过程：\n</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">ItemProcessor</span>&lt;<span class="code-title">I</span>, <span class="code-title">O</span>&gt; </span>{\n    <span class="hljs-function">O <span class="code-title">process</span><span class="hljs-params">(I item)</span> <span\n            class="code-keyword">throws</span> Exception</span>;\n}\n</code></pre>\n<p><code>Processor</code>的结构非常简单也是否易于理解。传入一个类型I，然后由<code>Processor</code>处理成为O。</p>\n<h3 id="h3-1">Processor链</h3>\n<p>在一个<a href="https://www.chkui.com/article/spring/spring_batch_step">Step</a>中可以使用多个<code>Processor</code>来按照顺序处理业务，此时同样可以使用<code>CompositeItem</code>模式来实现：\n</p>\n<pre><code class="Java">\n<span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> CompositeItemProcessor <span class="code-title">compositeProcessor</span><span\n        class="hljs-params">()</span> </span>{\n    <span class="code-comment">//创建 CompositeItemProcessor</span>\n    CompositeItemProcessor&lt;Foo,Foobar&gt; compositeProcessor = <span class="code-keyword">new</span> CompositeItemProcessor&lt;Foo,Foobar&gt;();\n    List itemProcessors = <span class="code-keyword">new</span> ArrayList();\n    <span class="code-comment">//添加第一个 Processor</span>\n    itemProcessors.add(<span class="code-keyword">new</span> FooTransformer());\n    <span class="code-comment">//添加第二个 Processor</span>\n    itemProcessors.add(<span class="code-keyword">new</span> BarTransformer());\n    <span class="code-comment">//添加链表</span>\n    compositeProcessor.setDelegates(itemProcessors);\n    <span class="code-keyword">return</span> processor;\n}\n</code></pre>\n<h3 id="h3-2">过滤记录</h3>\n<p>\n    在<code>Reader</code>读取数据的过程中，并不是所有的数据都可以使用，此时<code>Processor</code>还可以用于过滤非必要的数据，同时不会影响<code>Step</code>的处理过程。只要<code>ItemProcesspr</code>的实现类在<code>procss</code>方法中返回<code>null</code>即表示改行数据被过滤掉了。\n</p>\n<h2 id="h2-5">ItemStream</h2>\n<p>在<a href="https://www.chkui.com/article/spring/spring_batch_step">Step控制</a>一文中已经提到了<code>ItemStream</code>。在<a\n        href="https://www.chkui.com/article/spring/spring_batch_introduction">数据批处理概念</a>中提到过，Spring\n    Batch的每一步都是无状态的，进而<code>Reader</code>和<code>Writer</code>也是无状态的，这种方式能够很好的隔离每行数据的处理，也能将容错的范围收窄到可以空子的范围。但是这并不意味着整个批处理的过程中并不需要控制状态。例如从数据库持续读入或写入数据，每次<code>Reader</code>和<code>Writer</code>都单独去申请数据源的链接、维护数据源的状态（打开、关闭等）。因此框架提供了<code>ItemStream</code>接口来完善这些操作：\n</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">ItemStream</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">open</span><span\n            class="hljs-params">(ExecutionContext executionContext)</span> <span class="code-keyword">throws</span> ItemStreamException</span>;\n    <span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">update</span><span\n            class="hljs-params">(ExecutionContext executionContext)</span> <span class="code-keyword">throws</span> ItemStreamException</span>;\n    <span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">close</span><span\n            class="hljs-params">()</span> <span class="code-keyword">throws</span> ItemStreamException</span>;\n}\n</code></pre>\n<h2 id="h2-6">持久化数据</h2>\n<p>在使用Spring Batch之前需要初始化他的元数据存储（Meta-Data Schema）,也就是要将需要用到的表导入到对应的数据库中。当然，Spring\n    Batch支持不使用任何持久化数据库，仅仅将数据放到内存中，不设置<code>DataSource</code>即可。</p>\n<h3 id="h3-3">初始化序列</h3>\n<p>Spring Batch相关的工作需要使用序列<code>SEQUENCE</code>：</p>\n<pre><code class="SQL"><span class="code-keyword">CREATE</span> <span class="code-keyword">SEQUENCE</span> BATCH_STEP_EXECUTION_SEQ;\n<span class="code-keyword">CREATE</span> <span class="code-keyword">SEQUENCE</span> BATCH_JOB_EXECUTION_SEQ;\n<span class="code-keyword">CREATE</span> <span class="code-keyword">SEQUENCE</span> BATCH_JOB_SEQ;\n</code></pre>\n<p>有些数据库不支持<code>SEQUENCE</code>，可以通过表代理，比如在MySql（InnoDB数据库）中：</p>\n<pre><code class="SQL"><span class="code-keyword">CREATE</span> <span class="code-keyword">TABLE</span> BATCH_STEP_EXECUTION_SEQ (<span\n        class="code-keyword">ID</span> <span class="code-built_in">BIGINT</span> <span\n        class="code-keyword">NOT</span> <span class="hljs-literal">NULL</span>);\n<span class="code-keyword">INSERT</span> <span class="code-keyword">INTO</span> BATCH_STEP_EXECUTION_SEQ <span\n            class="code-keyword">values</span>(<span class="hljs-number">0</span>);\n<span class="code-keyword">CREATE</span> <span class="code-keyword">TABLE</span> BATCH_JOB_EXECUTION_SEQ (<span\n            class="code-keyword">ID</span> <span class="code-built_in">BIGINT</span> <span\n            class="code-keyword">NOT</span> <span class="hljs-literal">NULL</span>);\n<span class="code-keyword">INSERT</span> <span class="code-keyword">INTO</span> BATCH_JOB_EXECUTION_SEQ <span\n            class="code-keyword">values</span>(<span class="hljs-number">0</span>);\n<span class="code-keyword">CREATE</span> <span class="code-keyword">TABLE</span> BATCH_JOB_SEQ (<span\n            class="code-keyword">ID</span> <span class="code-built_in">BIGINT</span> <span\n            class="code-keyword">NOT</span> <span class="hljs-literal">NULL</span>);\n<span class="code-keyword">INSERT</span> <span class="code-keyword">INTO</span> BATCH_JOB_SEQ <span\n            class="code-keyword">values</span>(<span class="hljs-number">0</span>);\n</code></pre>\n<h3 id="h3-4">关于Version字段</h3>\n<p>某些表中都有<code>Version</code>字段。因为Spring的更新策略是乐观锁，因此在进行数据更新之后都会对表的<code>Version</code>字段进行+1处理。在内存与数据库交互的过程中，会使用采用<em>getVersion</em>、<em>increaseVersion（+1）</em>、<em>updateDataAndVersion</em>的过程，如果在<code>update</code>的时候发现Version不是预计的数值（+1），则会抛出<code>OptimisticLockingFailureException</code>的异常。当同一个<code>Job</code>在进群中不同服务上执行时，需要注意这个问题。\n</p>\n<h3 id="h3-5">BATCH_JOB_INSTANCE</h3>\n<p><code>BATCH_JOB_INSTANCE</code>用于记录JobInstance，在<a\n        href="https://www.chkui.com/article/spring/spring_batch_introduction">数据批处理概念</a>中介绍了他的工作方式，其结构为：</p>\n<pre><code class="SQL"><span class="code-keyword">CREATE</span> <span class="code-keyword">TABLE</span> BATCH_JOB_INSTANCE  (\n  JOB_INSTANCE_ID <span class="code-built_in">BIGINT</span>  PRIMARY <span class="code-keyword">KEY</span> ,\n  <span class="code-keyword">VERSION</span> <span class="code-built_in">BIGINT</span>,\n  JOB_NAME <span class="code-built_in">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="code-keyword">NOT</span> <span\n            class="hljs-literal">NULL</span> ,\n  JOB_KEY <span class="code-built_in">VARCHAR</span>(<span class="hljs-number">2500</span>)\n);\n</code></pre>\n<table>\n    <thead>\n    <tr>\n        <th>字段</th>\n        <th>说明</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n        <td>JOB_INSTANCE_ID</td>\n        <td>主键，主键与单个<code>JobInstance</code>相关。当获取到某个<code>JobInstance</code>实例后，通过<code>getId</code>方法可以获取到此数据</td>\n    </tr>\n    <tr>\n        <td>VERSION</td>\n        <td></td>\n    </tr>\n    <tr>\n        <td>JOB_NAME</td>\n        <td>Job的名称，用于标记运行的Job，在创建Job时候指定</td>\n    </tr>\n    <tr>\n        <td>JOB_KEY</td>\n        <td><em>JobParameters</em>的序列化数值。在<a href="https://www.chkui.com/article/spring/spring_batch_introduction">数据批处理概念</a>中介绍了一个<code>JobInstance</code>相当于<em>Job</em>+<em>JobParameters</em>。他用于标记同一个<code>Job</code>不同的实例\n        </td>\n    </tr>\n    </tbody>\n</table>\n<h3 id="h3-6">BATCH_JOB_EXECUTION_PARAMS</h3>\n<p><code>BATCH_JOB_EXECUTION_PARAMS</code>对应的是<code>JobParameters</code>对象。其核心功能是存储<em>Key-Value</em>结构的各种状态数值。字段中<code>IDENTIFYING=true</code>用于标记那些运行过程中必须的数据（可以理解是框架需要用到的数据），为了存储<em>key-value</em>结构该表一个列数据格式：\n</p>\n<pre><code class="SQL"><span class="code-keyword">CREATE</span> <span class="code-keyword">TABLE</span> BATCH_JOB_EXECUTION_PARAMS  (\n\tJOB_EXECUTION_ID <span class="code-built_in">BIGINT</span> <span class="code-keyword">NOT</span> <span\n            class="hljs-literal">NULL</span> ,\n\tTYPE_CD <span class="code-built_in">VARCHAR</span>(<span class="hljs-number">6</span>) <span class="code-keyword">NOT</span> <span\n            class="hljs-literal">NULL</span> ,\n\tKEY_NAME <span class="code-built_in">VARCHAR</span>(<span class="hljs-number">100</span>) <span\n            class="code-keyword">NOT</span> <span class="hljs-literal">NULL</span> ,\n\tSTRING_VAL <span class="code-built_in">VARCHAR</span>(<span class="hljs-number">250</span>) ,\n\tDATE_VAL DATETIME <span class="code-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> ,\n\tLONG_VAL <span class="code-built_in">BIGINT</span> ,\n\tDOUBLE_VAL <span class="code-keyword">DOUBLE</span> <span class="code-keyword">PRECISION</span> ,\n\tIDENTIFYING <span class="code-built_in">CHAR</span>(<span class="hljs-number">1</span>) <span class="code-keyword">NOT</span> <span\n            class="hljs-literal">NULL</span> ,\n\t<span class="code-keyword">constraint</span> JOB_EXEC_PARAMS_FK foreign <span class="code-keyword">key</span> (JOB_EXECUTION_ID)\n\t<span class="code-keyword">references</span> BATCH_JOB_EXECUTION(JOB_EXECUTION_ID)\n);\n</code></pre>\n<table>\n    <thead>\n    <tr>\n        <th>字段</th>\n        <th>说明</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n        <td>JOB_EXECUTION_ID</td>\n        <td>与<em>BATCH_JOB_EXECUTION</em>表关联的外键，详见<a\n                href="https://www.chkui.com/article/spring/spring_batch_introduction">数据批处理概念</a>中<em>Job</em>、<em>JobInstance</em>、<em>JobExecute</em>的关系\n        </td>\n    </tr>\n    <tr>\n        <td>TYPE_CD</td>\n        <td>用于标记数据的对象类型，例如 <em>string</em>、<em>date</em>、<em>long</em>、<em>double</em>，非空</td>\n    </tr>\n    <tr>\n        <td>KEY_NAME</td>\n        <td>key的值</td>\n    </tr>\n    <tr>\n        <td>STRING_VAL</td>\n        <td><em>string</em>类型的数值</td>\n    </tr>\n    <tr>\n        <td>DATE_VAL</td>\n        <td><em>date</em>类型的数值</td>\n    </tr>\n    <tr>\n        <td>LONG_VAL</td>\n        <td><em>long</em>类型的数值</td>\n    </tr>\n    <tr>\n        <td>DOUBLE_VAL</td>\n        <td><em>double</em>类型的数值</td>\n    </tr>\n    <tr>\n        <td>IDENTIFYING</td>\n        <td>标记这对<em>key-valuse</em>是否来自于<em>JobInstace</em>自身</td>\n    </tr>\n    </tbody>\n</table>\n<h3 id="h3-7">BATCH_JOB_EXECUTION</h3>\n<p>关联<code>JobExecution</code>，每当运行一个<code>Job</code>都会产生一个新的<code>JobExecution</code>，对应的在表中都会新增一行数据。</p>\n<pre><code class="SQL"><span class="code-keyword">CREATE</span> <span class="code-keyword">TABLE</span> BATCH_JOB_EXECUTION  (\n  JOB_EXECUTION_ID <span class="code-built_in">BIGINT</span>  PRIMARY <span class="code-keyword">KEY</span> ,\n  <span class="code-keyword">VERSION</span> <span class="code-built_in">BIGINT</span>,\n  JOB_INSTANCE_ID <span class="code-built_in">BIGINT</span> <span class="code-keyword">NOT</span> <span\n            class="hljs-literal">NULL</span>,\n  CREATE_TIME <span class="code-keyword">TIMESTAMP</span> <span class="code-keyword">NOT</span> <span\n            class="hljs-literal">NULL</span>,\n  START_TIME <span class="code-keyword">TIMESTAMP</span> <span class="code-keyword">DEFAULT</span> <span\n            class="hljs-literal">NULL</span>,\n  END_TIME <span class="code-keyword">TIMESTAMP</span> <span class="code-keyword">DEFAULT</span> <span\n            class="hljs-literal">NULL</span>,\n  <span class="code-keyword">STATUS</span> <span class="code-built_in">VARCHAR</span>(<span\n            class="hljs-number">10</span>),\n  EXIT_CODE <span class="code-built_in">VARCHAR</span>(<span class="hljs-number">20</span>),\n  EXIT_MESSAGE <span class="code-built_in">VARCHAR</span>(<span class="hljs-number">2500</span>),\n  LAST_UPDATED <span class="code-keyword">TIMESTAMP</span>,\n  JOB_CONFIGURATION_LOCATION <span class="code-built_in">VARCHAR</span>(<span class="hljs-number">2500</span>) <span\n            class="hljs-literal">NULL</span>,\n  <span class="code-keyword">constraint</span> JOB_INSTANCE_EXECUTION_FK foreign <span class="code-keyword">key</span> (JOB_INSTANCE_ID)\n  <span class="code-keyword">references</span> BATCH_JOB_INSTANCE(JOB_INSTANCE_ID)\n) ;\n</code></pre>\n<table>\n    <thead>\n    <tr>\n        <th>字段</th>\n        <th>说明</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n        <td>JOB_EXECUTION_ID</td>\n        <td><em>JobExecution</em>的主键，<em>JobExecution::getId</em>方法可以获取到该值</td>\n    </tr>\n    <tr>\n        <td>VERSION</td>\n        <td></td>\n    </tr>\n    <tr>\n        <td>JOB_INSTANCE_ID</td>\n        <td>关联到<em>JobInstace</em>的外键，详见<a\n                href="https://www.chkui.com/article/spring/spring_batch_introduction">数据批处理概念</a>中<em>Job</em>、<em>JobInstance</em>、<em>JobExecute</em>的关系\n        </td>\n    </tr>\n    <tr>\n        <td>CREATE_TIME</td>\n        <td>创建时间戳</td>\n    </tr>\n    <tr>\n        <td>START_TIME</td>\n        <td>开始时间戳</td>\n    </tr>\n    <tr>\n        <td>END_TIME</td>\n        <td>结束时间戳，无论成功或失败都会更新这一项数据。如果某行数据该值为空表示运行期间出现错误，并且框架无法更新该值</td>\n    </tr>\n    <tr>\n        <td>STATUS</td>\n        <td><em>JobExecute</em>的运行状态:<em>COMPLETED</em>、<em>STARTED</em>或者其他状态。此数值对应Java中<em>BatchStatus</em>枚举值</td>\n    </tr>\n    <tr>\n        <td>EXIT_CODE</td>\n        <td><em>JobExecute</em>执行完毕之后的退出返回值</td>\n    </tr>\n    <tr>\n        <td>EXIT_MESSAGE</td>\n        <td><em>JobExecute</em>退出的详细内容，如果是异常退出可能会包括异常堆栈的内容</td>\n    </tr>\n    <tr>\n        <td>LAST_UPDATED</td>\n        <td>最后一次更新的时间戳</td>\n    </tr>\n    </tbody>\n</table>\n<h3 id="h3-8">BATCH_STEP_EXECUTION</h3>\n<p>该表对应的是<code>StepExecution</code>，其结构和<code>BATCH_JOB_EXECUTION</code>基本相似，只是对应的对象是<code>Step</code>，增加了与之相对的一些字段数值：\n</p>\n<pre><code class="SQL"><span class="code-keyword">CREATE</span> <span class="code-keyword">TABLE</span> BATCH_STEP_EXECUTION  (\n  STEP_EXECUTION_ID <span class="code-built_in">BIGINT</span>  PRIMARY <span class="code-keyword">KEY</span> ,\n  <span class="code-keyword">VERSION</span> <span class="code-built_in">BIGINT</span> <span\n            class="code-keyword">NOT</span> <span class="hljs-literal">NULL</span>,\n  STEP_NAME <span class="code-built_in">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="code-keyword">NOT</span> <span\n            class="hljs-literal">NULL</span>,\n  JOB_EXECUTION_ID <span class="code-built_in">BIGINT</span> <span class="code-keyword">NOT</span> <span\n            class="hljs-literal">NULL</span>,\n  START_TIME <span class="code-keyword">TIMESTAMP</span> <span class="code-keyword">NOT</span> <span\n            class="hljs-literal">NULL</span> ,\n  END_TIME <span class="code-keyword">TIMESTAMP</span> <span class="code-keyword">DEFAULT</span> <span\n            class="hljs-literal">NULL</span>,\n  <span class="code-keyword">STATUS</span> <span class="code-built_in">VARCHAR</span>(<span\n            class="hljs-number">10</span>),\n  COMMIT_COUNT <span class="code-built_in">BIGINT</span> ,\n  READ_COUNT <span class="code-built_in">BIGINT</span> ,\n  FILTER_COUNT <span class="code-built_in">BIGINT</span> ,\n  WRITE_COUNT <span class="code-built_in">BIGINT</span> ,\n  READ_SKIP_COUNT <span class="code-built_in">BIGINT</span> ,\n  WRITE_SKIP_COUNT <span class="code-built_in">BIGINT</span> ,\n  PROCESS_SKIP_COUNT <span class="code-built_in">BIGINT</span> ,\n  ROLLBACK_COUNT <span class="code-built_in">BIGINT</span> ,\n  EXIT_CODE <span class="code-built_in">VARCHAR</span>(<span class="hljs-number">20</span>) ,\n  EXIT_MESSAGE <span class="code-built_in">VARCHAR</span>(<span class="hljs-number">2500</span>) ,\n  LAST_UPDATED <span class="code-keyword">TIMESTAMP</span>,\n  <span class="code-keyword">constraint</span> JOB_EXECUTION_STEP_FK foreign <span class="code-keyword">key</span> (JOB_EXECUTION_ID)\n  <span class="code-keyword">references</span> BATCH_JOB_EXECUTION(JOB_EXECUTION_ID)\n) ;\n</code></pre>\n<p>未填入内容部分见<code>BATCH_JOB_EXECUTION</code>说明。</p>\n<table>\n    <thead>\n    <tr>\n        <th>字段</th>\n        <th>说明</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n        <td>STEP_EXECUTION_ID</td>\n        <td><em>StepExecute</em>对应的主键</td>\n    </tr>\n    <tr>\n        <td>VERSION</td>\n        <td></td>\n    </tr>\n    <tr>\n        <td>STEP_NAME</td>\n        <td><em>Step</em>名称</td>\n    </tr>\n    <tr>\n        <td>JOB_EXECUTION_ID</td>\n        <td>关联到<em>BATCH_JOB_EXECUTION</em>表的外键，标记该<em>StepExecute</em>所属的<em>JobExecute</em></td>\n    </tr>\n    <tr>\n        <td>START_TIME</td>\n        <td></td>\n    </tr>\n    <tr>\n        <td>END_TIME</td>\n        <td></td>\n    </tr>\n    <tr>\n        <td>STATUS</td>\n        <td></td>\n    </tr>\n    <tr>\n        <td>COMMIT_COUNT</td>\n        <td>执行过程中，事物提交的次数，该值与数据的规模以及<em>chunk</em>的设置有关</td>\n    </tr>\n    <tr>\n        <td>READ_COUNT</td>\n        <td>读取数据的次数</td>\n    </tr>\n    <tr>\n        <td>FILTER_COUNT</td>\n        <td><em>Processor</em>中过滤记录的次数</td>\n    </tr>\n    <tr>\n        <td>WRITE_COUNT</td>\n        <td>吸入数据的次数</td>\n    </tr>\n    <tr>\n        <td>READ_SKIP_COUNT</td>\n        <td>读数据的跳过次数</td>\n    </tr>\n    <tr>\n        <td>WRITE_SKIP_COUNT</td>\n        <td>写数据的跳过次数</td>\n    </tr>\n    <tr>\n        <td>PROCESS_SKIP_COUNT</td>\n        <td><em>Processor</em>跳过的次数</td>\n    </tr>\n    <tr>\n        <td>ROLLBACK_COUNT</td>\n        <td>回滚的次数</td>\n    </tr>\n    <tr>\n        <td>EXIT_CODE</td>\n        <td></td>\n    </tr>\n    <tr>\n        <td>EXIT_MESSAGE</td>\n        <td></td>\n    </tr>\n    <tr>\n        <td>LAST_UPDATED</td>\n        <td></td>\n    </tr>\n    </tbody>\n</table>\n<h3 id="h3-9">BATCH_JOB_EXECUTION_CONTEXT</h3>\n<p>\n    该表会记录所有与<code>Job</code>相关的<code>ExecutionContext</code>信息。每个<code>ExecutionContext</code>都对应一个<code>JobExecution</code>，在运行的过程中它包含了所有<code>Job</code>范畴的状态数据，这些数据在执行失败后对于后续处理有中重大意义。\n</p>\n<pre><code class="SQL"><span class="code-keyword">CREATE</span> <span class="code-keyword">TABLE</span> BATCH_JOB_EXECUTION_CONTEXT  (\n  JOB_EXECUTION_ID <span class="code-built_in">BIGINT</span> PRIMARY <span class="code-keyword">KEY</span>,\n  SHORT_CONTEXT <span class="code-built_in">VARCHAR</span>(<span class="hljs-number">2500</span>) <span\n            class="code-keyword">NOT</span> <span class="hljs-literal">NULL</span>,\n  SERIALIZED_CONTEXT <span class="code-keyword">CLOB</span>,\n  <span class="code-keyword">constraint</span> JOB_EXEC_CTX_FK foreign <span class="code-keyword">key</span> (JOB_EXECUTION_ID)\n  <span class="code-keyword">references</span> BATCH_JOB_EXECUTION(JOB_EXECUTION_ID)\n) ;\n</code></pre>\n<table>\n    <thead>\n    <tr>\n        <th>字段</th>\n        <th>说明</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n        <td>JOB_EXECUTION_ID</td>\n        <td>关联到<em>JobExecution</em>的外键，建立<em>JobExecution</em>和<em>ExecutionContext</em>的关系。</td>\n    </tr>\n    <tr>\n        <td>SHORT_CONTEXT</td>\n        <td>标记<em>SERIALIZED_CONTEXT</em>的版本号</td>\n    </tr>\n    <tr>\n        <td>SERIALIZED_CONTEXT</td>\n        <td>序列化的<em>ExecutionContext</em></td>\n    </tr>\n    </tbody>\n</table>\n<h3 id="h3-10">BATCH_STEP_EXECUTION_CONTEXT</h3>\n<p><code>Step</code>中<code>ExecutionContext</code>相关的数据表，结构与<code>BATCH_JOB_EXECUTION_CONTEXT</code>完全一样。</p>\n<h3 id="h3-11">表索引建议</h3>\n<p>上面的所有建表语句都没有提供索引，但是并不代表索引没有价值。当感觉到SQL语句的执行有效率问题时候，可以增加索引。</p>\n<p>索引带来的价值取决于SQL查询的频率以及关联关系，下面是Spring Batch框架在运行过程中会用到的一些查询条件语句，用于参考优化索引：</p>\n<table>\n    <thead>\n    <tr>\n        <th>表</th>\n        <th>Where条件</th>\n        <th>执行频率</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n        <td>BATCH_JOB_INSTANCE</td>\n        <td>JOB_NAME = ? and JOB_KEY = ?</td>\n        <td>每次Job启动执时</td>\n    </tr>\n    <tr>\n        <td>BATCH_JOB_EXECUTION</td>\n        <td>JOB_INSTANCE_ID = ?</td>\n        <td>每次Job重启时</td>\n    </tr>\n    <tr>\n        <td>BATCH_EXECUTION_CONTEXT</td>\n        <td>EXECUTION_ID = ? and KEY_NAME = ?</td>\n        <td>视<em>chunk</em>的大小而定</td>\n    </tr>\n    <tr>\n        <td>BATCH_STEP_EXECUTION</td>\n        <td>VERSION = ?</td>\n        <td>视<em>chunk</em>的大小而定</td>\n    </tr>\n    <tr>\n        <td>BATCH_STEP_EXECUTION</td>\n        <td>STEP_NAME = ? and JOB_EXECUTION_ID = ?</td>\n        <td>每一个<em>Step</em>执行之前</td>\n    </tr>\n    </tbody>\n</table>\n<h2 id="h2-7">使用案例</h2>\n<p>下面是Spring Batch一些简单的应用，源码在下列地址的<em>simple</em>工程：</p>\n<ul>\n    <li>Gitee：<a\n            href="https://gitee.com/chkui-com/spring-batch-sample">https://gitee.com/chkui-com/spring-batch-sample</a>\n    </li>\n    <li>Github：<a href="https://github.com/chkui/spring-batch-sample">https://github.com/chkui/spring-batch-sample</a>\n    </li>\n</ul>\n<p>Spring Batch提供了2种执行方式：命令行方式或Java内嵌方式。命令行方式是直到需要执行批处理任务的时候才启动程序，内嵌方式是结合Web工程或其他外部化框架来使用。2者最大的差别就是是否直接向IoCs注入一个<code>Job</code>实例。\n</p>\n<h3 id="h3-12">通用基本配置</h3>\n<p>\n    两种方式的基本配置都是一样的，通过<code>Reader</code>、<code>Processor</code>、<code>Writer</code>来组装一个<code>Step</code>。代码中<code>Item</code>并不涉及文件或数据库的操作，只是简单的模拟数据读取、处理、写入的过程。实体<code>Record</code>和<code>Msg</code>用于模拟数据转换，基本配置如下：\n</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">BatchDefaultConfig</span> </span>{\n\t<span class="code-meta">@Bean</span>\n\t<span class="code-comment">//配置Step</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> Step <span class="code-title">simpleStep</span><span\n            class="hljs-params">(StepBuilderFactory builder, ItemReader&lt;Record&gt; reader, ItemProcessor&lt;Record, Msg&gt; processor,\n\t\t\tItemWriter&lt;Msg&gt; writer)</span> </span>{\n\t\t<span class="code-keyword">return</span> builder.get(<span class="code-string">"SimpleStep"</span>).&lt;Record, Msg&gt;chunk(<span\n            class="hljs-number">10</span>).reader(reader).processor(processor).writer(writer)\n\t\t\t\t.build();\n\t}\n\n\t<span class="code-meta">@Bean</span>\n\t<span class="code-comment">//配置 Reader</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> ItemReader&lt;Record&gt; <span\n            class="code-title">reader</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> ItemReader&lt;Record&gt;() {\n\t\t\t<span class="code-keyword">private</span> <span class="code-keyword">int</span> count = <span\n            class="hljs-number">0</span>;\n\t\t\t<span class="hljs-function"><span class="code-keyword">public</span> Record <span\n                    class="code-title">read</span><span class="hljs-params">()</span>\n\t\t\t\t\t<span class="code-keyword">throws</span> Exception, UnexpectedInputException, ParseException, NonTransientResourceException </span>{\n\t\t\t\t<span class="code-keyword">return</span> ++<span class="code-keyword">this</span>.count &lt; <span\n            class="hljs-number">100</span> ? <span class="code-keyword">new</span> Record().setId(<span\n            class="code-keyword">this</span>.count).setMsg(<span class="code-string">"Read Number:"</span> + <span\n            class="code-keyword">this</span>.count) : <span class="code-keyword">null</span>;\n\t\t\t}\n\t\t};\n\t}\n\n\t<span class="code-meta">@Bean</span>\n\t<span class="code-comment">//配置 Processor</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> ItemProcessor&lt;Record, Msg&gt; <span\n            class="code-title">processor</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> ItemProcessor&lt;Record, Msg&gt;() {\n\t\t\t<span class="hljs-function"><span class="code-keyword">public</span> Msg <span\n                    class="code-title">process</span><span class="hljs-params">(Record item)</span> <span\n                    class="code-keyword">throws</span> Exception </span>{\n\t\t\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> Msg(<span\n            class="code-string">"MSG GET INFO = "</span> + item.getMsg());\n\t\t\t}\n\t\t};\n\t}\n\n\t<span class="code-meta">@Bean</span>\n\t<span class="code-comment">//配置 Writer</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> ItemWriter&lt;Msg&gt; <span class="code-title">writer</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> ItemWriter&lt;Msg&gt;() {\n\t\t\t<span class="code-keyword">private</span> <span class="code-keyword">int</span> batchCount = <span\n            class="hljs-number">0</span>;\n\t\t\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n                    class="code-title">write</span><span\n                    class="hljs-params">(List&lt;? extends Msg&gt; items)</span> <span\n                    class="code-keyword">throws</span> Exception </span>{\n\t\t\t\tSystem.out.println(<span class="code-string">"Batch Count : "</span> + ++batchCount + <span\n            class="code-string">". Data:"</span>);\n\t\t\t\t<span class="code-keyword">for</span> (Msg msg : items) {\n\t\t\t\t\tSystem.out.println(msg.getInfo());\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n}\n</code></pre>\n<h3 id="h3-13">命令行方式运行</h3>\n<p>有了基本配置之后，命令行运行的方式仅仅是向容器添加一个<code>Job</code>：</p>\n<pre><code class="Java"><span class="code-meta">@Configuration</span>\n<span class="code-comment">//导入依赖配置</span>\n<span class="code-meta">@Import</span>({ BatchDefaultConfig.class })\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">BatchCommondConfig</span> </span>{\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> Job <span\n            class="code-title">simpleJob</span><span class="hljs-params">(Step step, JobBuilderFactory builder)</span> </span>{\n\t\t<span class="code-keyword">return</span> builder.get(<span class="code-string">"SimpleJob"</span>).start(step).build(); <span\n            class="code-comment">//向容器返回一个Job的Bean</span>\n\t}\n}\n</code></pre>\n<p>然后启动Spring Framework则会自动启用Command Runner运行方式运行——先调用<code>SpringApplication::callRunner</code>方法，然后使用<code>JobLauncherCommandLineRunner::execute</code>运行：\n</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">CommondSample</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> <span\n            class="code-keyword">throws</span> DuplicateJobException </span>{\n\t\t<span class="code-comment">//模拟测试参数, 这些参数值在执行Java时从外部传入的，比如-Dkey=value</span>\n\t\tString[] argsExt = <span class="code-keyword">new</span> String[<span class="hljs-number">2</span>];\n\t\targsExt[<span class="hljs-number">0</span>] = <span class="code-string">"BuilderParam1=Value1"</span>;\n\t\targsExt[<span class="hljs-number">1</span>] = <span class="code-string">"BuilderParam2=Value2"</span>;\n\t\t<span class="code-comment">//运行Spring Framework</span>\n\t\tSpringApplication.run(CommondSample.class, argsExt);\n\t}\n}\n</code></pre>\n<p>启用之后观察数据库已经发生了变更。使用命令行需要通过 Java运行参数（-Dkey=value）传递<code>JobParameters</code>的数据，上面的代码模拟实现了相关的过程。</p>\n<h3 id="h3-14">Java内嵌运行</h3>\n<p>Java内嵌的方式主要是用于搭配外部工程化使用，比如使用Web框架或则统一调度平台管之类的结构化框架来统一管理批处理任务。与命令行执行最大的区别就是不向容器注入<code>Job</code>：</p>\n<pre><code class="Java"><span class="code-meta">@Configuration</span>\n<span class="code-comment">//导入进出配置 </span>\n<span class="code-meta">@Import</span>({BatchDefaultConfig.class})\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">BatchOperatoConfig</span> </span>{\n\t<span class="code-meta">@Bean</span>\n\t<span class="code-comment">//返回JobFactory</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> JobFactory <span\n            class="code-title">simpleJob</span><span class="hljs-params">(Step step, JobBuilderFactory builder)</span> </span>{\n\t\tSimpleJobFactory sampleJobFactory = <span class="code-keyword">new</span> SimpleJobFactory();\n\t\tsampleJobFactory.setJob(builder.get(<span class="code-string">"SimpleJob"</span>).start(step).build());\n\t\t<span class="code-keyword">return</span> sampleJobFactory;\n\t}\n}\n</code></pre>\n<p>\n    配置代码向容器添加了一个<code>JobFactory</code>的实现类，<code>JobFactory</code>的两个接口一个是获取<code>Job</code>一个是获取<code>Job</code>的名称，<code>SimpleJobFactory</code>实现了<code>JobFactory</code>：\n</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">SimpleJobFactory</span> <span class="code-keyword">implements</span> <span\n        class="code-title">JobFactory</span> </span>{\n\t<span class="code-keyword">private</span> Job job;\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setJob</span><span class="hljs-params">(Job job)</span> </span>{\n\t\t<span class="code-keyword">this</span>.job = job;\n\t}\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> Job <span\n            class="code-title">createJob</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> job;\n\t}\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span\n            class="code-title">getJobName</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> job.getName();\n\t}\n}\n</code></pre>\n<p>最后通过<code>SimpleJobFactory</code>来启动一个<code>Job</code>：</p>\n<pre><code class="Java"><span class="code-meta">@SpringBootApplication</span>\n<span class="code-meta">@EnableBatchProcessing</span>\n<span class="code-meta">@EnableScheduling</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">OperatorSample</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> <span\n            class="code-keyword">throws</span> DuplicateJobException </span>{\n\t\t<span class="code-keyword">new</span> SuspendThread().run(); <span class="code-comment">//挂起系统一直运行</span>\n\t\tConfigurableApplicationContext ctx = SpringApplication.run(OperatorSample.class);\n\t\tCron cron = ctx.getBean(Cron.class);\n\t\tcron.register(); <span class="code-comment">//注册JobFactory</span>\n\t\tcron.runJobLaunch();\n\t}\n}\n\n<span class="code-meta">@Service</span>\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">Cron</span> </span>{\n\t<span class="code-meta">@Autowired</span>\n\tJobLauncher jobLauncher;\n\n\t<span class="code-meta">@Autowired</span>\n\t<span class="code-keyword">private</span> JobOperator jobOperator;\n\n\t<span class="code-meta">@Autowired</span>\n\t<span class="code-keyword">private</span> JobRegistry jobRegistry;\n\n\t<span class="code-meta">@Autowired</span>\n\t<span class="code-keyword">private</span> JobFactory jobFactory;\n\n\t<span class="code-comment">//注册JobFactory</span>\n\t<span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">register</span><span\n            class="hljs-params">()</span> <span class="code-keyword">throws</span> DuplicateJobException </span>{\n\t\tjobRegistry.register(jobFactory);\n\t}\n\n\t<span class="code-comment">//使用JobLaunch执行</span>\n\t<span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">runJobLaunch</span><span\n            class="hljs-params">()</span> </span>{\n\t\tMap&lt;String, JobParameter&gt; map = <span class="code-keyword">new</span> HashMap&lt;&gt;();\n\t\tmap.put(<span class="code-string">"Builder"</span>, <span class="code-keyword">new</span> JobParameter(<span\n            class="code-string">"1"</span>));\n\t\tmap.put(<span class="code-string">"Timer"</span>, <span class="code-keyword">new</span> JobParameter(<span\n            class="code-string">"2"</span>));\n\t\tjobLauncher.run(jobFactory.createJob(), <span class="code-keyword">new</span> JobParameters(map));\n\t}\n\n\t<span class="code-meta">@Scheduled</span>(cron = <span class="code-string">"30 * * * * ? "</span>)\n\t<span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">task1</span><span\n            class="hljs-params">()</span> </span>{\n\t\tSystem.out.println(<span class="code-string">"1"</span>);\n\t\trunOperator();\n\t}\n\n\t<span class="code-comment">//定时任务使用 JobOperator执行</span>\n\t<span class="hljs-function"><span class="code-keyword">private</span> <span class="code-keyword">void</span> <span\n            class="code-title">runOperator</span><span class="hljs-params">()</span> </span>{\n\t\tjobOperator.start(<span class="code-string">"SimpleJob"</span>, <span\n            class="code-string">"Builder=1,Timer=2"</span>);\n\t}\n}\n</code></pre>\n<p>这里使用了2种执行方式：<code>JobLauncher</code>和<code>JobOperator</code>。<code>JobLauncher</code>简单明了的启动一个批处理任务。而<code>JobOperator</code>扩展了一些用于<code>Job</code>管理的接口方法，观察<code>JobOperator</code>的源码可以发现它提供了获取<code>ExecuteContext</code>、检查<code>JobInstance</code>等功能，如果需要定制开发一个基于Web或者JMX管理批处理任务的系统，<code>JobOperator</code>更合适。<code>JobOperator</code>的第二个参数用于传递<code>JobParameters</code>，等号两端分别是<code>key</code>和<code>value</code>，逗号用于分割多行数据。\n</p>\n<p>在<a href="https://www.chkui.com/article/spring/spring_batch_job">Job配置与运行</a>提及过一个<code>JobInstance</code>相当于<code>Job</code>+<code>JobParameters</code>，因此虽然上面的代码使用了两种不同的运行方式，但是<code>Job</code>和<code>JobParameters</code>是一样的。在运行被定时任务包裹的<code>runOperator</code>方法时，会一直抛出<code>JobInstanceAlreadyExistsException</code>异常，因为同一个实例不能运行2次。如果运行失败可以使用对应的<code>restart</code>方法。\n</p>\n<p>后续会介绍各种<code>Reader</code>和<code>Writer</code>的使用。</p>'}});