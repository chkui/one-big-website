webpackJsonp([18],{401:function(s,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<p>批处理任务的主要业务逻辑都是在<code>Step</code>中去完成的。可以将<code>Job</code>理解为运行<code>Step</code>的框架，而<code>Step</code>理解为业务功能。</p>\n<h2 id="h2-1">Step配置</h2>\n<p><code>Step</code>是<code>Job</code>中的工作单元，每一个<code>Step</code>涵盖了单行记录的处理闭环。下图是一个<code>Step</code>的简要结构：</p>\n<p><img src="https://docs.spring.io/spring-batch/4.2.x/reference/html/images/step.png" alt="Spring Batch(3)——Step控制"\n        class="zoom-in-cursor"></p>\n<p>一个<code>Step</code>通常涵盖三个部分：读数据（Reader）、处理数据（Processor）和写数据（Writer）。但是并不是所有的<code>Step</code>都需要自身来完成数据的处理，比如存储过程等方式是通过外部功能来完成，因此Spring\n    Batch提供了2种Step的处理方式：1）面向分片的<code>ChunkStep</code>，2）面向过程的<code>TaskletStep</code>。但是基本上大部分情况下都是使用面向分片的方式来解决问题。</p>\n<h2 id="h2-2">面向分片的处理过程</h2>\n<p>在<code>Step</code>中数据是按记录（按行）处理的，但是每条记录处理完毕之后马上提交事物反而会导致IO的巨大压力。因此Spring\n    Batch提供了数据处理的分片功能。设置了分片之后，一次工作会从Read开始，然后交由给Processor处理。处理完毕后会进行聚合，待聚合到一定的数量的数据之后一次性调用Write将数据提交到物理数据库。其过程大致为：</p>\n<p><img src="https://docs.spring.io/spring-batch/4.2.x/reference/html/images/chunk-oriented-processing.png"\n        alt="Spring Batch(3)——Step控制" class="zoom-in-cursor"></p>\n<p>在Spring Batch中所谓的事物和数据事物的概念一样，就是一次性提交多少数据。如果在聚合数据期间出现任何错误，所有的这些数据都将不执行写入。</p>\n<h2 id="h2-3">面向对象配置Step</h2>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Job <span class="code-title">sampleJob</span><span\n        class="hljs-params">(JobRepository jobRepository, Step sampleStep)</span> </span>{\n    <span class="code-keyword">return</span> <span class="code-keyword">this</span>.jobBuilderFactory.get(<span\n            class="code-string">"sampleJob"</span>)\n    \t\t\t.repository(jobRepository)\n                .start(sampleStep)\n                .build();\n}\n\n<span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Step <span\n        class="code-title">sampleStep</span><span\n        class="hljs-params">(PlatformTransactionManager transactionManager)</span> </span>{\n\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>.stepBuilderFactory.get(<span\n            class="code-string">"sampleStep"</span>)\n\t\t\t\t.transactionManager(transactionManager)\n\t\t\t\t.&lt;String, String&gt;chunk(<span class="hljs-number">10</span>) <span\n            class="code-comment">//分片配置</span>\n\t\t\t\t.reader(itemReader()) <span class="code-comment">//reader配置</span>\n\t\t\t\t.writer(itemWriter()) <span class="code-comment">//write配置</span>\n\t\t\t\t.build();\n}\n</code></pre>\n<p>观察sampleStep方法：</p>\n<ol>\n    <li>reader: 使用ItemReader提供读数据的方法。</li>\n    <li>write：ItemWrite提供写数据的方法。</li>\n    <li>transactionManager：使用默认的 <code>PlatformTransactionManager</code> 对事物进行管理。<strong>当配置好事物之后Spring\n        Batch会自动对事物进行管理，无需开发人员显示操作</strong>。\n    </li>\n    <li>chunk：指定一次性数据提交的记录数，因为任务是基于Step分次处理的，当累计到chunk配置的次数则进行一次提交。提交的内容除了业务数据，还有批处理任务运行相关的元数据。</li>\n</ol>\n<p>是否使用<code>ItemProcessor</code>是一个可选项。如果没有Processor可以将数据视为读取并直接写入。</p>\n<h2 id="h2-4">提交间隔</h2>\n<p><code>Step</code>使用<code>PlatformTransactionManager</code>管理事物。每次事物提交的间隔根据<code>chunk</code>方法中配置的数据执行。如果设置为1，那么在每一条数据处理完之后都会调用<code>ItemWrite</code>进行提交。提交间隔设置太小，那么会浪费需要多不必要的资源，提交间隔设置的太长，会导致事物链太长占用空间，并且出现失败会导致大量数据回滚。因此设定一个合理的间隔是非常必要的，这需要根据实际业务情况、性能要求、以及数据安全程度来设定。如果没有明确的评估目标，设置为10~20较为合适。\n</p>\n<h2 id="h2-5">配置Step重启</h2>\n<p>前文介绍了<code>Job</code>的重启，但是每次重启对<code>Step</code>也是有很大的影响的，因此需要特定的配置。</p>\n<h3 id="h3-1">限定重启次数</h3>\n<p>某些<code>Step</code>可能用于处理一些先决的任务，所以当Job再次重启时这<code>Step</code>就没必要再执行，可以通过设置startLimit来限定某个<code>Step</code>重启的次数。当设置为1时候表示仅仅运行一次，而出现重启时将不再执行：\n</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Step <span class="code-title">step1</span><span\n        class="hljs-params">()</span> </span>{\n\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>.stepBuilderFactory.get(<span\n            class="code-string">"step1"</span>)\n\t\t\t\t.&lt;String, String&gt;chunk(<span class="hljs-number">10</span>)\n\t\t\t\t.reader(itemReader())\n\t\t\t\t.writer(itemWriter())\n\t\t\t\t.startLimit(<span class="hljs-number">1</span>)\n\t\t\t\t.build();\n}\n</code></pre>\n<h3 id="h3-2">重启已经完成任务的Step</h3>\n<p>\n    在单个<code>JobInstance</code>的上下文中，如果某个<code>Step</code>已经处理完毕（COMPLETED）那么在默认情况下重启之后这个<code>Step</code>并不会再执行。可以通过设置<code>allow-start-if-complete</code>为true告知框架每次重启该<code>Step</code>都要执行：\n</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Step <span class="code-title">step1</span><span\n        class="hljs-params">()</span> </span>{\n\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>.stepBuilderFactory.get(<span\n            class="code-string">"step1"</span>)\n\t\t\t\t.&lt;String, String&gt;chunk(<span class="hljs-number">10</span>)\n\t\t\t\t.reader(itemReader())\n\t\t\t\t.writer(itemWriter())\n\t\t\t\t.allowStartIfComplete(<span class="code-keyword">true</span>)\n\t\t\t\t.build();\n}\n</code></pre>\n<h2 id="h2-6">配置略过逻辑</h2>\n<p>某些时候在任务处理单个记录时中出现失败并不应该停止任务，而应该跳过继续处理下一条数据。是否跳过需要根据业务来判定，因此框架提供了跳过机制交给开发人员使用。如何配置跳过机制：</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Step <span class="code-title">step1</span><span\n        class="hljs-params">()</span> </span>{\n\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>.stepBuilderFactory.get(<span\n            class="code-string">"step1"</span>)\n\t\t\t\t.&lt;String, String&gt;chunk(<span class="hljs-number">10</span>)\n\t\t\t\t.reader(flatFileItemReader())\n\t\t\t\t.writer(itemWriter())\n\t\t\t\t.faultTolerant()\n\t\t\t\t.skipLimit(<span class="hljs-number">10</span>)\n\t\t\t\t.skip(FlatFileParseException.class)\n\t\t\t\t.build();\n}\n</code></pre>\n<p>代码的含义是当处理过程中抛出<code>FlatFileParseException</code>异常时就跳过该条记录的处理。<code>skip-limit</code>（skipLimit方法）配置的参数表示当跳过的次数超过数值时则会导致整个<code>Step</code>失败，从而停止继续运行。还可以通过反向配置的方式来忽略某些异常：\n</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Step <span class="code-title">step1</span><span\n        class="hljs-params">()</span> </span>{\n\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>.stepBuilderFactory.get(<span\n            class="code-string">"step1"</span>)\n\t\t\t\t.&lt;String, String&gt;chunk(<span class="hljs-number">10</span>)\n\t\t\t\t.reader(flatFileItemReader())\n\t\t\t\t.writer(itemWriter())\n\t\t\t\t.faultTolerant()\n\t\t\t\t.skipLimit(<span class="hljs-number">10</span>)\n\t\t\t\t.skip(Exception.class)\n\t\t\t\t.noSkip(FileNotFoundException.class)\n\t\t\t\t.build();\n}\n</code></pre>\n<p><code>skip</code>表示要当捕捉到<em>Exception</em>异常就跳过。但是<em>Exception</em>有很多继承类，此时可以使用<code>noSkip</code>方法指定某些异常不能跳过。</p>\n<h2 id="h2-7">设置重试逻辑</h2>\n<p>当处理记录出个异常之后并不希望他立即跳过或者停止运行，而是希望可以多次尝试执行直到失败：</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Step <span class="code-title">step1</span><span\n        class="hljs-params">()</span> </span>{\n\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>.stepBuilderFactory.get(<span\n            class="code-string">"step1"</span>)\n\t\t\t\t.&lt;String, String&gt;chunk(<span class="hljs-number">2</span>)\n\t\t\t\t.reader(itemReader())\n\t\t\t\t.writer(itemWriter())\n\t\t\t\t.faultTolerant()\n\t\t\t\t.retryLimit(<span class="hljs-number">3</span>)\n\t\t\t\t.retry(DeadlockLoserDataAccessException.class)\n\t\t\t\t.build();\n}\n</code></pre>\n<p><code>retry(DeadlockLoserDataAccessException.class)</code>表示只有捕捉到该异常才会重试，<code>retryLimit(3)</code>表示最多重试3次，<code>faultTolerant()</code>表示启用对应的容错功能。\n</p>\n<h2 id="h2-8">事物回滚控制</h2>\n<p>默认情况下，无论是设置了重试（retry）还是跳过（skip），只要从<code>Writer</code>抛出一个异常都会导致事物回滚。如果配置了skip机制，那么在<code>Reader</code>中抛出的异常不会导致回滚。有些从<code>Writer</code>抛出一个异常并不需要回滚数据，<code>noRollback</code>属性为<code>Step</code>提供了不必进行事物回滚的异常配置：\n</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Step <span class="code-title">step1</span><span\n        class="hljs-params">()</span> </span>{\n\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>.stepBuilderFactory.get(<span\n            class="code-string">"step1"</span>)\n\t\t\t\t.&lt;String, String&gt;chunk(<span class="hljs-number">2</span>)\n\t\t\t\t.reader(itemReader())\n\t\t\t\t.writer(itemWriter())\n\t\t\t\t.faultTolerant()\n\t\t\t\t.noRollback(ValidationException.class) <span class="code-comment">//不必回滚的异常</span>\n\t\t\t\t.build();\n}\n</code></pre>\n<h2 id="h2-9">事物数据读取的缓存</h2>\n<p>一次<code>Setp</code>分为<code>Reader</code>、<code>Processor</code>和<code>Writer</code>三个阶段，这些阶段统称为<code>Item</code>。默认情况下如果错误不是发生在Reader阶段，那么没必要再去重新读取一次数据。但是某些场景下需要Reader部分也需要重新执行，比如Reader是从一个JMS队列中消费消息，当发生回滚的时候消息也会在队列上重放，因此也要将Reader纳入到回滚的事物中，根据这个场景可以使用<code>readerIsTransactionalQueue</code>来配置数据重读：\n</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Step <span class="code-title">step1</span><span\n        class="hljs-params">()</span> </span>{\n\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>.stepBuilderFactory.get(<span\n            class="code-string">"step1"</span>)\n\t\t\t\t.&lt;String, String&gt;chunk(<span class="hljs-number">2</span>)\n\t\t\t\t.reader(itemReader())\n\t\t\t\t.writer(itemWriter())\n\t\t\t\t.readerIsTransactionalQueue() <span class="code-comment">//数据重读</span>\n\t\t\t\t.build();\n}\n</code></pre>\n<h2 id="h2-10">事物属性</h2>\n<p>\n    事物的属性包括<strong>隔离等级（isolation）</strong>、<strong>传播方式（propagation）<strong>以及</strong>过期时间（timeout）</strong>。关于事物的控制详见<a\n        href="https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#transaction"\n        title="Spring Data Access">Spring Data Access</a>的说明，下面是相关配置的方法：</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Step <span class="code-title">step1</span><span\n        class="hljs-params">()</span> </span>{\n\t<span class="code-comment">//配置事物属性</span>\n\tDefaultTransactionAttribute attribute = <span class="code-keyword">new</span> DefaultTransactionAttribute();\n\tattribute.setPropagationBehavior(Propagation.REQUIRED.value());\n\tattribute.setIsolationLevel(Isolation.DEFAULT.value());\n\tattribute.setTimeout(<span class="hljs-number">30</span>);\n\n\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>.stepBuilderFactory.get(<span\n            class="code-string">"step1"</span>)\n\t\t\t\t.&lt;String, String&gt;chunk(<span class="hljs-number">2</span>)\n\t\t\t\t.reader(itemReader())\n\t\t\t\t.writer(itemWriter())\n\t\t\t\t.transactionAttribute(attribute) <span class="code-comment">//设置事物属性</span>\n\t\t\t\t.build();\n}\n</code></pre>\n<h2 id="h2-11">向Step注册 ItemStream</h2>\n<p><code>ItemStream</code>是用于每一个阶段（Reader、Processor、Writer）的“生命周期回调数据处理器”，后续的文章会详细介绍<code>ItemStream</code>。在4.×版本之后默认注入注册了通用的<code>ItemStream</code>。\n</p>\n<p>有2种方式将<code>ItemStream</code>注册到<code>Step</code>中，一是使用<code>stream</code>方法：</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Step <span class="code-title">step1</span><span\n        class="hljs-params">()</span> </span>{\n\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>.stepBuilderFactory.get(<span\n            class="code-string">"step1"</span>)\n\t\t\t\t.&lt;String, String&gt;chunk(<span class="hljs-number">2</span>)\n\t\t\t\t.reader(itemReader())\n\t\t\t\t.writer(compositeItemWriter())\n\t\t\t\t.stream(fileItemWriter1())\n\t\t\t\t.stream(fileItemWriter2())\n\t\t\t\t.build();\n}\n</code></pre>\n<p>二是使用相关方法的代理：</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> CompositeItemWriter <span class="code-title">compositeItemWriter</span><span\n        class="hljs-params">()</span> </span>{\n\tList&lt;ItemWriter&gt; writers = <span class="code-keyword">new</span> ArrayList&lt;&gt;(<span\n            class="hljs-number">2</span>);\n\twriters.add(fileItemWriter1());\n\twriters.add(fileItemWriter2());\n\tCompositeItemWriter itemWriter = <span class="code-keyword">new</span> CompositeItemWriter();\n\titemWriter.setDelegates(writers);\n\t<span class="code-keyword">return</span> itemWriter;\n}\n</code></pre>\n<h2 id="h2-12">StepExecution拦截器</h2>\n<p>在<code>Step</code>执行的过程中会产生各种各样的事件，开发人员可以利用各种<code>Listener</code>接口对<code>Step</code>及<code>Item</code>进行监听。通常在创建一个Step的时候添加拦截器：\n</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Step <span class="code-title">step1</span><span\n        class="hljs-params">()</span> </span>{\n\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>.stepBuilderFactory.get(<span\n            class="code-string">"step1"</span>)\n\t\t\t\t.&lt;String, String&gt;chunk(<span class="hljs-number">10</span>)\n\t\t\t\t.reader(reader())\n\t\t\t\t.writer(writer())\n\t\t\t\t.listener(chunkListener()) <span class="code-comment">//添加拦截器</span>\n\t\t\t\t.build();\n}\n</code></pre>\n<p>Spring Batch提供了多个接口以满足不同事件的监听。</p>\n<h3 id="h3-3">StepExecutionListener</h3>\n<p><code>StepExecutionListener</code>可以看做一个通用的<code>Step</code>拦截器，他的作用是在Step开始之前和结束之后进行拦截处理：</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">StepExecutionListener</span> <span class="code-keyword">extends</span> <span\n        class="code-title">StepListener</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">beforeStep</span><span\n            class="hljs-params">(StepExecution stepExecution)</span></span>; <span\n            class="code-comment">//Step执行之前</span>\n    <span class="hljs-function">ExitStatus <span class="code-title">afterStep</span><span class="hljs-params">(StepExecution stepExecution)</span></span>; <span\n            class="code-comment">//Step执行完毕之后</span>\n}\n</code></pre>\n<p>在结束的时候开发人员可以自己定义返回的<code>ExitStatus</code>，用于配合流程控制（见后文）实现对整个Step执行过程的控制。</p>\n<h3 id="h3-4">ChunkListener</h3>\n<p><code>ChunkListener</code>是在数据事物发生的两端被触发。<code>chunk</code>的配置决定了处理多少项记录才进行一次事物提交，<code>ChunkListener</code>的作用就是对一次事物开始之后或事物提交之后进行拦截：\n</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">ChunkListener</span> <span class="code-keyword">extends</span> <span class="code-title">StepListener</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">beforeChunk</span><span\n            class="hljs-params">(ChunkContext context)</span></span>; <span\n            class="code-comment">//事物开始之后，ItemReader调用之前</span>\n    <span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">afterChunk</span><span\n            class="hljs-params">(ChunkContext context)</span></span>; <span class="code-comment">//事物提交之后</span>\n    <span class="hljs-function"><span class="code-keyword">void</span> <span\n            class="code-title">afterChunkError</span><span\n            class="hljs-params">(ChunkContext context)</span></span>; <span class="code-comment">//事物回滚之后</span>\n}\n</code></pre>\n<p>如果没有设定chunk也可以使用<code>ChunkListener</code>，它会被<code>TaskletStep</code>调用（<code>TaskletStep</code>见后文）。</p>\n<h3 id="h3-5">ItemReadListener</h3>\n<p>该接口用于对<code>Reader</code>相关的事件进行监控：</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">ItemReadListener</span>&lt;<span class="code-title">T</span>&gt; <span class="code-keyword">extends</span> <span\n        class="code-title">StepListener</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">beforeRead</span><span\n            class="hljs-params">()</span></span>;\n    <span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">afterRead</span><span\n            class="hljs-params">(T item)</span></span>;\n    <span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">onReadError</span><span\n            class="hljs-params">(Exception ex)</span></span>;\n}\n</code></pre>\n<p><code>beforeRead</code>在每次<code>Reader</code>调用之前被调用，<code>afterRead</code>在每次<code>Reader</code>成功返回之后被调用，而<code>onReadError</code>会在出现异常之后被调用，可以将其用于记录异常日志。\n</p>\n<h3 id="h3-6">ItemProcessListener</h3>\n<p><code>ItemProcessListener</code>和<code>ItemReadListener</code>类似，是围绕着<code>ItemProcessor</code>进行处理的：</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">ItemProcessListener</span>&lt;<span class="code-title">T</span>, <span\n        class="code-title">S</span>&gt; <span class="code-keyword">extends</span> <span\n        class="code-title">StepListener</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">void</span> <span\n            class="code-title">beforeProcess</span><span class="hljs-params">(T item)</span></span>; <span\n            class="code-comment">//processor执行之前</span>\n    <span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">afterProcess</span><span\n            class="hljs-params">(T item, S result)</span></span>; <span class="code-comment">//processor直线成功之后</span>\n    <span class="hljs-function"><span class="code-keyword">void</span> <span\n            class="code-title">onProcessError</span><span class="hljs-params">(T item, Exception e)</span></span>; <span\n            class="code-comment">//processor执行出现异常</span>\n}\n</code></pre>\n<h3 id="h3-7">ItemWriteListener</h3>\n<p><code>ItemWriteListener</code>的功能和<code>ItemReadListener</code>、<code>ItemReadListener</code>类似，但是需要注意的是它接收和处理的数据对象是一个<code>List</code>。<code>List</code>的长度与chunk配置相关。\n</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">ItemWriteListener</span>&lt;<span class="code-title">S</span>&gt; <span class="code-keyword">extends</span> <span\n        class="code-title">StepListener</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">beforeWrite</span><span\n            class="hljs-params">(List&lt;? extends S&gt; items)</span></span>;\n    <span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">afterWrite</span><span\n            class="hljs-params">(List&lt;? extends S&gt; items)</span></span>;\n    <span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">onWriteError</span><span\n            class="hljs-params">(Exception exception, List&lt;? extends S&gt; items)</span></span>;\n}\n</code></pre>\n<h3 id="h3-8">SkipListener</h3>\n<p><code>ItemReadListener</code>、<code>ItemProcessListener</code>和<code>ItemWriteListener</code>都提供了错误拦截处理的机制，但是没有处理跳过（skip）的数据记录。因此框架提供了<code>SkipListener</code>来专门处理那么被跳过的记录：\n</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">SkipListener</span>&lt;<span class="code-title">T</span>,<span class="code-title">S</span>&gt; <span\n        class="code-keyword">extends</span> <span class="code-title">StepListener</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">onSkipInRead</span><span\n            class="hljs-params">(Throwable t)</span></span>; <span class="code-comment">//Read期间导致跳过的异常</span>\n    <span class="hljs-function"><span class="code-keyword">void</span> <span\n            class="code-title">onSkipInProcess</span><span\n            class="hljs-params">(T item, Throwable t)</span></span>; <span\n            class="code-comment">//Process期间导致跳过的异常</span>\n    <span class="hljs-function"><span class="code-keyword">void</span> <span\n            class="code-title">onSkipInWrite</span><span class="hljs-params">(S item, Throwable t)</span></span>; <span\n            class="code-comment">//Write期间导致跳过的异常</span>\n}\n</code></pre>\n<p><code>SkipListener</code>的价值是可以将那些未能成功处理的记录在某个位置保存下来，然后交给其他批处理进一步解决，或者人工来处理。Spring Batch保证以下2个特征：</p>\n<ol>\n    <li>跳过的元素只会出现一次。</li>\n    <li><code>SkipListener</code>始终在事物提交之前被调用，这样可以保证监听器使用的事物资源不会被业务事物影响。</li>\n</ol>\n<h2 id="h2-13">TaskletStep</h2>\n<p>面向分片（Chunk-oriented processing\n    ）的过程并不是Step的唯一执行方式。比如用数据库的存储过程来处理数据，这个时候使用标准的Reader、Processor、Writer会很奇怪，针对这些情况框架提供了<code>TaskletStep</code>。</p>\n<p><code>TaskletStep</code>是一个非常简单的接口，仅有一个方法——<code>execute</code>。<code>TaskletStep</code>会反复的调用这个方法直到获取一个<code>RepeatStatus.FINISHED</code>返回或者抛出一个异常。所有的<code>Tasklet</code>调用都会包装在一个事物中。\n</p>\n<p>注册一个<code>TaskletStep</code>非常简单，只要添加一个实现了<code>Tasklet</code>接口的类即可：</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Step <span class="code-title">step1</span><span\n        class="hljs-params">()</span> </span>{\n    <span class="code-keyword">return</span> <span class="code-keyword">this</span>.stepBuilderFactory.get(<span\n            class="code-string">"step1"</span>)\n    \t\t\t.tasklet(myTasklet()) <span class="code-comment">//注入Tasklet的实现</span>\n    \t\t\t.build();\n}\n</code></pre>\n<p><code>TaskletStep</code>还支持适配器处理等，详见<a\n        href="https://docs.spring.io/spring-batch/4.2.x/reference/html/step.html#taskletStep" title="官网说明">官网说明</a>。</p>\n<h2 id="h2-14">控制Step执行流程</h2>\n<h3 id="h3-9">顺序执行</h3>\n<p>默认情况下。Step与Step之间是顺序执行的，如下图：</p>\n<p><img src="https://docs.spring.io/spring-batch/4.2.x/reference/html/images/sequential-flow.png"\n        alt="Spring Batch(3)——Step控制" title="Step顺序执行" class="zoom-in-cursor"></p>\n<p>顺序执行通过<code>next</code>方法来标记：</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Job <span class="code-title">job</span><span\n        class="hljs-params">()</span> </span>{\n\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>.jobBuilderFactory.get(<span\n            class="code-string">"job"</span>)\n\t\t\t\t.start(stepA())\n\t\t\t\t.next(stepB()) <span class="code-comment">//顺序执行</span>\n\t\t\t\t.next(stepC())\n\t\t\t\t.build();\n}\n</code></pre>\n<h3 id="h3-10">条件执行</h3>\n<p>在顺序执行的过程中，在整个执行链条中有一个<code>Step</code>执行失败则整个<code>Job</code>就会停止。但是通过条件执行，可以指定各种情况下的执行分支：</p>\n<p><img src="https://docs.spring.io/spring-batch/4.2.x/reference/html/images/conditional-flow.png"\n        alt="Spring Batch(3)——Step控制" title="Step条件执行" class="zoom-in-cursor"></p>\n<p>为了实现更加复杂的控制，可以通过<code>Step</code>执行后的退出命名来定义条件分之。先看一个简单的代码：</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Job <span class="code-title">job</span><span\n        class="hljs-params">()</span> </span>{\n\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>.jobBuilderFactory.get(<span\n            class="code-string">"job"</span>)\n\t\t\t\t.start(stepA()) <span class="code-comment">//启动时执行的step</span>\n\t\t\t\t.on(<span class="code-string">"*"</span>).to(stepB()) <span class="code-comment">//默认跳转到stepB</span>\n\t\t\t\t.from(stepA()).on(<span class="code-string">"FAILED"</span>).to(stepC()) <span class="code-comment">//当返回的ExitStatus为"FAILED"时，执行。</span>\n\t\t\t\t.end()\n\t\t\t\t.build();\n}\n</code></pre>\n<p>这里使用*来表示默认处理，*是一个通配符表示处理任意字符串，对应的还可以使用?表示匹配任意字符。在<a\n        href="https://www.chkui.com/article/spring/spring_batch_introduction" title="Spring Batch(1)——数据批处理概念">Spring\n    Batch(1)——数据批处理概念</a>一文中介绍了Step的退出都会有<code>ExitStatus</code>，命名都来源于它。下面是一个更加全面的代码。</p>\n<ol>\n    <li>配置拦截器处理ExitCode：</li>\n</ol>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">SkipCheckingListener</span> <span class="code-keyword">extends</span> <span\n        class="code-title">StepExecutionListenerSupport</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> ExitStatus <span\n            class="code-title">afterStep</span><span class="hljs-params">(StepExecution stepExecution)</span> </span>{\n        String exitCode = stepExecution.getExitStatus().getExitCode();\n        <span class="code-keyword">if</span> (!exitCode.equals(ExitStatus.FAILED.getExitCode()) &amp;&amp;\n              stepExecution.getSkipCount() &gt; <span class="hljs-number">0</span>) { <span class="code-comment">//当Skip的Item大于0时，则指定ExitStatus的内容</span>\n            <span class="code-keyword">return</span> <span class="code-keyword">new</span> ExitStatus(<span\n            class="code-string">"COMPLETED WITH SKIPS"</span>);\n        }\n        <span class="code-keyword">else</span> {\n            <span class="code-keyword">return</span> <span class="code-keyword">null</span>;\n        }\n    }\n}\n</code></pre>\n<p>拦截器指示当有一个以上被跳过的记录时，返回的<code>ExitStatus</code>为"COMPLETED WITH SKIPS"。对应的控制流程：</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Job <span class="code-title">job</span><span\n        class="hljs-params">()</span> </span>{\n\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>.jobBuilderFactory.get(<span\n            class="code-string">"job"</span>)\n\t\t\t.start(step1()).on(<span class="code-string">"FAILED"</span>).end() <span\n            class="code-comment">//执行失败直接退出</span>\n\t\t\t.from(step1()).on(<span class="code-string">"COMPLETED WITH SKIPS"</span>).to(errorPrint1()) <span\n            class="code-comment">//有跳过元素执行 errorPrint1()</span>\n\t\t\t.from(step1()).on(<span class="code-string">"*"</span>).to(step2()) <span class="code-comment">//默认（成功）情况下执行 Step2</span>\n\t\t\t.end()\n\t\t\t.build();\n}\n</code></pre>\n<h3 id="h3-11">Step的停机退出机制</h3>\n<p>Spring Batch为<code>Job</code>提供了三种退出机制，这些机制为批处理的执行提供了丰富的控制方法。在介绍退出机制之前需要回顾一下 <a\n        href="https://www.chkui.com/article/spring/spring_batch_introduction" title="数据批处理概念">数据批处理概念</a>一文中关于<code>StepExecution</code>的内容。在<code>StepExecution</code>中有2个表示状态的值，一个名为<code>status</code>，另外一个名为<code>exitStatus</code>。前者也被称为<code>BatchStatus</code>。\n</p>\n<p>前面以及介绍了<code>ExitStatus</code>的使用，他可以控制Step执行链条的条件执行过程。除此之外<code>BatchStatus</code>也会参与到过程的控制。</p>\n<h4 id="h4-1">End退出</h4>\n<p>默认情况下（没有使用<code>end</code>、<code>fail</code>方法结束），<code>Job</code>要顺序执行直到退出，这个退出称为<code>end</code>。这个时候，<code>BatchStatus</code>=<code>COMPLETED</code>、<code>ExitStatus</code>=<code>COMPLETED</code>，表示成功执行。\n</p>\n<p>除了<code>Step</code>链式处理自然退出，也可以显示调用<code>end</code>来退出系统。看下面的例子：</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Job <span class="code-title">job</span><span\n        class="hljs-params">()</span> </span>{\n\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>.jobBuilderFactory.get(<span\n            class="code-string">"job"</span>)\n\t\t\t\t.start(step1()) <span class="code-comment">//启动</span>\n\t\t\t\t.next(step2()) <span class="code-comment">//顺序执行</span>\n\t\t\t\t.on(<span class="code-string">"FAILED"</span>).end()\n\t\t\t\t.from(step2()).on(<span class="code-string">"*"</span>).to(step3()) <span\n            class="code-comment">//条件执行</span>\n\t\t\t\t.end()\n\t\t\t\t.build();\n}\n</code></pre>\n<p>\n    上面的代码，<code>step1</code>到<code>step2</code>是顺序执行，当<code>step2</code>的<code>exitStatus</code>返回"FAILED"时则直接<em>End退出</em>。其他情况执行<code>Step3</code>。\n</p>\n<h4 id="h4-2">Fail退出</h4>\n<p>除了<code>end</code>还可以使用<code>fail</code>退出，这个时候，<code>BatchStatus</code>=<code>FAILED</code>、<code>ExitStatus</code>=<code>EARLY\n    TERMINATION</code>，表示执行失败。这个状态与<code>End</code>最大的区别是<code>Job</code>会尝试重启执行新的<code>JobExecution</code>。看下面代码的例子：\n</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Job <span class="code-title">job</span><span\n        class="hljs-params">()</span> </span>{\n\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>.jobBuilderFactory.get(<span\n            class="code-string">"job"</span>)\n\t\t\t.start(step1()) <span class="code-comment">//执行step1</span>\n\t\t\t.next(step2()).on(<span class="code-string">"FAILED"</span>).fail() <span class="code-comment">//step2的ExitStatus=FAILED 执行fail</span>\n\t\t\t.from(step2()).on(<span class="code-string">"*"</span>).to(step3()) <span\n            class="code-comment">//否则执行step3</span>\n\t\t\t.end()\n\t\t\t.build();\n}\n</code></pre>\n<h4 id="h4-3">在指定的节点中断</h4>\n<p>Spring Batch还支持在指定的节点退出，退出后下次重启会从中断的点继续执行。中断的作用是某些批处理到某个步骤后需要人工干预，当干预完之后又接着处理：</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Job <span class="code-title">job</span><span\n        class="hljs-params">()</span> </span>{\n\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>.jobBuilderFactory.get(<span\n            class="code-string">"job"</span>)\n\t \t\t<span class="code-comment">//如果step1的ExitStatus=COMPLETED则在step2中断</span>\n\t\t\t.start(step1()).on(<span class="code-string">"COMPLETED"</span>).stopAndRestart(step2())\n\t\t\t <span class="code-comment">//否则直接退出批处理</span>\n\t\t\t.end()\n\t\t\t.build();\n}\n</code></pre>\n<h3 id="h3-12">程序化流程的分支</h3>\n<p>可以直接进行编码来控制<code>Step</code>之间的扭转，Spring Batch提供了<code>JobExecutionDecider</code>接口来协助分支管理：</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">MyDecider</span> <span class="code-keyword">implements</span> <span class="code-title">JobExecutionDecider</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> FlowExecutionStatus <span class="code-title">decide</span><span\n            class="hljs-params">(JobExecution jobExecution, StepExecution stepExecution)</span> </span>{\n        String status;\n        <span class="code-keyword">if</span> (someCondition()) {\n            status = <span class="code-string">"FAILED"</span>;\n        }\n        <span class="code-keyword">else</span> {\n            status = <span class="code-string">"COMPLETED"</span>;\n        }\n        <span class="code-keyword">return</span> <span class="code-keyword">new</span> FlowExecutionStatus(status);\n    }\n}\n</code></pre>\n<p>接着将<code>MyDecider</code>作为过滤器添加到配置过程中：</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Job <span class="code-title">job</span><span\n        class="hljs-params">()</span> </span>{\n\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>.jobBuilderFactory.get(<span\n            class="code-string">"job"</span>)\n\t\t\t.start(step1())\n\t\t\t.next(decider()).on(<span class="code-string">"FAILED"</span>).to(step2())\n\t\t\t.from(decider()).on(<span class="code-string">"COMPLETED"</span>).to(step3())\n\t\t\t.end()\n\t\t\t.build();\n}\n</code></pre>\n<h3 id="h3-13">流程分裂</h3>\n<p>在线性处理过程中，流程都是一个接着一个执行的。但是为了满足某些特殊的需要，Spring Batch提供了执行的过程分裂并行<code>Step</code>的方法。参看下面的<code>Job</code>配置：</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Job <span class="code-title">job</span><span\n        class="hljs-params">()</span> </span>{\n\tFlow flow1 = <span class="code-keyword">new</span> FlowBuilder&lt;SimpleFlow&gt;(<span\n            class="code-string">"flow1"</span>)\n\t\t\t.start(step1())\n\t\t\t.next(step2())\n\t\t\t.build();<span class="code-comment">//并行流程1</span>\n\tFlow flow2 = <span class="code-keyword">new</span> FlowBuilder&lt;SimpleFlow&gt;(<span\n            class="code-string">"flow2"</span>)\n\t\t\t.start(step3())\n\t\t\t.build();<span class="code-comment">//并行流程2</span>\n\n\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>.jobBuilderFactory.get(<span\n            class="code-string">"job"</span>)\n\t\t\t\t.start(flow1)\n\t\t\t\t.split(<span class="code-keyword">new</span> SimpleAsyncTaskExecutor()) <span class="code-comment">//创建一个异步执行任务</span>\n\t\t\t\t.add(flow2)\n\t\t\t\t.next(step4()) <span class="code-comment">//2个分支执行完毕之后再执行step4。</span>\n\t\t\t\t.end()\n\t\t\t\t.build();\n}\n</code></pre>\n<p>这里表示flow1和flow2会并行执行，待2者执行成功后执行step4。</p>\n<h3 id="h3-14">数据绑定</h3>\n<p>在<code>Job</code>或<code>Step</code>的任何位置，都可以获取到统一配置的数据。比如使用标准的Spring Framework方式：</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> FlatFileItemReader <span class="code-title">flatFileItemReader</span><span\n        class="hljs-params">(@Value(<span class="code-string">"${input.file.name}"</span>)</span> String name) </span>{\n\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> FlatFileItemReaderBuilder&lt;Foo&gt;()\n\t\t\t.name(<span class="code-string">"flatFileItemReader"</span>)\n\t\t\t.resource(<span class="code-keyword">new</span> FileSystemResource(name))\n\t\t\t...\n}\n</code></pre>\n<p>当我们通过配置文件（application.properties中\n    <code>input.file.name=filepath</code>）或者jvm参数（<code>-Dinput.file.name=filepath</code>）指定某些数据时，都可以通过这种方式获取到对应的配置参数。\n</p>\n<p>此外，也可以从<code>JobParameters</code>从获取到<code>Job</code>运行的上下文参数：</p>\n<pre><code class="Java"><span class="code-meta">@StepScope</span>\n<span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> FlatFileItemReader <span class="code-title">flatFileItemReader</span><span\n        class="hljs-params">(@Value(<span class="code-string">"#{jobParameters[\'input.file.name\']}"</span>)</span> String name) </span>{\n\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> FlatFileItemReaderBuilder&lt;Foo&gt;()\n\t\t\t.name(<span class="code-string">"flatFileItemReader"</span>)\n\t\t\t.resource(<span class="code-keyword">new</span> FileSystemResource(name))\n\t\t\t...\n}\n</code></pre>\n<p>无论是<code>JobExecution</code>还是<code>StepExecution</code>，其中的内容都可以通过这种方式去获取参数，例如：</p>\n<pre><code class="Java"><span class="code-meta">@StepScope</span>\n<span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> FlatFileItemReader <span class="code-title">flatFileItemReader</span><span\n        class="hljs-params">(@Value(<span class="code-string">"#{jobExecutionContext[\'input.file.name\']}"</span>)</span> String name) </span>{\n\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> FlatFileItemReaderBuilder&lt;Foo&gt;()\n\t\t\t.name(<span class="code-string">"flatFileItemReader"</span>)\n\t\t\t.resource(<span class="code-keyword">new</span> FileSystemResource(name))\n\t\t\t...\n}\n</code></pre>\n<p>或者</p>\n<pre><code class="Java"><span class="code-meta">@StepScope</span>\n<span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> FlatFileItemReader <span class="code-title">flatFileItemReader</span><span\n        class="hljs-params">(@Value(<span\n        class="code-string">"#{stepExecutionContext[\'input.file.name\']}"</span>)</span> String name) </span>{\n\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> FlatFileItemReaderBuilder&lt;Foo&gt;()\n\t\t\t.name(<span class="code-string">"flatFileItemReader"</span>)\n\t\t\t.resource(<span class="code-keyword">new</span> FileSystemResource(name))\n\t\t\t...\n}\n</code></pre>\n<h4 id="h4-4">Step Scope</h4>\n<p>注意看上面的代码例子，都有一个<code>@StepScope</code>注解。这是为了进行后期绑定进行的标识。因为在Spring的IoCs容器进行初始化的阶段并没有任何的<code>*Execution</code>在执行，进而也不存在任何<code>*ExecutionContext</code>，所以这个时候根本无法注入标记的数据。所以需要使用注解显式的告诉容器直到<code>Step</code>执行的阶段才初始化这个<code>@Bean</code>。\n</p>\n<h4 id="h4-5">Job Scope</h4>\n<p>Job Scope的概念和 Step Scope类似，都是用于标识在到了某个执行时间段再添加和注入Bean。<code>@JobScope</code>用于告知框架知道<code>JobInstance</code>存在时候才初始化对应的<code>@Bean</code>：\n</p>\n<pre><code class="Java"><span class="code-meta">@JobScope</span>\n<span class="code-meta">@Bean</span>\n<span class="code-comment">// 初始化获取 jobParameters中的参数</span>\n<span class="hljs-function"><span class="code-keyword">public</span> FlatFileItemReader <span class="code-title">flatFileItemReader</span><span\n        class="hljs-params">(@Value(<span\n        class="code-string">"#{jobParameters[input]}"</span>)</span> String name) </span>{\n\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> FlatFileItemReaderBuilder&lt;Foo&gt;()\n\t\t\t.name(<span class="code-string">"flatFileItemReader"</span>)\n\t\t\t.resource(<span class="code-keyword">new</span> FileSystemResource(name))\n\t\t\t...\n}\n</code></pre>\n<pre><code class="Java"><span class="code-meta">@JobScope</span>\n<span class="code-meta">@Bean</span>\n<span class="code-comment">// 初始化获取jobExecutionContext中的参数</span>\n<span class="hljs-function"><span class="code-keyword">public</span> FlatFileItemReader <span class="code-title">flatFileItemReader</span><span\n        class="hljs-params">(@Value(<span class="code-string">"#{jobExecutionContext中的参数[\'input.name\']}"</span>)</span> String name) </span>{\n\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> FlatFileItemReaderBuilder&lt;Foo&gt;()\n\t\t\t.name(<span class="code-string">"flatFileItemReader"</span>)\n\t\t\t.resource(<span class="code-keyword">new</span> FileSystemResource(name))\n\t\t\t...\n}\n</code></pre>'},402:function(s,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<p>在 <a href="https://www.chkui.com/article/spring/spring_batch_introduction" title="批处理概念">批处理概念</a> 中介绍一个标准的批处理分为 <a\n        href="https://www.chkui.com/article/spring/spring_batch_job" title="Job">Job</a> 和 <a\n        href="https://www.chkui.com/article/spring/spring_batch_step">Step</a>。本文将结合代码介绍在<code>Step</code>中<code>Reader</code>、<code>Processor</code>、<code>Writer</code>的实际使用。\n</p>\n<h2 id="h2-1">Reader</h2>\n<p><code>Reader</code>是指从各种各样的外部输入中获取数据，框架为获取各种类型的文件已经预定义了常规的<code>Reader</code>实现类。<code>Reader</code>通过<code>ItemReader</code>接口实现：\n</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">ItemReader</span>&lt;<span class="code-title">T</span>&gt; </span>{\n    <span class="hljs-function">T <span class="code-title">read</span><span class="hljs-params">()</span> <span\n            class="code-keyword">throws</span> Exception, UnexpectedInputException, ParseException, NonTransientResourceException</span>;\n}\n</code></pre>\n<p><code>read</code>方法的作用就是读取一条数据，数据以泛型T的实体结构返回，<strong>当read返回null时表示所有数据读取完毕</strong>。返回的数据可以是任何结构，比如文件中的一行字符串，数据库的一行数据，或者xml文件中的一系列元素，只要是一个Java对象即可。\n</p>\n<h2 id="h2-2">Writer</h2>\n<p><code>Writer</code>通过<code>ItemWriter</code>接口实现：</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">ItemWriter</span>&lt;<span class="code-title">T</span>&gt; </span>{\n    <span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">write</span><span\n            class="hljs-params">(List&lt;? extends T&gt; items)</span> <span class="code-keyword">throws</span> Exception</span>;\n}\n</code></pre>\n<p><code>Writer</code>是<code>Reader</code>的反向操作，是将数据写入到特定的数据源中。在<a\n        href="https://www.chkui.com/article/spring/spring_batch_step" title="Step控制">Step控制</a>一文已经介绍<code>Writer</code>是根据<code>chunk</code>属性设定的值按列表进行操作的，所以传入的是一个<code>List</code>结构。<code>chunk</code>用于表示批处理的事物分片，因此需要注意的是，在<code>writer</code>方法中进行完整数据写入事物操作。例如向数据库写入<code>List</code>中的数据，在写入完成之后再提交事物。\n</p>\n<h2 id="h2-3">读写的组合模式</h2>\n<p>无论是读还是写，有时会需要从多个不同的来源获取文件，或者写入到不同的数据源，或者是需要在读和写之间处理一些业务。可以使用组合模式来实现这个目的：</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">CompositeItemWriter</span>&lt;<span class="code-title">T</span>&gt; <span\n        class="code-keyword">implements</span> <span class="code-title">ItemWriter</span>&lt;<span\n        class="code-title">T</span>&gt; </span>{\n    ItemWriter&lt;T&gt; itemWriter;\n    <span class="hljs-function"><span class="code-keyword">public</span> <span\n            class="code-title">CompositeItemWriter</span><span\n            class="hljs-params">(ItemWriter&lt;T&gt; itemWriter)</span> </span>{\n        <span class="code-keyword">this</span>.itemWriter = itemWriter;\n    }\n\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">write</span><span class="hljs-params">(List&lt;? extends T&gt; items)</span> <span\n            class="code-keyword">throws</span> Exception </span>{\n        <span class="code-comment">//Add business logic here</span>\n       itemWriter.write(items);\n    }\n\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setDelegate</span><span\n            class="hljs-params">(ItemWriter&lt;T&gt; itemWriter)</span></span>{\n        <span class="code-keyword">this</span>.itemWriter = itemWriter;\n    }\n}\n</code></pre>\n<h2 id="h2-4">Processor</h2>\n<p>除了使用组合模式，直接使用<code>Processor</code>是一种更优雅的方法。<code>Processor</code>是<code>Step</code>中的可选项，但是批处理大部分时候都需要对数据进行处理，因此框架提供了<code>ItemProcessor</code>接口来满足<code>Processor</code>过程：\n</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">ItemProcessor</span>&lt;<span class="code-title">I</span>, <span class="code-title">O</span>&gt; </span>{\n    <span class="hljs-function">O <span class="code-title">process</span><span class="hljs-params">(I item)</span> <span\n            class="code-keyword">throws</span> Exception</span>;\n}\n</code></pre>\n<p><code>Processor</code>的结构非常简单也是否易于理解。传入一个类型I，然后由<code>Processor</code>处理成为O。</p>\n<h3 id="h3-1">Processor链</h3>\n<p>在一个<a href="https://www.chkui.com/article/spring/spring_batch_step">Step</a>中可以使用多个<code>Processor</code>来按照顺序处理业务，此时同样可以使用<code>CompositeItem</code>模式来实现：\n</p>\n<pre><code class="Java">\n<span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> CompositeItemProcessor <span class="code-title">compositeProcessor</span><span\n        class="hljs-params">()</span> </span>{\n    <span class="code-comment">//创建 CompositeItemProcessor</span>\n    CompositeItemProcessor&lt;Foo,Foobar&gt; compositeProcessor = <span class="code-keyword">new</span> CompositeItemProcessor&lt;Foo,Foobar&gt;();\n    List itemProcessors = <span class="code-keyword">new</span> ArrayList();\n    <span class="code-comment">//添加第一个 Processor</span>\n    itemProcessors.add(<span class="code-keyword">new</span> FooTransformer());\n    <span class="code-comment">//添加第二个 Processor</span>\n    itemProcessors.add(<span class="code-keyword">new</span> BarTransformer());\n    <span class="code-comment">//添加链表</span>\n    compositeProcessor.setDelegates(itemProcessors);\n    <span class="code-keyword">return</span> processor;\n}\n</code></pre>\n<h3 id="h3-2">过滤记录</h3>\n<p>\n    在<code>Reader</code>读取数据的过程中，并不是所有的数据都可以使用，此时<code>Processor</code>还可以用于过滤非必要的数据，同时不会影响<code>Step</code>的处理过程。只要<code>ItemProcesspr</code>的实现类在<code>procss</code>方法中返回<code>null</code>即表示改行数据被过滤掉了。\n</p>\n<h2 id="h2-5">ItemStream</h2>\n<p>在<a href="https://www.chkui.com/article/spring/spring_batch_step">Step控制</a>一文中已经提到了<code>ItemStream</code>。在<a\n        href="https://www.chkui.com/article/spring/spring_batch_introduction">数据批处理概念</a>中提到过，Spring\n    Batch的每一步都是无状态的，进而<code>Reader</code>和<code>Writer</code>也是无状态的，这种方式能够很好的隔离每行数据的处理，也能将容错的范围收窄到可以空子的范围。但是这并不意味着整个批处理的过程中并不需要控制状态。例如从数据库持续读入或写入数据，每次<code>Reader</code>和<code>Writer</code>都单独去申请数据源的链接、维护数据源的状态（打开、关闭等）。因此框架提供了<code>ItemStream</code>接口来完善这些操作：\n</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">ItemStream</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">open</span><span\n            class="hljs-params">(ExecutionContext executionContext)</span> <span class="code-keyword">throws</span> ItemStreamException</span>;\n    <span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">update</span><span\n            class="hljs-params">(ExecutionContext executionContext)</span> <span class="code-keyword">throws</span> ItemStreamException</span>;\n    <span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">close</span><span\n            class="hljs-params">()</span> <span class="code-keyword">throws</span> ItemStreamException</span>;\n}\n</code></pre>\n<h2 id="h2-6">持久化数据</h2>\n<p>在使用Spring Batch之前需要初始化他的元数据存储（Meta-Data Schema）,也就是要将需要用到的表导入到对应的数据库中。当然，Spring\n    Batch支持不使用任何持久化数据库，仅仅将数据放到内存中，不设置<code>DataSource</code>即可。</p>\n<h3 id="h3-3">初始化序列</h3>\n<p>Spring Batch相关的工作需要使用序列<code>SEQUENCE</code>：</p>\n<pre><code class="SQL"><span class="code-keyword">CREATE</span> <span class="code-keyword">SEQUENCE</span> BATCH_STEP_EXECUTION_SEQ;\n<span class="code-keyword">CREATE</span> <span class="code-keyword">SEQUENCE</span> BATCH_JOB_EXECUTION_SEQ;\n<span class="code-keyword">CREATE</span> <span class="code-keyword">SEQUENCE</span> BATCH_JOB_SEQ;\n</code></pre>\n<p>有些数据库不支持<code>SEQUENCE</code>，可以通过表代理，比如在MySql（InnoDB数据库）中：</p>\n<pre><code class="SQL"><span class="code-keyword">CREATE</span> <span class="code-keyword">TABLE</span> BATCH_STEP_EXECUTION_SEQ (<span\n        class="code-keyword">ID</span> <span class="code-built_in">BIGINT</span> <span\n        class="code-keyword">NOT</span> <span class="hljs-literal">NULL</span>);\n<span class="code-keyword">INSERT</span> <span class="code-keyword">INTO</span> BATCH_STEP_EXECUTION_SEQ <span\n            class="code-keyword">values</span>(<span class="hljs-number">0</span>);\n<span class="code-keyword">CREATE</span> <span class="code-keyword">TABLE</span> BATCH_JOB_EXECUTION_SEQ (<span\n            class="code-keyword">ID</span> <span class="code-built_in">BIGINT</span> <span\n            class="code-keyword">NOT</span> <span class="hljs-literal">NULL</span>);\n<span class="code-keyword">INSERT</span> <span class="code-keyword">INTO</span> BATCH_JOB_EXECUTION_SEQ <span\n            class="code-keyword">values</span>(<span class="hljs-number">0</span>);\n<span class="code-keyword">CREATE</span> <span class="code-keyword">TABLE</span> BATCH_JOB_SEQ (<span\n            class="code-keyword">ID</span> <span class="code-built_in">BIGINT</span> <span\n            class="code-keyword">NOT</span> <span class="hljs-literal">NULL</span>);\n<span class="code-keyword">INSERT</span> <span class="code-keyword">INTO</span> BATCH_JOB_SEQ <span\n            class="code-keyword">values</span>(<span class="hljs-number">0</span>);\n</code></pre>\n<h3 id="h3-4">关于Version字段</h3>\n<p>某些表中都有<code>Version</code>字段。因为Spring的更新策略是乐观锁，因此在进行数据更新之后都会对表的<code>Version</code>字段进行+1处理。在内存与数据库交互的过程中，会使用采用<em>getVersion</em>、<em>increaseVersion（+1）</em>、<em>updateDataAndVersion</em>的过程，如果在<code>update</code>的时候发现Version不是预计的数值（+1），则会抛出<code>OptimisticLockingFailureException</code>的异常。当同一个<code>Job</code>在进群中不同服务上执行时，需要注意这个问题。\n</p>\n<h3 id="h3-5">BATCH_JOB_INSTANCE</h3>\n<p><code>BATCH_JOB_INSTANCE</code>用于记录JobInstance，在<a\n        href="https://www.chkui.com/article/spring/spring_batch_introduction">数据批处理概念</a>中介绍了他的工作方式，其结构为：</p>\n<pre><code class="SQL"><span class="code-keyword">CREATE</span> <span class="code-keyword">TABLE</span> BATCH_JOB_INSTANCE  (\n  JOB_INSTANCE_ID <span class="code-built_in">BIGINT</span>  PRIMARY <span class="code-keyword">KEY</span> ,\n  <span class="code-keyword">VERSION</span> <span class="code-built_in">BIGINT</span>,\n  JOB_NAME <span class="code-built_in">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="code-keyword">NOT</span> <span\n            class="hljs-literal">NULL</span> ,\n  JOB_KEY <span class="code-built_in">VARCHAR</span>(<span class="hljs-number">2500</span>)\n);\n</code></pre>\n<table>\n    <thead>\n    <tr>\n        <th>字段</th>\n        <th>说明</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n        <td>JOB_INSTANCE_ID</td>\n        <td>主键，主键与单个<code>JobInstance</code>相关。当获取到某个<code>JobInstance</code>实例后，通过<code>getId</code>方法可以获取到此数据</td>\n    </tr>\n    <tr>\n        <td>VERSION</td>\n        <td></td>\n    </tr>\n    <tr>\n        <td>JOB_NAME</td>\n        <td>Job的名称，用于标记运行的Job，在创建Job时候指定</td>\n    </tr>\n    <tr>\n        <td>JOB_KEY</td>\n        <td><em>JobParameters</em>的序列化数值。在<a href="https://www.chkui.com/article/spring/spring_batch_introduction">数据批处理概念</a>中介绍了一个<code>JobInstance</code>相当于<em>Job</em>+<em>JobParameters</em>。他用于标记同一个<code>Job</code>不同的实例\n        </td>\n    </tr>\n    </tbody>\n</table>\n<h3 id="h3-6">BATCH_JOB_EXECUTION_PARAMS</h3>\n<p><code>BATCH_JOB_EXECUTION_PARAMS</code>对应的是<code>JobParameters</code>对象。其核心功能是存储<em>Key-Value</em>结构的各种状态数值。字段中<code>IDENTIFYING=true</code>用于标记那些运行过程中必须的数据（可以理解是框架需要用到的数据），为了存储<em>key-value</em>结构该表一个列数据格式：\n</p>\n<pre><code class="SQL"><span class="code-keyword">CREATE</span> <span class="code-keyword">TABLE</span> BATCH_JOB_EXECUTION_PARAMS  (\n\tJOB_EXECUTION_ID <span class="code-built_in">BIGINT</span> <span class="code-keyword">NOT</span> <span\n            class="hljs-literal">NULL</span> ,\n\tTYPE_CD <span class="code-built_in">VARCHAR</span>(<span class="hljs-number">6</span>) <span class="code-keyword">NOT</span> <span\n            class="hljs-literal">NULL</span> ,\n\tKEY_NAME <span class="code-built_in">VARCHAR</span>(<span class="hljs-number">100</span>) <span\n            class="code-keyword">NOT</span> <span class="hljs-literal">NULL</span> ,\n\tSTRING_VAL <span class="code-built_in">VARCHAR</span>(<span class="hljs-number">250</span>) ,\n\tDATE_VAL DATETIME <span class="code-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> ,\n\tLONG_VAL <span class="code-built_in">BIGINT</span> ,\n\tDOUBLE_VAL <span class="code-keyword">DOUBLE</span> <span class="code-keyword">PRECISION</span> ,\n\tIDENTIFYING <span class="code-built_in">CHAR</span>(<span class="hljs-number">1</span>) <span class="code-keyword">NOT</span> <span\n            class="hljs-literal">NULL</span> ,\n\t<span class="code-keyword">constraint</span> JOB_EXEC_PARAMS_FK foreign <span class="code-keyword">key</span> (JOB_EXECUTION_ID)\n\t<span class="code-keyword">references</span> BATCH_JOB_EXECUTION(JOB_EXECUTION_ID)\n);\n</code></pre>\n<table>\n    <thead>\n    <tr>\n        <th>字段</th>\n        <th>说明</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n        <td>JOB_EXECUTION_ID</td>\n        <td>与<em>BATCH_JOB_EXECUTION</em>表关联的外键，详见<a\n                href="https://www.chkui.com/article/spring/spring_batch_introduction">数据批处理概念</a>中<em>Job</em>、<em>JobInstance</em>、<em>JobExecute</em>的关系\n        </td>\n    </tr>\n    <tr>\n        <td>TYPE_CD</td>\n        <td>用于标记数据的对象类型，例如 <em>string</em>、<em>date</em>、<em>long</em>、<em>double</em>，非空</td>\n    </tr>\n    <tr>\n        <td>KEY_NAME</td>\n        <td>key的值</td>\n    </tr>\n    <tr>\n        <td>STRING_VAL</td>\n        <td><em>string</em>类型的数值</td>\n    </tr>\n    <tr>\n        <td>DATE_VAL</td>\n        <td><em>date</em>类型的数值</td>\n    </tr>\n    <tr>\n        <td>LONG_VAL</td>\n        <td><em>long</em>类型的数值</td>\n    </tr>\n    <tr>\n        <td>DOUBLE_VAL</td>\n        <td><em>double</em>类型的数值</td>\n    </tr>\n    <tr>\n        <td>IDENTIFYING</td>\n        <td>标记这对<em>key-valuse</em>是否来自于<em>JobInstace</em>自身</td>\n    </tr>\n    </tbody>\n</table>\n<h3 id="h3-7">BATCH_JOB_EXECUTION</h3>\n<p>关联<code>JobExecution</code>，每当运行一个<code>Job</code>都会产生一个新的<code>JobExecution</code>，对应的在表中都会新增一行数据。</p>\n<pre><code class="SQL"><span class="code-keyword">CREATE</span> <span class="code-keyword">TABLE</span> BATCH_JOB_EXECUTION  (\n  JOB_EXECUTION_ID <span class="code-built_in">BIGINT</span>  PRIMARY <span class="code-keyword">KEY</span> ,\n  <span class="code-keyword">VERSION</span> <span class="code-built_in">BIGINT</span>,\n  JOB_INSTANCE_ID <span class="code-built_in">BIGINT</span> <span class="code-keyword">NOT</span> <span\n            class="hljs-literal">NULL</span>,\n  CREATE_TIME <span class="code-keyword">TIMESTAMP</span> <span class="code-keyword">NOT</span> <span\n            class="hljs-literal">NULL</span>,\n  START_TIME <span class="code-keyword">TIMESTAMP</span> <span class="code-keyword">DEFAULT</span> <span\n            class="hljs-literal">NULL</span>,\n  END_TIME <span class="code-keyword">TIMESTAMP</span> <span class="code-keyword">DEFAULT</span> <span\n            class="hljs-literal">NULL</span>,\n  <span class="code-keyword">STATUS</span> <span class="code-built_in">VARCHAR</span>(<span\n            class="hljs-number">10</span>),\n  EXIT_CODE <span class="code-built_in">VARCHAR</span>(<span class="hljs-number">20</span>),\n  EXIT_MESSAGE <span class="code-built_in">VARCHAR</span>(<span class="hljs-number">2500</span>),\n  LAST_UPDATED <span class="code-keyword">TIMESTAMP</span>,\n  JOB_CONFIGURATION_LOCATION <span class="code-built_in">VARCHAR</span>(<span class="hljs-number">2500</span>) <span\n            class="hljs-literal">NULL</span>,\n  <span class="code-keyword">constraint</span> JOB_INSTANCE_EXECUTION_FK foreign <span class="code-keyword">key</span> (JOB_INSTANCE_ID)\n  <span class="code-keyword">references</span> BATCH_JOB_INSTANCE(JOB_INSTANCE_ID)\n) ;\n</code></pre>\n<table>\n    <thead>\n    <tr>\n        <th>字段</th>\n        <th>说明</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n        <td>JOB_EXECUTION_ID</td>\n        <td><em>JobExecution</em>的主键，<em>JobExecution::getId</em>方法可以获取到该值</td>\n    </tr>\n    <tr>\n        <td>VERSION</td>\n        <td></td>\n    </tr>\n    <tr>\n        <td>JOB_INSTANCE_ID</td>\n        <td>关联到<em>JobInstace</em>的外键，详见<a\n                href="https://www.chkui.com/article/spring/spring_batch_introduction">数据批处理概念</a>中<em>Job</em>、<em>JobInstance</em>、<em>JobExecute</em>的关系\n        </td>\n    </tr>\n    <tr>\n        <td>CREATE_TIME</td>\n        <td>创建时间戳</td>\n    </tr>\n    <tr>\n        <td>START_TIME</td>\n        <td>开始时间戳</td>\n    </tr>\n    <tr>\n        <td>END_TIME</td>\n        <td>结束时间戳，无论成功或失败都会更新这一项数据。如果某行数据该值为空表示运行期间出现错误，并且框架无法更新该值</td>\n    </tr>\n    <tr>\n        <td>STATUS</td>\n        <td><em>JobExecute</em>的运行状态:<em>COMPLETED</em>、<em>STARTED</em>或者其他状态。此数值对应Java中<em>BatchStatus</em>枚举值</td>\n    </tr>\n    <tr>\n        <td>EXIT_CODE</td>\n        <td><em>JobExecute</em>执行完毕之后的退出返回值</td>\n    </tr>\n    <tr>\n        <td>EXIT_MESSAGE</td>\n        <td><em>JobExecute</em>退出的详细内容，如果是异常退出可能会包括异常堆栈的内容</td>\n    </tr>\n    <tr>\n        <td>LAST_UPDATED</td>\n        <td>最后一次更新的时间戳</td>\n    </tr>\n    </tbody>\n</table>\n<h3 id="h3-8">BATCH_STEP_EXECUTION</h3>\n<p>该表对应的是<code>StepExecution</code>，其结构和<code>BATCH_JOB_EXECUTION</code>基本相似，只是对应的对象是<code>Step</code>，增加了与之相对的一些字段数值：\n</p>\n<pre><code class="SQL"><span class="code-keyword">CREATE</span> <span class="code-keyword">TABLE</span> BATCH_STEP_EXECUTION  (\n  STEP_EXECUTION_ID <span class="code-built_in">BIGINT</span>  PRIMARY <span class="code-keyword">KEY</span> ,\n  <span class="code-keyword">VERSION</span> <span class="code-built_in">BIGINT</span> <span\n            class="code-keyword">NOT</span> <span class="hljs-literal">NULL</span>,\n  STEP_NAME <span class="code-built_in">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="code-keyword">NOT</span> <span\n            class="hljs-literal">NULL</span>,\n  JOB_EXECUTION_ID <span class="code-built_in">BIGINT</span> <span class="code-keyword">NOT</span> <span\n            class="hljs-literal">NULL</span>,\n  START_TIME <span class="code-keyword">TIMESTAMP</span> <span class="code-keyword">NOT</span> <span\n            class="hljs-literal">NULL</span> ,\n  END_TIME <span class="code-keyword">TIMESTAMP</span> <span class="code-keyword">DEFAULT</span> <span\n            class="hljs-literal">NULL</span>,\n  <span class="code-keyword">STATUS</span> <span class="code-built_in">VARCHAR</span>(<span\n            class="hljs-number">10</span>),\n  COMMIT_COUNT <span class="code-built_in">BIGINT</span> ,\n  READ_COUNT <span class="code-built_in">BIGINT</span> ,\n  FILTER_COUNT <span class="code-built_in">BIGINT</span> ,\n  WRITE_COUNT <span class="code-built_in">BIGINT</span> ,\n  READ_SKIP_COUNT <span class="code-built_in">BIGINT</span> ,\n  WRITE_SKIP_COUNT <span class="code-built_in">BIGINT</span> ,\n  PROCESS_SKIP_COUNT <span class="code-built_in">BIGINT</span> ,\n  ROLLBACK_COUNT <span class="code-built_in">BIGINT</span> ,\n  EXIT_CODE <span class="code-built_in">VARCHAR</span>(<span class="hljs-number">20</span>) ,\n  EXIT_MESSAGE <span class="code-built_in">VARCHAR</span>(<span class="hljs-number">2500</span>) ,\n  LAST_UPDATED <span class="code-keyword">TIMESTAMP</span>,\n  <span class="code-keyword">constraint</span> JOB_EXECUTION_STEP_FK foreign <span class="code-keyword">key</span> (JOB_EXECUTION_ID)\n  <span class="code-keyword">references</span> BATCH_JOB_EXECUTION(JOB_EXECUTION_ID)\n) ;\n</code></pre>\n<p>未填入内容部分见<code>BATCH_JOB_EXECUTION</code>说明。</p>\n<table>\n    <thead>\n    <tr>\n        <th>字段</th>\n        <th>说明</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n        <td>STEP_EXECUTION_ID</td>\n        <td><em>StepExecute</em>对应的主键</td>\n    </tr>\n    <tr>\n        <td>VERSION</td>\n        <td></td>\n    </tr>\n    <tr>\n        <td>STEP_NAME</td>\n        <td><em>Step</em>名称</td>\n    </tr>\n    <tr>\n        <td>JOB_EXECUTION_ID</td>\n        <td>关联到<em>BATCH_JOB_EXECUTION</em>表的外键，标记该<em>StepExecute</em>所属的<em>JobExecute</em></td>\n    </tr>\n    <tr>\n        <td>START_TIME</td>\n        <td></td>\n    </tr>\n    <tr>\n        <td>END_TIME</td>\n        <td></td>\n    </tr>\n    <tr>\n        <td>STATUS</td>\n        <td></td>\n    </tr>\n    <tr>\n        <td>COMMIT_COUNT</td>\n        <td>执行过程中，事物提交的次数，该值与数据的规模以及<em>chunk</em>的设置有关</td>\n    </tr>\n    <tr>\n        <td>READ_COUNT</td>\n        <td>读取数据的次数</td>\n    </tr>\n    <tr>\n        <td>FILTER_COUNT</td>\n        <td><em>Processor</em>中过滤记录的次数</td>\n    </tr>\n    <tr>\n        <td>WRITE_COUNT</td>\n        <td>吸入数据的次数</td>\n    </tr>\n    <tr>\n        <td>READ_SKIP_COUNT</td>\n        <td>读数据的跳过次数</td>\n    </tr>\n    <tr>\n        <td>WRITE_SKIP_COUNT</td>\n        <td>写数据的跳过次数</td>\n    </tr>\n    <tr>\n        <td>PROCESS_SKIP_COUNT</td>\n        <td><em>Processor</em>跳过的次数</td>\n    </tr>\n    <tr>\n        <td>ROLLBACK_COUNT</td>\n        <td>回滚的次数</td>\n    </tr>\n    <tr>\n        <td>EXIT_CODE</td>\n        <td></td>\n    </tr>\n    <tr>\n        <td>EXIT_MESSAGE</td>\n        <td></td>\n    </tr>\n    <tr>\n        <td>LAST_UPDATED</td>\n        <td></td>\n    </tr>\n    </tbody>\n</table>\n<h3 id="h3-9">BATCH_JOB_EXECUTION_CONTEXT</h3>\n<p>\n    该表会记录所有与<code>Job</code>相关的<code>ExecutionContext</code>信息。每个<code>ExecutionContext</code>都对应一个<code>JobExecution</code>，在运行的过程中它包含了所有<code>Job</code>范畴的状态数据，这些数据在执行失败后对于后续处理有中重大意义。\n</p>\n<pre><code class="SQL"><span class="code-keyword">CREATE</span> <span class="code-keyword">TABLE</span> BATCH_JOB_EXECUTION_CONTEXT  (\n  JOB_EXECUTION_ID <span class="code-built_in">BIGINT</span> PRIMARY <span class="code-keyword">KEY</span>,\n  SHORT_CONTEXT <span class="code-built_in">VARCHAR</span>(<span class="hljs-number">2500</span>) <span\n            class="code-keyword">NOT</span> <span class="hljs-literal">NULL</span>,\n  SERIALIZED_CONTEXT <span class="code-keyword">CLOB</span>,\n  <span class="code-keyword">constraint</span> JOB_EXEC_CTX_FK foreign <span class="code-keyword">key</span> (JOB_EXECUTION_ID)\n  <span class="code-keyword">references</span> BATCH_JOB_EXECUTION(JOB_EXECUTION_ID)\n) ;\n</code></pre>\n<table>\n    <thead>\n    <tr>\n        <th>字段</th>\n        <th>说明</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n        <td>JOB_EXECUTION_ID</td>\n        <td>关联到<em>JobExecution</em>的外键，建立<em>JobExecution</em>和<em>ExecutionContext</em>的关系。</td>\n    </tr>\n    <tr>\n        <td>SHORT_CONTEXT</td>\n        <td>标记<em>SERIALIZED_CONTEXT</em>的版本号</td>\n    </tr>\n    <tr>\n        <td>SERIALIZED_CONTEXT</td>\n        <td>序列化的<em>ExecutionContext</em></td>\n    </tr>\n    </tbody>\n</table>\n<h3 id="h3-10">BATCH_STEP_EXECUTION_CONTEXT</h3>\n<p><code>Step</code>中<code>ExecutionContext</code>相关的数据表，结构与<code>BATCH_JOB_EXECUTION_CONTEXT</code>完全一样。</p>\n<h3 id="h3-11">表索引建议</h3>\n<p>上面的所有建表语句都没有提供索引，但是并不代表索引没有价值。当感觉到SQL语句的执行有效率问题时候，可以增加索引。</p>\n<p>索引带来的价值取决于SQL查询的频率以及关联关系，下面是Spring Batch框架在运行过程中会用到的一些查询条件语句，用于参考优化索引：</p>\n<table>\n    <thead>\n    <tr>\n        <th>表</th>\n        <th>Where条件</th>\n        <th>执行频率</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n        <td>BATCH_JOB_INSTANCE</td>\n        <td>JOB_NAME = ? and JOB_KEY = ?</td>\n        <td>每次Job启动执时</td>\n    </tr>\n    <tr>\n        <td>BATCH_JOB_EXECUTION</td>\n        <td>JOB_INSTANCE_ID = ?</td>\n        <td>每次Job重启时</td>\n    </tr>\n    <tr>\n        <td>BATCH_EXECUTION_CONTEXT</td>\n        <td>EXECUTION_ID = ? and KEY_NAME = ?</td>\n        <td>视<em>chunk</em>的大小而定</td>\n    </tr>\n    <tr>\n        <td>BATCH_STEP_EXECUTION</td>\n        <td>VERSION = ?</td>\n        <td>视<em>chunk</em>的大小而定</td>\n    </tr>\n    <tr>\n        <td>BATCH_STEP_EXECUTION</td>\n        <td>STEP_NAME = ? and JOB_EXECUTION_ID = ?</td>\n        <td>每一个<em>Step</em>执行之前</td>\n    </tr>\n    </tbody>\n</table>\n<h2 id="h2-7">使用案例</h2>\n<p>下面是Spring Batch一些简单的应用，源码在下列地址的<em>simple</em>工程：</p>\n<ul>\n    <li>Gitee：<a\n            href="https://gitee.com/chkui-com/spring-batch-sample">https://gitee.com/chkui-com/spring-batch-sample</a>\n    </li>\n    <li>Github：<a href="https://github.com/chkui/spring-batch-sample">https://github.com/chkui/spring-batch-sample</a>\n    </li>\n</ul>\n<p>Spring Batch提供了2种执行方式：命令行方式或Java内嵌方式。命令行方式是直到需要执行批处理任务的时候才启动程序，内嵌方式是结合Web工程或其他外部化框架来使用。2者最大的差别就是是否直接向IoCs注入一个<code>Job</code>实例。\n</p>\n<h3 id="h3-12">通用基本配置</h3>\n<p>\n    两种方式的基本配置都是一样的，通过<code>Reader</code>、<code>Processor</code>、<code>Writer</code>来组装一个<code>Step</code>。代码中<code>Item</code>并不涉及文件或数据库的操作，只是简单的模拟数据读取、处理、写入的过程。实体<code>Record</code>和<code>Msg</code>用于模拟数据转换，基本配置如下：\n</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">BatchDefaultConfig</span> </span>{\n\t<span class="code-meta">@Bean</span>\n\t<span class="code-comment">//配置Step</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> Step <span class="code-title">simpleStep</span><span\n            class="hljs-params">(StepBuilderFactory builder, ItemReader&lt;Record&gt; reader, ItemProcessor&lt;Record, Msg&gt; processor,\n\t\t\tItemWriter&lt;Msg&gt; writer)</span> </span>{\n\t\t<span class="code-keyword">return</span> builder.get(<span class="code-string">"SimpleStep"</span>).&lt;Record, Msg&gt;chunk(<span\n            class="hljs-number">10</span>).reader(reader).processor(processor).writer(writer)\n\t\t\t\t.build();\n\t}\n\n\t<span class="code-meta">@Bean</span>\n\t<span class="code-comment">//配置 Reader</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> ItemReader&lt;Record&gt; <span\n            class="code-title">reader</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> ItemReader&lt;Record&gt;() {\n\t\t\t<span class="code-keyword">private</span> <span class="code-keyword">int</span> count = <span\n            class="hljs-number">0</span>;\n\t\t\t<span class="hljs-function"><span class="code-keyword">public</span> Record <span\n                    class="code-title">read</span><span class="hljs-params">()</span>\n\t\t\t\t\t<span class="code-keyword">throws</span> Exception, UnexpectedInputException, ParseException, NonTransientResourceException </span>{\n\t\t\t\t<span class="code-keyword">return</span> ++<span class="code-keyword">this</span>.count &lt; <span\n            class="hljs-number">100</span> ? <span class="code-keyword">new</span> Record().setId(<span\n            class="code-keyword">this</span>.count).setMsg(<span class="code-string">"Read Number:"</span> + <span\n            class="code-keyword">this</span>.count) : <span class="code-keyword">null</span>;\n\t\t\t}\n\t\t};\n\t}\n\n\t<span class="code-meta">@Bean</span>\n\t<span class="code-comment">//配置 Processor</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> ItemProcessor&lt;Record, Msg&gt; <span\n            class="code-title">processor</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> ItemProcessor&lt;Record, Msg&gt;() {\n\t\t\t<span class="hljs-function"><span class="code-keyword">public</span> Msg <span\n                    class="code-title">process</span><span class="hljs-params">(Record item)</span> <span\n                    class="code-keyword">throws</span> Exception </span>{\n\t\t\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> Msg(<span\n            class="code-string">"MSG GET INFO = "</span> + item.getMsg());\n\t\t\t}\n\t\t};\n\t}\n\n\t<span class="code-meta">@Bean</span>\n\t<span class="code-comment">//配置 Writer</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> ItemWriter&lt;Msg&gt; <span class="code-title">writer</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> ItemWriter&lt;Msg&gt;() {\n\t\t\t<span class="code-keyword">private</span> <span class="code-keyword">int</span> batchCount = <span\n            class="hljs-number">0</span>;\n\t\t\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n                    class="code-title">write</span><span\n                    class="hljs-params">(List&lt;? extends Msg&gt; items)</span> <span\n                    class="code-keyword">throws</span> Exception </span>{\n\t\t\t\tSystem.out.println(<span class="code-string">"Batch Count : "</span> + ++batchCount + <span\n            class="code-string">". Data:"</span>);\n\t\t\t\t<span class="code-keyword">for</span> (Msg msg : items) {\n\t\t\t\t\tSystem.out.println(msg.getInfo());\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n}\n</code></pre>\n<h3 id="h3-13">命令行方式运行</h3>\n<p>有了基本配置之后，命令行运行的方式仅仅是向容器添加一个<code>Job</code>：</p>\n<pre><code class="Java"><span class="code-meta">@Configuration</span>\n<span class="code-comment">//导入依赖配置</span>\n<span class="code-meta">@Import</span>({ BatchDefaultConfig.class })\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">BatchCommondConfig</span> </span>{\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> Job <span\n            class="code-title">simpleJob</span><span class="hljs-params">(Step step, JobBuilderFactory builder)</span> </span>{\n\t\t<span class="code-keyword">return</span> builder.get(<span class="code-string">"SimpleJob"</span>).start(step).build(); <span\n            class="code-comment">//向容器返回一个Job的Bean</span>\n\t}\n}\n</code></pre>\n<p>然后启动Spring Framework则会自动启用Command Runner运行方式运行——先调用<code>SpringApplication::callRunner</code>方法，然后使用<code>JobLauncherCommandLineRunner::execute</code>运行：\n</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">CommondSample</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> <span\n            class="code-keyword">throws</span> DuplicateJobException </span>{\n\t\t<span class="code-comment">//模拟测试参数, 这些参数值在执行Java时从外部传入的，比如-Dkey=value</span>\n\t\tString[] argsExt = <span class="code-keyword">new</span> String[<span class="hljs-number">2</span>];\n\t\targsExt[<span class="hljs-number">0</span>] = <span class="code-string">"BuilderParam1=Value1"</span>;\n\t\targsExt[<span class="hljs-number">1</span>] = <span class="code-string">"BuilderParam2=Value2"</span>;\n\t\t<span class="code-comment">//运行Spring Framework</span>\n\t\tSpringApplication.run(CommondSample.class, argsExt);\n\t}\n}\n</code></pre>\n<p>启用之后观察数据库已经发生了变更。使用命令行需要通过 Java运行参数（-Dkey=value）传递<code>JobParameters</code>的数据，上面的代码模拟实现了相关的过程。</p>\n<h3 id="h3-14">Java内嵌运行</h3>\n<p>Java内嵌的方式主要是用于搭配外部工程化使用，比如使用Web框架或则统一调度平台管之类的结构化框架来统一管理批处理任务。与命令行执行最大的区别就是不向容器注入<code>Job</code>：</p>\n<pre><code class="Java"><span class="code-meta">@Configuration</span>\n<span class="code-comment">//导入进出配置 </span>\n<span class="code-meta">@Import</span>({BatchDefaultConfig.class})\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">BatchOperatoConfig</span> </span>{\n\t<span class="code-meta">@Bean</span>\n\t<span class="code-comment">//返回JobFactory</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> JobFactory <span\n            class="code-title">simpleJob</span><span class="hljs-params">(Step step, JobBuilderFactory builder)</span> </span>{\n\t\tSimpleJobFactory sampleJobFactory = <span class="code-keyword">new</span> SimpleJobFactory();\n\t\tsampleJobFactory.setJob(builder.get(<span class="code-string">"SimpleJob"</span>).start(step).build());\n\t\t<span class="code-keyword">return</span> sampleJobFactory;\n\t}\n}\n</code></pre>\n<p>\n    配置代码向容器添加了一个<code>JobFactory</code>的实现类，<code>JobFactory</code>的两个接口一个是获取<code>Job</code>一个是获取<code>Job</code>的名称，<code>SimpleJobFactory</code>实现了<code>JobFactory</code>：\n</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">SimpleJobFactory</span> <span class="code-keyword">implements</span> <span\n        class="code-title">JobFactory</span> </span>{\n\t<span class="code-keyword">private</span> Job job;\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setJob</span><span class="hljs-params">(Job job)</span> </span>{\n\t\t<span class="code-keyword">this</span>.job = job;\n\t}\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> Job <span\n            class="code-title">createJob</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> job;\n\t}\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span\n            class="code-title">getJobName</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> job.getName();\n\t}\n}\n</code></pre>\n<p>最后通过<code>SimpleJobFactory</code>来启动一个<code>Job</code>：</p>\n<pre><code class="Java"><span class="code-meta">@SpringBootApplication</span>\n<span class="code-meta">@EnableBatchProcessing</span>\n<span class="code-meta">@EnableScheduling</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">OperatorSample</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> <span\n            class="code-keyword">throws</span> DuplicateJobException </span>{\n\t\t<span class="code-keyword">new</span> SuspendThread().run(); <span class="code-comment">//挂起系统一直运行</span>\n\t\tConfigurableApplicationContext ctx = SpringApplication.run(OperatorSample.class);\n\t\tCron cron = ctx.getBean(Cron.class);\n\t\tcron.register(); <span class="code-comment">//注册JobFactory</span>\n\t\tcron.runJobLaunch();\n\t}\n}\n\n<span class="code-meta">@Service</span>\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">Cron</span> </span>{\n\t<span class="code-meta">@Autowired</span>\n\tJobLauncher jobLauncher;\n\n\t<span class="code-meta">@Autowired</span>\n\t<span class="code-keyword">private</span> JobOperator jobOperator;\n\n\t<span class="code-meta">@Autowired</span>\n\t<span class="code-keyword">private</span> JobRegistry jobRegistry;\n\n\t<span class="code-meta">@Autowired</span>\n\t<span class="code-keyword">private</span> JobFactory jobFactory;\n\n\t<span class="code-comment">//注册JobFactory</span>\n\t<span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">register</span><span\n            class="hljs-params">()</span> <span class="code-keyword">throws</span> DuplicateJobException </span>{\n\t\tjobRegistry.register(jobFactory);\n\t}\n\n\t<span class="code-comment">//使用JobLaunch执行</span>\n\t<span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">runJobLaunch</span><span\n            class="hljs-params">()</span> </span>{\n\t\tMap&lt;String, JobParameter&gt; map = <span class="code-keyword">new</span> HashMap&lt;&gt;();\n\t\tmap.put(<span class="code-string">"Builder"</span>, <span class="code-keyword">new</span> JobParameter(<span\n            class="code-string">"1"</span>));\n\t\tmap.put(<span class="code-string">"Timer"</span>, <span class="code-keyword">new</span> JobParameter(<span\n            class="code-string">"2"</span>));\n\t\tjobLauncher.run(jobFactory.createJob(), <span class="code-keyword">new</span> JobParameters(map));\n\t}\n\n\t<span class="code-meta">@Scheduled</span>(cron = <span class="code-string">"30 * * * * ? "</span>)\n\t<span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">task1</span><span\n            class="hljs-params">()</span> </span>{\n\t\tSystem.out.println(<span class="code-string">"1"</span>);\n\t\trunOperator();\n\t}\n\n\t<span class="code-comment">//定时任务使用 JobOperator执行</span>\n\t<span class="hljs-function"><span class="code-keyword">private</span> <span class="code-keyword">void</span> <span\n            class="code-title">runOperator</span><span class="hljs-params">()</span> </span>{\n\t\tjobOperator.start(<span class="code-string">"SimpleJob"</span>, <span\n            class="code-string">"Builder=1,Timer=2"</span>);\n\t}\n}\n</code></pre>\n<p>这里使用了2种执行方式：<code>JobLauncher</code>和<code>JobOperator</code>。<code>JobLauncher</code>简单明了的启动一个批处理任务。而<code>JobOperator</code>扩展了一些用于<code>Job</code>管理的接口方法，观察<code>JobOperator</code>的源码可以发现它提供了获取<code>ExecuteContext</code>、检查<code>JobInstance</code>等功能，如果需要定制开发一个基于Web或者JMX管理批处理任务的系统，<code>JobOperator</code>更合适。<code>JobOperator</code>的第二个参数用于传递<code>JobParameters</code>，等号两端分别是<code>key</code>和<code>value</code>，逗号用于分割多行数据。\n</p>\n<p>在<a href="https://www.chkui.com/article/spring/spring_batch_job">Job配置与运行</a>提及过一个<code>JobInstance</code>相当于<code>Job</code>+<code>JobParameters</code>，因此虽然上面的代码使用了两种不同的运行方式，但是<code>Job</code>和<code>JobParameters</code>是一样的。在运行被定时任务包裹的<code>runOperator</code>方法时，会一直抛出<code>JobInstanceAlreadyExistsException</code>异常，因为同一个实例不能运行2次。如果运行失败可以使用对应的<code>restart</code>方法。\n</p>\n<p>后续会介绍各种<code>Reader</code>和<code>Writer</code>的使用。</p>'}});