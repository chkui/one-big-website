webpackJsonp([19],{364:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<h2 id="h2-1">阅读之前</h2>\n<p>在了解<em>Next.js</em>之前，需要掌握<a href="https://www.chkui.com/category/react" title="React">React</a>的基本使用方法。</p>\n<p>参考代码：<a href="https://github.com/chkui/nextjs-getting-started">https://github.com/chkui/nextjs-getting-started</a> 。\n</p>\n<h2 id="h2-2">搭建</h2>\n<h3 id="h3-1">安装</h3>\n<pre><code class="bash"><span class="code-comment"># 创建项目目录</span>\nmkdir you_project\n<span class="code-comment"># 进入项目目录</span>\n<span class="code-built_in">cd</span> you_project\n<span class="code-comment"># 初始化package.json</span>\nnpm init -y\n<span class="code-comment"># 安装依赖包</span>\nnpm install --save react react-dom next\n<span class="code-comment"># 创建一个pages文件夹</span>\nmkdir pages\n</code></pre>\n<p>依次执行以上命令之后，<em>Next.js</em>运行所需的最基本的目录和依赖就创建好了。</p>\n<h3 id="h3-2">运行</h3>\n<p>将<em>package.json</em>里的“scripts"字段修改为：</p>\n<pre><code class="json">{\n  <span class="hljs-attr">"scripts"</span>: {\n    <span class="hljs-attr">"dev"</span>: <span class="code-string">"next"</span>,\n    <span class="hljs-attr">"build"</span>: <span class="code-string">"next build"</span>,\n    <span class="hljs-attr">"start"</span>: <span class="code-string">"next start"</span>\n  }\n}\n</code></pre>\n<p>运行以下命令启动<em>Next.js</em>：</p>\n<pre><code class="shell">npm run dev\n</code></pre>\n<p>在浏览器打开<a href="http://localhost:3000/">http://localhost:3000/</a> 看到输出"404 - This page could not be found"，表示<em>Next.js</em>安装成功。\n</p>\n<h3 id="h3-3">添加页面</h3>\n<p><em>./pages</em>是<em>Next.js</em>默认的网页路径，其中的<em>index.js</em>就代表整个网站的主页。创建一个*./pages/index.js*组件：</p>\n<pre><code class="JavaScript"><span class="code-keyword">const</span> Index = <span class="hljs-function"><span\n        class="hljs-params">()</span> =&gt;</span> (\n  <span class="xml"><span class="code-tag">&lt;<span class="code-name">div</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">p</span>&gt;</span>Hello World!<span class="code-tag">&lt;/<span\n              class="code-name">p</span>&gt;</span>\n  <span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>\n)\n<span class="code-keyword">export</span> <span class="code-keyword">default</span> Index\n</code></pre>\n<p>添加*./pages/index.js*后网站会自动刷新，呈现"Hello World!"。</p>\n<h2 id="h2-3">页面与导航栏</h2>\n<h3 id="h3-4">页面</h3>\n<p>添加<a href="http://localhost:3000/about">http://localhost:3000/about</a> 路径下的页面。</p>\n<p>创建*./pages/about.js*文件，添加以下内容：</p>\n<pre><code class="JavaScript"><span class="code-keyword">export</span> <span class="code-keyword">default</span> () =&gt; (\n  <span class="xml"><span class="code-tag">&lt;<span class="code-name">div</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">p</span>&gt;</span>About page<span class="code-tag">&lt;/<span\n              class="code-name">p</span>&gt;</span>\n  <span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>\n)\n</code></pre>\n<p>然后在浏览器输入<a href="http://localhost:3000/about">http://localhost:3000/about</a> 即可看到新增的About。</p>\n<h3 id="h3-5">导航栏</h3>\n<p>对*./pages/index.js*稍加修改引入导航栏功能：</p>\n<pre><code class="JavaScript"><span class="code-keyword">import</span> Link <span class="code-keyword">from</span> <span\n        class="code-string">\'next/link\'</span>\n\n<span class="code-keyword">const</span> Index = <span class="hljs-function"><span\n            class="hljs-params">()</span> =&gt;</span> (\n  <span class="xml"><span class="code-tag">&lt;<span class="code-name">div</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">Link</span> <span class="hljs-attr">href</span>=<span\n            class="code-string">"/about"</span>&gt;</span>\n      <span class="code-tag">&lt;<span class="code-name">a</span> <span class="hljs-attr">style</span>=<span\n              class="code-string">{{fontSize:</span> <span class="hljs-attr">20</span>}}&gt;</span>About Page<span\n              class="code-tag">&lt;/<span class="code-name">a</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">Link</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">p</span>&gt;</span>Hello Next.js<span class="code-tag">&lt;/<span\n              class="code-name">p</span>&gt;</span>\n  <span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>\n)\n\n<span class="code-keyword">export</span> <span class="code-keyword">default</span> Index\n</code></pre>\n<p><strong>注意</strong>：使用了<em>Next.js</em>作为服务端渲染工具，切记仅使用<em>next/link</em>中的Link组件。</p>\n<p>除了<code>&lt;a&gt;</code>标签，<code>&lt;button&gt;</code>或自定义的组件都可以被<code>Link</code>包装，只要传递<em>Click事件</em>即可，将上面的代码稍作修改实验这个效果：\n</p>\n<pre><code class="JavaScript"><span class="code-keyword">import</span> Link <span class="code-keyword">from</span> <span\n        class="code-string">\'next/link\'</span>\n\n<span class="code-keyword">const</span> Index = <span class="hljs-function"><span\n            class="hljs-params">()</span> =&gt;</span> (\n    <span class="xml"><span class="code-tag">&lt;<span class="code-name">div</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">Link</span> <span class="hljs-attr">href</span>=<span\n                class="code-string">"/about"</span>&gt;</span>\n            <span class="code-tag">&lt;<span class="code-name">button</span>&gt;</span>Click Me<span class="code-tag">&lt;/<span\n                class="code-name">button</span>&gt;</span>\n        <span class="code-tag">&lt;/<span class="code-name">Link</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">Link</span> <span class="hljs-attr">href</span>=<span\n                class="code-string">"/about"</span>&gt;</span>\n            <span class="code-tag">&lt;<span class="code-name">A</span>/&gt;</span>\n        <span class="code-tag">&lt;/<span class="code-name">Link</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">p</span>&gt;</span>Hello Next.js<span\n                class="code-tag">&lt;/<span class="code-name">p</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>\n)\n\n<span class="code-keyword">export</span> <span class="code-keyword">default</span> Index\n\n<span class="code-keyword">const</span> A = <span class="hljs-function"><span\n            class="hljs-params">props</span> =&gt;</span> (<span class="xml"><span class="code-tag">&lt;<span\n            class="code-name">div</span> <span class="hljs-attr">onClick</span>=<span class="code-string">{e</span> =&gt;</span> {\n    props.onClick(e)\n}}&gt;Click Me<span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>)\n</code></pre>\n<p>关于<em>Next.js</em>路由管理相关的细节内容，<a href="https://github.com/zeit/next.js#routing" title="可以到这里查看">可以到这里查看</a></p>\n<h2 id="h2-4">页面、资源与组件</h2>\n<p><em>./pages</em>是一个保留路径，在*/pages*路径下任何js文件中导出的默认React组件都被视作一个页面。</p>\n<p>除了*./pages*，<em>Next.js</em>还有一个保留路径是*./static*，它用来存放图片等静态资源。</p>\n<p><em>Next.js</em>会对*./pages<em>中的React组件进行“包装"，所以</em>./pages*内外的React组件在呈现结果上有一些差异，看下面的例子。</p>\n<h3 id="h3-6">创建网站结构</h3>\n<p>在工程根目录创建*/components*文件夹，然后添加以下组件：</p>\n<pre><code class="JavaScript"><span class="code-keyword">import</span> Link <span class="code-keyword">from</span> <span\n        class="code-string">\'next/link\'</span>\n\n<span class="code-keyword">const</span> linkStyle = {\n    <span class="hljs-attr">marginRight</span>: <span class="hljs-number">15</span>\n}\n\n<span class="code-keyword">const</span> Header = <span class="hljs-function"><span\n            class="hljs-params">()</span> =&gt;</span> (\n    <span class="xml"><span class="code-tag">&lt;<span class="code-name">div</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">Link</span> <span class="hljs-attr">href</span>=<span\n                class="code-string">"/"</span>&gt;</span>\n            <span class="code-tag">&lt;<span class="code-name">a</span> <span class="hljs-attr">style</span>=<span\n                    class="code-string">{linkStyle}</span>&gt;</span>Home<span class="code-tag">&lt;/<span\n                class="code-name">a</span>&gt;</span>\n        <span class="code-tag">&lt;/<span class="code-name">Link</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">Link</span> <span class="hljs-attr">href</span>=<span\n                class="code-string">"/about"</span>&gt;</span>\n            <span class="code-tag">&lt;<span class="code-name">a</span> <span class="hljs-attr">style</span>=<span\n                    class="code-string">{linkStyle}</span>&gt;</span>About<span class="code-tag">&lt;/<span\n                class="code-name">a</span>&gt;</span>\n        <span class="code-tag">&lt;/<span class="code-name">Link</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>\n)\n\n<span class="code-keyword">export</span> <span class="code-keyword">default</span> Header\n</code></pre>\n<p>然后将<code>Header</code>整合到<code>about.js</code>和<code>index.js</code>中：</p>\n<pre><code class="JavaScript"><span class="code-keyword">import</span> Header <span\n        class="code-keyword">from</span> <span class="code-string">\'../components/Header\'</span>\n<span class="code-keyword">export</span> <span class="code-keyword">default</span> () =&gt; (\n    <span class="xml"><span class="code-tag">&lt;<span class="code-name">div</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">Header</span> /&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">p</span>&gt;</span>Hello Next.js<span\n                class="code-tag">&lt;/<span class="code-name">p</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>\n)\n</code></pre>\n<p>再次进行页面操作，就会出现表头静止页面变换的效果。</p>\n<h3 id="h3-7">网站布局</h3>\n<p>通常情况下，开发一个网站先制定一个通用的布局（尤其是响应式布局的网站），然后再向布局中的添加各个部分的内容。使用<em>Next.js</em>可以通过组件的方式来设计一个布局，看下面的例子。\n    在*/components*中增加<code>Layout</code>和<code>Footer</code>组件:</p>\n<pre><code class="JavaScript"><span class="code-comment">// componments/layout.js</span>\n<span class="code-keyword">import</span> Header <span class="code-keyword">from</span> <span class="code-string">\'./header\'</span>\n<span class="code-keyword">import</span> Footer <span class="code-keyword">from</span> <span class="code-string">\'./footer\'</span>\n\n<span class="code-keyword">const</span> layoutStyle = {\n    <span class="hljs-attr">margin</span>: <span class="hljs-number">20</span>,\n    <span class="hljs-attr">padding</span>: <span class="hljs-number">20</span>,\n    <span class="hljs-attr">border</span>: <span class="code-string">\'1px solid #DDD\'</span>\n}\n\n<span class="code-keyword">const</span> Layout = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> (\n    <span class="xml"><span class="code-tag">&lt;<span class="code-name">div</span> <span class="hljs-attr">style</span>=<span\n            class="code-string">{layoutStyle}</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">Header</span> /&gt;</span>\n        {props.children}\n        <span class="code-tag">&lt;<span class="code-name">Footer</span> /&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>\n)\n\n<span class="code-keyword">export</span> <span class="code-keyword">default</span> Layout\n</code></pre>\n<pre><code class="JavaScript"><span class="code-comment">// components/footer.js</span>\n<span class="code-keyword">const</span> Footer = <span class="hljs-function"><span\n            class="hljs-params">()</span> =&gt;</span> (\n    <span class="xml"><span class="code-tag">&lt;<span class="code-name">div</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">p</span> <span class="hljs-attr">style</span>=<span\n                class="code-string">{{color:</span>\'<span class="hljs-attr">blue</span>\'}}&gt;</span>Footer<span\n                class="code-tag">&lt;/<span class="code-name">p</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>\n)\n\n<span class="code-keyword">export</span> <span class="code-keyword">default</span> Footer\n</code></pre>\n<p>然后将*/pages/index.js*修改为：</p>\n<pre><code class="JavaScript"><span class="code-keyword">import</span> Layout <span\n        class="code-keyword">from</span> <span class="code-string">\'../components/layout\'</span>\n\n<span class="code-keyword">export</span> <span class="code-keyword">default</span> () =&gt; (\n    <span class="xml"><span class="code-tag">&lt;<span class="code-name">Layout</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">p</span>&gt;</span>Hello Next.js<span\n                class="code-tag">&lt;/<span class="code-name">p</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">Layout</span>&gt;</span></span>\n)\n</code></pre>\n<p>这样，页面的内容和布局就完全隔离开了。</p>\n<h2 id="h2-5">页面跳转</h2>\n<h3 id="h3-8">传递参数</h3>\n<p>在实际应用中，经常需要在页面间传递参数，可以使用<a href="https://www.chkui.com/article/react/react_high_order_component"\n                              title="高阶组件">高阶组件</a><code>withRouter</code>来实现。\n    下面的代码对*/pages/index.js<em>进行了一些修改，使其在跳转时携带</em>query*参数：</p>\n<pre><code class="JavaScript"><span class="code-keyword">const</span> SubLink = <span class="hljs-function"><span\n        class="hljs-params">props</span> =&gt;</span> (\n    <span class="xml"><span class="code-tag">&lt;<span class="code-name">li</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">Link</span> <span class="hljs-attr">href</span>=<span\n                class="code-string">{</span>`/<span class="hljs-attr">post</span>?<span\n                class="hljs-attr">title</span>=<span class="code-string">${props.title}</span>`}&gt;</span>\n            <span class="code-tag">&lt;<span class="code-name">a</span>&gt;</span>{props.title}<span class="code-tag">&lt;/<span\n                class="code-name">a</span>&gt;</span>\n        <span class="code-tag">&lt;/<span class="code-name">Link</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">li</span>&gt;</span></span>\n)\n\n<span class="code-keyword">export</span> <span class="code-keyword">default</span> () =&gt; (\n    &lt;Layout&gt;\n        &lt;h2&gt;Information&lt;/h2&gt;\n        &lt;SubLink title="First Post"/&gt;\n        &lt;SubLink title="Second Post"/&gt;\n        &lt;SubLink title="Third Post"/&gt;\n    &lt;/Layout&gt;\n)\n</code></pre>\n<p>点击<em>First Post</em>之后浏览器的URL会出现这样的路径：“<a href="http://localhost:3000/post?title=First%20Post”">http://localhost:3000/post?title=First%20Post”</a>\n    。接下来利用<code>withRouter</code>来获取这个参数。创建*./pages/post.js*的文件：</p>\n<pre><code class="JavaScript"><span class="code-keyword">import</span> {withRouter} <span\n        class="code-keyword">from</span> <span class="code-string">\'next/router\'</span>\n<span class="code-keyword">import</span> Layout <span class="code-keyword">from</span> <span class="code-string">\'../components/layout\'</span>\n\n<span class="code-keyword">const</span> Page = withRouter(<span class="hljs-function">(<span\n            class="hljs-params">props</span>) =&gt;</span> (\n    <span class="xml"><span class="code-tag">&lt;<span class="code-name">Layout</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">h3</span>&gt;</span>Post Page<span\n                class="code-tag">&lt;/<span class="code-name">h3</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">p</span>&gt;</span>Info:{props.router.query.title}<span\n                class="code-tag">&lt;/<span class="code-name">p</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">Layout</span>&gt;</span></span>\n))\n<span class="code-keyword">export</span> <span class="code-keyword">default</span> Page\n</code></pre>\n<p>现在点击<em>First Post</em>链接之后，跳转的页面会显示<em>First Post</em>。</p>\n<h3 id="h3-9">路径隐藏</h3>\n<p>\n    <em>Next.js</em>提供了一个让URL更加清晰干净的特性功能——URL隐藏（官网直译的话应该叫“URL遮挡”），他的作用是可以隐藏原来比较复杂的URL，让网站路径更加清晰，有利于SEO等。实现这个特性非常简单，在使用<code>Link</code>组件时传递一个<em>as</em>参数。下面将继续修改*./pages/index.js*中的内容以实现这个特性：\n</p>\n<pre><code class="JavaScript"><span class="code-keyword">const</span> SubLink = <span class="hljs-function"><span\n        class="hljs-params">props</span> =&gt;</span> (\n    <span class="xml"><span class="code-tag">&lt;<span class="code-name">li</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">Link</span> <span class="hljs-attr">as</span>=<span\n                class="code-string">{</span>`<span class="hljs-attr">p</span>/${<span class="hljs-attr">props.as</span>}`} <span\n                class="hljs-attr">href</span>=<span class="code-string">{</span>`/<span\n                class="hljs-attr">post</span>?<span class="hljs-attr">title</span>=<span class="code-string">${props.title}</span>`}&gt;</span>\n            <span class="code-tag">&lt;<span class="code-name">a</span>&gt;</span>{props.title}<span class="code-tag">&lt;/<span\n                class="code-name">a</span>&gt;</span>\n        <span class="code-tag">&lt;/<span class="code-name">Link</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">li</span>&gt;</span></span>\n)\n\n<span class="code-keyword">export</span> <span class="code-keyword">default</span> () =&gt; (\n    &lt;Layout&gt;\n        &lt;h2&gt;Information&lt;/h2&gt;\n        &lt;SubLink as="first-post" title="First Post"/&gt;\n        &lt;SubLink as="first-post" title="Second Post"/&gt;\n        &lt;SubLink as="first-post" title="Third Post"/&gt;\n    &lt;/Layout&gt;\n)\n</code></pre>\n<p>注意观察<code>SubLink</code>组件中的修改，为<code>Link</code>增加了一个as参数，这个参数传递的内容将会在浏览器的地址栏显示。例如点击<em>FIrst\n    Post</em>后，浏览器的地址栏会显示<a href="http://localhost:3000/p/first-post">http://localhost:3000/p/first-post</a>\n    ，但是我们通过<code>withRouter</code>组件获取的URL还是<em>href</em>传递的路径。</p>\n<h2 id="h2-6">服务端渲染</h2>\n<p>只要运行了<em>Next.js</em>，他时时刻刻都在执行服务端渲染，可以通过刷新页面看到效果。如果没有太多需求，不进行任何调整<em>Next.js</em>能为我们完成静态页面的服务端渲染，但是通常情况下，还需要处理异步请求等等情况。\n</p>\n<h3 id="h3-10">二次服务端渲染</h3>\n<p>前面介绍了在<code>Link</code>组件上使用<em>as</em>参数可以设置浏览器路径栏上显示的内容。但是这个时候仅仅支持客户端跳转，如果进行页面刷新会出现404页面。导致这个问题出现的原因是在服务端并不知道*/p/first-post<em>对应</em>/pages*文件夹中的哪个文件。为了解决这个问题，需要在服务端进行二次渲染。\n</p>\n<p>首先需要添加<em>Express</em>服务：</p>\n<pre><code class="bash">npm install --save express\n</code></pre>\n<p>安装完成之后在根目录添加一个<em>server.js</em>文件，其内容如下：</p>\n<pre><code class="JavaScript"><span class="code-keyword">const</span> express = <span\n        class="code-built_in">require</span>(<span class="code-string">\'express\'</span>)\n<span class="code-keyword">const</span> next = <span class="code-built_in">require</span>(<span class="code-string">\'next\'</span>)\n\n<span class="code-comment">// 不等于\'production\'则表示运行的是开发环境</span>\n<span class="code-keyword">const</span> dev = process.env.NODE_ENV !== <span class="code-string">\'production\'</span>\n<span class="code-comment">// 创建一个服务端运行的Next app</span>\n<span class="code-keyword">const</span> app = next({dev})\n<span class="code-comment">// 请求处理器</span>\n<span class="code-keyword">const</span> handle = app.getRequestHandler()\n\napp.prepare()\n    .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n        <span class="code-keyword">const</span> server = express()\n\n        server.get(<span class="code-string">\'/p/:id\'</span>, (req, res) =&gt; {\n            <span class="code-comment">//将/p/:id的路径切换成/post?title=req.params.id的路径</span>\n            app.render(req, res, <span class="code-string">\'/post\'</span>, {<span class="hljs-attr">title</span>: req.params.id})\n        })\n\n        server.get(<span class="code-string">\'*\'</span>, (req, res) =&gt; {\n            <span class="code-keyword">return</span> handle(req, res)\n        })\n\n        server.listen(<span class="hljs-number">3000</span>, (err) =&gt; {\n            <span class="code-keyword">if</span> (err) <span class="code-keyword">throw</span> err\n            <span class="code-built_in">console</span>.log(<span class="code-string">\'&gt; Ready on http://localhost:3000\'</span>)\n        })\n    })\n    .catch(<span class="hljs-function">(<span class="hljs-params">ex</span>) =&gt;</span> {\n        <span class="code-built_in">console</span>.error(ex.stack)\n        process.exit(<span class="hljs-number">1</span>)\n    })\n</code></pre>\n<p>然后修改<em>package.json</em>的“scripts"字段，将启动方式方式指向<em>server.js</em>：</p>\n<pre><code class="json"><span class="code-string">"scripts"</span>: {\n    <span class="hljs-attr">"dev"</span>: <span class="code-string">"node server.js"</span>,\n    <span class="hljs-attr">"build"</span>: <span class="code-string">"next build"</span>,\n    <span class="hljs-attr">"start"</span>: <span class="code-string">"NODE_ENV=production node server.js"</span>\n  }\n</code></pre>\n<p>完成这2步网站服务端也可以正常跳转，实现功能的位置是这段代码：</p>\n<pre><code class="JavaScript">server.get(<span class="code-string">\'/p/:id\'</span>, (req, res) =&gt; {\n\tapp.render(req, res, <span class="code-string">\'/post\'</span>, {<span class="hljs-attr">title</span>: req.params.id})\n})\n</code></pre>\n<p>他将原来的请求“/p/:id”转换为请求"/post?title=id"。</p>\n<p>更多的<a href="https://github.com/zeit/next.js#custom-server-and-routing" title="服务端渲染的配置">服务端渲染的配置说明请看这里</a>。</p>\n<h3 id="h3-11">数据异步请求</h3>\n<p>对于一个前后端分离的系统来说，异步数据请求是几乎每个页面都需要的。<em>Next.js</em>通过<code>getInitialProps</code>来实现。\n    下面的示例数据来自<a href="https://www.tvmaze.com/api">https://www.tvmaze.com/api</a> 。创建*./pages/tvshows.js*的文件：</p>\n<pre><code class="JavaScript"><span class="code-keyword">import</span> Layout <span\n        class="code-keyword">from</span> <span class="code-string">\'../components/layout.js\'</span>\n<span class="code-keyword">import</span> Link <span class="code-keyword">from</span> <span class="code-string">\'next/link\'</span>\n<span class="code-keyword">import</span> fetch <span class="code-keyword">from</span> <span class="code-string">\'isomorphic-unfetch\'</span>\n\n<span class="code-keyword">const</span> TvShow = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> (\n    <span class="xml"><span class="code-tag">&lt;<span class="code-name">Layout</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">h1</span>&gt;</span>Batman TV Shows<span class="code-tag">&lt;/<span\n                class="code-name">h1</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">ul</span>&gt;</span>\n            {props.shows.map(({show}) =&gt; (\n                <span class="code-tag">&lt;<span class="code-name">li</span> <span class="hljs-attr">key</span>=<span\n                        class="code-string">{show.id}</span>&gt;</span>\n                    <span class="code-tag">&lt;<span class="code-name">Link</span> <span\n                            class="hljs-attr">href</span>=<span class="code-string">{</span>`/<span\n                            class="hljs-attr">tv</span>?<span class="hljs-attr">id</span>=<span class="code-string">${show.id}</span>`}&gt;</span>\n                        <span class="code-tag">&lt;<span class="code-name">a</span>&gt;</span>{show.name}<span\n                class="code-tag">&lt;/<span class="code-name">a</span>&gt;</span>\n                    <span class="code-tag">&lt;/<span class="code-name">Link</span>&gt;</span>\n                <span class="code-tag">&lt;/<span class="code-name">li</span>&gt;</span>\n            ))}\n        <span class="code-tag">&lt;/<span class="code-name">ul</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">Layout</span>&gt;</span></span>\n)\n\nTvShow.getInitialProps = <span class="code-keyword">async</span> <span class="hljs-function"><span class="code-keyword">function</span>(<span\n            class="hljs-params"></span>) </span>{\n    <span class="code-comment">//contxt是衔接Next.js包装组件和自定义主键的上下文，包含的参数有asPath、pathname、query</span>\n\n    <span class="code-comment">// 发送异步请求</span>\n    <span class="code-keyword">const</span> res = <span class="code-keyword">await</span> fetch(<span\n            class="code-string">\'https://api.tvmaze.com/search/shows?q=batman\'</span>)\n\n    <span class="code-comment">// 从response中异步读取数据流</span>\n    <span class="code-keyword">const</span> data = <span class="code-keyword">await</span> res.json()\n\n    <span class="code-built_in">console</span>.log(<span class="code-string">`Show data fetched. Count: <span\n            class="hljs-subst">${data.length}</span>`</span>)\n\n    <span class="code-comment">// 返回已获取的数据</span>\n    <span class="code-keyword">return</span> {\n        <span class="hljs-attr">shows</span>: data\n    }\n}\n\n<span class="code-keyword">export</span> <span class="code-keyword">default</span> TvShow\n</code></pre>\n<p><code>TvShow</code>组件的作用是异步请求数据并组装成列表展示。</p>\n<p>然后再创建一个查看详情的页面——<em>./pages/tv.js</em>，实现过程和上面一样：</p>\n<pre><code class="JavaScript"><span class="code-keyword">import</span> Layout <span\n        class="code-keyword">from</span> <span class="code-string">\'../components/layout\'</span>\n<span class="code-keyword">import</span> fetch <span class="code-keyword">from</span> <span class="code-string">\'isomorphic-unfetch\'</span>\n\n<span class="code-keyword">const</span> Tv =  <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> (\n    <span class="xml"><span class="code-tag">&lt;<span class="code-name">Layout</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">h1</span>&gt;</span>{props.show.name}<span class="code-tag">&lt;/<span\n                class="code-name">h1</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">p</span>&gt;</span>{props.show.summary.replace(/<span\n                class="code-tag">&lt;<span class="code-name">[</span>/]?<span class="hljs-attr">p</span>&gt;</span>/g, \'\')}<span\n                class="code-tag">&lt;/<span class="code-name">p</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">img</span> <span class="hljs-attr">src</span>=<span\n                class="code-string">{props.show.image.medium}/</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">Layout</span>&gt;</span>\n)\n\nTv.getInitialProps = async function (context) {\n    const { id } = context.query\n    const res = await fetch(`https://api.tvmaze.com/shows/${id}`)\n    const show = await res.json()\n\n    console.log(`Fetched show: ${show.name}`)\n\n    return { show }\n}\nexport default Tv\n</span></code></pre>\n<p>按照这个套路可以解决绝大部分数据异步请求的问题。不过如果数据组装过慢，会出页面现卡顿的问题，可以通过服务端缓存或异步页面加载实现，后续的篇幅会介绍。</p>\n<h2 id="h2-7">样式</h2>\n<h3 id="h3-12">源生添加样式</h3>\n<p>一个页面永远离不开样式，在<em>Next.js</em>中推荐一种简介高效的方法——<code>&lt;style jsx&gt;</code>。</p>\n<p>为的主页添加一些样式：</p>\n<pre><code class="JavaScript">(\n    &lt;Layout&gt;\n        &lt;h2&gt;Information&lt;/h2&gt;\n        &lt;SubLink as="first-post" title="First Post"/&gt;\n        &lt;SubLink as="first-post" title="Second Post"/&gt;\n        &lt;SubLink as="first-post" title="Third Post"/&gt;\n        &lt;style jsx&gt;{`\n            h2{\n                font-family: "Arial";\n            }\n        `}&lt;/style&gt;\n        &lt;style jsx global&gt;{`\n            .list{\n                list-style: none;\n                margin: 5px 0;\n            }\n        `}&lt;/style&gt;\n    &lt;/Layout&gt;\n)\n</code></pre>\n<p><code>&lt;style jsx&gt;</code>的作用就是为当前组件声明样式，需要注意的是在这个标签内声明的样式只能覆盖当前组件，子组件是不会出现层叠效果的。而<code>&lt;style jsx\n    global&gt;</code>标签的效果则是和标准的css层叠效果一致，在这个标签中声明的样式会影响到子组件。</p>\n<h3 id="h3-13">Loader添加载样式</h3>\n<p><em>Next.js</em>可以加载各种样式文件，下面以<em>Sass/Scss</em>为例。</p>\n<p>首先添加相关依赖：</p>\n<pre><code class="bash">npm install --save @zeit/next-sass node-sass\n</code></pre>\n<p>在项目根目录添加<em>next.config.js</em>文件，用于指示<em>Next</em>加载对用的功能：</p>\n<pre><code class="bash">const withSass = require(<span class="code-string">\'@zeit/next-sass\'</span>)\nmodule.exports = withSass()\n</code></pre>\n<p>现在就可以加载*.scss<em>文件了，添加一个</em>/pages/post.scss*文件：</p>\n<pre><code class="css">$<span class="code-selector-tag">font-size</span>: 50<span class="code-selector-tag">px</span>;\n<span class="code-selector-class">.header</span>{\n  <span class="code-attribute">font-size</span>: $font-size;\n  <span class="code-attribute">color</span>:red;\n}\n</code></pre>\n<p>修改*/pages/post.js*加载样式：</p>\n<pre><code class="JavaScript"><span class="code-keyword">import</span> {withRouter} <span\n        class="code-keyword">from</span> <span class="code-string">\'next/router\'</span>\n<span class="code-keyword">import</span> Layout <span class="code-keyword">from</span> <span class="code-string">\'../components/layout\'</span>\n<span class="code-comment">//加载样式</span>\n<span class="code-keyword">import</span> <span class="code-string">\'./post.scss\'</span>\n\n<span class="code-keyword">const</span> Page = withRouter(<span class="hljs-function">(<span\n            class="hljs-params">props</span>) =&gt;</span> (\n    <span class="xml"><span class="code-tag">&lt;<span class="code-name">Layout</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">h3</span> <span class="hljs-attr">className</span>=<span\n                class="code-string">"header"</span>&gt;</span>Post Page<span class="code-tag">&lt;/<span\n                class="code-name">h3</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">p</span>&gt;</span>Info:{props.router.query.title}<span\n                class="code-tag">&lt;/<span class="code-name">p</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">Layout</span>&gt;</span></span>\n))\n\n<span class="code-keyword">export</span> <span class="code-keyword">default</span> Page\n</code></pre>\n<p>由于是使用的<em>webpack</em>的<em>Loader</em>，可以根据需要在<em>next.config.js</em>文件中进行一些相关的设置：</p>\n<pre><code class="JavaScript"><span class="code-built_in">module</span>.exports = withSass({\n  <span class="hljs-attr">cssModules</span>: <span class="hljs-literal">true</span>,\n  <span class="hljs-attr">cssLoaderOptions</span>: {\n    <span class="hljs-attr">importLoaders</span>: <span class="hljs-number">1</span>,\n    <span class="hljs-attr">localIdentName</span>: <span class="code-string">"[local]___[hash:base64:5]"</span>,\n  }\n})\n</code></pre>\n<p>然后在组件中直接以对象的方式使用：</p>\n<pre><code class="JavaScript"><span class="code-keyword">import</span> style <span\n        class="code-keyword">from</span> <span class="code-string">\'./post.scss\'</span>\n<span class="code-keyword">const</span> Page = withRouter(<span class="hljs-function">(<span\n            class="hljs-params">props</span>) =&gt;</span> {\n    <span class="code-built_in">console</span>.log(style)\n    <span class="code-keyword">return</span> (\n        <span class="xml"><span class="code-tag">&lt;<span class="code-name">Layout</span>&gt;</span>\n            <span class="code-tag">&lt;<span class="code-name">h3</span> <span class="hljs-attr">className</span>=<span\n                    class="code-string">{style.header}</span>&gt;</span>Post Page<span class="code-tag">&lt;/<span\n                    class="code-name">h3</span>&gt;</span>\n            <span class="code-tag">&lt;<span class="code-name">p</span>&gt;</span>Info:{props.router.query.title}<span\n                    class="code-tag">&lt;/<span class="code-name">p</span>&gt;</span>\n        <span class="code-tag">&lt;/<span class="code-name">Layout</span>&gt;</span></span>\n    )\n})\n</code></pre>\n<p>更多关于cssLoaderOptions的参数说明可以查看<a href="https://github.com/webpack-contrib/css-loader#options"\n                                   title="webpack里css-loader的options说明">webpack里css-loader的options说明</a>。除了scss,<a\n        href="https://github.com/zeit/next.js#css-in-js" title="*Next.js*还支持css、less、post css的Loader"><em>Next.js</em>还支持css、less、post\n    css的Loader</a>。</p>\n<h2 id="h2-8">发布</h2>\n<p>在了解以上内容之后，已经可以开发一个网站了，接下来介绍如何发布生产包。</p>\n<p><em>package.json</em>中的“scripts"字段可以设置打包和生产运行方式：</p>\n<pre><code class="json">  <span class="code-string">"scripts"</span>: {\n    <span class="hljs-attr">"dev"</span>: <span class="code-string">"node server.js"</span>,\n    <span class="hljs-attr">"build"</span>: <span class="code-string">"next build"</span>,\n    <span class="hljs-attr">"start"</span>: <span class="code-string">"NODE_ENV=production node server.js"</span>\n  }\n</code></pre>\n<p>首先进行打包：</p>\n<pre><code class="bash">npm run build\n</code></pre>\n<p>打包完毕之后可以启动生产环境：</p>\n<pre><code class="bash">npm start\n</code></pre>\n<p>现在用浏览器打开<a href="http://localhost:3000/">http://localhost:3000/</a> 地址可以发现运行的是生产环境（可以使用React工具查看，也可以打开开发人员模式）。\n    由于之前了在<em>server.js</em>中引入了Express，所以现在启动的是一个Express服务器。打包之后的文件都在*./.next*\n    路径下，可以仅仅拷贝<strong>依赖包（node_module）</strong>、<strong>package.json</strong>、<strong>server.js</strong>以及**./.next**来运行生产环境。\n</p>\n<p>除了使用<em>Express</em>这一类第三方nodejs服务器，<a href="https://zeit.co/now" title="*Next.js*还提供了许多其他方式来部署和方法"><em>Next.js</em>还提供了许多其他方式来部署和方法</a>\n</p>'},394:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<h2 id="h2-1">SpringApplication</h2>\n<p>在使用Spring-boot时，永远要记住它仅仅是Spring Framework的延伸（或者说整合），其底层还是基于Spring Framework（core、contest、bean）。所以Spring该有的特性Spring\n    Boot中都会存在。</p>\n\n<h3 id="h3-1">启动异常</h3>\n<p>Spring在启动时需要初始化容器、向容器在注入类等等操作，如果在启动过程中发生任何异常，我们可以通过&nbsp;FailureAnalyzers 特性来获取异常启动的信息，结构如下：</p>\n<pre><code class="markdown"><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span\n        class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span>**\nAPPLICATION FAILED TO START\n<span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span\n            class="hljs-strong">*****</span><span class="hljs-strong">*****</span>**\n\nDescription:\n\nEmbedded servlet container failed to start. Port 8080 was already in use.\n\nAction:\n\nIdentify and stop the process that\'s listening on port 8080 or configure this application to listen on another port.</code></pre>\n<p>如果需要获取更详细的信息，我们可以开打DEBUG模式。请参看总结的第一章。</p>\n\n<h3 id="h3-2">自定义Banner</h3>\n<p>默认情况下Spring Boot启动时日志会自带一个Banner，如下：</p>\n<pre><code class="ruby"><span class="hljs-number">2018</span>-<span class="hljs-number">01</span>-<span\n        class="hljs-number">22</span> <span class="hljs-number">10</span><span class="hljs-symbol">:</span><span\n        class="hljs-number">49</span><span class="hljs-symbol">:</span><span\n        class="hljs-number">43.865</span> DEBUG <span class="hljs-number">4510</span> --- [  restartedMain] .b.l.ClasspathLoggingApplicationListener : Application started with <span\n        class="hljs-symbol">classpath:</span> [<span class="hljs-symbol">file:</span>/work/demo2/target/classes/]\n\n  .   ___<span class="hljs-number">_</span>          <span class="hljs-number">_</span>            _<span\n            class="hljs-number">_</span> <span class="hljs-number">_</span> <span class="hljs-number">_</span>\n /\\\\ / __<span class="hljs-number">_</span><span class="code-string">\'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | \'</span><span class="hljs-number">_</span> <span class="hljs-params">| \'_|</span> <span class="hljs-params">| \'_ \\/ _` |</span> \\ \\ \\ \\\n \\\\/  __<span class="hljs-number">_</span>)<span class="hljs-params">| |</span><span class="hljs-number">_</span>)<span\n            class="hljs-params">| |</span> <span class="hljs-params">| |</span> <span\n            class="hljs-params">| |</span><span class="hljs-params">| (_|</span> <span class="hljs-params">|  ) ) ) )\n  \'  |</span>___<span class="hljs-number">_</span><span class="hljs-params">| .__|</span><span\n            class="hljs-number">_</span><span class="hljs-params">| |</span><span class="hljs-number">_</span><span\n            class="hljs-params">|_|</span> <span class="hljs-params">|_\\__, |</span> / <span\n            class="hljs-regexp">/ /</span> /\n =========<span class="hljs-params">|_|</span>==============<span class="hljs-params">|___/=/_/_/_/\n :: Spring Boot ::        (v1.5.9.RELEASE)\n\n2018-01-22 10:49:44.007  INFO 4510 --- [  restartedMain] o.p.springframe.boot.demo.webmvc.Demo    : Starting Demo on chkui with PID 4510 (/work/demo2/target/classes started by chenkui <span\n                class="code-keyword">in</span> /work/demo2)</span></code></pre>\n<p>绝大部分情况我们直接关闭它，但是在某些场景下我们需要自定义我们的Banner（比如做为一个产品部分给客户时）。</p>\n<p>可以在ClassPath中添加一个名为"banner.txt"的文件，然后在JVM中设定"banner.location"的属性来指向他，还可以通过&nbsp;banner.charset\n    来指定文件的编码。除了文本之外，还可以将Banner设定为图片——在banner.txt中通过banner.gif、banner.jpg、banner.png来指定，或者直接设定JVM的banner.image.location属性。图片会被转换成ASCII并在文本中输出它。</p>\n<p>可以在banner.txt文件描述中通过${}方式引入各种参数，<a\n        href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#boot-features-banner"\n        rel="nofollow">详情见Banner的参数描述部分</a>。</p>\n<p>SpringApplication.setBanner()方法或org.springframework.boot.Banner 设置为false可以直接关闭Banner的输出。</p>\n\n<h3 id="h3-3">设置启动参数</h3>\n<p>\n    通常情况下，我们使用SpringApplication.run(args)的静态方法就可以启动Boot。其实静态的run方法也是在代码中创建了一个SpringApplication的实例。我们可以可以像下面这样自己创建SpringApplication实例并设置参数，最后启动它：</p>\n<pre><code class="java"><span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n        class="code-keyword">void</span> <span class="code-title">main</span><span\n        class="hljs-params">(String[] args)</span> </span>{\n    SpringApplication app = <span class="code-keyword">new</span> SpringApplication(MySpringConfiguration.class);\n    app.setBannerMode(Banner.Mode.OFF);<span class="code-comment">//不输出Banner</span>\n    app.run(args);\n}</code></pre>\n<p>传递给run方法的args参数可以用于Boot的外部配置，也可以直接使用@Configuration的方式而什么都不传递，关于外部化配置的说明请见后续配置部分说明。</p>\n\n<h3 id="h3-4">"函数式"Builder代码</h3>\n<p>Boot还提供了更加“函数式”方法来构建SpringApplication：</p>\n<pre><code class="java"><span class="code-keyword">new</span> SpringApplicationBuilder()\n        .sources(Parent.class)\n        .child(Application.class)\n        .bannerMode(Banner.Mode.OFF)\n        .run(args);</code></pre>\n<p>SpringApplicationBuilder可以很方便的用于创建多个Context，不过创建多个Context时也有一些限制，详情请看&nbsp;<a\n        href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/api/org/springframework/boot/builder/SpringApplicationBuilder.html"\n        rel="nofollow">SpringApplicationBuilder 的 API</a>。</p>\n\n<h3 id="h3-5">事件以及监听</h3>\n<p>\n    除了<a\n        href="https://docs.spring.io/spring/docs/4.3.13.RELEASE/spring-framework-reference/htmlsingle/#context-functionality-events"\n        rel="nofollow">Spring Framework原有的事件外</a>，Boot还额外增加了一些必要的事件。我们可以通过调用SpringApplication.addListeners(​)来增加事件。Boot特有的事件包括：\n</p>\n<ol>\n    <li>ApplicationStartingEvent：在Application开始运行（这个时候仅仅完成初始化工具的生成和监听器的生成，其他任何context或者bean都不存在）时触发这个事件。</li>\n    <li>ApplicationEnvironmentPreparedEvent：这个事件被触发的时机是，上下文环境已经确定但是还未创建context（即容器还未开始创建）。</li>\n    <li>ApplicationPreparedEvent：触发的时机是所有的Bean（Class类）已经被读取，但是还未执行Context的refresh方法（refresh用于Spring初始化一个Context）。</li>\n    <li>ApplicationReadyEvent：在完成上下文初始化、Beans加载，所有的功能都准备就绪时触发。</li>\n    <li>ApplicationFailedEvent：在启动初始化过程中出现异常时触发。</li>\n</ol>\n<p>\n    使用监听器需要注意的是某些事件会在Context初始化之前就被创建，所以我们无法将这些监听器著注册成一个@Bean使用，除了通过SpringApplication.addListeners(​)和SpringApplicationBuilder.listeners()方法，还可以在META-INF/spring.factories文件中创建一个org.springframework.context.ApplicationListener字段指向监听类列表，例如：</p>\n<pre><code class="">org.springframework.context.ApplicationListener=com.example.project.MyListener</code></pre>\n<p>SpringBoot的事件是通过Spring\n    Framework的事件机制传递的，这个事件的一个特点是当我们向子context发送事件时候，它的所有祖先context都会收到这个事件，所以我们在使用多个层级的SpringBoot应用时监听器必须对收到的事件来源加以区分，我们可以通过ApplicationContextAware来获取当前的Context，或者如果监听器是一个Bean，可以直接使用@Autowired注入。</p>\n\n<h3 id="h3-6">Web环境</h3>\n<p>\n    我们知道Spring有各种各样的ApplicationContext，而Boot的自动配置推导功能会根据ClassPath中所包含的内容来确定使用哪个ApplicationContext。通常情况下，如果你使用的是一个web环境工程（例如依赖了spring-boot-starter-web），Boot会使用AnnotationConfigEmbeddedWebApplicationContext，否则会使用AnnotationConfigApplicationContext。确定当前环境是否为Web环境的算法十分简单，通过判断几个类是否存在而确定，我们可以setWebEnvironment(boolean)方法来手工指定当前的环境。当然如果你对各类ApplicationContext十分了解，可以调用SpringApplication.setApplicationContextClass()直接设置ApplicationContext。</p>\n\n<h3 id="h3-7">获取Application参数</h3>\n<p>我们在运行run方法时会传递由main传入的String[] args 参数，这个参数可以设定各种运行环境参数。我们可以通过注入ApplicationArguments在任何地方获取这个参数。</p>\n<pre><code class="java"><span class="code-keyword">import</span> org.springframework.boot.*\n<span class="code-keyword">import</span> org.springframework.beans.factory.annotation.*\n<span class="code-keyword">import</span> org.springframework.stereotype.*\n\n<span class="code-meta">@Component</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">MyBean</span> </span>{\n\n    <span class="code-meta">@Autowired</span>\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-title">MyBean</span><span\n            class="hljs-params">(ApplicationArguments args)</span> </span>{\n        <span class="code-keyword">boolean</span> debug = args.containsOption(<span class="code-string">"debug"</span>);\n        List&lt;String&gt; files = args.getNonOptionArgs();\n        <span class="code-comment">// if run with "--debug logfile.txt" debug=true, files=["logfile.txt"]</span>\n    }\n\n}</code></pre>\n<p>除此之外，CommandLinePropertySource可以获取Boot相关的运行环境参数。</p>\n\n<h3 id="h3-8">Application退出</h3>\n<p>我们关闭一个Java程序通常会直接关闭运行他的JVM，每一个SpringApplication都会向JVM注册一个shutdow\n    hook，以确保程序在退出时正确关闭ApplicationContext。所有SpringFramework标准的生命周期回调方法都会在此时被调用（例如DisposableBean接口，或者@PreDestroy注解标记的方法）。除此之外，Boot还新增了org.springframework.boot.ExitCodeGenerator接口来设定System.exit()退出时的返回编码，</p>\n<pre><code class="java"><span class="code-meta">@SpringBootApplication</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">ExitCodeApplication</span> </span>{\n\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> ExitCodeGenerator <span class="code-title">exitCodeGenerator</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> ExitCodeGenerator() {\n\t\t\t<span class="code-meta">@Override</span>\n\t\t\t<span class="hljs-function"><span class="code-keyword">public</span> <span\n                    class="code-keyword">int</span> <span class="code-title">getExitCode</span><span\n                    class="hljs-params">()</span> </span>{\n\t\t\t\t<span class="code-keyword">return</span> <span class="hljs-number">42</span>;\n\t\t\t}\n\t\t};\n\t}\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tSystem.exit(SpringApplication\n\t\t\t\t.exit(SpringApplication.run(ExitCodeApplication.class, args)));\n\t}\n\n}</code></pre>\n\n<h3 id="h3-9">JMX MBeanServer</h3>\n<p>通过spring.application.admin.enabled属性可以打开MBean相关的功能，然后我们的系统会向外暴露<a\n        href="https://github.com/spring-projects/spring-boot/blob/v1.5.9.RELEASE/spring-boot/src/main/java/org/springframework/boot/admin/SpringApplicationAdminMXBean.java"\n        rel="nofollow">SpringApplicationAdminMXBean</a>，我们可以通过这个MBean了解一些环境信息和配置信息或直接关闭在运行的程序。</p>\n<p>获取local.server.port属性可以知道当前JMX暴露的端口。</p>\n\n<h2 id="h2-2">外部化配置</h2>\n<p>每一个需要面向市场的系统都需要一些外部化的配置来解决不同环境的问题（例如开发环境、测试环境、生产环境）。</p>\n\n<h3 id="h3-10">加载外部属性值</h3>\n<p>我们一般将配置的数据记录在properties文件、YAML文件、环境变量中，或者通过命令行参数来传入。Spring\n    Boot提供了一套价值将这些外部数据加载到JVM的系统参数中。既然可以通过多种方式给SpringApplication设定外部参数，所以需要明确各种方式的优先级。Spring\n    Boot使用了一个非常特殊的PropertySource命令来设计，用于依次覆盖先前的配置。其优先级依次为：</p>\n<ol>\n    <li>如果有Devtools存在，优先使用Devtools的全局配置参数。</li>\n    <li>在测试用例中&nbsp;@TestPropertySource 的优先级最高。</li>\n    <li>我们会通过@SpringBootTest注解标记一个测试用例，其中的属性参数优先级其次。</li>\n    <li>由命令行传入的参数。</li>\n    <li>SPRING_APPLICATION_JSON指定的参数。</li>\n    <li>ServletConfig 的 init parameters。</li>\n    <li>ServletContext 的 init parameters。</li>\n    <li>java:comp/env 设定的 JNDI参数。</li>\n    <li>通过System.setProperties设定的参数。</li>\n    <li>操作系统参数。</li>\n    <li>以 random.* 形式命名的的&nbsp;RandomValuePropertySource 参数。</li>\n    <li>Jar包之外application-{profile}.properties文件配置的参数。</li>\n    <li>Jar包之内application-{profile}.properties文件配置的参数。</li>\n    <li>Jar包之外application.properties文件配置的参数。</li>\n    <li>Jar包之内application.properties文件配置的参数。</li>\n    <li>@Configuration类上@PropertySource指定的参数。</li>\n</ol>\n<p>例如在 application.properties 文件中设定一个名为 name 的参数，在不同的环境中，我们可以提供不同的&nbsp;application.properties 文件来修改配置参数。此外，我们可以继续保留默认的&nbsp;application.properties\n    文件，通过 java -jar app.jar --name="Spring" 命令的方式来指定 name 参数，由于优先级的问题，命令行使用的数据会覆盖application.properties中的数据。</p>\n\n<h3 id="h3-11">application.properties配置文件规则</h3>\n<p>SpringApplication会从以下路径加载所有的application.properties文件：</p>\n<ol>\n    <li>file:./config/（当前目录下的config文件夹）</li>\n    <li>file:./（当前目录）</li>\n    <li>classpath:/config/（classpath下的config目录）</li>\n    <li>classpath:/（classpath根目录）</li>\n</ol>\n<p>\n    优先级由上至下。需要特别说明的是，这个优先级是指属性最后使用的值，而不是说仅仅扫描优先级高的路径，如果发现了application.properties文件就停止。例如classpath:/config/和file:./config/都存在配置文件，那么加载过程会加载classpath:/config/路径下配置文件的所有属性，然后再加载file:./config/路径下配置文件的属性并替换已有的属性。</p>\n<p>如果你不想使用application.properties的格式命名配置文件，那么可以通过环境变量spring.config.name来设置文件名称，例如：</p>\n<pre><code class="apache">$ <span\n        class="code-attribute">java</span> -jar myproject.jar --spring.config.name=myproject</code></pre>\n<p>此时，要加载的配置文件名为myproject.properties。</p>\n<p>除了修改名称，还可以使用&nbsp;spring.config.location 来添加要加载的路径。例如我们以这个命令启动JVM：</p>\n<pre><code\n        class="bash">$ java -jar myapp.jar --spring.config.location=classpath:/myconfig/,file:./myconfig/</code></pre>\n<p>那么加载application.properties文件的路径以及优先级会变为：</p>\n<ol>\n    <li>file:./myconfig/</li>\n    <li>classpath:/myconfig/</li>\n    <li>file:./config/</li>\n    <li>file:./</li>\n    <li>classpath:/config/</li>\n    <li>classpath:/</li>\n</ol>\n<p>spring.config.location环境变量也可以直接设定到加载文件的名称，例如：</p>\n<pre>--spring.config.location=classpath:/default.properties</pre>\n<p>通常情况下这样做并没有太大问题，但是结合到Profiles文件特性时，会导致无法根据标记加载对应的Profiles文件。详情请看后面的Profiles文件介绍。</p>\n<p>由于配置文件路径和配置文件名称在容器未启动时就需要声明，所以最好在OS的环境变量、JVM的系统环境变量或命令行参数就设定它。</p>\n\n<h3 id="h3-12">替换符与数据注入</h3>\n<p>在从各种外部配置读取数据后，需要将其注入到Bean中作为数据项使用。Spring通常情况下使用@Value注解来实现：</p>\n<pre><code class="java"><span class="code-keyword">import</span> org.springframework.stereotype.*\n<span class="code-keyword">import</span> org.springframework.beans.factory.annotation.*\n<span class="code-meta">@Component</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">MyBean</span> </span>{\n    <span class="code-meta">@Value</span>(<span class="code-string">"${name}"</span>)\n    <span class="code-keyword">private</span> String name;\n}</code></pre>\n<p>上面的例子中@Value("${name}")表示将JVM中的属性 --name注入到private String name成员变量。所以${}就是一个替换符号。</p>\n<p>除了直接指定某一个值，还通过JSON的方式更方便一次性指定多个属性。例如LINUX启动时使用：</p>\n<pre><code class="bash">$ SPRING_APPLICATION_JSON=<span class="code-string">\'{"foo":{"bar":"spam"}}\'</span> java -jar myapp.jar</code></pre>\n<p>在Spring环境中就有foo.bar=spam的数据。</p>\n<p>还可以直接通过 -D或直接--设定参数的方式直接设定Json：</p>\n<pre><code class="bash">$ java -Dspring.application.json=<span class="code-string">\'{"foo":"bar"}\'</span> -jar myapp.jar</code></pre>\n<pre><code class="java">$ java -jar myapp.jar --spring.application.json=<span class="code-string">\'{"foo":"bar"}\'</span></code></pre>\n<p>此时foo=bar。</p>\n\n<h3 id="h3-13">安全数据转换</h3>\n<p>使用@Value注解是将JVM中的属性转换为Bean最常规的方式。不过如果配置量很大，我们需要反复的书写很多的@Value，也不便于结构化。所以Spring Boot在Spring\n    Framework的基础上提供了一个支持结构化数据注入、支持安全类型推导转换、支持数据验证的方法——@<em>ConfigurationProperties。</em></p>\n<pre><code class="java"><span class="code-meta">@ConfigurationProperties</span>(<span class="code-string">"foo"</span>)\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">FooProperties</span> </span>{\n    <span class="code-keyword">private</span> <span class="code-keyword">boolean</span> enabled;\n    <span class="code-keyword">private</span> InetAddress remoteAddress;\n    <span class="code-keyword">private</span> <span class="code-keyword">final</span> Security security = <span\n            class="code-keyword">new</span> Security();\n    <span class="code-comment">//Getter and Setter</span>\n    <span class="code-keyword">public</span> <span class="code-keyword">static</span> <span class="hljs-class"><span\n            class="code-keyword">class</span> <span class="code-title">Security</span> </span>{\n        <span class="code-keyword">private</span> String username;\n        <span class="code-keyword">private</span> String password;\n        <span class="code-keyword">private</span> List&lt;String&gt; roles = <span class="code-keyword">new</span> ArrayList&lt;&gt;(Collections.singleton(<span\n            class="code-string">"USER"</span>));\n        <span class="code-comment">//Getter and Setter</span>\n    }\n}\n</code></pre>\n<p>上面的类省略了Get和Set方法，当时每一个作为POJO或Entity的类都必须提供完整的Get和Set方法。因为有了@ConfigurationProperties("foo")注解，此时JVM中有一个&nbsp;foo.enabled\n    =&nbsp;false/ture 的属性会被注入到enabled变量中，如果环境中没有foo.enabled，则会设定默认值 false。</p>\n<p>除了在POJO类上增加@ConfigurationProperties注解，还需要在入口类（一般设定在<em>@Configuration类上</em>）通过@EnableConfigurationProperties注解列举要执行@ConfigurationProperties的类，如下：\n</p>\n<pre><code class="java"><span class="code-meta">@Configuration</span>\n<span class="code-meta">@EnableConfigurationProperties</span>(FooProperties.class)\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">MyConfiguration</span> </span>{\n}</code></pre>\n<p>\n    对于@ConfigurationProperties，在注入环境的属性值之后，它会成为一个Bean在容器的任意位置使用。虽然一个Bean可以注入其他Bean，但是最好一个@ConfigurationProperties的类仅仅用来记录属性数据，而不要再依赖任何Bean。</p>\n\n<h3 id="h3-14">数据快捷绑定规则</h3>\n<p>用@ConfigurationProperties从JVM的属性转变为Bean可以有多种映射方式。直接用一个例子来说明：</p>\n<pre><code class="java"><span class="code-meta">@ConfigurationProperties</span>(prefix=<span class="code-string">"person"</span>)\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">OwnerProperties</span> </span>{<span class="code-comment">//Bean</span>\n    <span class="code-keyword">private</span> String firstName; <span class="code-comment">//值</span>\n    <span class="hljs-function"><span class="code-keyword">public</span> String <span\n            class="code-title">getFirstName</span><span class="hljs-params">()</span> </span>{\n        <span class="code-keyword">return</span> <span class="code-keyword">this</span>.firstName;\n    }\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setFirstName</span><span class="hljs-params">(String firstName)</span> </span>{\n        <span class="code-keyword">this</span>.firstName = firstName;\n    }\n\n}</code></pre>\n<p>根据前面的介绍，在SpringContext进行初始化的过程中会将person.firstName的属性注入到这个Bean的firsName成员变量中，但是除此之外，其他命名规则的属性值也会被绑定，如下：</p>\n<table border="1" cellpadding="1" cellspacing="1" style="width:500px">\n    <tbody>\n    <tr>\n        <td>person.firstName</td>\n        <td>标准的驼峰书写规则。</td>\n    </tr>\n    <tr>\n        <td>person.first-name</td>\n        <td>横线表示法，常用于在配置文件的书写中。</td>\n    </tr>\n    <tr>\n        <td>person.first_name</td>\n        <td>下划线表示法，用语配置文件的书写。</td>\n    </tr>\n    <tr>\n        <td>PERSON_FIRST_NAME</td>\n        <td>大写格式。常用于系统的环境变量。</td>\n    </tr>\n    </tbody>\n</table>\n<p>\n    Boot已经为@ConfigurationProperties提供了强大的类型匹配机制，不过如果在开发的过程中还有更特殊的匹配需求，可以用ConversionService、CustomEditorConfigurer来解决属性转换为Bean的类型匹配，<a\n        href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#boot-features-external-config-conversion"\n        rel="nofollow">详情看这里</a>。</p>\n\n<h3 id="h3-15">@ConfigurationProperties数据验证</h3>\n<p>\n    可以通过JSR-303描述的Java验证方式对配置数据进行注入验证，只要在@ConfigurationProperties类加上@Validated注解即可，并且在classPath中有JSR-303的实现（Spring已经自带了）。看例子：</p>\n<pre><code class="java"><span class="code-meta">@ConfigurationProperties</span>(prefix=<span\n        class="code-string">"foo"</span>)\n<span class="code-meta">@Validated</span> <span class="code-comment">//验证标记</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">FooProperties</span> </span>{\n    <span class="code-meta">@NotNull</span> <span class="code-comment">//注入Bean时，这个数据不能为空</span>\n    <span class="code-keyword">private</span> InetAddress remoteAddress;\n}</code></pre>\n<p>如果在类中还有嵌套在内部的实体，需要使用@Valid注解来触发验证：</p>\n<pre><code class="java"><span class="code-meta">@ConfigurationProperties</span>(prefix=<span class="code-string">"connection"</span>)\n<span class="code-meta">@Validated</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">FooProperties</span> </span>{\n    <span class="code-meta">@NotNull</span>\n    <span class="code-keyword">private</span> InetAddress remoteAddress;\n    <span class="code-meta">@Valid</span>\n    <span class="code-keyword">private</span> <span class="code-keyword">final</span> Security security = <span\n            class="code-keyword">new</span> Security();\n    <span class="code-keyword">public</span> <span class="code-keyword">static</span> <span class="hljs-class"><span\n            class="code-keyword">class</span> <span class="code-title">Security</span> </span>{\n        <span class="code-meta">@NotEmpty</span>\n        <span class="code-keyword">public</span> String username;\n    }\n}</code></pre>\n<p>除了已经定义好的验证方式，还可以自定义对Bean的验证，<a\n        href="https://github.com/spring-projects/spring-boot/tree/v1.5.9.RELEASE/spring-boot-samples/spring-boot-sample-property-validation"\n        rel="nofollow">请看这个例子</a>。</p>\n\n<h2 id="h2-3">环境配置</h2>\n<p>\n    前面介绍了如何配置，这一小节将详细介绍如何解决不同环境不同配置的问题。Spring提供了默认配置为主，部分分离配置为辅的配置方式，称之为Profiles特性。可以通过@Profiles注解和Profiles相关的命名来限制配置Beans的使用和配置文件的加载。通常我们使用spring.profiles.active属性来设置被激活指定的配置。例如\n    --spring.profiles.active = dev, hsqldb。</p>\n<p>像下面这样通过@Profiles注解来指定是否激活某个@Component或@Configuration。</p>\n<pre><code class="java"><span class="code-meta">@Configuration</span>\n<span class="code-meta">@Profile</span>(<span class="code-string">"production"</span>)\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">ProductionConfiguration</span> </span>{\n    <span class="code-comment">//仅仅在 spring.profiles.active = production时，这个Bean才会被注入</span>\n}</code></pre>\n\n<h3 id="h3-16">设置激活的profiles</h3>\n<p>\n    我们可以通过多种方式来设定spring.profiles.active的参数，这与前面设定属性的优先级一样（PropertySource算法）。这就意味着可以同样在application.properties配置文件中指定他，然后通过命令行的方式覆盖这个参数的内容。</p>\n<p>\n    除了spring.profiles.active，spring.profiles.include可以设置更多的激活内容。而SpringApplication也提供了setAdditionalProfiles()方法来设定当前的profiles。</p>\n\n<h3 id="h3-17">profiles文件</h3>\n<p>在前面介绍properties属性的内容里有提到application-{profile}.properties文件。它也Profiles特性之一，具备以下特点：</p>\n<ol>\n    <li>\n        application-{profile}.properties文件的加载路径和application.properties一样，同样使用spring.config.location和spring.config.name配置。不过优先级更高。\n    </li>\n    <li>若未指定spring.profiles.active环境变量，那么profile的名称默认为default，也就是会优先加载application-default.properties文件。</li>\n    <li>如果我们一次性指定了多个profile，那么最后一个的优先级最高。</li>\n    <li>\n        前面已经提到，如果spring.config.location环境变量直接指定到文件名称无法支持Profiles特性，建议通过spring.config.location设定路径、spring.config.name设定文件名。\n    </li>\n</ol>\n\n<h2 id="h2-4">Loggin日志</h2>\n<p>Spring Boot默认使用&nbsp;<a href="https://commons.apache.org/logging" target="_top" rel="nofollow">Commons Logging</a>&nbsp;作为内嵌的日志输出工具，但是保留了底层日志的实现接口。Boot为&nbsp;<a\n        href="http://docs.oracle.com/javase/7/docs/api/java/util/logging/package-summary.html" target="_top"\n        rel="nofollow">Java Util Logging</a>、<a href="https://logging.apache.org/log4j/2.x/" target="_top"\n                                                rel="nofollow">Log4J2</a>以及<a href="http://logback.qos.ch/"\n                                                                              target="_top" rel="nofollow">Logback</a>提供了默认配置，只要在classpath引入了对应的jar，Spring就会自动推导并注入配置。\n</p>\n<p>默认情况下，如果你引入了某个Starters就会使用Logback来进行日志输出（他们都依赖spring-boot-starter-logging）。Logback的路由功能可以支持其他使用Java Util\n    Logging、Commons Logging、Log4J或SLF4J的库。</p>\n\n<h3 id="h3-18">格式化</h3>\n<p>默认情况下，输出的格式是这样的：</p>\n<pre><code class="sql">2014-03-05 10:57:51.112  INFO 45469 <span class="code-comment">--- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/7.0.52</span>\n2014-03-05 10:57:51.253  INFO 45469 <span class="code-comment">--- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext</span>\n2014-03-05 10:57:51.253  INFO 45469 <span class="code-comment">--- [ost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 1358 ms</span>\n2014-03-05 10:57:51.698  INFO 45469 <span class="code-comment">--- [ost-startStop-1] o.s.b.c.e.ServletRegistrationBean        : Mapping servlet: \'dispatcherServlet\' to [/]</span>\n2014-03-05 10:57:51.702  INFO 45469 <span class="code-comment">--- [ost-startStop-1] o.s.b.c.embedded.FilterRegistrationBean  : Mapping filter: \'hiddenHttpMethodFilter\' to: [/*]</span></code></pre>\n<p>包含以下内容：</p>\n<ol>\n    <li>日期和时间，精确到毫秒级别。</li>\n    <li>日志等级——ERROR、WARN、INFO、DEBUG、TRACE。</li>\n    <li>进程ID。</li>\n    <li>分隔符 --- 用来标记之后为实际的日志输出内容。</li>\n    <li>输出日志的线程名称。</li>\n    <li>日志名称，一般情况下用缩写表示类名。</li>\n    <li>最后是日志详细信息。</li>\n</ol>\n<p>默认情况下日志仅仅输出ERROR、WARN、INFO（LogBack取消了FATAL级别，合并到ERROR）。我们可以通过Java\n    --debug或application.properties中的debug=true来开启DEBUG级别的日志输出（同样--trace或trace=true会开启跟踪日志）。</p>\n<p>如果你的输出终端支持ANSI，那么根据日志级别输出不同颜色文字，<a\n        href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#boot-features-logging-color-coded-output"\n        rel="nofollow">详情请看这里</a>。</p>\n\n<h3 id="h3-19">文件输出</h3>\n<p>默认情况下，Spring Boot只会在console输出日志，但是在服务器运行时输出到文件是必须的。</p>\n<p>实现将日志输出到文件并不复杂，仅仅需要设定2个环境变量logging.file和logging.path即可（例如写到application.properties中）。下面的表说明了2个参数设定值时的情况。</p>\n<table border="1" cellpadding="1" cellspacing="1" style="width:600px">\n    <tbody>\n    <tr>\n        <td>logging.file</td>\n        <td>logging.path</td>\n        <td>说明</td>\n    </tr>\n    <tr>\n        <td>none</td>\n        <td>none</td>\n        <td>仅仅输出到Console</td>\n    </tr>\n    <tr>\n        <td>my.log/log/my.log</td>\n        <td>none</td>\n        <td>从当前位置或绝对路径输出某个日志文件。</td>\n    </tr>\n    <tr>\n        <td>none</td>\n        <td>/var/log</td>\n        <td>输出一个名为spring.log的日志文件到指定位置。</td>\n    </tr>\n    </tbody>\n</table>\n<p>日志文件默认也是输出ERROR、WARN、INFO，每当达到10MB时会切换一个文件继续输出。</p>\n\n<h3 id="h3-20">日志级别控制</h3>\n<p>所有的支持日志系统的库都支持从环境变量中读取相关日志级别，所以我们可以将日志级别的描述也记录在环境变量中（例如application.properties文件）。其格式一般为logging.level.*=&amp;{LEVEL}，LEVEL取值TRACE,\n    DEBUG, INFO, WARN, ERROR, FATAL, OFF。全局日志配置使用logging.level.root环境变量来设定，例如：</p>\n<pre><code class="bash">logging.level.root=WARN\nlogging.level.org.springframework.web=DEBUG\nlogging.level.org.hibernate=ERROR</code></pre>\n<p>通常情况下，我们对日志的控制只要了解上述2个规则即可，但是如果有更特殊的邀请，可以从<a\n        href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#boot-features-custom-log-configuration"\n        rel="nofollow">Spring Boot的日志配置</a>开始了解。</p>\n\n<h2 id="h2-5">Web工程相关的特性</h2>\n<p>Spring Boot非常适用于开发一个Web工程，直接引入一个spring-boot-starter-web即可开始开发。</p>\n\n<h3 id="h3-21">Spring Web MVC framework</h3>\n<p>Spring Boot的web功能是通过Spring Web MVC framework（以下简称SpringMVC）来实现的，它通过@Controller和@RestController注解即可快速创建一个基于HTTP\n    Requset/Response的模型：</p>\n<pre><code class="java"><span class="code-meta">@RestController</span>\n<span class="code-meta">@RequestMapping</span>(value=<span class="code-string">"/users"</span>)\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">MyRestController</span> </span>{\n    <span class="code-meta">@RequestMapping</span>(value=<span class="code-string">"/{user}"</span>, method=RequestMethod.GET)\n    <span class="hljs-function"><span class="code-keyword">public</span> User <span\n            class="code-title">getUser</span><span class="hljs-params">(@PathVariable Long user)</span> </span>{\n        <span class="code-comment">//拦截/users/{user},user变量能够获取{user}的值</span>\n    }\n    <span class="code-meta">@RequestMapping</span>(value=<span class="code-string">"/{user}/customers"</span>, method=RequestMethod.GET)\n    <span class="hljs-function">List&lt;Customer&gt; <span class="code-title">getUserCustomers</span><span\n            class="hljs-params">(@PathVariable Long user)</span> </span>{\n        <span class="code-comment">//拦截/users/{user}/customers,user变量能够获取{user}的值</span>\n    }\n    <span class="code-meta">@RequestMapping</span>(value=<span class="code-string">"/{user}"</span>, method=RequestMethod.DELETE)\n    <span class="hljs-function"><span class="code-keyword">public</span> User <span class="code-title">deleteUser</span><span\n            class="hljs-params">(@PathVariable Long user)</span> </span>{\n        <span class="code-comment">//拦截/users/{user}的DELETE调用,user变量能够获取{user}的值</span>\n    }\n    <span class="code-meta">@RequestMapping</span>(value=<span class="code-string">"/query"</span>, method=RequestMethod.DELETE)\n    <span class="hljs-function"><span class="code-keyword">public</span> User <span class="code-title">deleteUser</span><span\n            class="hljs-params">(@RequestParam(value=<span class="code-string">"user"</span>, defaultValue=<span\n            class="hljs-number">1</span>L)</span> Long user) </span>{\n        <span class="code-comment">//拦截/users/query请求,当/users/query?user=2时，可以获取query变量中的user=2</span>\n    }\n}</code></pre>\n<p>关于SpringMVC的详细说明请看<a\n        href="https://docs.spring.io/spring/docs/4.3.13.RELEASE/spring-framework-reference/htmlsingle/#spring-web"\n        rel="nofollow">Spring Framework MVC部分的文档说明</a>。</p>\n\n<h3 id="h3-22">SpingMVC的自动配置</h3>\n<p>上一篇文章已经介绍了Boot最大的特色就是为各种引入的包提供了相关配置以降低起步的门槛。Boot为SpringMVC添加了一下配置：</p>\n<ol>\n    <li>自动注入了ContentNegotiatingViewResolver和BeanNameViewResolver Bean。</li>\n    <li>支持静态资源，包括多WebJars的支持。</li>\n    <li>自动注册Converter、GenericConverter、Formatter Bean。</li>\n    <li>支持HttpMessageConverters。</li>\n    <li>提供了一个默认的index.html页面。</li>\n    <li>提供了一个 favicon图表，并支持配置。</li>\n    <li>自定使用&nbsp;ConfigurableWebBindingInitializer bean。</li>\n</ol>\n<p>接下来会介绍自动添加的这些功能到底做了什么事。</p>\n\n<h3 id="h3-23">HttpMessageConverters</h3>\n<p>Spring\n    MVC使用HttpMessageConverters接口来转换HTTP的requests请求和responses响应，Boot提供了一个便捷的HttpMessageConverters实现，Objects对象会自动转换为一个JSON（使用Jackson）或者XML（Jackson\n    XML），并且所有的字符串都会转换为UTF-8。</p>\n<p>如果需要自定义一个converters，可以使用Spring Boot的HttpMessageConverters类：</p>\n<pre><code class="java"><span class="code-keyword">import</span> org.springframework.boot.autoconfigure.web.HttpMessageConverters;\n<span class="code-keyword">import</span> org.springframework.context.annotation.*;\n<span class="code-keyword">import</span> org.springframework.http.converter.*;\n\n<span class="code-meta">@Configuration</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">MyConfiguration</span> </span>{\n    <span class="code-meta">@Bean</span>\n    <span class="hljs-function"><span class="code-keyword">public</span> HttpMessageConverters <span class="code-title">customConverters</span><span\n            class="hljs-params">()</span> </span>{\n        HttpMessageConverter&lt;?&gt; additional = ...\n        HttpMessageConverter&lt;?&gt; another = ...\n        <span class="code-keyword">return</span> <span class="code-keyword">new</span> HttpMessageConverters(additional, another);\n    }\n}</code></pre>\n<p>所有添加到容器中的HttpMessageConverter实现类都会添加到converters的处理列表上，当然也可以直接替换默认的HttpMessageConverter。</p>\n\n<h3 id="h3-24">自定义JSON序列化反序列化工具</h3>\n<p>\n    如果我们继续Jackson作为JSON的序列化、反序列化工具，我们可以为特殊的类编写我们自定义的JsonSerializer和JsonDeserializer过程。Boot提供了@JsonComponent注解来快速实现这个功能：</p>\n<pre><code class="java"><span class="code-meta">@JsonComponent</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Example</span> </span>{\n    <span class="code-keyword">public</span> <span class="code-keyword">static</span> <span class="hljs-class"><span\n            class="code-keyword">class</span> <span class="code-title">Serializer</span> <span class="code-keyword">extends</span> <span\n            class="code-title">JsonSerializer</span>&lt;<span class="code-title">SomeObject</span>&gt; </span>{\n        <span class="code-comment">// ...</span>\n    }\n    <span class="code-keyword">public</span> <span class="code-keyword">static</span> <span class="hljs-class"><span\n            class="code-keyword">class</span> <span class="code-title">Deserializer</span> <span class="code-keyword">extends</span> <span\n            class="code-title">JsonDeserializer</span>&lt;<span class="code-title">SomeObject</span>&gt; </span>{\n        <span class="code-comment">// ...</span>\n    }\n}</code></pre>\n<p>所有被@JsonComponent限定的Bean都会自动注册到Jackson中，根据范型的类型对指定的类进行序列化与反序列化操作。</p>'}});