webpackJsonp([12],{335:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<h2 id="h2-1">那些年困扰着我们的null</h2>\n<p>在Java江湖流传着这样一个传说：<strong>直到真正了解了空指针异常，才能算一名合格的Java开发人员</strong>。在我们逼格闪闪的java码字符生涯中，每天都会遇到各种null的处理，像下面这样的代码可能我们每天都在反复编写：\n</p>\n<pre><code class="java"><span class="code-keyword">if</span>(<span class="code-keyword">null</span> != obj1){\n  <span class="code-keyword">if</span>(<span class="code-keyword">null</span> != obje2){\n     <span class="code-comment">// do something</span>\n  }\n}</code></pre>\n<p>稍微有点眼界<em>javaer</em>就去干一些稍有逼格的事，弄一个判断<em>null</em>的方法：</p>\n<pre><code class="java"><span class="hljs-function"><span class="code-keyword">boolean</span> <span class="code-title">checkNotNull</span><span\n        class="hljs-params">(Object obj)</span></span>{\n  <span class="code-keyword">return</span> <span class="code-keyword">null</span> == obj ? <span class="code-keyword">false</span> : <span\n            class="code-keyword">true</span>;\n}\n\n<span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">do</span><span\n        class="hljs-params">()</span></span>{\n  <span class="code-keyword">if</span>(checkNotNull(obj1)){\n     <span class="code-keyword">if</span>(checkNotNull(obj2)){\n        <span class="code-comment">//do something</span>\n     }\n  }\n}</code></pre>\n<p>然后，问题又来了：如果一个null表示一个空字符串，那""表示什么？</p>\n<p>然后惯性思维告诉我们，""和null不都是空字符串码？索性就把判断空值升级了一下：</p>\n<pre><code class="java"><span class="hljs-function"><span class="code-keyword">boolean</span> <span class="code-title">checkNotBlank</span><span\n        class="hljs-params">(Object obj)</span></span>{\n  <span class="code-keyword">return</span> <span class="code-keyword">null</span> != obj &amp;&amp; !<span\n            class="code-string">""</span>.equals(obj) ? <span class="code-keyword">true</span> : <span\n            class="code-keyword">false</span>;\n}\n<span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">do</span><span\n        class="hljs-params">()</span></span>{\n  <span class="code-keyword">if</span>(checkNotBlank(obj1)){\n     <span class="code-keyword">if</span>(checkNotNull(obj2)){\n        <span class="code-comment">//do something</span>\n     }\n  }\n}</code></pre>\n<p>有空的话各位可以看看目前项目中或者自己过往的代码，到底写了多少和上面类似的代码。</p>\n<p><strong>不知道你是否认真思考过一个问题：一个null到底意味着什么？</strong></p>\n<ol>\n    <li>浅显的认识——null当然表示“值不存在”。</li>\n    <li>对内存管理有点经验的理解——null表示内存没有被分配，指针指向了一个空地址。</li>\n    <li>稍微透彻点的认识——null可能表示某个地方处理有问题了，也可能表示某个值不存在。</li>\n    <li>被虐千万次的认识——哎哟，又一个NullPointerException异常，看来我得加一个<em>if(null != value)</em>了。</li>\n</ol>\n<p>\n    回忆一下，在咱们前面码字生涯中到底遇到过多少次java.lang.NullPointerException异常？NullPointerException作为一个RuntimeException级别的异常不用显示捕获，若不小心处理我们经常会在生产日志中看到各种由NullPointerException引起的异常堆栈输出。而且根据这个异常堆栈信息我们根本无法定位到导致问题的原因，因为并不是抛出NullPointerException的地方引发了这个问题。我们得更深处去查询什么地方产生了这个null，而这个时候日志往往无法跟踪。</p>\n<p>有时更悲剧的是，产生null值的地方往往不在我们自己的项目代码中。这就存在一个更尴尬的事实——在我们调用各种良莠不齐第三方接口时，说不清某个接口在某种机缘巧合的情况下就会返回一个null……</p>\n<p>回到前面对null的认知问题。很多javaer认为null就是表示“什么都没有”或者“值不存在”。按照这个惯性思维我们的代码逻辑就是：<span style="color:#FF8C00">你调用我的接口，按照你给我的参数返回对应的“值”，如果这条件没法找到对应的“值”，那我当然返回一个null给你表示没有“任何东西”了</span>。我们看看下面这个代码，用很传统很标准的Java编码风格编写：\n</p>\n<pre><code class="java"><span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MyEntity</span></span>{\n   <span class="code-keyword">int</span> id;\n   String name;\n   <span class="hljs-function">String <span class="code-title">getName</span><span class="hljs-params">()</span></span>{\n      <span class="code-keyword">return</span> name;\n   }\n}\n\n<span class="code-comment">// main</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Test</span></span>{\n   <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n           class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span>\n       <span class="code-keyword">final</span> MyEntity myEntity </span>= getMyEntity(<span\n            class="code-keyword">false</span>);\n       System.out.println(myEntity.getName());\n   }\n\n   <span class="hljs-function"><span class="code-keyword">private</span> <span\n           class="code-title">getMyEntity</span><span class="hljs-params">(<span class="code-keyword">boolean</span> isSuc)</span></span>{\n       <span class="code-keyword">if</span>(isSuc){\n           <span class="code-keyword">return</span> <span class="code-keyword">new</span> MyEntity();\n       }<span class="code-keyword">else</span>{\n           <span class="code-keyword">return</span> <span class="code-keyword">null</span>;\n       }\n   }\n}</code></pre>\n<p>\n    这一段代码很简单，日常的业务代码肯定比这个复杂的多，但是实际上我们大量的Java编码都是按这种套路编写的，懂货的人一眼就可以看出最终肯定会抛出NullPointerException。但是在我们编写业务代码时，很少会想到要处理这个可能会出现的null（<span\n        style="color:#FF0000">也许API文档已经写得很清楚在某些情况下会返回null，但是你确保你会认真看完API文档后才开始写代码么？</span>），直到我们到了某个测试阶段，突然蹦出一个NullPointerException异常，我们才意识到原来我们得像下面这样加一个判断来搞定这个可能会返回的null值。\n</p>\n<pre><code class="java"><span class="code-comment">// main</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Test</span></span>{\n   <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n           class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span>\n       <span class="code-keyword">final</span> MyEntity myEntity </span>= getMyEntity(<span\n            class="code-keyword">false</span>);\n       <span class="code-keyword">if</span>(<span class="code-keyword">null</span> != myEntity){\n           System.out.println(myEntity.getName());\n       }<span class="code-keyword">else</span>{\n           System.out.println(<span class="code-string">"ERROR"</span>);\n       }\n   }\n}</code></pre>\n<p>仔细想想过去这么些年，咱们是不是都这样干过来的？如果直到测试阶段才能发现某些null导致的问题，那么现在问题就来了——在那些雍容繁杂、层次分明的业务代码中到底还有多少null没有被正确处理呢？</p>\n<p>对于null的处理态度，往往可以看出一个项目的成熟和严谨程度。比如Guava早在JDK1.6之前就给出了优雅的null处理方式，可见功底之深。</p>\n\n<h2 id="h2-2">鬼魅一般的null阻碍我们进步</h2>\n<p>如果你是一位聚焦于传统面向对象开发的Javaer，或许你已经习惯了null带来的种种问题。但是早在许多年前，大神就说了null这玩意就是个坑。</p>\n<p>托尼.霍尔（你不知道这货是谁吗？自己去查查吧）曾经说过：“I call it my billion-dollar mistake. It was the invention of the null reference in 1965.\n    I couldn\'t resist the temptation to put in a null reference, simply because it was so easy to\n    implement.”（大意是：“哥将发明null这事称为价值连城的错误。因为在1965那个计算机的蛮荒时代，空引用太容易实现，让哥根本经不住诱惑发明了空指针这玩意。”）。</p>\n<p>然后，我们再看看null还会引入什么问题。</p>\n<p>看看下面这个代码：</p>\n<pre><code class="java">String address = person.getCountry().getProvince().getCity();</code></pre>\n<p>如果你玩过一些函数式语言（Haskell、Erlang、Clojure、Scala等等），上面这样是一种很自然的写法。用Java当然也可以实现上面这样的编写方式。</p>\n<p>但是为了完满的处理所有可能出现的null异常，我们不得不把这种优雅的函数编程范式改为这样：</p>\n<pre><code class="java"><span class="code-keyword">if</span> (person != <span class="code-keyword">null</span>) {\n\tCountry country = person.getCountry();\n\t<span class="code-keyword">if</span> (country != <span class="code-keyword">null</span>) {\n\t\tProvince province = country.getProvince();\n\t\t<span class="code-keyword">if</span> (province != <span class="code-keyword">null</span>) {\n\t\t\taddress = province.getCity();\n\t\t}\n\t}\n}</code></pre>\n<p>瞬间，高逼格的函数式编程Java8又回到了10年前。这样一层一层的嵌套判断，增加代码量和不优雅还是小事。更可能出现的情况是：在大部分时间里，人们会忘记去判断这可能会出现的null，即使是写了多年代码的老人家也不例外。</p>\n<p>上面这一段层层嵌套的 null 处理，也是传统Java长期被诟病的地方。如果以Java早期版本作为你的启蒙语言，这种get-&gt;if null-&gt;return\n    的臭毛病会影响你很长的时间（记得在某国外社区，这被称为：面向entity开发）。</p>\n\n<h2 id="h2-3">利用Optional实现Java函数式编程</h2>\n<p>好了，说了各种各样的毛病，然后我们可以进入新时代了。</p>\n<p>早在推出Java SE 8版本之前，其他类似的函数式开发语言早就有自己的各种解决方案。下面是Groovy的代码：</p>\n<pre><code class="groovy javascript"><span class="code-built_in">String</span> version = computer?.getSoundcard()?.getUSB()?.getVersion()：<span\n        class="code-string">"unkonwn"</span>;</code></pre>\n<p>Haskell用一个&nbsp;Maybe 类型类标识处理null值。而号称多范式开发语言的Scala则提供了一个和Maybe差不多意思的Option[T]，用来包裹处理null。</p>\n<p>Java8引入了&nbsp;java.util.Optional&lt;T&gt;来处理函数式编程的null问题，Optional&lt;T&gt;的处理思路和Haskell、Scala类似，但又有些许区别。先看看下面这个Java代码的例子：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">Test</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\t<span class="code-keyword">final</span> String text = <span class="code-string">"Hallo world!"</span>;\n\t\tOptional.ofNullable(text)<span class="code-comment">//显示创建一个Optional壳</span>\n\t\t    .map(Test::print)\n\t\t\t.map(Test::print)\n\t\t\t.ifPresent(System.out::println);\n\n\t\tOptional.ofNullable(text)\n\t\t\t.map(s -&gt;{ \n\t\t\t\tSystem.out.println(s);\n\t\t\t\t<span class="code-keyword">return</span> s.substring(<span class="hljs-number">6</span>);\n\t\t\t})\n\t\t\t.map(s -&gt; <span class="code-keyword">null</span>)<span class="code-comment">//返回 null</span>\n\t\t\t.ifPresent(System.out::println);\n\t}\n\t<span class="code-comment">// 打印并截取str[5]之后的字符串</span>\n\t<span class="hljs-function"><span class="code-keyword">private</span> <span class="code-keyword">static</span> String <span\n            class="code-title">print</span><span class="hljs-params">(String str)</span> </span>{\n\t\tSystem.out.println(str);\n\t\t<span class="code-keyword">return</span> str.substring(<span class="hljs-number">6</span>);\n\t}\n}\n<span class="code-comment">//Consol 输出</span>\n<span class="code-comment">//num1:Hallo world!</span>\n<span class="code-comment">//num2:world!</span>\n<span class="code-comment">//num3:</span>\n<span class="code-comment">//num4:Hallo world!</span></code></pre>\n<p><span style="color:#FFA500"><em> （可以把上面的代码copy到你的IDE中运行，前提是必须安装了JDK8。）</em></span></p>\n<p>上面的代码中创建了2个<em>Optional</em>，实现的功能基本相同，都是使用<em>Optional</em>作为<em>String</em>的外壳对<em>String</em>进行截断处理。当在处理过程中遇到null值时，就不再继续处理。我们可以发现第二个<em>Optional</em>中出现<em>s-&gt;null</em>之后，后续的ifPresent不再执行。\n</p>\n<p>注意观察输出的&nbsp;//num3:，这表示输出了一个""字符，而不是一个null。</p>\n<p><em>Optional</em>提供了丰富的接口来处理各种情况，比如可以将代码修改为：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">Test</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\t<span class="code-keyword">final</span> String text = <span class="code-string">"Hallo World!"</span>;\n\t\tSystem.out.println(lowerCase(text));<span class="code-comment">//方法一</span>\n\t\tlowerCase(<span class="code-keyword">null</span>, System.out::println);<span class="code-comment">//方法二</span>\n\t}\n\n\t<span class="hljs-function"><span class="code-keyword">private</span> <span class="code-keyword">static</span> String <span\n            class="code-title">lowerCase</span><span class="hljs-params">(String str)</span> </span>{\n\t\t<span class="code-keyword">return</span> Optional.ofNullable(str).map(s -&gt; s.toLowerCase()).map(s-&gt;s.replace(<span\n            class="code-string">"world"</span>, <span class="code-string">"java"</span>)).orElse(<span\n            class="code-string">"NaN"</span>);\n\t}\n\n\t<span class="hljs-function"><span class="code-keyword">private</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">lowerCase</span><span class="hljs-params">(String str, Consumer&lt;String&gt; consumer)</span> </span>{\n\t\tconsumer.accept(lowerCase(str));\n\t}\n}\n<span class="code-comment">//输出</span>\n<span class="code-comment">//hallo java!</span>\n<span class="code-comment">//NaN</span></code></pre>\n<p>这样，我们可以动态的处理一个字符串，如果在任何时候发现值为<em>null</em>，则使用<em>orElse</em>返回预设默认的<em>"NaN"</em>。</p>\n<p>总的来说，我们可以将任何数据结构用<em>Optional</em>包裹起来，然后使用函数式的方式对他进行处理，而不必关心随时可能会出现的<em>null</em>。</p>\n<p>我们看看前面提到的<em>Person.getCountry().getProvince().getCity()</em>怎么不用一堆if来处理。</p>\n<p><strong>第一种方法是不改变以前的entity：</strong></p>\n<pre><code class="java"><span class="code-keyword">import</span> java.util.Optional;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Test</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tSystem.out.println(Optional.ofNullable(<span class="code-keyword">new</span> Person())\n\t\t\t.map(x-&gt;x.country)\n\t\t\t.map(x-&gt;x.provinec)\n\t\t\t.map(x-&gt;x.city)\n\t\t\t.map(x-&gt;x.name)\n\t\t\t.orElse(<span class="code-string">"unkonwn"</span>));\n\t}\n}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">Person</span> </span>{\n\tCountry country;\n}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">Country</span> </span>{\n\tProvince provinec;\n}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">Province</span> </span>{\n\tCity city;\n}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">City</span> </span>{\n\tString name;\n}</code></pre>\n<p>这里用<em>Optional</em>作为每一次返回的外壳，如果有某个位置返回了null，则会直接得到"unkonwn"。</p>\n<p><strong>第二种办法是将所有的值都用Optional来定义：</strong></p>\n<pre><code class="java"><span class="code-keyword">import</span> java.util.Optional;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Test</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tSystem.out.println(<span class="code-keyword">new</span> Person()\n\t\t\t\t.country.flatMap(x -&gt; x.provinec)\n\t\t\t\t.flatMap(Province::getCity)\n\t\t\t\t.flatMap(x -&gt; x.name)\n\t\t\t\t.orElse(<span class="code-string">"unkonwn"</span>));\n\t}\n}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">Person</span> </span>{\n\tOptional&lt;Country&gt; country = Optional.empty();\n}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">Country</span> </span>{\n\tOptional&lt;Province&gt; provinec;\n}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">Province</span> </span>{\n\tOptional&lt;City&gt; city;\n\t<span class="hljs-function">Optional&lt;City&gt; <span class="code-title">getCity</span><span\n            class="hljs-params">()</span></span>{<span class="code-comment">//用于::</span>\n\t\t<span class="code-keyword">return</span> city;\n\t}\n}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">City</span> </span>{\n\tOptional&lt;String&gt; name;\n}</code></pre>\n<p>第一种方法可以平滑的和已有的JavaBean、<em>Entity</em>或<em>POJA</em>整合，而无需改动什么，也能更轻松的整合到第三方接口中（例如<em>spring</em>的<em>bean</em>）。建议目前还是以第一种<em>Optional</em>的使用方法为主，毕竟不是团队中每一个人都能理解每个<em>get/set</em>带着一个<em>Optional</em>的用意。\n</p>\n<p><em>Optional</em>还提供了一个<em>filter</em>方法用于过滤数据（实际上<em>Java8</em>里<em>stream</em>风格的接口都提供了<em>filter</em>方法）。例如过去我们判断值存在并作出相应的处理：\n</p>\n<pre><code class="java"><span class="code-keyword">if</span>(Province!= <span class="code-keyword">null</span>){\n  City city = Province.getCity();\n  <span class="code-keyword">if</span>(<span class="code-keyword">null</span> != city &amp;&amp; <span\n            class="code-string">"guangzhou"</span>.equals(city.getName()){\n    System.out.println(city.getName());\n  }<span class="code-keyword">else</span>{\n    System.out.println(<span class="code-string">"unkonwn"</span>);\n  }\n}</code></pre>\n<p><strong>&nbsp; &nbsp; </strong>现在我们可以修改为</p>\n<pre><code class="java">Optional.ofNullable(province)\n   .map(x-&gt;x.city)\n   .filter(x-&gt;<span class="code-string">"guangzhou"</span>.equals(x.getName()))\n   .map(x-&gt;x.name)\n   .orElse(<span class="code-string">"unkonw"</span>);</code></pre>\n<p>\n    到此，利用<em>Optional</em>来进行函数式编程介绍完毕。<em>Optional</em>除了上面提到的方法，还有<em>orElseGet</em>、<em>orElseThrow</em>等根据更多需要提供的方法。<em>orElseGet</em>会因为出现null值抛出空指针异常，而<em>orElseThrow</em>会在出现<em>null</em>时，抛出一个使用者自定义的异常。可以查看<em>API</em>文档来了解所有方法的细节。\n</p>\n\n<h2 id="h2-4">写在最后的</h2>\n<p>\n    <em>Optional</em>只是<em>Java</em>函数式编程的冰山一角，需要结合<em>lambda</em>、<em>stream</em>、<em>Funcationinterface</em>等特性才能真正的了解<em>Java8</em>函数式编程的效用。本来还想介绍一些<em>Optional</em>的源码和运行原理的，但是<em>Optional</em>本身的代码就很少、API接口也不多，仔细想想也没什么好说的就省略了。\n</p>\n<p><em>Optional</em>虽然优雅，但是个人感觉有一些效率问题，不过还没去验证。如果有谁有确实的数据，请告诉我。</p>\n<p>本人也不是“函数式编程支持者”。从团队管理者的角度来说，每提升一点学习难度，人员的使用成本和团队交互成本就会更高一些。就像在传说中<em>Lisp</em>可以比<em>C++</em>的代码量少三十倍、开发更高效，但是若一个国内的常规IT公司真用<em>Lisp</em>来做项目，请问去哪、得花多少钱弄到这些用<em>Lisp</em>的哥们啊？\n</p>\n<p>\n    但是我非常鼓励大家都学习和了解函数式编程的思路。尤其是过去只侵淫在<em>Java</em>这一门语言、到现在还不清楚<em>Java8</em>会带来什么改变的开发人员，<em>Java8</em>是一个良好的契机。更鼓励把新的<em>Java8</em>特性引入到目前的项目中，一个长期配合的团队以及一门古老的编程语言都需要不断的注入新活力，否则不进则退。\n</p>'},381:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<p><em>ApplicationContext</em>是一个<em>Context</em>策略（见<a\n        href="https://www.chkui.com/article/spring/spring_core_context_and_ioc"\n        title="上下文与IoC">上下文与IoC</a>），他除了提供最基础的<em>IoC</em>容器功能，还提供了<a\n        href="https://www.chkui.com/article/spring/spring_core_internationalization_with_messagesource" title="MessageSource实现的国际化">MessageSource实现的国际化</a>、全局事件、资源层级管理等等功能。本文将详细介绍Spring核心模块的事件管理机制。\n</p>\n<p><em>Spring</em>核心模块的事件机制和常规意义上的“事件”并没有太大区别（例如浏览器上的用户操作事件）都是通过订阅/发布模式实现的。</p>\n<p><em>Spring</em>事件管理的内容包括标准事件、自定义事件、注解标记处理器、异步事件处理、通用实体包装。下面将通过几个例子来说明这些内容，可执行代码请到本人的<a\n        href="https://gitee.com/chkui-com/spring-core-sample" rel="nofollow">gitee库下载</a>，本文的内容在包<em>chkui.springcore.example.javabase.event</em>中。\n</p>\n<p>我们都知道在订阅/发布模式中至少要涉及三个部分——发布者（<em>publisher</em>）、订阅者（<em>listener/subscriber</em>）和事件（<em>event</em>）。针对这个模型Spring也提供了对应的两个接口——<em>ApplicationEventPublisher、ApplicationListener</em>以及一个抽象类<em>ApplicationEvent</em>。基本上，要使用<em>Spring</em>事件的功能，只要<em>实现/继承</em>这这三个<em>接口/抽象类</em>并按照Spring定好的规则来使用即可。掌握这个原则那么接下来的内容就好理解了。\n</p>\n\n<h2 id="h2-1">标准事件</h2>\n<p><em>Spring</em>为一些比较常规的事件制定了标准的事件类型和固定的发布方法，我们只需要定制好订阅者（<em>listener/subscriber</em>）就可以监听这些事件。</p>\n<p>先指定2个订阅者：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.event.standard;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">ContextStartedListener</span> <span class="code-keyword">implements</span> <span\n            class="code-title">ApplicationListener</span>&lt;<span\n            class="code-title">ContextStartedEvent</span>&gt; </span>{\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">onApplicationEvent</span><span\n            class="hljs-params">(ContextStartedEvent event)</span> </span>{\n\t\tSystem.out.println(<span class="code-string">"Start Listener: I am start"</span>);\n\t}\n}</code></pre>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.event.standard;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">ContextStopListener</span> <span class="code-keyword">implements</span> <span\n            class="code-title">ApplicationListener</span>&lt;<span\n            class="code-title">ContextStoppedEvent</span>&gt; </span>{\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">onApplicationEvent</span><span\n            class="hljs-params">(ContextStoppedEvent event)</span> </span>{\n\t\tSystem.out.println(<span class="code-string">"Stop Listener: I am stop"</span>);\n\t}\n}</code></pre>\n<p>然后运行使用他们：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.event;\n<span class="code-meta">@Configuration</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">EventApp</span> </span>{\n\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function">ContextStopListener <span class="code-title">contextStopListener</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> ContextStopListener();\n\t}\n\t\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function">ContextStartedListener <span class="code-title">contextStartedListener</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> ContextStartedListener();\n\t}\n\t\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tConfigurableApplicationContext context = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(EventApp.class);\n\t\t<span class="code-comment">//发布start事件</span>\n\t\tcontext.start();\n\t\t<span class="code-comment">//发布stop事件</span>\n\t\tcontext.stop();\n        <span class="code-comment">//关闭容器</span>\n\t\tcontext.close();\n\t}\n}</code></pre>\n<p>在例子代码中，<em>ContextStartedListener</em>和<em>ContextStopListener</em>类都实现了ApplicationListener接口，然后通过<em>onApplicationEvent</em>的方法参数来指定监听的事件类型。在<em>ConfigurableApplicationContext</em>接口中已经为“start”和“stop”事件提供对应的发布方法。除了<em>StartedEvent</em>和<em>StoppedEvent</em>，<em>Spring</em>还为其他几项操作提供了标准事件：\n</p>\n<ol>\n    <li>\n        ContextRefreshedEvent：ConfigurableApplicationContext::refresh方法被调用后触发。事件发出的时机是所有的后置处理器已经执行、所有的Bean已经被加载、所有的ApplicationContext接口方法都可以提供服务。\n    </li>\n    <li>ContextStartedEvent：ConfigurableApplicationContext::start方法被调用后触发。</li>\n    <li>ContextStoppedEvent：ConfigurableApplicationContext::stop方法被调用后触发。</li>\n    <li>ContextClosedEvent：ConfigurableApplicationContext::close方法被调用后触发。</li>\n    <li>RequestHandledEvent：这是一个用于Web容器的事件（例如启用了DispatcherServlet），当接收到前端请求时触发。</li>\n</ol>\n\n<h2 id="h2-2">自定义事件</h2>\n<p>除了使用标准事件，我们还可以定义各种各样的事件。实现前面提到的三个接口/抽象类即可。</p>\n<p>继承<em>ApplicationEvent</em>实现自定义事件：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.event.custom;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">MyEvent</span> <span class="code-keyword">extends</span> <span class="code-title">ApplicationEvent</span> </span>{\n\n\t<span class="code-keyword">private</span> String value = <span class="code-string">"This is my event!"</span>;\n\t\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-title">MyEvent</span><span\n            class="hljs-params">(Object source,String value)</span> </span>{\n\t\t<span class="code-keyword">super</span>(source);\n\t\t<span class="code-keyword">this</span>.value = value;\n\t}\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">getValue</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> value;\n\t}\n}</code></pre>\n<p>定义事件对应的<em>Listener</em>:</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.event.custom;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">MyEventListener</span> <span class="code-keyword">implements</span> <span\n            class="code-title">ApplicationListener</span>&lt;<span class="code-title">MyEvent</span>&gt; </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">onApplicationEvent</span><span class="hljs-params">(MyEvent event)</span> </span>{\n\t\tSystem.out.println(<span class="code-string">"MyEventListener :"</span> + event.getValue());\n\t}\n}</code></pre>\n<p>然后通过<em>ApplicationEventPublisher</em>接口发布事件：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.event.custom;\n<span class="code-meta">@Service</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">MyEventService</span> <span class="code-keyword">implements</span> <span\n            class="code-title">ApplicationEventPublisherAware</span> </span>{\n\t<span class="code-keyword">private</span> ApplicationEventPublisher publisher;\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setApplicationEventPublisher</span><span class="hljs-params">(ApplicationEventPublisher applicationEventPublisher)</span> </span>{\n\t\tpublisher = applicationEventPublisher;\n\t}\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">publish</span><span class="hljs-params">(String value)</span> </span>{\n\t\tpublisher.publishEvent(<span class="code-keyword">new</span> MyEvent(<span class="code-keyword">this</span>, value));\n\t}\n}</code></pre>\n\n<h2 id="h2-3">使用@EventListener实现订阅者</h2>\n<p>在<em>Spring Framework4.2</em>之后可以直接使用<em>@EventListener</em>注解来指定事件的处理器，我们将上面的<em>MyEventListener</em>类进行简单的修改：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.event.custom;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">MyEventListenerAnnotation</span></span>{\n\t<span class="code-meta">@EventListener</span>\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">handleMyEvent</span><span class="hljs-params">(MyEvent event)</span> </span>{\n\t\tSystem.out.println(<span class="code-string">"MyEventListenerAnnotation :"</span> + event.getValue());\n    }\n}</code></pre>\n<p>使用<em>@EventListener</em>可以不必实现<em>ApplicationListener</em>，只要添加为一个<em>Bean</em>即可。<em>Spring</em>会根据方法的参数类型订阅对应的事件。\n</p>\n<p>我们也可以使用注解指定绑定的事件：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.event.custom;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">MyEventListenerAnnotation</span></span>{\n\t<span class="code-meta">@EventListener</span>(ContextStartedEvent.class})\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">handleMyEvent</span><span class="hljs-params">()</span> </span>{\n        <span class="code-comment">//----</span>\n    }\n}</code></pre>\n<p>还可以指定一次性监听多个事件：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.event.standard;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">MultiEventListener</span> </span>{\n\t<span class="code-meta">@EventListener</span>({ContextStartedEvent.class, ContextStoppedEvent.class})\n    <span class="code-meta">@Order</span>(<span class="hljs-number">2</span>)\n\t<span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">contenxtStandadrEventHandle</span><span\n            class="hljs-params">(ApplicationContextEvent event)</span> </span>{\n\t\tSystem.out.println(<span class="code-string">"MultiEventListener:"</span> + event.getClass().getSimpleName());\n\t}\n}</code></pre>\n<p>注意上面代码中的<em>@Order</em>注解，同一个事件可以被多个订阅者订阅。在多个定于者存在的情况下可以使用<em>@Order</em>注解来指定他们的执行顺序，数值越小越优先执行。\n</p>\n\n<h2 id="h2-4">EL表达式设定事件监听的条件</h2>\n<p>通过注解还可以使用<em>Spring</em>的<em>EL</em>表达式来更细粒度的控制监听的范围，比如下面的例子仅仅当事件的实例中MyEvent.value == "Second publish!"才触发处理器：</p>\n<p>事件：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.event.custom;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">MyEvent</span> <span class="code-keyword">extends</span> <span class="code-title">ApplicationEvent</span> </span>{\n\t<span class="code-keyword">private</span> String value = <span class="code-string">"This is my event!"</span>;\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-title">MyEvent</span><span\n            class="hljs-params">(Object source,String value)</span> </span>{\n\t\t<span class="code-keyword">super</span>(source);\n\t\t<span class="code-keyword">this</span>.value = value;\n\t}\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">getValue</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> value;\n\t}\n}</code></pre>\n<p>通过EL表达式指定监听的数据：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.event.custom;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">MyEventListenerElSp</span> </span>{\n\t<span class="code-meta">@EventListener</span>(condition=<span\n            class="code-string">"#p0.value == \'Second publish!\'"</span>)\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">handleMyEvent</span><span class="hljs-params">(MyEvent event)</span> </span>{\n\t\tSystem.out.println(<span class="code-string">"MyEventListenerElSp :"</span> + event.getValue());\n    }\n}</code></pre>\n<p>这样，当这个事件被发布，而且其中的成员变量value值等于"Second\n    publish!"，对应的MyEventListenerElSp::handleMyEvent方法才会被触发。EL表达式还可以使用通配符等等丰富的表现形式来设定过滤规则，后续介绍EL表达式时会详细说明。</p>\n\n<h2 id="h2-5">通用包装事件</h2>\n<p>Spring还提供一个方式使用事件来包装实体类，起到传递数据但是不用重复定义多个事件的作用。看下面的例子。</p>\n<p>我们先定义2个实体类：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.event.generics;\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">PES</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">toString</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"PRO EVOLUTION SOCCER"</span>;\n\t}\n}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">WOW</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">toString</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"World Of Warcraft"</span>;\n\t}\n}</code></pre>\n<p>定义可以用于包装任何实体的事件，需要实现ResolvableTypeProvider接口：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.event.generics;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">EntityWrapperEvent</span>&lt;<span class="code-title">T</span>&gt; <span\n            class="code-keyword">extends</span> <span class="code-title">ApplicationEvent</span> <span\n            class="code-keyword">implements</span> <span class="code-title">ResolvableTypeProvider</span> </span>{\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span\n            class="code-title">EntityWrapperEvent</span><span class="hljs-params">(T entity)</span> </span>{\n\t\t<span class="code-keyword">super</span>(entity);\n\t}\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> ResolvableType <span class="code-title">getResolvableType</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> ResolvableType.forClassWithGenerics(getClass(),\n                ResolvableType.forInstance(getSource()));\n\t}\n\n}</code></pre>\n<p>订阅者可以根据被包裹的entity的不同来监听不同的事件：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.event.generics;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">EntiryWrapperEventListener</span> </span>{\n\t<span class="code-meta">@EventListener</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">handlePES</span><span\n            class="hljs-params">(EntityWrapperEvent&lt;PES&gt; evnet)</span> </span>{\n\t\tSystem.out.println(<span class="code-string">"EntiryWrapper PES: "</span> +  evnet);\n\t}\n\t<span class="code-meta">@EventListener</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">handleWOW</span><span\n            class="hljs-params">(EntityWrapperEvent&lt;WOW&gt; evnet)</span> </span>{\n\t\tSystem.out.println(<span class="code-string">"EntiryWrapper WOW: "</span> +  evnet);\n\t}\n}</code></pre>\n<p>\n    上面的代码起到最用的主要是ResolvableType.forInstance(getSource())这一行代码，getSource()方法来自于EventObject类，它实际上就是返回构造方法中super(entity)设定的entity实例。</p>\n\n<h2 id="h2-6">写在最后的</h2>\n<p>\n    订阅/发布模式是几乎所有软件程序都会触及的问题，无论是浏览器前端、还是古老的winMFC程序。而在后端应用中，对于使用过MQ工具或者Vertx这种纯事件轮询驱动的框架码友，应该已经请清楚这种<strong>订阅/发布+事件驱动</strong>的价值。它除了能够降低各层的耦合度，还能更有效的利用多线程而大大的提执行效率（当然对开发人员的要求也会高不少）。\n</p>\n<p>\n    对于Spring核心框架来说，事件的订阅/发布只是IoC容器的一个附属功能，Spring的核心价值并不在这个地方。Spring的订阅发布功能在实现层面至少现在并没有使用EventLoop的方式，还是类与类之间的直接调用，所以在性能上是完全无法向Vertx看齐的。不过Spring事件的机制还是能够起到事件驱动的效果，可以用来全局控制一些状态。如果选用Spring生态中的框架（boot等）作为我们的底层框架，现阶段还是应该使用IoC的方式来组合功能，而事件的订阅/发布仅仅用于辅助。</p>'},403:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<p>最近项目中需要针对Vert.x的运行效率进行监控，查阅Vert.x官文，发现目前提供了Dropwizard和Hawkular两种开箱即用的工具。本文将介绍使用Dropwizard\n    Metrics实现Vert.x性能统计的过程（当然还有踩过的坑）。</p>\n<p>首先简要说说dropwizard&nbsp;metrics。</p>\n<h2 id="h2-1">Dropwizard Metrics</h2>\n<p>按照官网的说法：Metrics是一个Java库，这个库可以让我们有无可比拟的能力去了解编码是如何在生产环境运行的。Metrics提供了强大的工具来测量关键组件在生产环境的运行行为。</p>\n<p>如果仅仅使用Metrics的功能，其实并没有什么复杂，也就是嵌入一些类去使用。把他理解log4j就很容易了。</p>\n<p>在运行之前，通过Maven引入依赖关系：</p>\n<blockquote>\n    <p><br> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&lt;dependency&gt;<br> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;\n        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&lt;groupId&gt;io.dropwizard.metrics&lt;/groupId&gt;<br> &nbsp;&nbsp;\n        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&lt;artifactId&gt;metrics-core&lt;/artifactId&gt;<br>\n        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&lt;version&gt;${metrics.version}&lt;/version&gt;<br>\n        &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&lt;/dependency&gt;</p>\n</blockquote>\n<p><em>metrics.version&nbsp;</em>使用最新的版本号。</p>\n<p>下面的例子简要说明了如何使用metric。例子中先是包装了一个具有监控功能的队列，在调用add和remove方法时更新指标数据。</p>\n<pre class="cpp"><code class="cpp"><span class="code-comment"><span class="code-comment">//声明一个自带指标功能的队列</span></span>\n<span class="code-keyword"><span class="code-keyword">class</span></span> QueueWarp {\n\t<span class="code-comment"><span class="code-comment">// 真实队列</span></span>\n    <span class="code-keyword"><span class="code-keyword">private</span></span> final Queue&lt;Object&gt; <span\n            class="code-built_in"><span class="code-built_in">queue</span></span>;\n    <span class="code-comment"><span class="code-comment">// 计数器指标</span></span>\n    <span class="code-keyword"><span class="code-keyword">private</span></span> Counter counter;\n    <span class="code-comment"><span class="code-comment">// 柱状图指标</span></span>\n    <span class="code-keyword"><span class="code-keyword">private</span></span> Histogram size_rate;\n    <span class="code-comment"><span class="code-comment">// 计时器指标</span></span>\n    <span class="code-keyword"><span class="code-keyword">private</span></span> Timer optTimer;\n    <span class="code-comment"><span class="code-comment">// 构造函数</span></span>\n    <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">public</span></span></span><span class="hljs-function"> </span><span\n            class="code-title"><span class="hljs-function"><span class="code-title">QueueWarp</span></span></span><span\n            class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MetricRegistry metrics, String name)</span></span></span><span\n            class="hljs-function"> </span></span>{\n        <span class="code-keyword"><span class="code-keyword">this</span></span>.<span class="code-built_in"><span\n            class="code-built_in">queue</span></span> = <span class="code-keyword"><span class="code-keyword">new</span></span> LinkedList&lt;Object&gt;();\n\n        <span class="code-comment"><span class="code-comment">//注册一个测量值对象</span></span>\n        metrics.<span class="code-keyword"><span class="code-keyword">register</span></span>(MetricRegistry.name(QueueWarp.<span\n            class="code-keyword"><span class="code-keyword">class</span></span>, name, <span class="code-string"><span\n            class="code-string">"size"</span></span>),\n                         <span class="code-keyword"><span class="code-keyword">new</span></span> Gauge&lt;Integer&gt;() {\n                             @Override\n                             <span class="code-comment"><span class="code-comment">//每次发起统计时获取数据的接口</span></span>\n                             <span class="code-keyword"><span class="code-keyword">public</span></span> Integer getValue() {\n                                 <span class="code-keyword"><span class="code-keyword">return</span></span> <span\n            class="code-built_in"><span class="code-built_in">queue</span></span>.size();\n                             }\n                         });\n        <span class="code-comment"><span class="code-comment">// 注册计数器</span></span>\n        counter = metrics.<span class="code-keyword"><span class="code-keyword">register</span></span>(MetricRegistry.name(QueueWarp.<span\n            class="code-keyword"><span class="code-keyword">class</span></span>, name, <span class="code-string"><span\n            class="code-string">"count"</span></span>), <span class="code-keyword"><span class="code-keyword">new</span></span> Counter());\n        <span class="code-comment"><span class="code-comment">// 注册柱状图</span></span>\n        size_rate = metrics.histogram(MetricRegistry.name(QueueWarp.<span class="code-keyword"><span\n            class="code-keyword">class</span></span>, <span class="code-string"><span\n            class="code-string">"size-rate"</span></span>));\n        <span class="code-comment"><span class="code-comment">// 注册计时器</span></span>\n        optTimer = metrics.timer(MetricRegistry.name(QueueWarp.<span class="code-keyword"><span class="code-keyword">class</span></span>, <span\n            class="code-string"><span class="code-string">"opt-timer"</span></span>));\n    }\n    <span class="code-comment"><span class="code-comment">//增加</span></span>\n    <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">public</span></span></span><span class="hljs-function"> boolean </span><span\n            class="code-title"><span class="hljs-function"><span class="code-title">add</span></span></span><span\n            class="hljs-params"><span class="hljs-function"><span\n            class="hljs-params">(Object e)</span></span></span></span>{\n    \tfinal Timer.Context timerContext = optTimer.time();<span class="code-comment"><span\n            class="code-comment">//开始计时</span></span>\n    \tcounter.inc();<span class="code-comment"><span class="code-comment">//计数器+1</span></span>\n    \tsize_rate.update(<span class="code-built_in"><span class="code-built_in">queue</span></span>.size());<span\n            class="code-comment"><span class="code-comment">//柱状图更新</span></span>\n    \tboolean ret = <span class="code-keyword"><span class="code-keyword">this</span></span>.<span\n            class="code-built_in"><span class="code-built_in">queue</span></span>.add(e);<span\n            class="code-comment"><span class="code-comment">//添加数据到队列</span></span>\n    \ttimerContext.stop();<span class="code-comment"><span class="code-comment">//停止计时</span></span>\n        <span class="code-keyword"><span class="code-keyword">return</span></span> ret;\n    }\n    <span class="code-comment"><span class="code-comment">// 删除</span></span>\n    <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">public</span></span></span><span class="hljs-function"> Object </span><span\n            class="code-title"><span class="hljs-function"><span class="code-title">remove</span></span></span><span\n            class="hljs-params"><span class="hljs-function"><span\n            class="hljs-params">(Object e)</span></span></span></span>{\n    \tfinal Timer.Context timerContext = optTimer.time();\n    \tcounter.dec();\n    \tsize_rate.update(<span class="code-built_in"><span class="code-built_in">queue</span></span>.size());\n    \tObject ret = <span class="code-keyword"><span class="code-keyword">this</span></span>.<span\n            class="code-built_in"><span class="code-built_in">queue</span></span>.remove();\n    \ttimerContext.stop();\n        <span class="code-keyword"><span class="code-keyword">return</span></span> ret;\n    }\n}</code></pre>\n<p>在上面的代码中，当调用add、remove方法时，会记录：</p>\n<ol>\n    <li>方法从调用到返回的时间间隔。</li>\n    <li>更新队列中的数据规模。（Counter和Gauge都记录了规模）</li>\n    <li>更新当前队列成员个数和最大值的比率。</li>\n</ol>\n<p>然后使用一个main方法来测试这个类并输出指标数据：</p>\n<pre class="cpp"><code class="cpp"><span class="code-keyword"><span class="code-keyword">public</span></span> <span\n        class="code-keyword"><span class="code-keyword">class</span></span> MetricDemoRun {\n\t<span class="code-comment"><span class="code-comment">// 注册指标实例</span></span>\n\t<span class="code-keyword"><span class="code-keyword">static</span></span> final MetricRegistry metrics = <span\n            class="code-keyword"><span class="code-keyword">new</span></span> MetricRegistry();\n\t<span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">public</span></span></span><span class="hljs-function"> </span><span\n            class="code-keyword"><span class="hljs-function"><span class="code-keyword">static</span></span></span><span\n            class="hljs-function"> </span><span class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">void</span></span></span><span class="hljs-function"> </span><span\n            class="code-title"><span class="hljs-function"><span class="code-title">main</span></span></span><span\n            class="hljs-params"><span class="hljs-function"><span\n            class="hljs-params">(String args[])</span></span></span><span class="hljs-function"> </span></span>{\n\t\t<span class="code-comment"><span class="code-comment">//新建队列</span></span>\n\t\tQueueWarp <span class="code-built_in"><span class="code-built_in">queue</span></span> = <span\n            class="code-keyword"><span class="code-keyword">new</span></span> QueueWarp(metrics, <span\n            class="code-string"><span class="code-string">"jobss"</span></span>);\n\t\t<span class="code-built_in"><span class="code-built_in">queue</span></span>.add(<span class="code-string"><span\n            class="code-string">"1"</span></span>);\n\t\t<span class="code-comment"><span class="code-comment">// 启动指标数据输出</span></span>\n\t\tstartReport();\n\t\t<span class="code-keyword"><span class="code-keyword">try</span></span> {\n\t\t\tThread.sleep(<span class="hljs-number"><span class="hljs-number">5</span></span> * <span\n            class="hljs-number"><span class="hljs-number">1000</span></span>);\n\t\t} <span class="code-keyword"><span class="code-keyword">catch</span></span> (InterruptedException e) {\n\t\t}\n\t\t<span class="code-built_in"><span class="code-built_in">queue</span></span>.add(<span class="code-string"><span\n            class="code-string">"2"</span></span>);\n\t\tMeter requests = metrics.meter(<span class="code-string"><span class="code-string">"requests"</span></span>);\n\t\trequests.mark();\n\t\twait5Seconds();\n\t}\n\n\t<span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">static</span></span></span><span class="hljs-function"> </span><span\n            class="code-keyword"><span class="hljs-function"><span class="code-keyword">void</span></span></span><span\n            class="hljs-function"> </span><span class="code-title"><span class="hljs-function"><span class="code-title">startReport</span></span></span><span\n            class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span\n            class="hljs-function"> </span></span>{\n\t\t<span class="code-comment"><span class="code-comment">//注册报告对象</span></span>\n\t\tConsoleReporter reporter = ConsoleReporter.forRegistry(metrics).\n\t\t\t\tconvertRatesTo(TimeUnit.SECONDS).\n\t\t\t\tconvertDurationsTo(TimeUnit.MILLISECONDS)\n\t\t\t\t.build();\n\n\t\t<span class="code-comment"><span class="code-comment">// 开始输出报告</span></span>\n\t\treporter.start(<span class="hljs-number"><span class="hljs-number">1</span></span>, TimeUnit.SECONDS);\n\t}\n\n\t<span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">static</span></span></span><span class="hljs-function"> </span><span\n            class="code-keyword"><span class="hljs-function"><span class="code-keyword">void</span></span></span><span\n            class="hljs-function"> </span><span class="code-title"><span class="hljs-function"><span class="code-title">wait5Seconds</span></span></span><span\n            class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span\n            class="hljs-function"> </span></span>{\n\t\t<span class="code-keyword"><span class="code-keyword">try</span></span> {\n\t\t\tThread.sleep(<span class="hljs-number"><span class="hljs-number">300</span></span> * <span\n            class="hljs-number"><span class="hljs-number">1000</span></span>);\n\t\t} <span class="code-keyword"><span class="code-keyword">catch</span></span> (InterruptedException e) {\n\t\t}\n\t}\n}</code></pre>\n<p>MetricDemoRun类中还有2个静态方法，一个用来输出报告数据。一个用来将主线程睡眠一段的时间。运行main以后，会在控制台重复输出下列内容：</p>\n<blockquote>\n    <p>16-7-7 16:50:35 ================================================================</p>\n    <p>-- Gauges ----------------------------------------------------------------------<br>\n        com.oakss.demo.metrics.app.QueueWarp.jobss.size<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;value = 2\n    </p>\n    <p>-- Counters --------------------------------------------------------------------<br>\n        com.oakss.demo.metrics.app.QueueWarp.jobss.count<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;count = 2\n    </p>\n    <p>-- Histograms ------------------------------------------------------------------<br>\n        com.oakss.demo.metrics.app.QueueWarp.size-rate<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;count = 2<br>\n        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;min = 0<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n        &nbsp; &nbsp;max = 1<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mean = 0.52<br> &nbsp; &nbsp; &nbsp;\n        &nbsp; &nbsp; &nbsp; stddev = 0.50<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; median = 1.00<br> &nbsp; &nbsp;\n        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 75% &lt;= 1.00<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 95% &lt;=\n        1.00<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 98% &lt;= 1.00<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n        &nbsp; &nbsp; 99% &lt;= 1.00<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 99.9% &lt;= 1.00</p>\n    <p>-- Meters ----------------------------------------------------------------------<br> requests<br> &nbsp; &nbsp;\n        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;count = 1<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mean rate = 1.00 events/second<br>\n        &nbsp; &nbsp; &nbsp;1-minute rate = 0.00 events/second<br> &nbsp; &nbsp; &nbsp;5-minute rate = 0.00\n        events/second<br> &nbsp; &nbsp; 15-minute rate = 0.00 events/second</p>\n    <p>-- Timers ----------------------------------------------------------------------<br>\n        com.oakss.demo.metrics.app.QueueWarp.opt-timer<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;count = 2<br>\n        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mean rate = 0.33 calls/second<br> &nbsp; &nbsp; &nbsp;1-minute rate = 0.20\n        calls/second<br> &nbsp; &nbsp; &nbsp;5-minute rate = 0.20 calls/second<br> &nbsp; &nbsp; 15-minute rate = 0.20\n        calls/second<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;min = 0.07 milliseconds<br> &nbsp;\n        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;max = 2.75 milliseconds<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n        &nbsp; &nbsp; mean = 1.35 milliseconds<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stddev = 1.34\n        milliseconds<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; median = 0.07 milliseconds<br> &nbsp; &nbsp; &nbsp;\n        &nbsp; &nbsp; &nbsp; &nbsp; 75% &lt;= 2.75 milliseconds<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 95%\n        &lt;= 2.75 milliseconds<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 98% &lt;= 2.75 milliseconds<br>\n        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 99% &lt;= 2.75 milliseconds<br> &nbsp; &nbsp; &nbsp; &nbsp;\n        &nbsp; &nbsp; 99.9% &lt;= 2.75 milliseconds<br> &nbsp;</p>\n</blockquote>\n<p>看完上面的例子。并没有感受什么特别牛逼的地方，无非是在代码中嵌入一些统计点。&nbsp;看来看去都像一个增强版的日志工具。</p>\n\n<h2 id="h2-2">Vert.x指标统计&nbsp; &nbsp;&nbsp;</h2>\n\n<h3 id="h3-1">嵌入Metrics</h3>\n<p>说完基本的dropwizard&nbsp;metrics功能我们再看看如何整合Vert.x和dropwizard&nbsp;metrics用来统计各种有效的指标。</p>\n<p>\n    Vert.x通过MetricsService的SPI接口提供了接入指标统计工具的入口。在创建Vertx实例时使用DropwizardMetricsOptions来告诉Vertx使用对应的实现类。首先需要加入Vert.x的Dropwizard包：</p>\n<pre class="xml"><code class="xml"><span class="code-tag"><span class="code-tag">&lt;</span><span\n        class="code-name"><span class="code-tag"><span class="code-name">dependency</span></span></span><span\n        class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">groupId</span></span></span><span class="code-tag">&gt;</span></span>io.vertx<span\n            class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">groupId</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">artifactId</span></span></span><span class="code-tag">&gt;</span></span>vertx-dropwizard-metrics<span\n            class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">artifactId</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">version</span></span></span><span class="code-tag">&gt;</span></span>3.3.0<span\n            class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">version</span></span></span><span class="code-tag">&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n        class="code-name">dependency</span></span></span><span class="code-tag">&gt;</span></span></code></pre>\n<p>然后下列代码展示了创建一个具有Metrics功能的<em>Vertx</em>实例以及从中读取指标数据。</p>\n<pre class="cs"><code class="cs"><span class="code-keyword"><span class="code-keyword">public</span></span> <span\n        class="code-keyword"><span class="code-keyword">class</span></span> <span class="code-title"><span\n        class="code-title">VertxMetricDemo</span></span> {\n\t<span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">public</span></span></span><span class="hljs-function"> </span><span\n            class="code-keyword"><span class="hljs-function"><span class="code-keyword">static</span></span></span><span\n            class="hljs-function"> </span><span class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">void</span></span></span><span class="hljs-function"> </span><span\n            class="code-title"><span class="hljs-function"><span class="code-title">main</span></span></span><span\n            class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span\n            class="hljs-params">String[] args</span></span></span><span class="hljs-function">) </span></span>{\n\t\t<span class="code-comment"><span class="code-comment">// 使用DropwizardMetricsOptions配置创建单机Vertx实例</span></span>\n\t\tVertx vertx = Vertx.vertx(\n\t\t\t\t<span class="code-keyword"><span class="code-keyword">new</span></span> VertxOptions().setMetricsOptions(\n\t\t\t\t\t\t<span class="code-keyword"><span class="code-keyword">new</span></span> DropwizardMetricsOptions().setEnabled(<span\n            class="hljs-literal"><span class="hljs-literal">true</span></span>)\n\t\t\t\t));\n\n\t\t<span class="code-comment"><span class="code-comment">// 创建指标服务</span></span>\n\t\tMetricsService metricsService = MetricsService.create(vertx);\n\n\t\t<span class="code-comment"><span class="code-comment">// 获取当前的指标服务</span></span>\n\t\tJsonObject json = metricsService.getMetricsSnapshot(vertx);\n\n\t\t<span class="code-comment"><span class="code-comment">// 输出</span></span>\n\t\tSystem.<span class="code-keyword"><span class="code-keyword">out</span></span>.println(json);\n\t}\n}</code></pre>\n<p>Vert.x实现指标功能的原理是接口继承Measured，这些接口包括HttpServer、NetServer、EventBus、Vertx等。通过Measured可以注入对各种组件的指标统计。</p>\n<p><a title="MetricsService" href="http://vertx.io/docs/apidocs/io/vertx/ext/dropwizard/MetricsService.html"\n      rel="nofollow">MetricsService</a>提供了丰富的功能接口来获取各种指标数据，每一项指标数据都有自己特定的命名规则。我们可以过全称获取某一项指标，例如获取eventBus上的handler相关指标，可以使用以下方法：\n</p>\n<pre class="lua"><code class="lua">JsonObject metrics = metricsService.getMetricsSnapshot(vertx);\nmetrics.getJsonObject(<span class="code-string"><span\n            class="code-string">"vertx.eventbus.handlers"</span></span>);</code></pre>\n<p>或者直接从指定的eventBus获取数据：</p>\n<pre class="lua"><code class="lua">EventBus eventBus = vertx.eventBus();\nJsonObject metrics = metricsService.getMetricsSnapshot(eventBus);\nmetrics.getJsonObject(<span class="code-string"><span class="code-string">"handlers"</span></span>);</code></pre>\n<p>两种方式获得同样的数据，只要接口继承了Measured就可以用MetricsService::create来获取指标。</p>\n\n<h3 id="h3-2">指标格式和指标数据</h3>\n<p>Metric提供了丰富的数据格式。目前有：Gauge（测量值）、Counter（计数器）、Histogram（柱状图）、Meter（仪表）、ThroughputMeter（吞吐量统计）、Timer（计时器）和Throughput\n    Timer（吞吐量计时器）。</p>\n<p>Vert.x提供了丰富的指标数据内容，下面将一一列举说明。</p>\n\n<h4 id="h4-1">Vert.x指标</h4>\n<blockquote>\n    <ul>\n        <li><p><code>vertx.event-loop-size</code>&nbsp;- 类型：Gauge（测量值）含义：event loop线程池的线程数量。</p></li>\n        <li><p><code>vertx.worker-pool-size</code>&nbsp;- 类型：Gauge（测量值）含义：worker线程池的线程数量。</p></li>\n        <li><p><code>vertx.cluster-host</code>&nbsp;- 类型：Gauge（测量值）含义：集群主机的设置值。</p></li>\n        <li><p><code>vertx.cluster-port</code>&nbsp;- 类型：Gauge（测量值）含义：集群接口的设置值。</p></li>\n        <li><p><code>vertx.verticles</code>&nbsp;- 类型：Counter（计数器）含义：当前已部署的verticles数量。</p></li>\n        <li><p><code>vertx.verticles.&lt;verticle-name&gt;</code>&nbsp;- 类型：Counter（计数器）含义：&lt;verticle-name&gt;指定名称的verticle部署数量。\n        </p></li>\n    </ul>\n</blockquote>\n\n<h4 id="h4-2">Event bus 指标</h4>\n<p>基础名称:&nbsp;<code>vertx.eventbus</code></p>\n<blockquote>\n    <ul>\n        <li><p><code>handlers</code>&nbsp;- 类型：Counter（计数器）含义： event bus中已注册handler的数量。</p></li>\n        <li><p><code>handlers.myaddress</code>&nbsp;- 类型：Timer（计时器）含义：名为<em>myaddress</em>的handler出个单个messages的速率。</p>\n        </li>\n        <li><p><code>messages.bytes-read</code>&nbsp;- 类型：Meter（仪表）含义：获取远程信息的字节数总量。</p></li>\n        <li><p><code>messages.bytes-written</code>&nbsp;- 类型：Meter（仪表）含义：发送到远程地址的信息数据总量。</p></li>\n        <li><p><code>messages.pending</code>&nbsp;- 类型：Counter（计数器）含义：已经被eventbus接受，但是还未被handler处理的信息数。</p></li>\n        <li><p><code>messages.pending-local</code>&nbsp;- 类型：Counter（计数器）含义：由本地发送的已经被eventbus接受，但是还未被handler处理的信息数。</p>\n        </li>\n        <li><p><code>messages.pending-remote</code>&nbsp;- 类型：Counter（计数器）含义：由远程发送的已经被eventbus接受，但是还未被handler处理的信息数。</p>\n        </li>\n        <li><p><code>messages.received</code>&nbsp;- 类型：ThroughputMeter（吞吐量统计）含义：表示接受消息条目数的速率。</p></li>\n        <li><p><code>messages.received-local</code>&nbsp;- 类型：ThroughputMeter（吞吐量统计）含义：表示接受本地消息条目数的速率。</p></li>\n        <li><p><code>messages.received-remote</code>&nbsp;- 类型：ThroughputMeter（吞吐量统计）含义：表示接受远程消息条目数的速率。</p></li>\n        <li><p><code>messages.delivered</code>&nbsp;- 类型：ThroughputMeter（吞吐量统计）含义：表示消息被传递到一个处理程序的速率。</p></li>\n        <li><p><code>messages.delivered-local</code>&nbsp;- 类型：ThroughputMeter（吞吐量统计）含义：表示本地消息被传递到一个handler的速率。</p></li>\n        <li><p><code>messages.delivered-remote</code>&nbsp;- 类型：ThroughputMeter（吞吐量统计）含义：表示远程消息被传递到一个handler的速率。</p>\n        </li>\n        <li><p><code>messages.sent</code>&nbsp;- 类型：ThroughputMeter（吞吐量统计）含义：表示消息被发送的速率。</p></li>\n        <li><p><code>messages.sent-local</code>&nbsp;- 类型：ThroughputMeter（吞吐量统计）含义：表示消息被发送到本地的速率。</p></li>\n        <li><p><code>messages.sent-remote</code>&nbsp;- 类型：ThroughputMeter（吞吐量统计）含义：表示消息被发送到远程服务的速率。</p></li>\n        <li><p><code>messages.published</code>&nbsp;- 类型：ThroughputMeter（吞吐量统计）含义：表示发布消息的速率。</p></li>\n        <li><p><code>messages.published-local</code>&nbsp;- 类型：ThroughputMeter（吞吐量统计）含义：表示发布本地消息的速率。</p></li>\n        <li><p><code>messages.published-remote</code>&nbsp;- 类型：ThroughputMeter（吞吐量统计）含义：表示发布远程消息的速率。</p></li>\n        <li><p><code>messages.reply-failures</code>&nbsp;- 类型：Meter含义：表示回复失败的频率。</p></li>\n    </ul>\n</blockquote>\n\n<h4 id="h4-3">Http 服务指标</h4>\n<p>基础名称:&nbsp;<code>vertx.http.servers.&lt;host&gt;:&lt;port&gt;</code></p>\n<p>Http 服务的数据包括&nbsp;<strong><em>Net服务的指标&nbsp;</em></strong>加上以下指标：</p>\n<blockquote>\n    <ul>\n        <li><p><code>requests</code>&nbsp;- 类型：Throughput Timer（吞吐量计时器）含义：单个请求及其出现的频率。</p></li>\n        <li><p><code>&lt;http-method&gt;-requests</code>&nbsp;- 类型：Throughput Timer（吞吐量计时器）含义：指定由&lt;http-method&gt;（PUT、GET、POST等）表示方法获取的请求及其频率。\n        </p>\n            <ul>\n                <li><p>例如:&nbsp;<code>get-requests</code>,&nbsp;<code>post-requests</code></p></li>\n            </ul>\n        </li>\n        <li><p><code>&lt;http-method&gt;-requests./&lt;uri&gt;</code>&nbsp;- A&nbsp;Throughput Timer（吞吐量计时器）含义：指定由&lt;http-method&gt;表示的方法和/&lt;uri&gt;表示的路径的请求内容及其频率。\n        </p>\n            <ul>\n                <li><p>例如:&nbsp;<code>get-requests./some/uri</code>,&nbsp;<code>post-requests./some/uri?foo=bar</code>\n                </p></li>\n            </ul>\n        </li>\n        <li><p><code>responses-1xx</code>&nbsp;- 类型：ThroughputMeter（吞吐量统计）含义：1xx响应的频次。</p></li>\n        <li><p><code>responses-2xx</code>&nbsp;- 类型：ThroughputMeter（吞吐量统计）含义：2xx响应的频次。</p></li>\n        <li><p><code>responses-3xx</code>&nbsp;- 类型：ThroughputMeter（吞吐量统计）含义：3xx响应的频次。</p></li>\n        <li><p><code>responses-4xx</code>&nbsp;- 类型：ThroughputMeter（吞吐量统计）含义：4xx响应的频次。</p></li>\n        <li><p><code>responses-5xx</code>&nbsp;- 类型：ThroughputMeter（吞吐量统计）含义：5xx响应的频次。</p></li>\n        <li><p><code>open-websockets</code>&nbsp;- 类型：Counter（计数器）含义：打开网络套接字的连接个数。</p></li>\n        <li><p><code>open-websockets.&lt;remote-host&gt;</code>&nbsp;- 类型：Counter（计数器）含义：连接到&lt;remote-host&gt;指定的地址打开网络套接字的连接个数。\n        </p></li>\n    </ul>\n</blockquote>\n\n<h4 id="h4-4">Net 服务指标</h4>\n<p>基础名称:&nbsp;<code>vertx.net.servers.&lt;host&gt;:&lt;port&gt;</code></p>\n<blockquote>\n    <ul>\n        <li><p><code>open-netsockets</code>&nbsp;- 类型：Counter（计数器）含义：打开net socket的连接数。</p></li>\n        <li><p><code>open-netsockets.&lt;remote-host&gt;</code>&nbsp;- 类型：Counter（计数器）含义：连接到指定的远程主机所打开的net socket连接数。\n        </p></li>\n        <li><p><code>connections</code>&nbsp;- 类型：Timer（计时器）含义：创建连接的频率。</p></li>\n        <li><p><code>exceptions</code>&nbsp;- 类型：Counter（计数器）含义：出现异常的次数。</p></li>\n        <li><p><code>bytes-read</code>&nbsp;- 类型：Histogram（柱状图）含义：读取的字节数。</p></li>\n        <li><p><code>bytes-written</code>&nbsp;- 类型：Histogram（柱状图）含义：写入的字节数。</p></li>\n    </ul>\n</blockquote>\n\n<h4 id="h4-5">池指标（Pool metrics）</h4>\n<p>基础名称:&nbsp;<code>vertx.pool.&lt;type&gt;.&lt;name&gt;</code>。这里的<code>type</code>表示池类型(例如&nbsp;<em>worker</em>、<em>datasource</em>)，&nbsp;<code>name</code>表示池的名称(例如&nbsp;<code>vert.x-worker-thread</code>)。\n</p>\n<p>类型为<em>worker</em>的线程池是用于阻塞运行的工作线程池，Vert.x将其用于<em>vert.x-worker-thread</em>线程或<em>vert.x-internal-blocking</em>线程。\n    名为worker的执行线程都使用<code><a title="WorkerExecutor"\n                             href="http://vertx.io/docs/apidocs/io/vertx/core/WorkerExecutor.html" rel="nofollow">WorkerExecutor</a></code>来创建。\n</p>\n<p>数据源（Datasource）使用Vert.x的JDBC客户端创建，名为<em>datasource</em>.</p>\n<blockquote>\n    <ul>\n        <li><p><code>queue-delay</code>&nbsp;- 类型：Timer（计时器）含义：测量获取某个资源的等待时间，例如在队列中的等待时间。</p></li>\n        <li><p><code>queue-size</code>&nbsp;- 类型：Counter（计数器）含义：在队列中等待的资源数。</p></li>\n        <li><p><code>usage</code>&nbsp;- 类型：Timer（计时器）含义：测量某个资源被持续使用的时间。</p></li>\n        <li><p><code>in-use</code>&nbsp;- 类型：Counter（计数器）含义：使用资源的实际数量。</p></li>\n        <li><p><code>pool-ratio</code>&nbsp;- 类型：Gauge（测量值）含义：已使用的资源和池规模的比率。</p></li>\n        <li><p><code>max-pool-size</code>&nbsp;- 类型：Gauge（测量值）含义：池的最大规模。</p></li>\n    </ul>\n</blockquote>\n<p>当池的最大规模没有声明时，<code>pool-ratio</code>和<code>max_pool_size</code>将没有任何数据。</p>\n<p>除了以上服务器端的指标之外，Vertx还包括一些客户端指标，有需要可以去官网查看。</p>\n\n<h2 id="h2-3">图形化展示指标数据</h2>\n<p>在收集到各种指标数据之后，如果只能输出到console看各字符串就太没意思了。在互联网时代，必须有牛逼闪闪的图形统计工具啊，下面将介绍使用开源项目呈现数据报表。</p>\n<p>官网介绍了2个开源工具来实现呈现报表的功能——Jolokia和Hawtio。</p>\n\n<h3 id="h3-3">Jolokia代理</h3>\n<p><a title="Jolokia" href="https://jolokia.org/" rel="nofollow">Jolokia </a>是按照JSR-160的要求实现JMX-HTTP桥接的工具。按照官网的说法，有非常多的平台使用了Jolokia，并且Jolokia在处理远程连接时提供了更安全的支持。（另外一篇博文介绍了Jolokia，想了解点这里：<a\n        href="http://my.oschina.net/chkui/blog/708639" rel="nofollow">http://my.oschina.net/chkui/blog/708639</a>）</p>\n<p>首先，需要像下面这样创建一个Vertx实例：</p>\n<pre class="actionscript"><code class="language-java">Vertx vertx = Vertx.vertx(<span class="code-keyword"><span\n        class="code-keyword">new</span></span> VertxOptions().setMetricsOptions(\n    <span class="code-keyword"><span class="code-keyword">new</span></span> DropwizardMetricsOptions()\n        .setEnabled(<span class="code-keyword"><span class="hljs-literal">true</span></span>)\n        .setJmxEnabled(<span class="code-keyword"><span class="hljs-literal">true</span></span>)\n        .setJmxDomain(<span class="code-string"><span class="code-string">"vertx-metrics"</span></span>)));</code></pre>\n<p><em>Domain&nbsp;</em>参数是可以修改的，这个参数会影响Hawtio的服务的浏览名称，下文会有说明。完成这个配并启用统计功能后，vertx-dropwizard-metric会暴露本地的的Mbean服务接口，Jolokia可以通过这个接口获取指标数据。（<span\n        style="color:#FFA07A">以上配置也可以用于Vert.x的集群环境。</span>）</p>\n<p>然后，我们插入Jolokia来做桥接功能。</p>\n<p>首先到官网去下载最新的代理包&lt;<a title="Jolokia代理包"\n                        href="http://search.maven.org/remotecontent?filepath=org/jolokia/jolokia-jvm/1.3.3/jolokia-jvm-1.3.3-agent.jar"\n                        rel="nofollow">点我下载</a>&gt;。下载完成后，需要嵌入到我们自己的应用中，像下面这样在java启动命令中增加以下参数来植入Jolokia代理：</p>\n<pre class="xml"><code class="xml">-javaagent:%jolokia_home%/jolokia-jvm-<span class="code-tag"><span class="code-tag">&lt;</span><span\n        class="code-name"><span class="code-tag"><span class="code-name">version</span></span></span><span\n        class="code-tag">&gt;</span></span>-agent.jar=port=7777,host=localhost</code></pre>\n<p>下面是完整的例子：</p>\n<pre class="groovy"><code class="groovy">java -<span class="code-string"><span\n        class="code-string">javaagent:</span></span><span class="code-string"><span class="code-string">D:</span></span><span\n        class="hljs-regexp"><span class="hljs-regexp">/soft/</span></span>jolokia/jolokia-jvm<span\n        class="hljs-number"><span class="hljs-number">-1.3</span></span><span class="hljs-number"><span\n        class="hljs-number">.3</span></span>-agent.jar=port=<span class="hljs-number"><span\n        class="hljs-number">7777</span></span>,host=localhost com.a.b.c.runApp</code></pre>\n<p>在eclipse下，右键-&gt;[Debug|Run] As-&gt;[Debug|Run] Config。弹出的选项卡中，选择Arguments。然后在VM arguments中增加代理参数，如下图：</p>\n<p><img alt="Vert.x Dropwizard指标数据监控" height="535"\n        src="http://static.oschina.net/uploads/space/2016/0712/165407_jrTG_2649413.png" width="900"></p>\n<p>然后点击右下角的Debug启动。如果启动成功，会在控制台输出。</p>\n<blockquote>\n    <p>I&gt; No access restrictor found, access to any MBean is allowed<br> Jolokia: Agent started with URL\n        http://127.0.0.1:7777/jolokia/</p>\n</blockquote>\n<p>至此。我们的Vertx实例成功启动，启动的同时开启了：</p>\n<ol>\n    <li>Dropwizard Metrics用于指标收集；</li>\n    <li>Jmx暴露桥接接口；</li>\n    <li>Jolokia提供指标数据Rest接口；</li>\n</ol>\n<p>随后，我们需要添加一个Hawtio来获取Jolokia暴露的接口数据。</p>\n\n<h3 id="h3-4">Hawtio展示指标数据</h3>\n<p>Hawtio看做一个web服务即可，他按照servlet规范开发，是个标准的web服务。他功能就是从暴露的Jolokia接口中读取指标数据，然后以图像化的方式呈现给用户。下面说明如何搭建好Hawtio服务。</p>\n<p>首先下载Hawtio的war包&lt;<a title="Hawtio运行包"\n                         href="https://oss.sonatype.org/content/repositories/public/io/hawt/hawtio-default/1.4.65/hawtio-default-1.4.65.war"\n                         rel="nofollow">点我下载</a>&gt;。</p>\n<p>然后将war包放置到web容器中。Hawtio支持多种servlet规范的web容器，如中国javaer最喜欢的tomcat和jetty，还有Karaf\n    、Wildfly(Jboss)等。每种容器的配置都有些许不同，我们这里只说明如何配置Tomcat，其他容器的配置方法见<a title="Hawtio的配置说明"\n                                                                  href="http://hawt.io/configuration/index.html"\n                                                                  rel="nofollow">Hawtio的配置说明</a>。</p>\n<p>使用的tomcat并没有多少配置，如果不需要管理用户权限的话，把download的war包直接丢到webapps里启动tomcat就可以看到以下页面了：</p>\n<p><img alt="Vert.x Dropwizard指标数据监控" height="337"\n        src="https://file.mahoooo.com/res/file/vertx_metrics_using_dropwizard_2018_5_7_1.png" width="600"></p>\n<p>然后点击Connect栏,可以看到以下内容：</p>\n<p><img alt="Vert.x Dropwizard指标数据监控" height="319"\n        src="https://file.mahoooo.com/res/file/vertx_metrics_using_dropwizard_2018_5_7_2.png" width="600"></p>\n<p>\n    在表单中填写连接内容：Name随便取一个即可、Scheme选择默认的http、Host填写主机地址（本例是在本地运行，使用127.0.0.1或者localhost）、端口使用前面启动Jolokia使用的端口、Path选择Jolokia。然后点击Connect\n    to remote server。</p>\n<p>连接成功后点击左上角导航栏里的JMX（其他菜单可以看到cpu、内存、线程的使用情况等）。下图就是Hawtio图形化的指标数据，提供多种图标（Chart）。这里的文件夹名称“vertx-metrics”就是在上面代码 <span\n        style="color:#0000FF"><em>setJmxDomain("vertx-metrics")&nbsp;</em></span>中命名的domian名称。</p>\n<p><img alt="Vert.x Dropwizard指标数据监控" height="392"\n        src="https://file.mahoooo.com/res/file/vertx_metrics_using_dropwizard_2018_5_7_3.png" width="800">&nbsp;&nbsp;&nbsp;\n</p>\n<p>Hawtio除了展示Vertx相关的所有数据外，还可以看到Jvm相关的其他数据，例如Cpu、堆、栈、线程池等。如果需要的话，还可以把自己定义更多的监控数据传递到Hawtio显示。</p>\n\n<h3 id="h3-5">Hawtio权限管理</h3>\n<p>上面例子说明了如何使用Hawtio展示指标数据。但是任何使用者都可以查看到相关数据。Hawtio提供了开箱即用的用户权限控制功能。需要针对不同的容器环境进行配置。这里以tomcat为例。</p>\n<p>在tomcat的启动脚本中添加下面的参数：</p>\n<p>linux：</p>\n<pre class="bash"><code class="bash"><span class="code-built_in"><span class="code-built_in">export</span></span> CATALINA_OPTS=<span\n        class="code-string"><span class="code-string">\'-Dhawtio.authenticationEnabled=true -Dhawtio.role=manager\'</span></span></code></pre>\n<p>windows：</p>\n<pre class="bash"><code class="bash"><span class="code-built_in"><span class="code-built_in">set</span></span> JAVA_OPTS=-Dhawtio.authenticationEnabled=<span\n        class="hljs-literal"><span class="hljs-literal">true</span></span>\n</code></pre>\n<p>然后Hawtio会使用tomcat的用户权限来控制自身的用户权限。也就是说，如果在 %TOMCAT_HOME%/conf/tomcat-users.xml中配置了以下内容：</p>\n<pre class="xml"><code class="xml"><span class="code-tag"><span class="code-tag">&lt;</span><span\n        class="code-name"><span class="code-tag"><span class="code-name">user</span></span></span><span\n        class="code-tag"> </span><span class="hljs-attr"><span class="code-tag"><span class="hljs-attr">username</span></span></span><span\n        class="code-tag">=</span><span class="code-string"><span class="code-tag"><span\n        class="code-string">"user"</span></span></span><span class="code-tag"> </span><span class="hljs-attr"><span\n        class="code-tag"><span class="hljs-attr">password</span></span></span><span class="code-tag">=</span><span\n        class="code-string"><span class="code-tag"><span class="code-string">"passwd"</span></span></span><span\n        class="code-tag"> </span><span class="hljs-attr"><span class="code-tag"><span\n        class="hljs-attr">roles</span></span></span><span class="code-tag">=</span><span class="code-string"><span\n        class="code-tag"><span class="code-string">"tomcat"</span></span></span><span\n        class="code-tag">/&gt;</span></span></code></pre>\n<p>则可以使用user/passwd作为账号密码登录Hawtio。</p>\n<p>配置生效后输入Hawtio的地址会跳转到下面这个页面。</p>\n<p><img alt="Vert.x Dropwizard指标数据监控" height="243"\n        src="https://file.mahoooo.com/res/file/vertx_metrics_using_dropwizard_2018_5_7_4.png" width="400"></p>\n<p>只有登录成功才能继续访问其他资源。</p>\n<p>现在，你的Vert.x已经有了一个牛逼闪闪的图像化监控工具。当然，本文提到的工具不仅仅只能用于监控Vert.x，只要稍加改动，可以监控JVM的方方面面。</p>'}});