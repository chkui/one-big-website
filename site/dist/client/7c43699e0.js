webpackJsonp([7],{324:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h2 id="h2-1">从一个类开始</h2>\n<p>我们从一个简单类开始说起：</p>\n<pre><code class="java"><span class="code-keyword">package</span> example.classLifecicle;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">SimpleClass</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tSimpleClass ins = <span class="code-keyword">new</span> SimpleClass();\n\t}\n}</code></pre>\n<p>这是一段平凡得不能再平凡的Java代码，稍微有点编程语言入门知识的人都能理解它表达的意思：</p>\n<ol>\n    <li>创建一个名为SimpleClass的类；</li>\n    <li>定义一个入口main方法；</li>\n    <li>在main方法中创建一个SimpleClass类实例；</li>\n    <li>退出。</li>\n</ol>\n\n<h2 id="h2-2">什么是Java bytecode</h2>\n<p>那么这一段代码是怎么在机器（JVM）里运行的呢？在向下介绍之前先说清几个概念。</p>\n<p>首先，Java语言和JVM完全可以看成2个完全不相干的体系。虽然JVM全称叫Java Virtual\n    Machine，最开始也是为了能够实现Java的设计思想而制定开发的。但是时至今日他完全独立于Java语言成为一套生命力更为强悍的体系工具。他有整套规范，根据这个规范它有上百个应用实现，其中包括我们最熟悉的hotspot、jrockit等。还有一些知名的变种版本——harmony和android\n    dalvik，严格意义上变种版本并不能叫java虚拟机，因为其并未按照jvm规范开发，但是从设计思想、API上看又有大量的相似之处。</p>\n<p>其次，JVM并不能理解Java语言，他所理解的是称之为Java bytecode的"语言"。Java\n    bytecode从形式上来说是面向过程的，目前包含130多个指令，他更像可以直接用于CPU计算的一组指令集。所以无论什么语言，最后只要按照规范编译成java\n    bytecode（以下简称为"字节码"）都可以在JVM上运行。这也是scala、groovy、kotlin等各具特色的语言虽然在语法规则上不一致，但是最终都可以在JVM上平稳运行的原因。</p>\n\n<h2 id="h2-3">Java bytecode的规范和存储形式</h2>\n<p>前面代码保存成 <em>.java</em> 文件然后用下面的命令编译过后就可以生成.class字节码了：</p>\n<pre><code class="bash">$ javac SimpleClass.java <span class="code-comment">#SimpleClass.class</span></code></pre>\n<p>字节码是直接使用2进制的方式存储的，每一段数据都定义了具体的作用。下面是<em>SimpleClass.class</em> 的16进制数据（使用<em>vim + xxd</em>打开）：</p>\n<p><img alt="Jvm与字节码——类的方法区模型" height="315"\n        src="https://file.mahoooo.com/res/file/java_jvm_class_compile_in_the_method_area_2.png" width="500"></p>\n<p>一个 <em>.class</em> 文件的字节码分为10个部分：</p>\n<p>0~4字节：文件头，用于表示这是一个<em>Java bytecode</em>文件，值固定为0xCAFEBABE。</p>\n<p>2+2字节：编译器的版本信息。</p>\n<p>2+n字节：常量池信息。</p>\n<p>2字节：入口权限标记。</p>\n<p>2字节：类符号名称。</p>\n<p>2字节：父类符号名称。</p>\n<p>2+n字节：接口。</p>\n<p>2+n字节：域（成员变量）。</p>\n<p>2+n字节：方法。</p>\n<p>2+n字节：属性。</p>\n<p>每个部分的前2个字节都是该部分的标识位。</p>\n<p>本篇的目的是说明字节码的作用以及JVM如何使用字节码运转的，想要详细了解2进制意义的请看这里：http://www.jianshu.com/p/252f381a6bc4。</p>\n\n<h2 id="h2-4">反汇编及字节码解析</h2>\n<p>我们可以使用 <strong><em>javap</em></strong> 命令将字节码反汇编成我们容易阅读的格式化了的指令集编码:</p>\n<pre><code class="bash">$ javap -p SimpleClass.class <span class="code-comment">#查看类和成员</span>\n$ javap -s SimpleClass.class <span class="code-comment">#查看方法签名</span>\n$ javap -c SimpleClass.class <span class="code-comment">#反汇编字节码</span>\n$ javap -v SimpleClass.class <span class="code-comment">#返汇编查看所有信息</span></code></pre>\n<p><strong><em>javap</em></strong> 还有很多的参数，可以使用 <strong><em>javap --help</em></strong> 来了解。下面是使用<strong><em>javap\n    -v</em></strong> 命令输出的内容，输出了常量池信息、方法签名、方法描述、堆栈数量、本地内存等信息：</p>\n<pre><code class="apache"><span class="code-attribute">public</span> class example.classLifecicle.SimpleClass\n  <span class="code-attribute">flags</span>: ACC_PUBLIC, ACC_SUPER\n<span class="code-attribute">Constant</span> pool:\n   <span class="code-comment">#1 = Methodref          #4.#13         // java/lang/Object."&lt;init&gt;":()V</span>\n   <span class="code-comment">#2 = Class              #14            // example/classLifecicle/SimpleClass</span>\n   <span class="code-comment">#3 = Methodref          #2.#13         // example/classLifecicle/SimpleClass."&lt;init&gt;":()V</span>\n   <span class="code-comment">#4 = Class              #15            // java/lang/Object</span>\n   <span class="code-comment">#5 = Utf8               &lt;init&gt;</span>\n   <span class="code-comment">#6 = Utf8               ()V</span>\n   <span class="code-comment">#7 = Utf8               Code</span>\n   <span class="code-comment">#8 = Utf8               LineNumberTable</span>\n   <span class="code-comment">#9 = Utf8               main</span>\n  <span class="code-comment">#10 = Utf8               ([Ljava/lang/String;)V</span>\n  <span class="code-comment">#11 = Utf8               SourceFile</span>\n  <span class="code-comment">#12 = Utf8               SimpleClass.java</span>\n  <span class="code-comment">#13 = NameAndType        #5:#6          // "&lt;init&gt;":()V</span>\n  <span class="code-comment">#14 = Utf8               example/classLifecicle/SimpleClass</span>\n  <span class="code-comment">#15 = Utf8               java/lang/Object</span>\n{\n  <span class="code-attribute">public</span> example.classLifecicle.SimpleClass();\n    <span class="code-attribute">descriptor</span>: ()V\n    <span class="code-attribute">flags</span>: ACC_PUBLIC\n    <span class="code-attribute">Code</span>:\n      <span class="code-attribute">stack</span>=1, locals=1, args_size=1\n         <span class="code-attribute">0</span>: aload_0\n         <span class="code-attribute">1</span>: invokespecial #1                  // Method java/lang/Object.<span\n            class="code-string">"&lt;init&gt;"</span>:()V\n         <span class="code-attribute">4</span>: return\n      <span class="code-attribute">LineNumberTable</span>:\n        <span class="code-attribute">line</span> 3: 0\n\n  <span class="code-attribute">public</span> static void main(java.lang.String[]);\n    <span class="code-attribute">descriptor</span>: ([Ljava/lang/String;)V\n    <span class="code-attribute">flags</span>: ACC_PUBLIC, ACC_STATIC\n    <span class="code-attribute">Code</span>:\n      <span class="code-attribute">stack</span>=2, locals=2, args_size=1\n         <span class="code-attribute">0</span>: new           #2                  // class example/classLifecicle/SimpleClass\n         <span class="code-attribute">3</span>: dup\n         <span class="code-attribute">4</span>: invokespecial #3                  // Method <span class="code-string">"&lt;init&gt;"</span>:()V\n         <span class="code-attribute">7</span>: astore_1\n         <span class="code-attribute">8</span>: return\n      <span class="code-attribute">LineNumberTable</span>:\n        <span class="code-attribute">line</span> 5: 0\n        <span class="code-attribute">line</span> 6: 8\n}\n</code></pre>\n<p>下面是关于字节码格式的描述：</p>\n<p><strong><em>public class example.classLifecicle.SimpleClass</em></strong></p>\n<p>这一段表示这个类的符号。</p>\n<p><em><strong>flags: ACC_PUBLIC, ACC_SUPER</strong></em></p>\n<p>该类的标记。例如是否是public类等等，实际上就是将一些Java关键字转译成对应的Java bytecode。</p>\n<p><em><strong>Constant pool:</strong></em></p>\n<p><em>constant pool:</em> 之后的内容一直到<em> { </em>符号，都是我们所说的"常量池"。在对java类进行编译之后就会产生这个常量池。通常我们所说的类加载，就是加载器将字节码描述的常量信息转换成实际存储在运行时常量池中的一些内存数据（当然每个方法中的指令集也会随之加载到方法指向的某个内存空间中）。\n</p>\n<p>"#1"可以理解为常量的ID。可以把常量池看作一个Table，每一个ID都指向一个常量，而在使用时都直接用"#1"这样的ID来引用常量。</p>\n<p>常量池中的包含了运行这个类中方法所有需要用到的所有常量信息，Methodref、Class、Utf8、NameAndType等表示常量的类型，后面跟随的参数表示这个常量的引用位置或者数值。</p>\n<p><em><strong>{}:</strong></em></p>\n<p>常量池之后的{}之间是方法。每一个方法分为符号（名称）、标记、描述以及指令集。descriptor：描述。flags：入口权限标记。Code：指令集。</p>\n<p>Code中，stack表示这一段指令集堆栈的最大深度, locals表示本地存储的最大个数, args_size表述传入参数的个数。</p>\n\n<h2 id="h2-5">字节码如何驱动机器运行</h2>\n<p>\n    在往下说之前，先说下JVM方法区的内容。方法区顾名思义就是存储各种方法的地方。但是从实际应用来看，以Hotspot为例——方法区在实现时通常分为class常量池、运行常量池。在大部分书籍中，运行时常量池被描述为包括类、方法的所有描述信息以及常量数据,（<a\n        href="https://www.chkui.com/article/java/java_jvm_method_area_and_constant_pool" rel="nofollow">详情请看这篇文章</a>。</p>\n<p>对于机器来说并不存在什么类的感念的。到了硬件层面，他所能了解的内容就是：1）我要计算什么（cpu），2）我要存储什么（缓存、主存、磁盘等，我们统称内存）？</p>\n<p>\n    按照分层模型来说JVM只是一个应用进程，是不可能直接和机器打交道的（这话也不是绝对的，有些虚拟机还真直接当作操作系统在特有硬件设备上用）。在JVM到硬件之间还隔着一层操作系统，在本地运行时是直接调用操作系统接口的（windows和linux都是C/C++）。不过为了JVM虚拟机更高效，字节码设计为更接近机器逻辑行为的方式来运行。不然也没必要弄一个字节码来转译Java语言，像nodejs用的V8引擎那样实时编译Javascript不是更直接？这也是过去C/C++唾弃Java效率低下，到了如今Java反而去吐槽其他解释型编译环境跑得慢的原因（不过这也不见得100%正确。比如某些情况下Java在JVM上处理JSON不见得比JavaScript在nodejs上快，而且写起代码来也挺费劲的）。</p>\n<p>\n    我们回到硬件计算和存储的问题。CPU的计算过程实质上就是操作系统的线程不断给CPU传递指令集。线程就像传送带一样，把一系列指令排好队然后一个一个交给CPU去处理。每一个指令告诉CPU干一件事，而干事的前后总得有个依据（输入）和结果（输出），这就是各种缓存、内存、磁盘的作用——提供依据、保存结果。JVM线程和操作系统线程是映射关系（mapping），而JVM的堆（heap）和非堆（Non-heap）就是一个内存管理的模型。所以我们跳出分层的概念，将字节码理解为直接在驱动cpu和内存运行的汇编码更容易理解。</p>\n<p>最后，我们回到方法区（Method\n    Area）这个规范概念。CPU只关心一堆指令，而JVM中所有的指令都是放置在方法区中的。JVM的首要任务是把这些指令有序的组织起来，按照编程好的逻辑将指令一个一个交给CPU去运行。而CPU都是靠线程来组织指令运算的，所以JVM中每个线程都有一个线程栈，通过他将指令组织起来一个一个的交给CPU去运算——这就是计数器（Counter\n    Register，用以指示当前应该执行什么字节码指令）、线程栈（Stacks，线程的运算模型——先进后出） 和 栈帧（Stacks\n    Frame，方法执行的本地变量）&nbsp;的概念。所以无论多复杂的设计，方法区可以简单的理解为：<strong>有序的将指令集组织起来，并在使用的时候可以通过某些方法找到对应的指令集合</strong>。</p>\n<p><strong>解析常量池</strong></p>\n<p><img alt="Jvm与字节码——类的方法区模型" height="339"\n        src="https://file.mahoooo.com/res/file/java_jvm_class_compile_in_the_method_area_1.png" width="563"></p>\n<p>先看 <em><strong>SimpleClass</strong></em>&nbsp;字节码中常量池中的一些数据，上图中每一个方框表示一个常量。方框中第一行的 <em><strong>#1</strong></em>\n    表示当前常量的ID，第二行 <strong><em>Methodref</em></strong> 表示这个这个常量的类型，第三行 <em><strong>#4,#13</strong></em> 表示常量的值。</p>\n<p>我们从 <em><strong>#1</strong></em> 开始跟着每个常量的值向下延伸可以展开一根以 <strong><em>Utf8</em></strong>&nbsp;类型作为叶节点的树，每一个叶节点都是一个值。所有的方法我们都可以通过树的方式展开得到下面的查询字段：\n</p>\n<pre><code class="apache"><span class="code-attribute">class</span> = java/lang/Object //属于哪个类\n<span class="code-attribute">method</span> = <span class="code-string">"&lt;init&gt;"</span> //方法名称\n<span class="code-attribute">params</span> = NaN //参数\n<span class="code-attribute">return</span> = V //返回类型</code></pre>\n<p>所有的方法都会以 <em><strong>package.class.name:(params)return&nbsp;</strong></em>的形式存储在方法区中，通过上面的参数很快可以定位到方法，例如&nbsp; <em>java.lang.Object."&lt;init&gt;":()V</em>，这里"&lt;init&gt;"是构造方法专用的名称。\n</p>\n<p><strong>解析方法中的指令集</strong></p>\n<p>方法除了用于定位的标识符外就是指令集，下面解析main方法的指令集：</p>\n<pre><code class="http"><span class="code-attribute">0</span>: new &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// class example/classLifecicle/SimpleClass\n<span class="code-attribute">3</span>: dup\n<span class="code-attribute">4</span>: invokespecial #3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Method "&lt;init&gt;":()V\n<span class="code-attribute">7</span>: astore_1\n<span class="code-attribute">8</span>: return</code></pre>\n<p>1)）new 表示新建一个ID为#2的对象即SimpleClass(#2-&gt;#15="<em><strong>example/classLifecicle/SimpleClass"</strong></em>)。此时JVM会在堆上创建一个能放置<strong><em>SimpleClass</em></strong>类的空间并将引用地址返回写到栈顶。这里仅仅完成在堆中分配空间，没执行初始化。\n</p>\n<p>2）dup表示复制栈顶数据。此时栈中有2个指向同一内存区域的<em><strong>SimpleClass</strong></em>引用。</p>\n<p>3）invokespecial\n    #3表示执行#3的方法。通过解析常量池#3就是<em><strong>SimpleClass</strong></em>的构造方法。此后会将<em><strong>SimpleClass</strong></em>构造方法中的指令压入栈中执行。\n</p>\n<p>4）接下来来是<em><strong>SimpleClass</strong></em>的构造方法部分： a）aload_0 表示将本地内存的第一个数据压入栈顶，本地内存的第一个数据就是this。b）invokespecial #1\n    表示执行 <em><strong>Object</strong></em> 的构造方法。c）退出方法。这样就完成了实例的构造过程。</p>\n<p>5）完成上述步骤后，线程栈上还剩下一个指向<em><strong>SimpleClass</strong></em>实例的引用，astore_1 表示将引用存入本地缓存第二个位置。</p>\n<p>6）return -&gt; 退出 <em>main</em> 方法。</p>\n\n<h2 id="h2-6">方法区结构</h2>\n<p><strong>那么在方法区中所有的类是如何组织存放的呢？</strong></p>\n<p>我们用一个关系型数据库常的结构就可以解释他。在数据库中我们常用的对象有3个——表、字段、数据。每一个类对应的字节码我们都可以看成会生成2张数据库表——常量池表、方法表。通过字节码的解析，在内存中产生了如下结构的表：</p>\n<p>常量池表:example.classLifecicle.SimpleClass_Constant</p>\n<table border="1" cellpadding="1" cellspacing="1" style="width:500px">\n    <tbody>\n    <tr>\n        <td><strong><em>id</em></strong></td>\n        <td><strong><em>type</em></strong></td>\n        <td><strong><em>value</em></strong></td>\n    </tr>\n    <tr>\n        <td>#1</td>\n        <td>Methodref</td>\n        <td>#4,#13</td>\n    </tr>\n    <tr>\n        <td>…</td>\n        <td>……</td>\n        <td>……</td>\n    </tr>\n    <tr>\n        <td>#4</td>\n        <td>Class</td>\n        <td>#15</td>\n    </tr>\n    <tr>\n        <td>#15</td>\n        <td>Utf8</td>\n        <td>java/lang/Object</td>\n    </tr>\n    </tbody>\n</table>\n<p>方法表:example.classLifecicle.SimpleClass_Method</p>\n<table border="1" cellpadding="1" cellspacing="1" style="width:500px">\n    <tbody>\n    <tr>\n        <td>name</td>\n        <td>params</td>\n        <td>return</td>\n        <td>flag</td>\n        <td>code</td>\n    </tr>\n    <tr>\n        <td>&lt;init&gt;</td>\n        <td>&nbsp; &nbsp; NaN</td>\n        <td>V</td>\n        <td>static,public</td>\n        <td>……</td>\n    </tr>\n    <tr>\n        <td>…&nbsp;</td>\n        <td>……</td>\n        <td>……</td>\n        <td>……</td>\n        <td>……</td>\n    </tr>\n    </tbody>\n</table>\n<p>然后在运行过程中当计数器遇到&nbsp;<strong><em>invokespecial #3</em></strong>&nbsp;这样的指令时就会根据指令后面的ID去本类的常量表中查询并组装数据。当组装出&nbsp;class\n    = java/lang/Object、method = "&lt;init&gt;"、params = NaN、return = V这样的数据后，就会去名为java.lang.Object的表中根据&nbsp;<em>method、params、return&nbsp;</em>字段的数据查询对应的code，找到后为该code创建一个本地内存，随后线程计数器逐个执行code中的指令。\n</p>\n<p>这里仅仅用关系型数据库表的概念来解释方法区中如何将指令执行和字节码对应起来，真正的JVM运行方式比这复杂得多。不过这样很容易理解方法区到底是怎么一回事。</p>'},332:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h3 id="h3-1">不使用ES6</h3>\n<p>通常情况下，定义一个React组件可以使用ES6规范中的class关键字：</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span\n        class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span\n        class="code-title"><span class="hljs-class"><span class="code-title">Greeting</span></span></span><span\n        class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="xml"><span class="code-tag">&lt;<span\n            class="code-name">h1</span>&gt;</span><span class="code-type">Hello</span>, {<span\n            class="code-keyword">this</span>.props.name}<span class="code-tag">&lt;/<span class="code-name">h1</span>&gt;</span></span>;\n  }\n}</code></pre>\n<p>如果不使用ES6语法，可以直接使用&nbsp;<code>React.createClass</code>&nbsp;来实现相同的功能：</p>\n<pre class="javascript"><code class="language-javascript"><span class="code-keyword"><span\n        class="code-keyword">var</span></span> Greeting = React.createClass({\n  render: <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">function</span></span></span><span\n            class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span\n            class="hljs-params"></span>) </span></span>{\n    <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="xml"><span class="code-tag"><span\n            class="xml"><span class="code-tag">&lt;</span></span><span class="code-name"><span class="xml"><span\n            class="code-tag"><span class="code-name">h1</span></span></span></span><span class="xml"><span\n            class="code-tag">&gt;</span></span></span><span class="xml">Hello, {this.props.name}</span><span\n            class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span\n            class="xml"><span class="code-tag"><span class="code-name">h1</span></span></span></span><span\n            class="xml"><span class="code-tag">&gt;</span></span></span></span>;\n  }\n});</code></pre>\n\n<h4 id="h4-1">声明Prop的检查类型以及默认Props值</h4>\n<p>在前面的博文（<a title="React prop类型检查与Dom" href="https://www.chkui.com/article/react/react_typechecking_with_proptypes_and_dom_element">React prop类型检查与Dom</a>）中介绍了如何规约Prop的参数值，给出的例子都是用ES6实现的：</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span\n        class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span\n        class="code-title"><span class="hljs-class"><span class="code-title">Greeting</span></span></span><span\n        class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  <span class="code-comment"><span class="code-comment">// ...</span></span>\n}\n\n<span class="code-type">Greeting</span>.propTypes = {\n  name: <span class="code-type">React</span>.<span class="code-type">PropTypes</span>.string\n};\n\n<span class="code-type">Greeting</span>.defaultProps = {\n  name: <span class="code-string"><span class="hljs-symbol">\'Mar</span>y\'</span>\n};</code></pre>\n<p>\n    在使用&nbsp;<code>React.createClass</code>&nbsp;时，可以通过设定传入的对象的一个属性值——&nbsp;<code>propTypes</code>&nbsp;来指定参数类型，通过&nbsp;<code>getDefaultProps()</code>&nbsp;方法来设定每个参数的默认值：\n</p>\n<pre class="actionscript"><code class="language-javascript"><span class="code-keyword"><span\n        class="code-keyword">var</span></span> Greeting = React.createClass({\n  propTypes: {\n    name: PropTypes.string\n  },\n\n  getDefaultProps: <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">function</span></span></span><span class="hljs-function"><span\n            class="hljs-params">(</span></span><span class="hljs-params"></span><span class="hljs-function"><span\n            class="hljs-params">)</span> </span></span>{\n    <span class="code-keyword"><span class="code-keyword">return</span></span> {\n      name: <span class="code-string"><span class="code-string">\'Mary\'</span></span>\n    };\n  },\n\n  <span class="code-comment"><span class="code-comment">// ...</span></span>\n\n});</code></pre>\n\n<h4 id="h4-2">设定初始化状态</h4>\n<p>在ES6的 class&nbsp;结构中，我们可以在构造函数中设定初始化状态：</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span\n        class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span\n        class="code-title"><span class="hljs-class"><span class="code-title">Counter</span></span></span><span\n        class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  <span class="code-keyword">constructor</span>(props) {\n    <span class="code-keyword"><span class="code-keyword">super</span></span>(props);\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.state = {count: props.initialCount};\n  }\n  <span class="code-comment"><span class="code-comment">// ...</span></span>\n}</code></pre>\n<p>在使用&nbsp;<code>React.createClass</code>&nbsp;时，可以为传入的对象参数添加一个&nbsp;&nbsp;<code>getInitialState</code>&nbsp;方法并返回一个初始状态值：\n</p>\n<pre class="actionscript"><code class="language-javascript"><span class="code-keyword"><span\n        class="code-keyword">var</span></span> Counter = React.createClass({\n  getInitialState: <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">function</span></span></span><span class="hljs-function"><span\n            class="hljs-params">(</span></span><span class="hljs-params"></span><span class="hljs-function"><span\n            class="hljs-params">)</span> </span></span>{\n    <span class="code-keyword"><span class="code-keyword">return</span></span> {count: <span class="code-keyword"><span\n            class="code-keyword">this</span></span>.props.initialCount};\n  },\n  <span class="code-comment"><span class="code-comment">// ...</span></span>\n});</code></pre>\n\n<h4 id="h4-3">自动绑定</h4>\n<p>当使用ES6的 <em>class </em>关键字声明一个React组件时，类中的方法遵循与常规的方法一样的定义。这就意味着在类中申明的方法在执行时并不会自动属于当前实例，必须在构造函数中显示的使用.bind(this)方法绑定到当前实例：\n</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span\n        class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span\n        class="code-title"><span class="hljs-class"><span class="code-title">SayHello</span></span></span><span\n        class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  <span class="code-keyword">constructor</span>(props) {\n    <span class="code-keyword"><span class="code-keyword">super</span></span>(props);\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.state = {message: <span\n            class="code-string"><span class="hljs-symbol">\'Hello</span>!\'</span>};\n    <span class="code-comment"><span class="code-comment">// 必须，否在在handleClick中this将指向调用对象</span></span>\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.handleClick = <span\n            class="code-keyword"><span class="code-keyword">this</span></span>.handleClick.bind(<span\n            class="code-keyword"><span class="code-keyword">this</span></span>);\n  }\n\n  handleClick() {\n    alert(<span class="code-keyword"><span class="code-keyword">this</span></span>.state.message);\n  }\n\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> (\n      <span class="xml"><span class="code-tag">&lt;<span class="code-name">button</span> <span\n              class="hljs-attr">onClick</span>=<span class="code-string">{<span class="code-keyword">this</span>.handleClick}</span>&gt;</span>\n        <span class="code-type">Say</span> hello\n      <span class="code-tag">&lt;/<span class="code-name">button</span>&gt;</span></span>\n    );\n  }\n}</code></pre>\n<p>在使用&nbsp;<code>React.createClass</code>&nbsp;时不必绑定所有的方法：</p>\n<pre class="javascript"><code class="language-javascript"><span class="code-keyword"><span\n        class="code-keyword">var</span></span> SayHello = React.createClass({\n  getInitialState: <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">function</span></span></span><span class="hljs-function">(</span><span\n            class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{\n    <span class="code-keyword"><span class="code-keyword">return</span></span> {message: <span class="code-string"><span\n            class="code-string">\'Hello!\'</span></span>};\n  },\n\n  handleClick: <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">function</span></span></span><span class="hljs-function">(</span><span\n            class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{\n    alert(<span class="code-keyword"><span class="code-keyword">this</span></span>.state.message);\n  },\n\n  render: <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">function</span></span></span><span\n            class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span\n            class="hljs-params"></span>) </span></span>{\n    <span class="code-keyword"><span class="code-keyword">return</span></span> (\n      <span class="xml"><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n              class="code-name"><span class="xml"><span class="code-tag"><span\n              class="code-name">button</span></span></span></span><span class="xml"><span\n              class="code-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="code-tag"><span\n              class="hljs-attr">onClick</span></span></span></span><span class="xml"><span\n              class="code-tag">=</span></span><span class="code-string"><span class="xml"><span class="code-tag"><span\n              class="code-string">{this.handleClick}</span></span></span></span><span class="xml"><span\n              class="code-tag">&gt;</span></span></span><span class="xml">\n        Say hello\n      </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span\n              class="xml"><span class="code-tag"><span class="code-name">button</span></span></span></span><span\n              class="xml"><span class="code-tag">&gt;</span></span></span></span>\n    );\n  }\n});</code></pre>\n<p>以上的特性意味着使用ES6编写代码每一个方法都会额外增加一些样板式代码，但是对于大型应用来说代码结构更清晰。</p>\n<p>如果十分排斥样板式代码，可以启用Babal的 类属性功能（&nbsp;<a title="Class Properties" href="https://babeljs.io/docs/plugins/transform-class-properties/"\n                                         rel="nofollow">Class Properties</a>&nbsp;），利用双箭头来创建方法：</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span\n        class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span\n        class="code-title"><span class="hljs-class"><span class="code-title">SayHello</span></span></span><span\n        class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  <span class="code-keyword">constructor</span>(props) {\n    <span class="code-keyword"><span class="code-keyword">super</span></span>(props);\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.state = {message: <span\n            class="code-string"><span class="hljs-symbol">\'Hello</span>!\'</span>};\n  }\n\n  handleClick = () =&gt; {\n    alert(<span class="code-keyword"><span class="code-keyword">this</span></span>.state.message);\n  }\n\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> (\n      <span class="xml"><span class="code-tag">&lt;<span class="code-name">button</span> <span\n              class="hljs-attr">onClick</span>=<span class="code-string">{<span class="code-keyword">this</span>.handleClick}</span>&gt;</span>\n        <span class="code-type">Say</span> hello\n      <span class="code-tag">&lt;/<span class="code-name">button</span>&gt;</span></span>\n    );\n  }\n}</code></pre>\n<p>需要注意的是，目前这个功能还是实验性的，双箭头的表达式很有可能会调整。该提议不一定会被委员会接纳。</p>\n<p>如果非常想要尝试这种写法，你可以有这几种实现方式：</p>\n<ol>\n    <li>在构造函数中绑定方法。</li>\n    <li>使用箭头来定义方法。</li>\n    <li>使用&nbsp;<code>React.createClass</code>&nbsp;。</li>\n</ol>\n\n<h4 id="h4-4">代码混合器</h4>\n<blockquote>\n    <p>注意：</p>\n    <p>ES6在目前的方案中并不支持代码混合功能，因此在使用ES6编写React代码时并不能实现相关功能。</p>\n    <p>官方也收到许多在使用混合器时遇到的问题，强烈建议不要在新的代码中使用混合器功能。</p>\n    <p>以下的内容仅供参考。</p>\n</blockquote>\n<p>某些时候2个不同的组件需要共享一些相同的方法或者功能。这种情况我们称为 横切关联（&nbsp;<a title="cross-cutting concerns" href="https://en.wikipedia.org/wiki/Cross-cutting_concern"\n                                                     rel="nofollow">cross-cutting concerns</a>）。&nbsp;<a title="React.createClass"\n        href="https://facebook.github.io/react/docs/top-level-api.html#react.createclass" rel="nofollow"><code>React.createClass</code></a>&nbsp;可以通过继承来实现组件间公用相同方法。\n</p>\n<p>一个通用的案例是一个组件需要定期更新自己的状态，只要使用<code>setInterval()</code>就可以实现。但是当您不再需要它来节省内存时，取消定时器是很重要的。React提供了生命周期方法来通知创建和销毁事件。下面的代码创建了一个肩带的混合器，混合器的作用是当组件被销毁之前，可以清除已有的定时器：\n</p>\n<pre class="javascript"><code class="language-javascript"><span class="code-comment"><span class="code-comment">// 定义一个混合器</span></span>\n<span class="code-keyword"><span class="code-keyword">var</span></span> SetIntervalMixin = {\n  <span class="code-comment"><span class="code-comment">//组件将要被渲染时调用</span></span>\n  componentWillMount: <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">function</span></span></span><span class="hljs-function">(</span><span\n            class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.intervals = [];\n  },\n  <span class="code-comment"><span class="code-comment">// 设置定时器方法</span></span>\n  setInterval: <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">function</span></span></span><span class="hljs-function">(</span><span\n            class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.intervals.push(setInterval.apply(<span\n            class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="code-built_in"><span\n            class="code-built_in">arguments</span></span>));\n  },\n\n  <span class="code-comment"><span class="code-comment">//组件将要被卸载时调用</span></span>\n  componentWillUnmount: <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">function</span></span></span><span class="hljs-function">(</span><span\n            class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.intervals.forEach(clearInterval);\n  }\n};\n\n<span class="code-keyword"><span class="code-keyword">var</span></span> TickTock = React.createClass({\n  mixins: [SetIntervalMixin], <span class="code-comment"><span class="code-comment">// 设定混合器</span></span>\n  getInitialState: <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">function</span></span></span><span class="hljs-function">(</span><span\n            class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{\n    <span class="code-keyword"><span class="code-keyword">return</span></span> {seconds: <span class="hljs-number"><span\n            class="hljs-number">0</span></span>};\n  },\n  componentDidMount: <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">function</span></span></span><span class="hljs-function">(</span><span\n            class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.setInterval(<span\n            class="code-keyword"><span class="code-keyword">this</span></span>.tick, <span class="hljs-number"><span\n            class="hljs-number">1000</span></span>); <span class="code-comment"><span class="code-comment">// 调用混合器中的setInterval 方法</span></span>\n  },\n  tick: <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">function</span></span></span><span\n            class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span\n            class="hljs-params"></span>) </span></span>{\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.setState({seconds: <span\n            class="code-keyword"><span class="code-keyword">this</span></span>.state.seconds + <span\n            class="hljs-number"><span class="hljs-number">1</span></span>});\n  },\n  render: <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">function</span></span></span><span\n            class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span\n            class="hljs-params"></span>) </span></span>{\n    <span class="code-keyword"><span class="code-keyword">return</span></span> (\n      <span class="xml"><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n              class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">p</span></span></span></span><span\n              class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n        React has been running for {this.state.seconds} seconds.\n      </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span\n              class="xml"><span class="code-tag"><span class="code-name">p</span></span></span></span><span class="xml"><span\n              class="code-tag">&gt;</span></span></span></span>\n    );\n  }\n});\n\nReactDOM.render(\n  <span class="xml"><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n          class="code-name"><span class="xml"><span class="code-tag"><span\n          class="code-name">TickTock</span></span></span></span><span class="xml"><span\n          class="code-tag"> /&gt;</span></span></span><span class="xml">,\n  document.getElementById(\'example\')\n);</span></span></code></pre>\n<p>如果组件使用了多个混合器并且很多混合器定义了相同的生命周期方法，比如同时定义了componentWillUnmount方法当组件卸载时注销某些资源。所有混合器的生命周期方法都会被调用，React会按照混合器设定的顺序来执行。</p>\n\n<h3 id="h3-2">不使用JSX</h3>\n<p>对于React来说JSX并不是必须要使用的表达式。当在环境中不想在家额外的编译工具时尤其适用。</p>\n<p>每一个JSX的元素都仅仅是<code>React.createElement(component, props, ...children)</code>的语法糖，所以任何使用JSX表达式实现的内容都可以直接用JavaScript来实现。\n</p>\n<p>例如下面使用JSX编码的例子：</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span\n        class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span\n        class="code-title"><span class="hljs-class"><span class="code-title">Hello</span></span></span><span\n        class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="xml"><span class="code-tag">&lt;<span\n            class="code-name">div</span>&gt;</span><span class="code-type">Hello</span> {<span\n            class="code-keyword">this</span>.props.toWhat}<span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>;\n  }\n}\n\n<span class="code-type">ReactDOM</span>.render(\n  <span class="xml"><span class="code-tag">&lt;<span class="code-name"><span class="code-type">Hello</span></span> <span\n          class="hljs-attr">toWhat</span>=<span class="code-string"><span class="code-string">"World"</span></span> /&gt;</span>,\n  document.getElementById(<span class="hljs-symbol">\'roo</span>t\')\n);</span></code></pre>\n<p>如果我们不想使用JSX，可以将其修改为：</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span\n        class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span\n        class="code-title"><span class="hljs-class"><span class="code-title">Hello</span></span></span><span\n        class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="code-type">React</span>.createElement(<span\n            class="code-string"><span class="hljs-symbol">\'di</span>v\'</span>, <span class="hljs-literal"><span\n            class="hljs-literal">null</span></span>, <span class="code-string">`<span\n            class="code-type">Hello</span> <span class="hljs-subst">${<span class="code-keyword">this</span>.props.toWhat}</span>`</span>);\n  }\n}\n\n<span class="code-type">ReactDOM</span>.render(\n  <span class="code-type">React</span>.createElement(<span class="code-type">Hello</span>, {toWhat: <span\n            class="code-string"><span class="hljs-symbol">\'Worl</span>d\'</span>}, <span class="hljs-literal"><span\n            class="hljs-literal">null</span></span>),\n  <span class="code-built_in">document</span>.getElementById(<span class="code-string"><span\n            class="hljs-symbol">\'roo</span>t\'</span>)\n);</code></pre>\n<p>如果你对JSX如何转换成JavaScript有很强的兴趣，可以打开这个在线编译器试试：<a title="the online Babel compiler"\n        href="https://babeljs.io/repl/#?babili=false&amp;evaluate=true&amp;lineWrap=false&amp;presets=es2015%2Creact%2Cstage-0&amp;code=function%20hello()%20%7B%0A%20%20return%20%3Cdiv%3EHello%20world!%3C%2Fdiv%3E%3B%0A%7D"\n        rel="nofollow">the online Babel compiler</a>。</p>\n<p>组件被编译成一段字符串、由&nbsp;<code>React.Component</code>创建的子类或者一个普通无状态的组件。</p>\n<p>如果对编码时每次都要键入长长React.createElement感到痛苦，一个常见的模式是分配一个别名：</p>\n<pre class="javascript"><code class="language-javascript"><span class="code-keyword"><span\n        class="code-keyword">const</span></span> e = React.createElement;\n\nReactDOM.render(\n  e(<span class="code-string"><span class="code-string">\'div\'</span></span>, <span class="hljs-literal"><span\n            class="hljs-literal">null</span></span>, <span class="code-string"><span\n            class="code-string">\'Hello World\'</span></span>),\n  <span class="code-built_in"><span class="code-built_in">document</span></span>.getElementById(<span\n            class="code-string"><span class="code-string">\'root\'</span></span>)\n);</code></pre>\n<p></p>'},352:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<p><a href="https://www.chkui.com/article/spring/spring_core_bean_post_processors" title="Spring核心——IOC处理器扩展">上一篇文章</a>介绍了非侵入式的框架的概念以及IOC的功能扩展点之一——BeanPostProcessor，我们接下来的内容继续说明IoC更多的扩展方法。\n</p>\n\n<h2 id="h2-1">BeanFactoryPostProcessor</h2>\n<p>BeanFactoryPostProcessor是针对整个容器的后置处理器。他的使用也非常简单，只要向容器中添加一个继承BeanFactoryPostProcessor的Bean即可。</p>\n\n<h3 id="h3-1">如何使用</h3>\n<p>继承了BeanFactoryPostProcessor接口的类PostProcessors：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.xml.beanfactorypostprocessor;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">PostProcessors</span> <span class="code-keyword">implements</span> <span\n            class="code-title">BeanFactoryPostProcessor</span></span>{\n<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span\n            class="code-keyword">throws</span> BeansException </span>{\n         <span class="code-comment">//DO</span>\n    }\n}</code></pre>\n<p>然后再向容器中添加这个Bean就增加了一个BeanFactoryPostProcessor。</p>\n<pre><code class="xml"><span class="php"><span class="code-meta">&lt;?</span>xml version=<span\n        class="code-string">"1.0"</span> encoding=<span class="code-string">"UTF-8"</span><span\n        class="code-meta">?&gt;</span></span>\n<span class="code-comment">&lt;!-- xml.beanfactorypostprocessor --&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">beans</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"chkui.springcore.example.xml.beanfactorypostprocessor.PostProcessors"</span> /&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>BeanFactoryPostProcessor主要用于处理容器相关的内容，他被触发时机是在IoC容器加载完各种配置后，还没执行Bean的初始化之前。这个时候除了PostProcessors这个Bean，其他任何Bean都没有被创建。&nbsp;所以在BeanFactoryPostProcessor处理Bean是不合适的，Bean应该要到BeanPostProcessor中去处理，2者的区别就是前者面向容器，后者面向Bean。接下来将通过一个详细例子来说明BeanFactoryPostProcessor和BeanPostProcessor的区别以及使用方式。期间还会介绍BeanDefinitio相关的内容。</p>\n\n<h3 id="h3-2">BeanFactoryPostProcessor与BeanPostProcessor使用</h3>\n<p><span style="color:#e74c3c">（文中仅仅是示例代码，无法运行，源码在</span><a href="https://gitee.com/chkui-com/spring-core-sample"\n                                                            rel="nofollow"><span style="color:#e74c3c">https://gitee.com/chkui-com/spring-core-sample</span></a><span\n        style="color:#e74c3c">，如需下载请自行clone）</span></p>\n\n<h4 id="h4-1"><span style="color:null">建造者模式</span></h4>\n<p>下面将会通过一个例子介绍2者的使用方式和使用场景。例子使用建造者模式模拟组装一台个人电脑，分为一下3步：</p>\n<ol>\n    <li>&nbsp;容器启动之后，会将电脑的所有“配件”（Cpu、Graphics、Ram）都添加到容器中。</li>\n    <li>&nbsp;在PostProcessorS实现BeanFactoryPostProcessor接口，它的功能是向容器添加一个Pc对象。</li>\n    <li>&nbsp;在PostProcessor实现BeanPostProcessor接口。他的工作是组装电脑——每一个Bean都会检查域上的@Autowired注解，并注入对应的部件，部件也会标记自己所属的电脑。</li>\n</ol>\n<p>下面是XML配置文件，它负责将Cpu、显卡、内存等电脑常用品牌的部件放置到容器中等待组装。此外它还添加了PostProcessorS和PostProcessor两个后置处理器用于装载电脑。</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"chkui.springcore.example.xml.beanfactorypostprocessor.bean.Cpu"</span>&gt;</span>\n     \t<span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"brand"</span> <span class="hljs-attr">value</span>=<span\n                class="code-string">"Amd"</span>/&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n    \n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"chkui.springcore.example.xml.beanfactorypostprocessor.bean.Graphics"</span>&gt;</span>\n     \t<span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"brand"</span> <span class="hljs-attr">value</span>=<span class="code-string">"Nvdia"</span>/&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n    \n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"chkui.springcore.example.xml.beanfactorypostprocessor.bean.Ram"</span>&gt;</span>\n     \t<span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"brand"</span> <span class="hljs-attr">value</span>=<span class="code-string">"Kingston"</span>/&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n    \n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"chkui.springcore.example.xml.beanfactorypostprocessor.PostProcessor"</span> /&gt;</span>\n    \n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"chkui.springcore.example.xml.beanfactorypostprocessor.PostProcessors"</span> /&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>下面是一个Cpu对象的结构，他标记了品牌和所属电脑。Graphics和Ram的结构和它一模一样。</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.xml.beanfactorypostprocessor.bean;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Cpu</span> </span>{\n\t<span class="code-keyword">private</span> String brand;\n\t\n\t<span class="code-meta">@Autowired</span>\n\t<span class="code-keyword">private</span> Pc belong;\n}</code></pre>\n<p>注意这里的@Autowired注解，我们的配置文件并没有开启Spring的自动装配功能，我们将在PostProcessor实现自动装配。</p>\n<p>PostProcessorS的作用是向容器动态添加一个之前未定义的Bean——Pc。</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.xml.beanfactorypostprocessor;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">PostProcessors</span> <span class="code-keyword">implements</span> <span\n            class="code-title">BeanFactoryPostProcessor</span></span>{\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span\n            class="code-keyword">throws</span> BeansException </span>{\n\t\t<span class="code-comment">//获取容器的注册接口</span>\n\t\tBeanDefinitionRegistry registry = (BeanDefinitionRegistry)beanFactory;\n\t\t<span class="code-comment">//新建一个BeanDefinition用于动态装配Bean</span>\n\t\tGenericBeanDefinition defininition = <span class="code-keyword">new</span> GenericBeanDefinition();\n\t\t<span class="code-comment">//设置要添加的类</span>\n\t\tdefininition.setBeanClass(Pc.class);\n\t\t<span class="code-comment">//注册BeanDefinition</span>\n\t\tregistry.registerBeanDefinition(<span class="code-string">"postBean"</span>, defininition);\n\t}\n}</code></pre>\n<p>如果看过 <a href="https://www.chkui.com/article/spring/spring_core_context_and_ioc" title="Spring核心——上下文与IoC">Ioc结构介绍的这篇文章</a>，你就会知道BeanFactory经过层层派生，实际上大部分接口都在一个类实现——DefaultListableBeanFactory，它除了实现ConfigurableListableBeanFactory接口，还实现了BeanDefinitionRegistry接口。BeanDefinitionRegistry提供了BeanDefinition的管理功能。\n</p>\n\n<h4 id="h4-2">BeanDefinition与适配器模式</h4>\n<p>\n    在上面的代码中出现了BeanDefinition接口，这里就顺道说一说这个有趣的小玩意。关于他如何使用Spring的官网并没有太详细的介绍（至少我没找到），网上倒是有各路大神的博客在解读他的源码，不过代码只是表象，要理解他的整套设计思路才能提升。</p>\n<p>关于BeanDefinition的使用模式，官网将其称呼为<em>configuration metadata</em>，直译过来叫“配置元数据”。&nbsp;他的作用有点类似于<a\n        href="https://www.chkui.com/article/spring/spring_core_context_and_ioc" title="Spring核心——上下文与IoC">Context分层应用的效果（见Spring核心——上下文与IoC&nbsp;关于\n    ApplicationContext的说明）</a>，目的就是将Bean的配置和初始化工作分成2个互不干扰的部分。</p>\n<p>我们知道 Spring现在支持各种各样的方式来添加Bean，比如在XML配置文件中使用&lt;bean&gt;标签、使用@Component以及他的派生类注解、可以在@Configuration类中生成、甚至还可以通过RMI实现远程配置等等。如果所有的这些配置来源直接和IoC容器产生关系生成Bean，那么耦合度、代码复杂度会越来越高，而且以后指不定什么时候又会加入什么新的配置方式。</p>\n<p>\n    为了解决这个问题Spring的大神们引入了适配器模式——IoC容器只接受BeanDefinition接口，IoC如何初始化一个Bean是仅仅是看BeanDefinition里的信息。而各种配置方式都有自己的适配器，所有的适配器都会根据他所需要处理的内容来生成一个BeanDefinition的实现类。这样，如果新增一个新的配置方式，增加一个适配器就可以搞定。</p>\n<p><img align="left" alt="Spring核心——IOC功能扩展点" height="381"\n        src="https://static.oschina.net/uploads/img/201807/11171429_ggwk.png" width="600"></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p>所以，我们也可以利用BeanDefinitionRegistry接口向容器添加一个BeanDefinition，进而在随后的执行过程中IoC容器会根据 这个BeanDefinition创建一个对应的Bean。</p>\n\n<h4 id="h4-3">BeanPostProcessor</h4>\n<p>\n    前面已经提到，BeanFactoryPostProcessor用于处理容器级别的问题，而BeanPostProcessor用来处理每一个Bean。我们前面已经用BeanFactoryPostProcessor向容器添加了一个Pc对象的Bean，接下来我们在BeanPostProcessor中处理每一个Bean的自动注入注解。</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.xml.beanfactorypostprocessor;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">PostProcessor</span> <span class="code-keyword">implements</span> <span\n            class="code-title">BeanPostProcessor</span>, <span class="code-title">BeanFactoryAware</span> </span>{\n\t<span class="code-keyword">private</span> ConfigurableListableBeanFactory beanFactory;\n\t<span class="hljs-function"><span class="code-keyword">public</span> Object <span class="code-title">postProcessBeforeInitialization</span><span\n            class="hljs-params">(Object bean, String beanName)</span> </span>{\n        <span class="code-keyword">return</span> autowiredImplement(bean);\n    }\n\t<span class="hljs-function"><span class="code-keyword">public</span> Object <span class="code-title">postProcessAfterInitialization</span><span\n            class="hljs-params">(Object bean, String beanName)</span> </span>{\n        <span class="code-keyword">return</span> bean;\n    }\n\t\n\t<span class="code-comment">//自定义实现autowired功能</span>\n\t<span class="hljs-function"><span class="code-keyword">private</span> Object <span class="code-title">autowiredImplement</span><span\n            class="hljs-params">(<span class="code-keyword">final</span> Object bean)</span> </span>{\n\t\t<span class="code-keyword">for</span>(Field field : bean.getClass().getDeclaredFields()) {\n\t\t\tAutowired value = field.getAnnotation(Autowired.class);\n\t\t\t<span class="code-keyword">if</span>(<span class="code-keyword">null</span> != value) {\n\t\t\t\tObject obj = beanFactory.getBean(field.getType());\n\t\t\t\tfield.setAccessible(<span class="code-keyword">true</span>);\n\t\t\t\tfield.set(bean, obj);\n\t\t\t}\n\t\t}\n\t\t<span class="code-keyword">return</span> bean;\n\t}\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setBeanFactory</span><span class="hljs-params">(BeanFactory beanFactory)</span> <span\n            class="code-keyword">throws</span> BeansException </span>{\n\t\t<span class="code-keyword">this</span>.beanFactory = (ConfigurableListableBeanFactory)beanFactory;\n\t}\n}</code></pre>\n<p>这里的PostProcessor实现BeanFactoryAware接口来获取&nbsp;BeanFactory。自动注入的处理逻辑都在autowiredImplement方法中，它会扫描Bean的每一个域检查是否有@Autowired注解，如果有则根据这个域的Class类型到BeanFactory去获取对应的Bean，然后反射注入。</p>\n<p>最后我们创建一个ApplicationContext来运行他们：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">SampleApp</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n    \tApplicationContext context = <span class="code-keyword">new</span> ClassPathXmlApplicationContext(<span\n            class="code-string">"xml/beanfactorypostprocessor/config.xml"</span>);\n    \tPc pc = context.getBean(Pc.class);\n        <span class="code-comment">/**\n        Pc Info: Graphics=Nvdia, Cpu=Amd, Ram=Kingston]\n        */</span>\n        System.out.println(pc);\n    }\n}</code></pre>\n<p>本文介绍了BeanFactoryPostProcessor和BeanPostProcessor的使用方式，以及IoC容易是如何通过BeanDefinition装载各种配置的。后续还会持续介绍Spring\n    IoC容器的各种功能扩展点。</p>'}});