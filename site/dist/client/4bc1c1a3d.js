webpackJsonp([4],{344:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<p>JSR330是Jcp给出的官方标准反向依赖注入规范。Java大部分反向依赖注入的工具或者框架目前基本上都满足JSR330规范、例如spring、guice以及Dagger。</p>\n<p>以我们最常用的spring为例。</p>\n<p>JSR中<span style="color:#cc0000">@Inject</span>可以当做<span style="color:#cc0000">@AutoWired</span>来使用。而<span\n        style="color:#cc0000">@Named</span>可以当做<span style="color:#cc0000">@Component</span>来使用。</p>\n<p>使用JSR330首先要引入javax.inject包：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">dependency</span>&gt;</span>  \n    <span class="code-tag">&lt;<span class="code-name">groupId</span>&gt;</span>javax.inject<span class="code-tag">&lt;/<span\n            class="code-name">groupId</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">artifactId</span>&gt;</span>javax.inject<span class="code-tag">&lt;/<span\n            class="code-name">artifactId</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">version</span>&gt;</span>1<span class="code-tag">&lt;/<span\n            class="code-name">version</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">dependency</span>&gt;</span> </code></pre>\n<p>目前Maven中央仓库中就一个inject的jar。</p>\n<p>首先使用xml配置通过注解扫描添加bean。</p>\n<pre><code class="xml"><span class="php"><span class="code-meta">&lt;?</span>xml version=<span\n        class="code-string">"1.0"</span> encoding=<span class="code-string">"UTF-8"</span><span\n        class="code-meta">?&gt;</span></span>\n<span class="code-tag">&lt;<span class="code-name">beans</span> <span class="hljs-attr">xmlns</span>=<span\n        class="code-string">"http://www.springframework.org/schema/beans"</span>\n    <span class="hljs-attr">xmlns:xsi</span>=<span\n            class="code-string">"http://www.w3.org/2001/XMLSchema-instance"</span>\n    <span class="hljs-attr">xmlns:context</span>=<span class="code-string">"http://www.springframework.org/schema/context"</span>  \n    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="code-string">"http://www.springframework.org/schema/beans  \n    http://www.springframework.org/schema/beans/spring-beans-3.1.xsd  \n    http://www.springframework.org/schema/context  \n    http://www.springframework.org/schema/context/spring-context-3.1.xsd"</span>&gt;</span>  \n    <span class="code-tag">&lt;<span class="code-name">context:component-scan</span>  <span class="hljs-attr">base-package</span>=<span\n            class="code-string">"com.demo.jsr330"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span>  </code></pre>\n<p>然后像下面这个添加一个bean</p>\n<pre><code class="java"><span class="code-meta">@Named</span>  \n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">service</span> </span>{\n  <span class="hljs-function"><span class="code-keyword">public</span>  <span class="code-keyword">void</span>   <span\n          class="code-title">print</span><span class="hljs-params">()</span></span>{\n     System.out.println(<span class="code-string">"Service  print  method is invoked"</span>);  \n  }  \n}  </code></pre>\n<p>然后将这个bean注入到其他bean中去使用</p>\n<pre><code class="java"><span class="code-meta">@Named</span>  \n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Faction</span> </span>{\n  <span class="code-meta">@Inject</span>\n  Service service;\n\n  <span class="hljs-function"><span class="code-keyword">public</span>  <span class="code-keyword">void</span>  <span\n          class="code-title">show</span><span class="hljs-params">()</span></span>{\n     service.print()； \n  }  \n}  </code></pre>\n<p>JSR330还定义了<span style="color:#FF0000">@Qualifier</span>和<span style="color:#FF0000">@Provider</span>，对应到spring都给出了标准的实现。\n</p>\n<p>使用JSR330代替原注解的好处是无论使用任何反向依赖注入工具或框架，只要他是支持JSR330的，都可以平滑的切换。</p>'},350:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h2 id="h2-1">Maven生命周期阶段</h2>\n<p>Maven为打包过程提供了各种各样的生命周期功能，主要有：</p>\n<ol>\n    <li>Validate：验证，对工程的所有内容进行验证。</li>\n    <li>compile：编译。</li>\n    <li>test：运行测试用例。</li>\n    <li>package：将代码进行打包并生成到本地。</li>\n    <li>integration-test：与其他的工程进行集成测试，会将依赖内容放置到一个统一环境中。</li>\n    <li>verify：校验功能，检查包的质量。</li>\n    <li>install：将打包之后的文件放置到本地仓库。</li>\n    <li>deploy：将已经打包的文件放置到远程仓库。</li>\n    <li>clean：清除之前构建的内容。</li>\n    <li>site：针对当前的工程生成一个可视化的站点文档。</li>\n</ol>\n<h2 id="h2-2">常用命令</h2>\n<p>对应以上生命周期都有一个对应的命令。</p>\n<ol>\n    <li><code>mvn compile</code>，编译代码，编译之后代码会出现在/target目录中，整合了IDE会自动执行这个步骤。</li>\n    <li><code>mvn test</code>，运行单元测试。</li>\n    <li><code>mvn test-compile</code>, 编译测试用用欧，并执行。如果在IDE中通过IDE会自定对单元测试代码打包。</li>\n    <li><code>mvn package</code>，对项目进行打包，打包之后会出现在/targer目录下。</li>\n    <li><code>mvn install</code>，安装包，会将打包之后的包安装到本地仓库对应的位置。</li>\n    <li><code>mvn deploy</code>，将包发布到远程仓库。</li>\n</ol>\n<p>maven打包基本上就涉及以上命令，除此之外还有一些配套的命令：</p>\n<ol>\n    <li><code>mvn site</code>，输出到/target一个依赖视图文档。</li>\n    <li>``</li>\n</ol>\n<h2 id="h2-3">Xml文件元素定义</h2>\n<ol>\n    <li>project：整个XML文档的最顶层标签。</li>\n    <li>modelVersion：使用的maven模型版本<code>&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</code></li>\n    <li>groupId：组织Id。<code>&lt;groupId&gt;com.mycompany.app&lt;/groupId&gt;</code></li>\n    <li>artifactId：标识符号id。<code>&lt;artifactId&gt;my-app&lt;/artifactId&gt;</code></li>\n    <li>packaging：打包模式， 例如JAR, WAR, EAR。<code>&lt;packaging&gt;jar&lt;/packaging&gt;</code></li>\n    <li>version：当前的版本号。<code>&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</code></li>\n    <li>name：项目名称。<code>&lt;name&gt;Maven Quick Start Archetype&lt;/name&gt;</code></li>\n    <li>url：项目地址。<code>&lt;url&gt;http://maven.apache.org&lt;/url&gt;</code></li>\n    <li>description: 项目介绍。</li>\n</ol>\n<h2 id="h2-4">测试用例运行规则</h2>\n<p>测试用例在运行的时候装载和排除一下格式的文件。\n    包含：</p>\n<ol>\n    <li><code>**/*Test.java</code></li>\n    <li><code>**/Test*.java</code></li>\n    <li><code>**/*TestCase.java</code></li>\n</ol>\n<p>排除：</p>\n<ol>\n    <li><code>**/Abstract*Test.java</code></li>\n    <li><code>**/Abstract*TestCase.java</code></li>\n</ol>\n<h2 id="h2-5">SNAPSHOT（快照版本）</h2>\n<p>当版本号使用<code>-SNAPSHOT</code>结构的后缀时表示这是一个快照版本。快照版本一般用于开发分支，快照版本即使不改变版本号也会自动获取到最新版本。以只相对的是发布（<code>Release</code>）版本，只要不使用<code>-SNAPSHOT</code>结尾的都是发布版本。每一个发布版本只对应一个编号。\n</p>\n<h2 id="h2-6">插件使用</h2>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">build</span>&gt;</span>\n  <span class="code-tag">&lt;<span class="code-name">plugins</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">plugin</span>&gt;</span>\n      <span class="code-tag">&lt;<span class="code-name">groupId</span>&gt;</span>org.apache.maven.plugins<span\n            class="code-tag">&lt;/<span class="code-name">groupId</span>&gt;</span>\n      <span class="code-tag">&lt;<span class="code-name">artifactId</span>&gt;</span>maven-compiler-plugin<span\n            class="code-tag">&lt;/<span class="code-name">artifactId</span>&gt;</span>\n      <span class="code-tag">&lt;<span class="code-name">version</span>&gt;</span>3.3<span class="code-tag">&lt;/<span\n            class="code-name">version</span>&gt;</span>\n      <span class="code-tag">&lt;<span class="code-name">configuration</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">source</span>&gt;</span>1.5<span class="code-tag">&lt;/<span\n            class="code-name">source</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">target</span>&gt;</span>1.5<span class="code-tag">&lt;/<span\n            class="code-name">target</span>&gt;</span>\n      <span class="code-tag">&lt;/<span class="code-name">configuration</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">plugin</span>&gt;</span>\n  <span class="code-tag">&lt;/<span class="code-name">plugins</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">build</span>&gt;</span>\n</code></pre>\n<p>\n    上面是在<code>build</code>过程中使用插件的一个配置。插件的使用方式和依赖比较类似，也是2级菜单引入一个插件，插件也是要标记<code>groupId</code>、<code>artifactId</code>以及<code>version</code>等内容。<code>configuration</code>标签用于向插件传递参数（插件就好像一个方法执行一个任务，某些方法需要我们提供参数才能正常运行）。\n</p>\n<p>这个配置会在build阶段被运行（package，install，deploy）。</p>\n<p>插件可以在maven执行的各个生命周期被使用。（<a href="http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html"\n                              title="maven生命周期">maven生命周期</a>）插件的类型繁多，除了直接通过<code>&lt;plugin&gt;</code>引入，实际上maven的各种标签功能也是通过插件实现的，需要知道使用某个插件可以查看官方提供的<a\n        href="http://maven.apache.org/plugins/" title="插件清单">插件清单</a>。</p>\n<p>##　资源文件管理</p>\n<p>一个Java程序肯定会涉及到各种各样的配置文件，在maven的结构下通常我们会将资源文件放置到<code>${root}/src/main/resources</code>目录下。如下面结构的<code>application.properties</code>。\n</p>\n<pre><code class="sql">my-app\n|<span class="code-comment">-- pom.xml</span>\n`<span class="code-comment">-- src</span>\n    |<span class="code-comment">-- main</span>\n    |   |<span class="code-comment">-- java</span>\n    |   |   `<span class="code-comment">-- com</span>\n    |   |       `<span class="code-comment">-- mycompany</span>\n    |   |           `<span class="code-comment">-- app</span>\n    |   |               `<span class="code-comment">-- App.java</span>\n    |   `<span class="code-comment">-- resources</span>\n    |       `<span class="code-comment">-- META-INF</span>\n    |           `<span class="code-comment">-- application.properties</span>\n    `<span class="code-comment">-- test</span>\n        `<span class="code-comment">-- java</span>\n            `<span class="code-comment">-- com</span>\n                `<span class="code-comment">-- mycompany</span>\n                    `<span class="code-comment">-- app</span>\n                        `<span class="code-comment">-- AppTest.java</span>\n</code></pre>\n<p>例如上面这个文件格式，</p>\n<p>对于maven项目而言，classpath的根路径是从java开始的，与之对应的，<code>/resources</code>路径也是一个classpath的root，编译或者打包后，会将<code>resource</code>中的文件合并到一个classpath中。如下图的是根据上面的结构打包成JAR之后的文件格式。\n</p>\n<pre><code class="sql">|<span class="code-comment">-- META-INF</span>\n|   |<span class="code-comment">-- MANIFEST.MF</span>\n|   |<span class="code-comment">-- application.properties</span>\n|   `<span class="code-comment">-- maven</span>\n|       `<span class="code-comment">-- com.mycompany.app</span>\n|           `<span class="code-comment">-- my-app</span>\n|               |<span class="code-comment">-- pom.properties</span>\n|               `<span class="code-comment">-- pom.xml</span>\n`<span class="code-comment">-- com</span>\n    `<span class="code-comment">-- mycompany</span>\n        `<span class="code-comment">-- app</span>\n            `<span class="code-comment">-- App.class</span>\n</code></pre>\n<p>META-INF用于存放程序入口的相关信息，可以将他理解为classpath的一个root，所以在其中的各种配置文件也可以直接在classpath中获取，除此之外还存在<code>MANIFEST.MF</code>、<code>pom.properties</code>、<code>pom.xml</code>等几个文件。这些问价那都是maven在<code>package</code>时生成的标准文件，<code>MANIFEST.MF</code>告知了程序的入口，另外两个文件标记了maven的依赖关系。\n</p>\n<p>对应的，也可以在test目录下建立一个<code>resources</code>目录，在执行单元测试的时候，它会被加入到单元测试时的classpath中。</p>\n<h2 id="h2-7">资源文件参数化</h2>\n<p>通常情况下，发布生产和发布测试某些参数肯定是不一样的（比如数据库链接参数），所以某些时候需要资源文件中的参数根据打包命令进行变更。这个使用会用到<code>&lt;resources&gt;</code>标签（插件）。</p>\n<p>替换参数的过程并不复杂，首先是如下图引入<code>&lt;resources&gt;</code>标签。</p>\n<pre><code class="xml">  <span class="code-tag">&lt;<span class="code-name">build</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">resources</span>&gt;</span>\n      <span class="code-tag">&lt;<span class="code-name">resource</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">directory</span>&gt;</span>src/main/resources<span\n            class="code-tag">&lt;/<span class="code-name">directory</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">filtering</span>&gt;</span>true<span\n            class="code-tag">&lt;/<span class="code-name">filtering</span>&gt;</span>\n      <span class="code-tag">&lt;/<span class="code-name">resource</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">resources</span>&gt;</span>\n  <span class="code-tag">&lt;/<span class="code-name">build</span>&gt;</span>\n</code></pre>\n<p>然后用<code>&lt;directory&gt;</code>表示要进行参数替换的路径位置，这里将会把<code>resource</code>目录中的内容全部替换。</p>\n<p>对应的，在配置文件中使用占位符表示要替换的内容：</p>\n<p>properties：</p>\n<pre><code class="apache"><span class="code-attribute">application</span>.name=<span class="code-variable">${project.name}</span>\n<span class="code-attribute">application</span>.version=<span class="code-variable">${project.version}</span>\n</code></pre>\n<p>yaml：</p>\n<pre><code class="yaml coffeescript">application:\n\tname: @project.name@\n\tversion: @project.version@\n</code></pre>\n<p>配置好之后可以通过<code>mvn process-resources</code>命令来检查文件替换的效果。执行后可以到/target/classses看到替换效果。除了使用<em>project.version</em>之类的固定参数，还可以使用<code>&lt;properties&gt;</code>在<strong>pom.xml</strong>文件中定义全局参数：\n</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">properties</span>&gt;</span>\n\t<span class="code-tag">&lt;<span class="code-name">my.value</span>&gt;</span>hello<span class="code-tag">&lt;/<span\n            class="code-name">my.value</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">properties</span>&gt;</span>\n</code></pre>\n<p>最后，maven还支持系统参数和Java运行时参数，比如：</p>\n<pre><code class="apache"><span class="code-attribute">java</span>.version=<span\n        class="code-variable">${java.version}</span>\n<span class="code-attribute">command</span>.line.prop=<span class="code-variable">${command.line.prop}</span>\n</code></pre>\n<p><code>${java.version}</code>可以获取到操作系统中Java的版本参数。maven本身是一个Java程序，所以<code>mvn process-resources\n    "-Dcommand.line.prop=hello again"</code>命令在启动jvm同时，还传入了<code>command.line.prop</code>的数据。</p>\n<h2 id="h2-8">依赖管理</h2>\n<p><code>&lt;dependencies&gt;</code>和<code>&lt;dependency&gt;</code>组合表示引入依赖。一项依赖通过<code>&lt;groupId&gt;</code>、<code>&lt;artifactId&gt;</code>、<code>&lt;version&gt;</code>引入。<code>&lt;scope&gt;</code>用于确定依赖包的使用范围，与maven的运行生命周期相对应。更多的标签说明参见\n    <a href="http://maven.apache.org/ref/3.6.1/maven-model/maven.html" title="官网Project Descriptor Reference">官网Project\n        Descriptor Reference</a>。</p>\n<h3 id="h3-1">依赖范围</h3>\n<ol>\n    <li>compile：这是默认的范围，引入的包会在mvn的整个生命周期内被用到。</li>\n    <li>provided：在编译和测试的时候都会引入该包，但是到了打包（<code>install</code>）之后的阶段将不会依赖这个包。主要应用场景是使用tomcat之类的容器，在开发和单元测试的时候并不会引入容器，但是需要引用某些包（比如Servlet）完成编译。但是打包放入容器后某些包容器已经提供了，不需要我们带入到classpath中。\n    </li>\n    <li>runtime：除了编译（<code>compile</code>）阶段，其他阶段都会被引入。</li>\n    <li>test：仅用于测试。</li>\n    <li>system：本地操作系统依赖，不会去仓库下载jar包，根据配置的路径（包括网络路径）查找包。</li>\n    <li>import：导入其他pom文件，该标签仅仅能适用于<code>&lt;dependencyManagement&gt;</code>依赖管理标签中。<a\n            href="http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html。"\n            title="参考这篇文章的说明">参考说明</a>。\n    </li>\n</ol>\n<p>关于maven的依赖机制见<a href="http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html"\n                   title="官网关于依赖的说明">官网关于依赖的说明</a>。</p>\n<h3 id="h3-2">包引入过程</h3>\n<p>对于maven而言，一个包最终被引入到项目中有很多层级。首先每个人的操作系统上都有一个本地仓库。在本地执行<code>mvn install</code>命令时都会将对应的包安装到这个仓库中。当其他工程需要这个包时候，maven也是直接到本地仓库获取。\n</p>\n<p>除了自己<code>install</code>的包，更多的时候都是使用第三发提供的包。需要用到某个包时都是先去本地仓路获取，如果不存在maven会到远程仓库去获取。</p>\n<h3 id="h3-3">仓库说明</h3>\n<p>前面已经提及maven的包加载过程涉及到2个仓路：本地仓库（默认位置：<code>${user.home}/.m2/repository</code>）和远程仓库（默认位置：repo.maven.apache.org/maven2/）。\n</p>\n<p>本地仓路可以通过修改<code>${Maven_HOme}/conf/setting.xml</code>的<code>&lt;localRepository&gt;</code>设定，远程仓库通过<code>&lt;mirrors&gt;</code>标签指定。详情见：<a\n        href="http://maven.apache.org/guides/introduction/introduction-to-repositories.html" title="远程仓库介绍">仓库介绍</a>、<a\n        href="http://maven.apache.org/guides/mini/guide-mirror-settings.html"\n        title="远程仓库Mirrors配置说明">远程仓库Mirrors配置说明</a>、<a href="http://maven.apache.org/repository/index.html"\n                                                       title="中央仓库结构">中央仓库结构</a>。</p>\n<h2 id="h2-9">发布到远程仓库</h2>\n<p>发布到远程仓库需要对本地pom.xml以及本机的setting.xml进行配置。\n    pom.xml文件增加：</p>\n<pre><code class="xml">  <span class="code-tag">&lt;<span class="code-name">distributionManagement</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">repository</span>&gt;</span>\n      <span class="code-tag">&lt;<span class="code-name">id</span>&gt;</span>mycompany-repository<span class="code-tag">&lt;/<span\n            class="code-name">id</span>&gt;</span>\n      <span class="code-tag">&lt;<span class="code-name">name</span>&gt;</span>MyCompany Repository<span\n            class="code-tag">&lt;/<span class="code-name">name</span>&gt;</span>\n      <span class="code-tag">&lt;<span class="code-name">url</span>&gt;</span>scp://repository.mycompany.com/repository/maven2<span\n            class="code-tag">&lt;/<span class="code-name">url</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">repository</span>&gt;</span>\n  <span class="code-tag">&lt;/<span class="code-name">distributionManagement</span>&gt;</span>\n</code></pre>\n<p>setting.xml配置：</p>\n<pre><code class="xml"> <span class="code-tag">&lt;<span class="code-name">servers</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">server</span>&gt;</span>\n      <span class="code-comment">&lt;!-- 使用账号密码登录 --&gt;</span>\n      <span class="code-tag">&lt;<span class="code-name">id</span>&gt;</span>mycompany-repository<span class="code-tag">&lt;/<span\n            class="code-name">id</span>&gt;</span>\n      <span class="code-tag">&lt;<span class="code-name">username</span>&gt;</span>jvanzyl<span\n            class="code-tag">&lt;/<span class="code-name">username</span>&gt;</span>\n      <span class="code-comment">&lt;!-- 使用ssh登录 --&gt;</span>\n      <span class="code-tag">&lt;<span class="code-name">privateKey</span>&gt;</span>/path/to/identity<span\n            class="code-tag">&lt;/<span class="code-name">privateKey</span>&gt;</span>\n      <span class="code-tag">&lt;<span class="code-name">passphrase</span>&gt;</span>my_key_passphrase<span\n            class="code-tag">&lt;/<span class="code-name">passphrase</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">server</span>&gt;</span>\n  <span class="code-tag">&lt;/<span class="code-name">servers</span>&gt;</span>\n</code></pre>\n<p>远程服务器的权限有各种各样的规则——<a href="http://maven.apache.org/guides/mini/guide-encryption.html" title="参考文件">参考文件</a>。</p>\n<p>参考资料：<a href="http://maven.apache.org/guides/getting-started/index.html" title="官网介绍">官网介绍</a>。</p>'},354:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h2 id="h2-1">Niubility的Nodejs &nbsp;&nbsp;</h2>\n<p>关于大名鼎鼎的Nodejs是什么就不用再介绍了，他的牛逼之处数都数不完——让javascript称霸全宇宙、将一个只用于前端的编程语言同时可以制霸前后端、让致力于前端开发的小哥又多了一项事业新增了一门手艺、亮瞎人的全异步事件驱动型架构（event-driven、non-blocking、scalability）。总的来说就是，学好Nodejs必须能够赚大钱迎娶白富美。</p>\n<p>本人一直垂涎与Nodejs的鼎鼎大名，但是由于工作繁忙，一直没时间深入亵玩。最近因为一些机缘，又要着手一些前端开发的工作才觅得一次全面接触的良机。</p>\n<p>看到这里你肯定要说，又是一个要把Nodejs吹上天的文章！NoNo，本文会一步一步的说明我是怎么学会和用上nodejs的，然后结合其我所了解的语言告诉各位我所了解的Nodejs坑和优势。</p>\n\n<h2 id="h2-2">学习基础</h2>\n<p>先说说本人开始学习使用的基础。早期在某外企开发室内3D设计软件，那段时间用已经成为古董的MFC做各种windows事件驱动开发。</p>\n<p>之后就一直在做Java生态的东西、反正就是SSH啦、MVC啦、Dao啦、Entity啦、JNDI啦、JDBC啦等等，相信每个Javaer都懂的。早些年做Java时，前端部分基本就是玩转Jsp，页面清一色的用Jsp动态生成，然后丢给浏览器。现在所属团队几乎已经放弃这种方式，都是用spring-boot等弄前后端分离了。</p>\n<p>随后有幸接到一个自己可以全权负责的全新的项目，于是带着2个人开始尝试抛弃JSP，引入了大量的ajax异步请求的客户端组装数据。那时候这样做其实蛮痛苦的，新项目根本没有真正意义的前端开发人员（都玩JSP呢），所以自己不得不去研究前端的各种前端技术。在随后的许多时光中，深入且大量的学习了前端开发的所有东西，从一穷二白只会用div画画静态页面，到后面自己封装列表、消息通知等组件，通杀jquery、angularjs，了解各种脚手架。所以学习Nodejs开发，我基本上是没有语言障碍的，只是需要跟上它的思路。</p>\n\n<h2 id="h2-3">安装Nodejs</h2>\n<p>要用一样东西之前，当然是要先安装环境。Nodejs的安装网上一搜一大把，这里就简单记录一下流程，方面以后查阅。因为本人用一台windows（windows10）办公、用一台linux（ubuntu16.04）开发，所以2个操作系统都安装了Nodejs，像OSX这样高大上的玩意，暂时没机器去弄（穷）。</p>\n\n<h3 id="h3-1">windows</h3>\n<ol>\n    <li>先去官网（https://nodejs.org或https://nodejs.org/en/download/）下载一个安装包，我下的是长期稳定版。建议下载.msi。</li>\n    <li>然后就是安装了，这没什么好说的。无非就是设定一下安装目录，然后一通Next。</li>\n    <li>安装好之后检查下环境变量，看看path下添加入了Nodejs的运行路径。cmd中输入path可以看到添加了nodejs的安装目录。然后输入node --version可以看到当前的Nodejs版本号。如下图：&nbsp;&nbsp;&nbsp;&nbsp;<img alt="安装NodeJs运行环境" height="175" src="https://file.mahoooo.com/res/file/install_nodejs_runtime_environment_1.png" width="527"></li>\n    <li>Nodejs自带npm，npm和其他未来要使用的组件都存放在“X:\\yourpath\\nodejs\\node_modules”里。所以需要在windows环境变量重增加一个NODE_PATH=X:\\yourpath\\nodejs\\node_modules的参数，保证未来新增的一些模块工具可以正常使用。右键“我的电脑”-&gt;高级系统设置-&gt;环境变量-&gt;然后新建以上参数。</li>\n    <li>再然后就是最后一步了，设置node_cache（用于npm存放一些临时文件）和node_global（全局工具文件夹），当然这里也可以不设置，他会自动放在当前用户的文件夹下，但是有强迫症的我必须要设置。在cmd中输入一下命令：</li>\n</ol>\n<pre class="sql"><code class="language-bash">npm config <span class="code-built_in"><span class="code-keyword">set</span></span> prefix <span class="code-string"><span class="code-string">\'X:\\yourpath\\nodejs\\node-global\'</span></span>\n\nnpm config <span class="code-built_in"><span class="code-keyword">set</span></span> <span class="code-keyword">cache</span> <span class="code-string"><span class="code-string">\'X:\\yourpath\\nodejs\\node_cache\'</span></span></code></pre>\n\n<h3 id="h3-2">linux</h3>\n<p>linux安装和windows安装Nodejs差不多，都是下载包、解压、开用。</p>\n<ol>\n    <li>先去官网下载一个linux版本的安装包（下首页的那个就行）。下载以后发现是 xz后缀，先得用xz命令解压成tar，再用tar完成解压。</li>\n    <li>添加Nodejs运行环境：直接把node的运行目录添加到&amp;PATH里。在profile中添加Node的运行环境： <pre class="bash"><code class="language-bash"><span class="code-comment"><span class="code-comment">#node</span></span>\n<span class="code-built_in"><span class="code-built_in">export</span></span> NODE_HOME=/yourpath/node-v4.5.0-linux-x64\n<span class="code-built_in"><span class="code-built_in">export</span></span> PATH=<span class="code-variable"><span class="code-variable">$NODE_HOME</span></span>/bin:<span class="code-variable"><span class="code-variable">$PATH</span></span></code></pre> <p>然后再任意位置测试了一下运行node命令都可以正常使用。</p> </li>\n    <li> <p>然后我们需要添加node_modules到PATH中，保证npm可以使用：</p> <pre class="bash"><code class="language-apache"><span class="code-comment">#npm</span>\n<span class="code-built_in">export</span> NODE_PATH=<span class="code-variable">$NODE_HOME</span>/node_modules\n</code></pre> <p>配置完之后，就可以使用npm命令了。（修改之后切记注销用户）</p> </li>\n</ol>\n<p>完成以上步奏之后，就可以用node和npm命令干你相干的事了。安装之前按看到很多教程说是要安装python2.2到2.7的版本。但是我解压完nodejs包后在bin下运行了node -v命令居然可以跑，我就没去管python的事，应该是我用的是打包版的原因。</p>\n\n<h3 id="h3-3">Apt安装Nodejs</h3>\n<p>1.设定Nodejs安装源：</p>\n<pre class="nginx"><code class="language-bash"><span class="code-attribute">curl</span> <span class="hljs-_">-s</span>L https://deb.nodesource.com/setup_8.x | sudo -E bash -</code></pre>\n<p>2.安装Nodejs</p>\n<pre class="actionscript"><code class="language-bash">sudo apt-<span class="code-keyword">get</span> install -y nodejs</code></pre>\n\n<h3 id="h3-4">验证安装结果</h3>\n<p>安装完成之后，我在windows和linux都测试了一下。</p>\n<p>测试nodejs：输入node打开REPL，然后使用log打印数据：</p>\n<pre class="javascript"><code class="language-bash">$ node\n&gt; <span class="code-built_in">console</span>.log(<span class="code-string"><span class="code-string">"hello nodejs!"</span></span>);\nhello nodejs!\n<span class="hljs-literal">undefined</span></code></pre>\n<p>然后用npm测试安装grunt-cli：</p>\n<pre class="groovy"><code class="language-bash">$ npm install -g grunt-cli\n<span class="hljs-regexp">/yourpath/</span>node-v4<span class="hljs-number">.5</span><span class="hljs-number">.0</span>-linux-x64<span class="hljs-regexp">/node_global/</span>bin<span class="hljs-regexp">/grunt -&gt; /</span>yourpath<span class="hljs-regexp">/node-v4.5.0-linux-x64/</span>node_global<span class="hljs-regexp">/lib/</span>node_modules<span class="hljs-regexp">/grunt-cli/</span>bin/grunt\ngrunt-cli@<span class="hljs-number">1.2</span><span class="hljs-number">.0</span> <span class="hljs-regexp">/me/</span>soft<span class="hljs-regexp">/node/</span>node-v4<span class="hljs-number">.5</span><span class="hljs-number">.0</span>-linux-x64<span class="hljs-regexp">/node_global/</span>lib<span class="hljs-regexp">/node_modules/</span>grunt-cli\n├── grunt-known-options@<span class="hljs-number">1.1</span><span class="hljs-number">.0</span>\n├── resolve@<span class="hljs-number">1.1</span><span class="hljs-number">.7</span>\n├── nopt@<span class="hljs-number">3.0</span><span class="hljs-number">.6</span> (abbrev@<span class="hljs-number">1.0</span><span class="hljs-number">.9</span>)\n└── findup-sync@<span class="hljs-number">0.3</span><span class="hljs-number">.0</span> (glob@<span class="hljs-number">5.0</span><span class="hljs-number">.15</span>)</code></pre>\n\n<h3 id="h3-5">运行一个Nodejs程序</h3>\n<p>安装好之后，node的命令行和npm的命令行就都可以使用了，随后当然就是要跑跑Nodejs了。像下面这样创建一个创建一个example.js文件，随便放在某个文件：</p>\n<pre class="javascript"><code class="language-javascript"><span class="code-keyword"><span class="code-keyword">const</span></span> http = <span class="code-built_in"><span class="code-built_in">require</span></span>(<span class="code-string"><span class="code-string">\'http\'</span></span>);\n\n<span class="code-keyword"><span class="code-keyword">const</span></span> hostname = <span class="code-string"><span class="code-string">\'127.0.0.1\'</span></span>;\n<span class="code-keyword"><span class="code-keyword">const</span></span> port = <span class="hljs-number"><span class="hljs-number">3000</span></span>;\n\n<span class="code-keyword"><span class="code-keyword">const</span></span> server = http.createServer((req, res) -&gt; {\n  res.statusCode = <span class="hljs-number"><span class="hljs-number">200</span></span>;\n  res.setHeader(<span class="code-string"><span class="code-string">\'Content-Type\'</span></span>, <span class="code-string"><span class="code-string">\'text/plain\'</span></span>);\n  res.end(<span class="code-string"><span class="code-string">\'Hello World Nodejs\\n\'</span></span>);\n});\n\nserver.listen(port, hostname, () =&gt; {\n  <span class="code-built_in"><span class="code-built_in">console</span></span>.log(<span class="code-string"><span class="code-string">`Server running at http://</span><span class="hljs-subst"><span class="code-string"><span class="hljs-subst">${hostname}</span></span></span><span class="code-string">:</span><span class="hljs-subst"><span class="code-string"><span class="hljs-subst">${port}</span></span></span><span class="code-string">/`</span></span>);\n});</code></pre>\n<p>然后在当前文件下打开一个cmd运行以下命令：</p>\n<pre class="css"><code class="language-bash"><span class="code-selector-tag">node</span> <span class="code-selector-tag">example</span><span class="code-selector-class">.js</span></code></pre>\n<p>可以看到输出：</p>\n<pre class="php"><code class="language-bash"><span class="code-variable">$node</span> example.js\n\nServer running at http:<span class="code-comment">//127.0.0.1:3000</span></code></pre>\n'},363:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h2 id="h2-1">什么叫前后端同构？</h2>\n<p>为了解决某些问题（比如SEO、提升渲染速度等）<strong><em>react</em></strong>\n    提供了2个方法在服务端生成一个HTML文本格式的字符串。在得到了这个HTML格式的字符串之后，通常会将其组装成一个页面直接返回给用户的浏览器。</p>\n<p>到这里，服务端的活已经干完了，然后就是浏览器这边干活。</p>\n<p>浏览器拿到HTML文本后，立刻进行渲染将内容呈现给用户。然后加载页面所需的 .js 文件，然后执行\n    <em><strong>JavaScript&nbsp;</strong></em>脚本，然后开始初始化&nbsp;<em><strong>react</strong></em> 组件…………</p>\n<p>到这里问题就来了。<strong><em>react</em></strong> 初始化组件后会执行组件内所有\n    <em>render&nbsp;() </em>方法，然后生成虚拟DOM的树形结构，然后在适当的时候将虚拟dom<em>写</em>到浏览器的真实dom中。因为 <strong><em>react</em></strong>\n    总是根据虚拟dom来生成真实dom，所以最后会把服务器端渲染好的HTML全部替换掉。</p>\n<p>\n    上面这个事情说不是问题确实也不是问题，无非就是用户看到页面然后“闪现”一下。说是问题还真是个问题，产品会拿着这毛病从用户体验的角度在各种场合和你死磕半个月。磕累了你索性把服务端渲染关了，然后运营又拿着SEO的问题准备和你开始撕逼了。</p>\n<p>聪明如 Facebook 的工程师当然想到了这些问题，所以他们在<em>ReactDOMServer.renderToString(element) 方法</em>中提供了一个\n    <strong><em>checksum</em></strong> 机制。</p>\n<p>关于&nbsp;<strong><em>checksum </em></strong> <a href="https://facebook.github.io/react/docs/react-dom-server.html"\n                                                  rel="nofollow">官网</a> 并没有太多介绍，但是国内外的各路博客介绍了不少。我一直想找&nbsp;<em><strong>react</strong></em>\n    开发者关于这个机制的介绍一直没找到……。</p>\n<p><strong>前后端同构</strong>就是保证前端和后端的dom结构一致，不会发生重复渲染。<em><strong>react</strong></em>\n    使用&nbsp;<strong><em>checksum </em></strong>机制进行保障。</p>\n\n<h2 id="h2-2">什么叫React首屏渲染？</h2>\n<p>简单的说就是 <em><strong>react</strong></em> 在浏览器内存中第一次生成的虚拟 dom 树。<strong>切记是虚拟 dom ，而不是浏览器的dom</strong>。</p>\n<p>了解 <strong><em>react</em></strong> 的应该知道，所有 <em><strong>react</strong></em> 组件都有一个 <em>render()</em>\n    方法（如果使用function方式编写的组件会把function里的所有代码都塞到 <em>render()</em> 方法中去）。当<em>ReactDOM.render( element, container,\n        [callback] )</em>方法执行时，会执行以下步骤：</p>\n<ol>\n    <li>所有组件的会先进行初始化（es6执行构造函数）。</li>\n    <li>所有组件的&nbsp;<em>render</em>&nbsp;<em>()</em> 方法会被调用一次，完成这个过程后会得到一颗虚拟的 dom 树。</li>\n    <li>&nbsp;<em><strong>react</strong></em> 会将虚拟dom转换成浏览器dom，完成后调用组件的&nbsp;<em>componentDidMount()</em>&nbsp;方法告诉你已经装载到浏览器上了。\n    </li>\n</ol>\n<p>在上面这个过程成中，步骤2完成后即为完成 <em><strong>react</strong></em> 的首屏渲染。结合 <strong><em>checksum</em></strong>&nbsp;机制步骤3有可能不会执行。\n</p>\n<p>当组件状态发生变更时（ <em>setState() </em>生命周期函数被调用）或者 父组件渲染时（父组件的 <em>render()</em> 方法被调用），当前组件的 <em>render()</em>\n    方法都会被执行，都有可能会导致虚拟dom变更，但是这些变更和首屏渲染没任何关系了。</p>\n\n<h2 id="h2-3">React前后端同构首屏渲染</h2>\n<p>了解了同构和首屏渲染，就好理解如何解决首屏不重复渲染的问题了。</p>\n<p>首先服务端渲染完之后会有一个 <em><strong>checksum</strong></em> 值写在根元素的属性上：</p>\n<p><img alt="React 前后端同构防止重复渲染" height="70"\n        src="https://file.mahoooo.com/res/file/react_server_render_with_checksum_1.png" width="601"></p>\n<p>这个 <em><strong>checksum</strong></em>&nbsp;是根据服务端生成的HTML内容哈希计算得到的。</p>\n<p>然后在浏览器加载完所有的js文件之后，开始执行前面介绍的&nbsp;<em>ReactDOM.render( element, container, [callback] )</em> &nbsp;初始化渲染的三个步骤。当执行完第二步生成虚拟dom后，<strong><em>react</em></strong>\n    会根虚拟dom用相同的算法计算一个哈希值，如果和 <em><strong>checksum</strong></em> 一致则认为服务器已经完成渲染，不会再执行第三步。</p>\n<p>如果 <strong><em>checksum</em></strong> 比对不一致，在 <strong>开发环境</strong>&nbsp;和 <strong>测试环境</strong>\n    会在浏览器console中输出以下警告内容：</p>\n<p><img alt="React 前后端同构防止重复渲染" height="85"\n        src="https://file.mahoooo.com/res/file/react_server_render_with_checksum_2.png" width="790"></p>\n<p><strong>生产环境不会输出任何警告。</strong></p>\n<p>同构渲染的内容就这么多，原理其实蛮简单的，无非就是保证DOM一致。但是结合代码分片、异步加载、服务端调接口异步组装数据等等功能后，如何保证服务端和浏览器端第一次渲染的dom一致还得花不少功夫。不过原理清楚了，事情总能办成。</p>'},375:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h2 id="h2-1">Flow</h2>\n<p>Flow是Facebook开源的静态代码检查工具，他的作用是在运行代码之前对React组件以及Jsx语法进行静态代码的检查以发现一些可能存在的问题。Flow可以用于所有前端开发的项目而不仅仅局限于React，码友们可以到\n  <a title="Flow官网" href="https://flow.org/en/docs/getting-started/" rel="nofollow">官网</a>仔细了解（友情提示：可能需要VPN，非常不稳定），本文只介绍如何配合React开发使用。</p>\n<p>Flow仅仅是一个用于检查的工具，安装使用都很方便，使用时注意以下3点即可：</p>\n<ol>\n  <li>将Flow增加到我们的项目中。</li>\n  <li>确保编译之后的代码移除了Flow相关的语法。</li>\n  <li>在需要检查的地方增加了Flow相关的类型注解。（类似与Java的Annotation机制）</li>\n</ol>\n<p>接下来我们来一一说明以上三点的具体内容。码友们边阅读边操作即可。</p>\n\n<h2 id="h2-2">将Flow增加到我们的项目中</h2>\n<p>安装最新版本的Flow：</p>\n<p>Npm：</p>\n<pre class="sql"><code class="language-bash">npm <span class="code-keyword">install</span> <span class="code-comment">--save-dev flow-bin</span></code></pre>\n<p>安装完成之后在package.json文件中增加执行脚本：</p>\n<pre class="actionscript"><code class="language-javascript">{\n  <span class="code-comment"><span class="code-comment">// ...</span></span>\n  <span class="code-string"><span class="code-string">"scripts"</span></span>: {\n    <span class="code-string"><span class="code-string">"your-script-name"</span></span>: <span class="code-string"><span class="code-string">"flow"</span></span>,\n    <span class="code-comment"><span class="code-comment">// ...</span></span>\n  },\n  <span class="code-comment"><span class="code-comment">// ...</span></span>\n}</code></pre>\n<p>然后初始化Flow：</p>\n<pre class="nginx"><code class="language-bash"><span class="code-attribute">npm</span> run flow init</code></pre>\n<p>执行完成后，Flow会在终端输出一下内容：</p>\n<pre class="css"><code class="css">&gt; <span class="code-selector-tag"><span class="code-selector-tag">yourProjectName</span></span>@<span class="code-keyword"><span class="code-keyword">1</span></span>.<span class="code-keyword"><span class="code-keyword">0</span></span>.<span class="code-keyword"><span class="code-keyword">0</span></span> flow /yourProjectPath\n&gt; flow <span class="code-string"><span class="code-string">"init"</span></span>\n</code></pre>\n<p>然后在根目录下生成一个名为&nbsp;.flowconfig 的文件，打开之后是这样的：</p>\n<pre class="json"><code class="language-bash">[ignore]\n\n[include]\n\n[libs]\n\n[lints]\n\n[options]\n\n[strict]\n</code></pre>\n<p>基本上，配置文件没有什么特殊需求是不用去配置的，Flow默认涵盖了当前目录之后的所有文件。[include]用于引入项目之外的文件。例如：</p>\n<pre class="gradle"><code class="gradle">[<span class="code-keyword"><span class="code-keyword">include</span></span>]\n\n..<span class="hljs-regexp"><span class="hljs-regexp">/otherProject/</span></span>a.js\n\n[libs]\n</code></pre>\n<p>他会将和当前项目平级的otherProject/a.js 文件纳入进来。关于配置文件请看<a title="Flow配置文件说明" href="https://flow.org/en/docs/config/" rel="nofollow">这里</a>。</p>\n\n<h2 id="h2-3">编译之后的代码移除Flow相关的语法</h2>\n<p>Flow在JavaScript语法的基础上增加了一些 注解（annotation）进行了扩展。因此浏览器无法正确的解读这些Flow相关的语法，我们必须在编译之后的代码中（最终发布的代码）将增加的Flow注解移除掉。具体方法需要看我们使用了什么样的编译工具。下面将说明一些React开发常用的编译工具</p>\n\n<h3 id="h3-1">Create React App</h3>\n<p>如果你的项目是使用<a title="Create React App" href="https://github.com/facebook/create-react-app" rel="nofollow">Create React App</a>直接创建的。那么移除Flow语法的事项就不用操心了，Create React App已经帮你搞定了这个事，直接跳过这一小节吧。</p>\n\n<h3 id="h3-2">Babel</h3>\n<p>在15.x版本之前入坑React的码友应该绝大部分都用的Babel作为语法糖编译器，那个时候毕竟Create React App完全没有成熟。如果使用Babel我们还需要安装一个Babel对于Flow的preset：</p>\n<pre class="sql"><code class="language-apache">npm <span class="code-keyword">install</span> <span class="code-comment">--save-dev babel-preset-flow</span></code></pre>\n<p>然后，我们需要在<a title="Babel配置文件" href="http://babeljs.io/docs/usage/babelrc/" rel="nofollow">项目根目录Babel的配置文件 .babelrc 中</a>添加一个Flow相关的preset：</p>\n<pre class="json"><code class="language-javascript">{\n  <span class="code-string"><span class="hljs-attr">"presets"</span></span>: [\n    <span class="code-string"><span class="code-string">"flow"</span></span>,\n    <span class="code-comment">//other config</span>\n  ]\n}</code></pre>\n\n<h3 id="h3-3">其他方式</h3>\n<p>如果你既没有使用Create React App也没使用Babel作为语法糖编译器，那么可以使用<a title="Flow语法处理工具" href="https://github.com/flowtype/flow-remove-types" rel="nofollow">&nbsp;flow-remove-types </a>这个工具在发布之前移除Flow代码。</p>\n\n<h2 id="h2-4">运行Flow</h2>\n<p>完成上述步骤之后，就可以开始运行flow了：</p>\n<pre class="nginx"><code class="language-bash"><span class="code-attribute">npm</span> run flow</code></pre>\n<p>然后会输类似一下的内容：</p>\n<pre class="css"><code class="css">&gt; <span class="code-selector-tag"><span class="code-selector-tag">yourProjectName</span></span>@<span class="code-keyword"><span class="code-keyword">1</span></span>.<span class="code-keyword"><span class="code-keyword">0</span></span>.<span class="code-keyword"><span class="code-keyword">0</span></span> flow /yourProjectPath\n&gt; flow\n\nLaunching Flow server for /yourProjectPath\nSpawned flow server (pid=<span class="hljs-number"><span class="hljs-number">10705</span></span>)\nLogs will go to /tmp/flow/zSworkzSchkuizSone-big-website.log\nMonitor logs will go to /tmp/flow/zSworkzSchkuizSone-big-website.monitor_log\nNo errors!\n</code></pre>\n<p>第一次运行会生成很多临时文件比较慢，之后会快许多。</p>\n\n<h2 id="h2-5">增加Flow注解</h2>\n<p>如果你了解C++/C#的元编程或者Java的Annotation，那么理解Flow的Annotation就会非常轻松。大概就是在文件、方法、代码块之前增加一个注解（Annotation）用来告知Flow的执行行为。</p>\n<p>首先，Flow只检查包含 // @flow 注解的文件。所以如果需要检查，我们需要这样编写我们的文件：</p>\n<pre class="scala"><code class="language-javascript"><span class="code-comment"><span class="code-comment">// @flow</span></span>\n<span class="code-keyword"><span class="code-keyword">import</span></span> <span class="code-type">React</span> <span class="code-keyword">from</span> <span class="code-string"><span class="hljs-symbol">\'reac</span>t\'</span>\n\n<span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span class="hljs-class"><span class="code-title">Component</span></span></span><span class="hljs-class"> </span></span>{\n    render(){\n        <span class="code-keyword"><span class="code-keyword">return</span></span> (<span class="xml"><span class="code-tag">&lt;<span class="code-name">div</span>&gt;</span><span class="code-type">MyComponent</span><span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>)\n    }\n}\n\n<span class="code-keyword">export</span> <span class="code-keyword"><span class="code-keyword">default</span></span> <span class="code-type">MyComponent</span></code></pre>\n<p>然后我们再运行Flow就变成这样的风格了：</p>\n<pre class="scala"><code class="language-bash">&gt; yourProjectName@<span class="hljs-number">1.0</span><span class="hljs-number">.0</span> flow /yourProjectPath\n&gt; flow\n\n<span class="code-type">Error</span> ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ dev/src/home/test.js:<span class="hljs-number">5</span>:<span class="hljs-number">21</span>\n\n<span class="code-type">Cannot</span> use property <span class="code-type">Component</span> [<span class="hljs-number">1</span>] <span class="code-keyword">with</span> less than <span class="hljs-number">1</span> <span class="code-built_in"><span class="hljs-class"><span class="code-keyword">type</span></span></span><span class="hljs-class"> <span class="code-title">argument</span>.</span>\n\n     dev/src/home/test.js\n      <span class="hljs-number">2</span>│\n      <span class="hljs-number">3</span>│ <span class="code-keyword">import</span> <span class="code-type">React</span> from <span class="code-string"><span class="hljs-symbol">\'reac</span>t\'</span>\n      <span class="hljs-number">4</span>│\n      <span class="hljs-number">5</span>│ <span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MyComponent</span> <span class="code-keyword">extends</span> <span class="code-title">React</span>.<span class="code-title">Component</span> </span>{\n      <span class="hljs-number">6</span>│     <span class="hljs-function"><span class="code-title">render</span></span>(){\n      <span class="hljs-number">7</span>│         <span class="code-built_in"><span class="code-keyword">return</span></span> (&lt;div&gt;<span class="code-type">MyComponent</span>&lt;/div&gt;)\n      <span class="hljs-number">8</span>│     }\n\n     /tmp/flow/flowlib_cc1898a/react.js\n [<span class="hljs-number">1</span>] <span class="hljs-number">26</span>│ <span class="code-built_in">declare</span> <span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">React</span></span><span class="code-variable"><span class="hljs-class"><span class="code-title">$Component</span></span></span><span class="hljs-class"><span class="code-title">&lt;Props</span>, <span class="code-title">State</span> </span>= void&gt; {</code></pre>\n<p>到这里，Flow已经算是安装成功了，接下来的事是要增加各种注解以加强类型限定或者参数检测。之后的内容将简要介绍flow的相关语法规则。</p>\n\n<h2 id="h2-6">React组件参数检查</h2>\n<p><a title="PropType参数类型检测" href="https://chkui.com/article/react/react_typechecking_with_proptypes_and_dom_element">React组件参数检查</a>介绍了React通过PropType机制限定使用者使用组件传递的参数类型以及范围，但是PropType是一种运行检测机制，在程序跑起来之后获取到具体数据才会执行检查。而Flow是静态检查，是在代码编译运行之前进行一次检查，两者相辅相成互不干扰。</p>\n\n<h3 id="h3-4">Props参数检查</h3>\n<p>承接上面 MyComponent 的例子，我们引入Flow的注解对代码进行检查：</p>\n<pre class="scala"><code class="language-javascript"><span class="code-comment"><span class="code-comment">// @flow</span></span>\n<span class="code-comment"><span class="code-comment">// flow的例子，可以看看和PropType的差异在哪</span></span>\n<span class="code-keyword"><span class="code-keyword">import</span></span> <span class="code-type">React</span> <span class="code-keyword">from</span> <span class="code-string"><span class="hljs-symbol">\'reac</span>t\'</span>\n\n<span class="hljs-class"><span class="code-keyword">type</span> <span class="code-title">Props</span> </span>= {\n    num : number,\n    text : ?string\n}\n\n<span class="code-comment"><span class="code-comment">//通过&lt;&gt;引入Flow类型检查</span></span>\n<span class="code-comment"><span class="code-comment">//可以直接写成 React.Component&lt;{num : number, text ?: string}&gt;这样的形式</span></span>\n<span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span class="hljs-class"><span class="code-title">Component</span></span></span><span class="hljs-class"><span class="code-title">&lt;</span></span><span class="code-title"><span class="hljs-class"><span class="code-title">Props</span></span></span><span class="hljs-class"><span class="code-title">&gt;</span> </span></span>{\n    render(){\n        <span class="code-keyword"><span class="code-keyword">return</span></span> (<span class="xml"><span class="code-tag">&lt;<span class="code-name">div</span>&gt;</span>{<span class="code-keyword">this</span>.props.num}\\{<span class="code-keyword">this</span>.props.text}<span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>)\n    }\n}\n\n<span class="code-keyword">export</span> <span class="code-keyword"><span class="code-keyword">default</span></span> <span class="code-type">MyComponent</span></code></pre>\n<p>然后在运行Flow，输出了No Error。</p>\n<p>然后我们使用这个组件：</p>\n<pre class="scala"><code class="language-javascript"><span class="code-comment"><span class="code-comment">// @flow</span></span>\n<span class="code-comment"><span class="code-comment">// flow的例子，可以看看和PropType的差异在哪</span></span>\n<span class="code-keyword"><span class="code-keyword">import</span></span> <span class="code-type">React</span> <span class="code-keyword">from</span> <span class="code-string"><span class="hljs-symbol">\'reac</span>t\'</span>\n\n<span class="hljs-class"><span class="code-keyword">type</span> <span class="code-title">Props</span> </span>= {\n    num : number,\n    text : ?string\n}\n\n<span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span class="hljs-class"><span class="code-title">Component</span></span></span><span class="hljs-class"><span class="code-title">&lt;</span></span><span class="code-title"><span class="hljs-class"><span class="code-title">Props</span></span></span><span class="hljs-class"><span class="code-title">&gt;</span> </span></span>{\n    render(){\n        <span class="code-keyword"><span class="code-keyword">this</span></span>.props.myValue;\n        <span class="code-keyword"><span class="code-keyword">return</span></span> (<span class="xml"><span class="code-tag">&lt;<span class="code-name">div</span>&gt;</span>{<span class="code-keyword">this</span>.props.num}\\{<span class="code-keyword">this</span>.props.text}<span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>)\n    }\n}\n\n<span class="code-comment"><span class="code-comment">//void 表示 undefined 不传递参数</span></span>\n<span class="code-comment"><span class="code-comment">//这里传递类型发生错误</span></span>\n<span class="code-keyword">const</span> <span class="code-type">UseComponent</span> = (props : <span class="code-keyword">void</span>) =&gt;(<span class="xml"><span class="code-tag">&lt;<span class="code-name"><span class="code-type">MyComponent</span></span> <span class="hljs-attr">num</span>=<span class="code-string"><span class="code-string">"2"</span></span> <span class="hljs-attr">text</span>=<span class="code-string">{<span class="hljs-number">2</span>}/</span>&gt;</span>)\n\nexport <span class="code-keyword">default</span> <span class="code-type">UseComponent</span></span></code></pre>\n<p>运行flow之后输出：</p>\n<pre class="actionscript"><code class="language-bash">Error ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ dev/src/home/test.js:<span class="hljs-number">12</span>:<span class="hljs-number">20</span>\n\nCannot <span class="code-keyword">get</span> <span class="code-keyword">this</span>.props.myValue because property myValue <span class="code-keyword">is</span> missing <span class="code-keyword"><span class="code-keyword">in</span></span> Props [<span class="hljs-number">1</span>].\n\n      <span class="hljs-number">9</span>│\n [<span class="hljs-number">1</span>] <span class="hljs-number">10</span>│ <span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MyComponent</span> <span class="code-keyword">extends</span> <span class="code-title">React</span>.<span class="code-title">Component</span>&lt;<span class="code-title">Props</span>&gt; </span>{\n     <span class="hljs-number">11</span>│     <span class="hljs-function"><span class="code-title">render</span></span>(){\n     <span class="hljs-number">12</span>│         <span class="code-keyword">this</span>.props.myValue;\n     <span class="hljs-number">13</span>│         <span class="code-built_in"><span class="code-keyword">return</span></span> (&lt;div&gt;{<span class="code-keyword">this</span>.props.num}\\{<span class="code-keyword">this</span>.props.text}&lt;/div&gt;)\n     <span class="hljs-number">14</span>│     }\n     <span class="hljs-number">15</span>│ }\n\n\nError ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ dev/src/home/test.js:<span class="hljs-number">17</span>:<span class="hljs-number">40</span>\n\nCannot create MyComponent element because:\n • string [<span class="hljs-number">1</span>] <span class="code-keyword">is</span> incompatible <span class="code-keyword">with</span> number [<span class="hljs-number">2</span>] <span class="code-keyword"><span class="code-keyword">in</span></span> property num.\n • number [<span class="hljs-number">3</span>] <span class="code-keyword">is</span> incompatible <span class="code-keyword">with</span> string [<span class="hljs-number">4</span>] <span class="code-keyword"><span class="code-keyword">in</span></span> property text.\n\n    [<span class="hljs-number">2</span>]  <span class="hljs-number">6</span>│     num : number,\n    [<span class="hljs-number">4</span>]  <span class="hljs-number">7</span>│     text : ?string\n          :\n        <span class="hljs-number">14</span>│     }\n        <span class="hljs-number">15</span>│ }\n        <span class="hljs-number">16</span>│\n [<span class="hljs-number">1</span>][<span class="hljs-number">3</span>] <span class="hljs-number">17</span>│ <span class="code-keyword">const</span> UseComponent = (props : <span class="code-keyword">void</span>) =&gt;(&lt;MyComponent num=<span class="code-string"><span class="code-string">"2"</span></span> text={<span class="hljs-number">2</span>}/&gt;)\n        <span class="hljs-number">18</span>│\n        <span class="hljs-number">19</span>│ <span class="code-built_in">export</span> <span class="code-keyword">default</span> UseComponent\n\n\n\nFound <span class="hljs-number">3</span> errors</code></pre>\n<p>输出内容可以看出一共有2个错误栏输出：</p>\n<ul>\n  <li>第一栏表示myValue并没有声明。</li>\n  <li>第二栏[1]违反了[2]的限定，[3]违反了[4]的限定。我们将组件变更为&lt;MyComponent num={2}&nbsp;text="2"/&gt;即可检查通过。</li>\n</ul>\n\n<h3 id="h3-5">增加对State的检查</h3>\n<p>React的数据通过两处控制——<a title="React 深入说明JSX语法与Props特性" href="https://www.chkui.com/article/react/react_understand_jsx_and_props">props</a> 和&nbsp;<a title="React 状态、事件与动态渲染" href="https://www.chkui.com/article/react/react_state_event_and_render">state</a>。Flow也提供了state数据的检查，我们在例子中增加state检查：</p>\n<pre class="scala"><code class="language-javascript"><span class="code-comment"><span class="code-comment">// @flow</span></span>\n<span class="code-comment"><span class="code-comment">// flow的例子，可以看看和PropType的差异在哪</span></span>\n<span class="code-keyword"><span class="code-keyword">import</span></span> <span class="code-type">React</span> <span class="code-keyword">from</span> <span class="code-string"><span class="hljs-symbol">\'reac</span>t\'</span>\n\n<span class="hljs-class"><span class="code-keyword">type</span> <span class="code-title">Props</span> </span>= {\n    num : number,\n    text : ?string\n}\n\n<span class="hljs-class"><span class="code-keyword">type</span> <span class="code-title">State</span> </span>= {\n    count: number,\n};\n\n<span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span class="hljs-class"><span class="code-title">Component</span></span></span><span class="hljs-class"><span class="code-title">&lt;</span></span><span class="code-title"><span class="hljs-class"><span class="code-title">Props</span></span></span><span class="hljs-class">, </span><span class="code-title"><span class="hljs-class"><span class="code-title">State</span></span></span><span class="hljs-class"><span class="code-title">&gt;</span> </span></span>{\n    <span class="code-keyword">constructor</span>(...props){\n        <span class="code-keyword"><span class="code-keyword">super</span></span>(...props)\n        <span class="code-keyword"><span class="code-keyword">this</span></span>.state = {count:<span class="code-string">\'<span class="hljs-number">1</span>\'</span>}\n    }\n\n    render(){\n        <span class="code-keyword"><span class="code-keyword">return</span></span> (<span class="xml"><span class="code-tag">&lt;<span class="code-name">div</span>&gt;</span>{<span class="code-keyword">this</span>.props.num}\\{<span class="code-keyword">this</span>.props.text}<span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>)\n    }\n}\n\n<span class="code-keyword">const</span> <span class="code-type">UseComponent</span> = (props : <span class="code-keyword">void</span>) =&gt;(<span class="xml"><span class="code-tag">&lt;<span class="code-name"><span class="code-type">MyComponent</span></span> <span class="hljs-attr">num</span>=<span class="code-string">{<span class="hljs-number">2</span>}</span> <span class="hljs-attr">text</span>=<span class="code-string"><span class="code-string">"2"</span></span>/&gt;</span>)\n\nexport <span class="code-keyword">default</span> <span class="code-type">UseComponent</span></span></code></pre>\n<p>此时运行Flow会输出：</p>\n<pre class="scala"><code class="language-bash"><span class="code-type">Error</span> ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ dev/src/home/test.js:<span class="hljs-number">17</span>:<span class="hljs-number">29</span>\n\n<span class="code-type">Cannot</span> assign <span class="hljs-class"><span class="code-keyword">object</span> <span class="code-title">literal</span> <span class="code-title">to</span> <span class="code-title">this</span>.<span class="code-title">state</span> <span class="code-title">because</span> <span class="code-title">string</span> [1] <span class="code-title">is</span> <span class="code-title">incompatible</span></span>\n<span class="code-keyword">with</span> number [<span class="hljs-number">2</span>] <span class="code-keyword">in</span> property count.\n\n [<span class="hljs-number">2</span>] <span class="hljs-number">11</span>│     count: number,\n     <span class="hljs-number">12</span>│ };\n     <span class="hljs-number">13</span>│\n     <span class="hljs-number">14</span>│ <span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MyComponent</span> <span class="code-keyword">extends</span> <span class="code-title">React</span>.<span class="code-title">Component&lt;Props</span>, <span class="code-title">State&gt;</span> </span>{\n     <span class="hljs-number">15</span>│     constructor(...props){\n     <span class="hljs-number">16</span>│         <span class="code-keyword">super</span>(...props)\n [<span class="hljs-number">1</span>] <span class="hljs-number">17</span>│         <span class="code-keyword">this</span>.state = {count:<span class="code-string">\'<span class="hljs-number">1</span>\'</span>}\n     <span class="hljs-number">18</span>│     }\n     <span class="hljs-number">19</span>│\n     <span class="hljs-number">20</span>│     <span class="hljs-function"><span class="code-title">render</span></span>(){\n</code></pre>\n<p>检测出state.count在构造函数中赋值的类型错误。</p>\n\n<h3 id="h3-6">组件默认值</h3>\n<p>使用Flow后一样可以使用默认值，但是必须要注意默认值的类型要和注解声明的一致：</p>\n<pre class="scala"><code class="language-javascript"><span class="code-keyword"><span class="code-keyword">import</span></span> * <span class="code-keyword">as</span> <span class="code-type">React</span> <span class="code-keyword">from</span> <span class="code-string"><span class="hljs-symbol">\'reac</span>t\'</span>;\n\n<span class="hljs-class"><span class="code-keyword">type</span> <span class="code-title">Props</span> </span>= {\n  foo: number, \n};\n\n<span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span class="hljs-class"><span class="code-title">Component</span></span></span><span class="hljs-class"><span class="code-title">&lt;</span></span><span class="code-title"><span class="hljs-class"><span class="code-title">Props</span></span></span><span class="hljs-class"><span class="code-title">&gt;</span> </span></span>{\n  <span class="code-keyword">static</span> defaultProps = {\n    foo: <span class="hljs-number"><span class="hljs-number">42</span></span>, \n  };\n}</code></pre>\n\n<h3 id="h3-7">函数类型的组件</h3>\n<p>除了使用Class关键字，使用函数同样可以构造一个React组件，配合Flow使用：</p>\n<pre class="javascript"><code class="language-javascript"><span class="code-keyword"><span class="code-keyword">import</span></span> React <span class="code-keyword"><span class="code-keyword">from</span></span> <span class="code-string"><span class="code-string">\'react\'</span></span>;\n\ntype Props = {<span class="code-comment"><span class="code-comment">//参数检查</span></span>\n  foo: number,\n  bar?: string,\n};\n\n<span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">function</span></span></span><span class="hljs-function"> </span><span class="code-title"><span class="hljs-function"><span class="code-title">MyComponent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props: Props</span></span></span><span class="hljs-function">) </span></span>{\n  <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="xml"><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">div</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">{props.bar}</span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">div</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span></span>;\n}\n\nMyComponent.defaultProps = {\n  foo: <span class="hljs-number"><span class="hljs-number">42</span></span> <span class="code-comment"><span class="code-comment">//指定默认值</span></span>\n};</code></pre>\n\n<h3 id="h3-8">React事件、子组件、高阶组件检查扩展</h3>\n<p>除了对单个组件基本的检查，Flow还提供了对React事件、refs、子组件、高阶组件、Redux。本文就不一一介绍了，有需要的码友可以按照下面的资源清单去了解相关的内容：</p>\n<ul>\n  <li><a title="Flow React事件检查" href="https://flow.org/en/docs/react/events/" rel="nofollow">React事件</a></li>\n  <li><a title="Flow Refs引入对象检查" href="https://flow.org/en/docs/react/refs/" rel="nofollow">Refs引入对象</a></li>\n  <li><a title="Flow React子组件列表检查" href="https://flow.org/en/docs/react/children/" rel="nofollow">子组件列表</a></li>\n  <li><a title="Flow React高阶组件参数检查" href="https://flow.org/en/docs/react/hoc/" rel="nofollow">高阶组件参数</a></li>\n  <li><a title="Flow ReactRedux整合参数检查" href="https://flow.org/en/docs/react/redux/" rel="nofollow">Redux整合</a></li>\n</ul>\n\n<h3 id="h3-9">类型检查扩展</h3>\n<p>Flow会检查所有的JavaScript基础类型——Boolean、String、Number、null、undefined（在Flow中用void代替）。除此之外还提供了一些操作符号，例如例子中的 text : ?string，他表示参数存在“没有值”的情况，除了传递string类型之外，还可以是null或undefined。需要特别注意的是，这里的没有值和JavaScript的表达式的“非”是两个概念，Flow的“没有值”只有null、void（undefined），而JavaScript表达式的“非”包含：null、undefined、0、false。</p>\n<p>除了前面的例子中给出的各种类型参数，Flow还有更丰富的检查功能，查看 <a title="Flow 检查参数说明" href="https://flow.org/en/docs/types/" rel="nofollow">这里</a> 以了解更多内容。</p>\n\n<h3 id="h3-10">React数据类型参考</h3>\n<p>对于Flow来说，除了常规的JavaScript数据类型之外，React也有自己特有的数据类型。比如React.Node、React.Key、React.Ref&lt;&gt;等。需要详细了解的，可以查看官网关于<a title="Flow React类型的说明" href="https://flow.org/en/docs/react/types/" rel="nofollow">React类型的说明</a>。</p>\n<p>需要特别说明的是，如果所要使用React的类型，在通过ES6引入React对象时需要使用这样的方式：</p>\n<pre class="python"><code class="language-javascript"><span class="code-keyword"><span class="code-keyword">import</span></span> * <span class="code-keyword"><span class="code-keyword">as</span></span> React <span class="code-keyword"><span class="code-keyword">from</span></span> <span class="code-string"><span class="code-string">\'react\'</span></span>\n<span class="code-comment">//替换 <span class="code-keyword">import</span> React <span class="code-keyword">from</span> <span class="code-string">\'react\'</span></span>\n\n<span class="code-comment">//或者单独引入一个类型</span>\n<span class="code-comment">//<span class="code-keyword">import</span> type {Node} <span class="code-keyword">from</span> <span class="code-string">\'react</span></span></code></pre>\n<p>两者的差异在于ES6的星号import的特性，使用*号会将一个文件中的所有 export 内容组合成一个对象返回，而不使用星号仅仅能获取到exprot default 那个原型。而引入Flow后不会修改React的默认导出类型，因为默认导出不一定是一个对象，他会通过export为React扩展更多的类型。</p>\n<p>比如我们用React.Node限制render方法的返回类型：</p>\n<pre class="scala"><code class="language-javascript"><span class="code-keyword"><span class="code-keyword">import</span></span> * <span class="code-keyword">as</span> <span class="code-type">React</span> <span class="code-keyword">from</span> <span class="code-string"><span class="hljs-symbol">\'reac</span>t\'</span>\n<span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span class="hljs-class"><span class="code-title">Component</span></span></span><span class="hljs-class"><span class="code-title">&lt;</span></span></span>{}&gt; {\n  render(): <span class="code-type">React</span>.<span class="code-type">Node</span> {\n    <span class="code-comment"><span class="code-comment">// ...</span></span>\n  }\n}</code></pre>\n\n<h2 id="h2-7">遇到的一些问题</h2>\n<p>我在使用的过程中目前遇到的问题之一是import 样式资源&nbsp;或&nbsp; 图片时报 “./xxx.scss. Required module not found” 的异常，查看官方文档了解Flow只支持.js、.jsx、.mjs、.json的文件，如果需要导入其他文件需要并支持需要扩展options。在.flowconfig添加options：</p>\n<pre class=""><code class="">[ignore]\n[<span class="code-keyword"><span class="code-keyword">include</span></span>]\n[libs]\n[lints]\n[options]\n<span class="code-keyword"><span class="code-keyword">module</span></span>.file_ext=.scss\n[strict]</code></pre>\n<p>此外，某些IDE对Flow的支持不是很好。我目前所使用的webstorm 2017.3.5相对还不错，不过切记要到File-&gt;Setting-&gt;Languages&amp;Frameworks-&gt;Javascript中将version设置为Flow。</p>\n\n<h2 id="h2-8">写在最后的使用心得</h2>\n<p>引入并按照Flow的规范去约束每一个组件会导致开发量增加不少（当然你引入不用是另外一回事，但是不用引入他做什么？）。搭建好Flow的框架仅仅是开始，之后除了团队成员要去了解flow的使用方法，早期还会遇到各种坑需要去解决。而且Flow也要比React的 <a title="React 深入说明JSX语法与Props特性" href="/article/react/react_understand_jsx_and_props">PropTypes</a>&nbsp;”重“许多。</p>\n<p>JavaScript本来是一个类型推导的原型语言，弄个Flow进来搞得越来越像Java这种强类型语言，也不知道是好是坏，而Java10又学JavaScript等加入了val这种可以类型推导的关键字....。</p>\n<p>总的来说引入规范是有成本的，具体要看团队规模以及项目大小，不是引入越多的技术栈就越有逼格。如果你独立项目的前端开发人数并不多，或者代码膨胀（代码腐烂）速度也没有让你措手不及，建议慎重引入Flow。个人觉得Flow除了开发人员自检还要整合到整个测试框架中，在集成测试或某个版本的代码发布之前进行集中检查。需要思考它在项目的开发、测试、仿真、上线迭代周期中扮演的角色，甚至整合到类似与CMMI之类的管理流程去反向量化考核代码质量。</p>'}});