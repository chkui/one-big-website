webpackJsonp([4],{302:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<p>本文将一点一滴的累计记录Java中的一些细节知识。不只是加以说明，而是所有的细节都找到来源，以官方文档、知名社区的介绍为主。</p>\n<h2 id="h2-1"><strong>StringTokenizer和String.split</strong></h2>\n<pre class="gradle"><code class="gradle">&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-comment"><span class="code-comment">//Use&nbsp;StringTokenizer&nbsp;</span></span>\n&nbsp;&nbsp;&nbsp;&nbsp;StringTokenizer&nbsp;st&nbsp;=&nbsp;<span class="code-keyword"><span\n            class="code-keyword">new</span></span>&nbsp;StringTokenizer(<span class="code-string"><span\n            class="code-string">"this&nbsp;is&nbsp;a&nbsp;test"</span></span>);\n&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-keyword"><span class="code-keyword">while</span></span>&nbsp;(st.hasMoreTokens())&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.<span class="code-keyword"><span\n            class="code-keyword">println</span></span>(st.nextToken());\n&nbsp;&nbsp;&nbsp;&nbsp;}</code></pre>\n<pre class="javascript"><code class="javascript">&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-comment"><span\n        class="code-comment">//Use&nbsp;split</span></span>\n&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-built_in"><span class="code-built_in">String</span></span>[]&nbsp;results&nbsp;=&nbsp;<span\n            class="code-string"><span class="code-string">"this&nbsp;is&nbsp;a&nbsp;test"</span></span>.split(<span\n            class="code-string"><span class="code-string">"\\\\s"</span></span>);\n&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-keyword"><span class="code-keyword">for</span></span>&nbsp;(<span\n            class="code-built_in"><span class="code-built_in">String</span></span>&nbsp;result：results){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(result);\n&nbsp;&nbsp;&nbsp;&nbsp;}</code></pre>\n<p></p>\n<p>关于StringTokenizer和String.split的差异说法很多。官方文档<a\n        href="http://docs.oracle.com/javase/6/docs/api/java/util/StringTokenizer.html有定型说明：" rel="nofollow">http://docs.oracle.com/javase/6/docs/api/java/util/StringTokenizer.html</a>&nbsp;有定性说明（附注：最新的JDK8\n    API文档中也是相同的说明）。</p>\n<blockquote>\n    <p><span style="font-size:11px"><span style="font-family:微软雅黑,microsoft yahei">StringTokenizer</span><span\n            style="background-color:rgb(255, 255, 255); font-family:微软雅黑,microsoft yahei">&nbsp;is a legacy class that is retained for compatibility reasons although its use is discouraged in new code. It is recommended that anyone seeking this functionality use the&nbsp;</span><span\n            style="font-family:微软雅黑,microsoft yahei">split</span><span\n            style="background-color:rgb(255, 255, 255); font-family:微软雅黑,microsoft yahei">&nbsp;method of&nbsp;</span><span\n            style="font-family:微软雅黑,microsoft yahei">String</span><span\n            style="background-color:rgb(255, 255, 255); font-family:微软雅黑,microsoft yahei">&nbsp;or the java.util.regex package instead.</span></span>\n    </p>\n</blockquote>\n<p>大意是StringTokenizer是一个历史遗留类，为了保证向后兼容性而保留这个类。推荐在新的代码中使用split或regex替换。</p>\n<p>至于网上的测评资料说<strong>StringTokenizer比<strong>String.split</strong></strong>效率更高，由于没有亲测就不妄加评论了。作为项目管理者，从风险和可靠性的角度考虑，在项目规范和代码review的过程中，还是以官方文档为准。\n</p>\n<h2 id="h2-2"><strong>transient和volatile关键词的使用</strong></h2>\n<pre class="java"><code class="java"><span class="code-keyword"><span class="code-keyword">transient</span></span>&nbsp;<span\n        class="code-keyword"><span class="code-keyword">volatile</span></span>&nbsp;Set&lt;K&gt;&nbsp;keySet&nbsp;=&nbsp;<span\n        class="code-keyword"><span class="code-keyword">null</span></span>;\n<span class="code-keyword"><span class="code-keyword">transient</span></span>&nbsp;<span class="code-keyword"><span\n            class="code-keyword">volatile</span></span>&nbsp;Collection&lt;V&gt;&nbsp;values&nbsp;=&nbsp;<span\n            class="code-keyword"><span class="code-keyword">null</span></span>;</code></pre>\n<p>transient是变量修饰符，表明该字段不是对象持久状态的一部分，储存的时候不用储存，比如序列化这个对象时，该字段是不会储存的。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;volatile也是变量修饰符，只能用来修饰变量。volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。&nbsp;而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。<br>\n    在此解释一下Java的内存机制：<br>\n    Java使用一个主内存来保存变量当前值，而每个线程则有其独立的工作内存。线程访问变量的时候会将变量的值拷贝到自己的工作内存中，这样，当线程对自己工作内存中的变量进行操作之后，就造成了工作内存中的变量拷贝的值与主内存中的变量值不同。<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java语言规范中指出：为了获得最佳速度，允许线程保存共享成员变量的私有拷贝，而且只当线程进入或者离开同步代码块时才与共享成员变量的原始值对比。这样当多个线程同时与某个对象交互时，就必须要注意到要让线程及时地得到共享成员变量的变化。而volatile关键字就是提示VM：对于这个成员变量不能保存它的私有拷贝，而应直接与共享成员变量交互。<br>\n    使用建议：在两个或者更多的线程访问的成员变量上使用volatile。当要访问的变量已在synchronized代码块中，或者为常量时，不必使用。由于使用volatile屏蔽掉了VM中必要的代码优化，所以在效率上比较低，因此一定在必要时才使用此关键字。\n</p>'},304:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<p>JSR330是Jcp给出的官方标准反向依赖注入规范。Java大部分反向依赖注入的工具或者框架目前基本上都满足JSR330规范、例如spring、guice以及Dagger。</p>\n<p>以我们最常用的spring为例。</p>\n<p>JSR中<span style="color:#cc0000">@Inject</span>可以当做<span style="color:#cc0000">@AutoWired</span>来使用。而<span\n        style="color:#cc0000">@Named</span>可以当做<span style="color:#cc0000">@Component</span>来使用。</p>\n<p>使用JSR330首先要引入javax.inject包：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">dependency</span>&gt;</span>  \n    <span class="code-tag">&lt;<span class="code-name">groupId</span>&gt;</span>javax.inject<span class="code-tag">&lt;/<span\n            class="code-name">groupId</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">artifactId</span>&gt;</span>javax.inject<span class="code-tag">&lt;/<span\n            class="code-name">artifactId</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">version</span>&gt;</span>1<span class="code-tag">&lt;/<span\n            class="code-name">version</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">dependency</span>&gt;</span> </code></pre>\n<p>目前Maven中央仓库中就一个inject的jar。</p>\n<p>首先使用xml配置通过注解扫描添加bean。</p>\n<pre><code class="xml"><span class="php"><span class="code-meta">&lt;?</span>xml version=<span\n        class="code-string">"1.0"</span> encoding=<span class="code-string">"UTF-8"</span><span\n        class="code-meta">?&gt;</span></span>\n<span class="code-tag">&lt;<span class="code-name">beans</span> <span class="hljs-attr">xmlns</span>=<span\n        class="code-string">"http://www.springframework.org/schema/beans"</span>\n    <span class="hljs-attr">xmlns:xsi</span>=<span\n            class="code-string">"http://www.w3.org/2001/XMLSchema-instance"</span>\n    <span class="hljs-attr">xmlns:context</span>=<span class="code-string">"http://www.springframework.org/schema/context"</span>  \n    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="code-string">"http://www.springframework.org/schema/beans  \n    http://www.springframework.org/schema/beans/spring-beans-3.1.xsd  \n    http://www.springframework.org/schema/context  \n    http://www.springframework.org/schema/context/spring-context-3.1.xsd"</span>&gt;</span>  \n    <span class="code-tag">&lt;<span class="code-name">context:component-scan</span>  <span class="hljs-attr">base-package</span>=<span\n            class="code-string">"com.demo.jsr330"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span>  </code></pre>\n<p>然后像下面这个添加一个bean</p>\n<pre><code class="java"><span class="code-meta">@Named</span>  \n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">service</span> </span>{\n  <span class="hljs-function"><span class="code-keyword">public</span>  <span class="code-keyword">void</span>   <span\n          class="code-title">print</span><span class="hljs-params">()</span></span>{\n     System.out.println(<span class="code-string">"Service  print  method is invoked"</span>);  \n  }  \n}  </code></pre>\n<p>然后将这个bean注入到其他bean中去使用</p>\n<pre><code class="java"><span class="code-meta">@Named</span>  \n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Faction</span> </span>{\n  <span class="code-meta">@Inject</span>\n  Service service;\n\n  <span class="hljs-function"><span class="code-keyword">public</span>  <span class="code-keyword">void</span>  <span\n          class="code-title">show</span><span class="hljs-params">()</span></span>{\n     service.print()； \n  }  \n}  </code></pre>\n<p>JSR330还定义了<span style="color:#FF0000">@Qualifier</span>和<span style="color:#FF0000">@Provider</span>，对应到spring都给出了标准的实现。\n</p>\n<p>使用JSR330代替原注解的好处是无论使用任何反向依赖注入工具或框架，只要他是支持JSR330的，都可以平滑的切换。</p>'},319:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h2 id="h2-1">为什么要用Fragments</h2>\n<p>在我们使用React开发组件的时候，每个React组件都必须返回一个根元素。例如下面这样：</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">Table</span></span></span><span class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span class="hljs-class"><span class="code-title">Component</span></span></span><span class="hljs-class"> </span></span>{\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> (\n      <span class="xml"><span class="code-tag">&lt;<span class="code-name">table</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">tr</span>&gt;</span>\n          <span class="code-tag">&lt;<span class="code-name"><span class="code-type">Columns</span></span> /&gt;</span>\n        <span class="code-tag">&lt;/<span class="code-name">tr</span>&gt;</span>\n      <span class="code-tag">&lt;/<span class="code-name">table</span>&gt;</span>\n    );\n  }\n}\n\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">Columns</span> <span class="code-keyword">extends</span> <span class="code-title">React</span>.<span class="code-title">Component</span> </span>{\n  render() {\n    <span class="code-keyword">return</span> (\n      <span class="code-tag">&lt;<span class="code-name">div</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">td</span>&gt;</span><span class="code-type">Hello</span><span class="code-tag">&lt;/<span class="code-name">td</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">td</span>&gt;</span><span class="code-type">World</span><span class="code-tag">&lt;/<span class="code-name">td</span>&gt;</span>\n      <span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span>\n    );\n  }\n}</span></code></pre>\n<p>在正常的HTML行文中，&lt;tr&gt;标签与&lt;td&gt;标签之间的&lt;div&gt;标签是不应该存在的。</p>\n<p>虽然在这个小小的例子中，我们可以将tr标签移入到Columns中去解决这个问题，但是在错综复杂的业务层级代码中，我们经常会遇到希望一个组件返回多个并列标签的情况。</p>\n<p>为了解决这个问题，React在16.x版本新推出了一个Fragments特性——组件碎片化。Fragments的使用方法非常简单，我们将Column组件稍作改造即可：</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">Columns</span></span></span><span class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span class="hljs-class"><span class="code-title">Component</span></span></span><span class="hljs-class"> </span></span>{\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> (\n      <span class="xml"><span class="code-tag">&lt;<span class="code-name"><span class="code-type">React</span>.<span class="code-type">Fragment</span></span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">td</span>&gt;</span><span class="code-type">Hello</span><span class="code-tag">&lt;/<span class="code-name">td</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">td</span>&gt;</span><span class="code-type">World</span><span class="code-tag">&lt;/<span class="code-name">td</span>&gt;</span>\n      <span class="code-tag">&lt;/<span class="code-name"><span class="code-type">React</span>.<span class="code-type">Fragment</span></span>&gt;</span>\n    );\n  }\n}</span></code></pre>\n<p>这样，在最终渲染成Dom后，并不会出现任何与HTML行文不符的标签。</p>\n\n<h2 id="h2-2">简写与注意事项</h2>\n<p>除了React.Fragment这样的写法，React还推荐使用更加明了的简短写法：</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">Columns</span></span></span><span class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span class="hljs-class"><span class="code-title">Component</span></span></span><span class="hljs-class"> </span></span>{\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> (\n      <span class="xml"><span class="code-tag">&lt;&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">td</span>&gt;</span><span class="code-type">Hello</span><span class="code-tag">&lt;/<span class="code-name">td</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">td</span>&gt;</span><span class="code-type">World</span><span class="code-tag">&lt;/<span class="code-name">td</span>&gt;</span>\n      <span class="code-tag">&lt;/&gt;</span>\n    );\n  }\n}</span></code></pre>\n<p>需要注意的是：<span style="color:#FF0000">这样的写法不支持传递任何参数，而且某些编译器或者编译工具并不支持这种写法</span>。</p>\n\n<h2 id="h2-3">在队列中使用</h2>\n<p>一个React元素除了直接写成一个组件，也可以在队列中返回。Fragment标签使用到队列中同样也要<a href="https://www.chkui.com/article/react/react_list_key_and_form" title="列表与组件的键值">使用key属性来标记队列的位置</a>：</p>\n<pre class="javascript"><code class="language-javascript"><span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">function</span></span></span><span class="hljs-function"> </span><span class="code-title"><span class="hljs-function"><span class="code-title">Glossary</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{\n  <span class="code-keyword"><span class="code-keyword">return</span></span> (\n    <span class="xml"><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">dl</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n      {props.items.map(item =&gt; (\n        </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">React.Fragment</span></span></span></span><span class="xml"><span class="code-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="code-tag"><span class="hljs-attr">key</span></span></span></span><span class="xml"><span class="code-tag">=</span></span><span class="code-string"><span class="xml"><span class="code-tag"><span class="code-string">{item.id}</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n          </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">dt</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">{item.term}</span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">dt</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n          </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">dd</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">{item.description}</span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">dd</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n        </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">React.Fragment</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n      ))}\n    </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">dl</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n  );\n}</span></span></code></pre>\n<p></p>'}});