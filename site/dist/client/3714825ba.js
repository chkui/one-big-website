webpackJsonp([3],{311:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h2 id="h2-1">Niubility的Nodejs &nbsp;&nbsp;</h2>\n<p>关于大名鼎鼎的Nodejs是什么就不用再介绍了，他的牛逼之处数都数不完——让javascript称霸全宇宙、将一个只用于前端的编程语言同时可以制霸前后端、让致力于前端开发的小哥又多了一项事业新增了一门手艺、亮瞎人的全异步事件驱动型架构（event-driven、non-blocking、scalability）。总的来说就是，学好Nodejs必须能够赚大钱迎娶白富美。</p>\n<p>本人一直垂涎与Nodejs的鼎鼎大名，但是由于工作繁忙，一直没时间深入亵玩。最近因为一些机缘，又要着手一些前端开发的工作才觅得一次全面接触的良机。</p>\n<p>看到这里你肯定要说，又是一个要把Nodejs吹上天的文章！NoNo，本文会一步一步的说明我是怎么学会和用上nodejs的，然后结合其我所了解的语言告诉各位我所了解的Nodejs坑和优势。</p>\n\n<h2 id="h2-2">学习基础</h2>\n<p>先说说本人开始学习使用的基础。早期在某外企开发室内3D设计软件，那段时间用已经成为古董的MFC做各种windows事件驱动开发。</p>\n<p>之后就一直在做Java生态的东西、反正就是SSH啦、MVC啦、Dao啦、Entity啦、JNDI啦、JDBC啦等等，相信每个Javaer都懂的。早些年做Java时，前端部分基本就是玩转Jsp，页面清一色的用Jsp动态生成，然后丢给浏览器。现在所属团队几乎已经放弃这种方式，都是用spring-boot等弄前后端分离了。</p>\n<p>随后有幸接到一个自己可以全权负责的全新的项目，于是带着2个人开始尝试抛弃JSP，引入了大量的ajax异步请求的客户端组装数据。那时候这样做其实蛮痛苦的，新项目根本没有真正意义的前端开发人员（都玩JSP呢），所以自己不得不去研究前端的各种前端技术。在随后的许多时光中，深入且大量的学习了前端开发的所有东西，从一穷二白只会用div画画静态页面，到后面自己封装列表、消息通知等组件，通杀jquery、angularjs，了解各种脚手架。所以学习Nodejs开发，我基本上是没有语言障碍的，只是需要跟上它的思路。</p>\n\n<h2 id="h2-3">安装Nodejs</h2>\n<p>要用一样东西之前，当然是要先安装环境。Nodejs的安装网上一搜一大把，这里就简单记录一下流程，方面以后查阅。因为本人用一台windows（windows10）办公、用一台linux（ubuntu16.04）开发，所以2个操作系统都安装了Nodejs，像OSX这样高大上的玩意，暂时没机器去弄（穷）。</p>\n\n<h3 id="h3-1">windows</h3>\n<ol>\n    <li>先去官网（https://nodejs.org或https://nodejs.org/en/download/）下载一个安装包，我下的是长期稳定版。建议下载.msi。</li>\n    <li>然后就是安装了，这没什么好说的。无非就是设定一下安装目录，然后一通Next。</li>\n    <li>安装好之后检查下环境变量，看看path下添加入了Nodejs的运行路径。cmd中输入path可以看到添加了nodejs的安装目录。然后输入node --version可以看到当前的Nodejs版本号。如下图：&nbsp;&nbsp;&nbsp;&nbsp;<img alt="安装NodeJs运行环境" height="175" src="https://file.mahoooo.com/res/file/install_nodejs_runtime_environment_1.png" width="527"></li>\n    <li>Nodejs自带npm，npm和其他未来要使用的组件都存放在“X:\\yourpath\\nodejs\\node_modules”里。所以需要在windows环境变量重增加一个NODE_PATH=X:\\yourpath\\nodejs\\node_modules的参数，保证未来新增的一些模块工具可以正常使用。右键“我的电脑”-&gt;高级系统设置-&gt;环境变量-&gt;然后新建以上参数。</li>\n    <li>再然后就是最后一步了，设置node_cache（用于npm存放一些临时文件）和node_global（全局工具文件夹），当然这里也可以不设置，他会自动放在当前用户的文件夹下，但是有强迫症的我必须要设置。在cmd中输入一下命令：</li>\n</ol>\n<pre class="sql"><code class="language-bash">npm config <span class="code-built_in"><span class="code-keyword">set</span></span> prefix <span class="code-string"><span class="code-string">\'X:\\yourpath\\nodejs\\node-global\'</span></span>\n\nnpm config <span class="code-built_in"><span class="code-keyword">set</span></span> <span class="code-keyword">cache</span> <span class="code-string"><span class="code-string">\'X:\\yourpath\\nodejs\\node_cache\'</span></span></code></pre>\n\n<h3 id="h3-2">linux</h3>\n<p>linux安装和windows安装Nodejs差不多，都是下载包、解压、开用。</p>\n<ol>\n    <li>先去官网下载一个linux版本的安装包（下首页的那个就行）。下载以后发现是 xz后缀，先得用xz命令解压成tar，再用tar完成解压。</li>\n    <li>添加Nodejs运行环境：直接把node的运行目录添加到&amp;PATH里。在profile中添加Node的运行环境： <pre class="bash"><code class="language-bash"><span class="code-comment"><span class="code-comment">#node</span></span>\n<span class="code-built_in"><span class="code-built_in">export</span></span> NODE_HOME=/yourpath/node-v4.5.0-linux-x64\n<span class="code-built_in"><span class="code-built_in">export</span></span> PATH=<span class="code-variable"><span class="code-variable">$NODE_HOME</span></span>/bin:<span class="code-variable"><span class="code-variable">$PATH</span></span></code></pre> <p>然后再任意位置测试了一下运行node命令都可以正常使用。</p> </li>\n    <li> <p>然后我们需要添加node_modules到PATH中，保证npm可以使用：</p> <pre class="bash"><code class="language-apache"><span class="code-comment">#npm</span>\n<span class="code-built_in">export</span> NODE_PATH=<span class="code-variable">$NODE_HOME</span>/node_modules\n</code></pre> <p>配置完之后，就可以使用npm命令了。（修改之后切记注销用户）</p> </li>\n</ol>\n<p>完成以上步奏之后，就可以用node和npm命令干你相干的事了。安装之前按看到很多教程说是要安装python2.2到2.7的版本。但是我解压完nodejs包后在bin下运行了node -v命令居然可以跑，我就没去管python的事，应该是我用的是打包版的原因。</p>\n\n<h3 id="h3-3">Apt安装Nodejs</h3>\n<p>1.设定Nodejs安装源：</p>\n<pre class="nginx"><code class="language-bash"><span class="code-attribute">curl</span> <span class="hljs-_">-s</span>L https://deb.nodesource.com/setup_8.x | sudo -E bash -</code></pre>\n<p>2.安装Nodejs</p>\n<pre class="actionscript"><code class="language-bash">sudo apt-<span class="code-keyword">get</span> install -y nodejs</code></pre>\n\n<h3 id="h3-4">验证安装结果</h3>\n<p>安装完成之后，我在windows和linux都测试了一下。</p>\n<p>测试nodejs：输入node打开REPL，然后使用log打印数据：</p>\n<pre class="javascript"><code class="language-bash">$ node\n&gt; <span class="code-built_in">console</span>.log(<span class="code-string"><span class="code-string">"hello nodejs!"</span></span>);\nhello nodejs!\n<span class="hljs-literal">undefined</span></code></pre>\n<p>然后用npm测试安装grunt-cli：</p>\n<pre class="groovy"><code class="language-bash">$ npm install -g grunt-cli\n<span class="hljs-regexp">/yourpath/</span>node-v4<span class="hljs-number">.5</span><span class="hljs-number">.0</span>-linux-x64<span class="hljs-regexp">/node_global/</span>bin<span class="hljs-regexp">/grunt -&gt; /</span>yourpath<span class="hljs-regexp">/node-v4.5.0-linux-x64/</span>node_global<span class="hljs-regexp">/lib/</span>node_modules<span class="hljs-regexp">/grunt-cli/</span>bin/grunt\ngrunt-cli@<span class="hljs-number">1.2</span><span class="hljs-number">.0</span> <span class="hljs-regexp">/me/</span>soft<span class="hljs-regexp">/node/</span>node-v4<span class="hljs-number">.5</span><span class="hljs-number">.0</span>-linux-x64<span class="hljs-regexp">/node_global/</span>lib<span class="hljs-regexp">/node_modules/</span>grunt-cli\n├── grunt-known-options@<span class="hljs-number">1.1</span><span class="hljs-number">.0</span>\n├── resolve@<span class="hljs-number">1.1</span><span class="hljs-number">.7</span>\n├── nopt@<span class="hljs-number">3.0</span><span class="hljs-number">.6</span> (abbrev@<span class="hljs-number">1.0</span><span class="hljs-number">.9</span>)\n└── findup-sync@<span class="hljs-number">0.3</span><span class="hljs-number">.0</span> (glob@<span class="hljs-number">5.0</span><span class="hljs-number">.15</span>)</code></pre>\n\n<h3 id="h3-5">运行一个Nodejs程序</h3>\n<p>安装好之后，node的命令行和npm的命令行就都可以使用了，随后当然就是要跑跑Nodejs了。像下面这样创建一个创建一个example.js文件，随便放在某个文件：</p>\n<pre class="javascript"><code class="language-javascript"><span class="code-keyword"><span class="code-keyword">const</span></span> http = <span class="code-built_in"><span class="code-built_in">require</span></span>(<span class="code-string"><span class="code-string">\'http\'</span></span>);\n\n<span class="code-keyword"><span class="code-keyword">const</span></span> hostname = <span class="code-string"><span class="code-string">\'127.0.0.1\'</span></span>;\n<span class="code-keyword"><span class="code-keyword">const</span></span> port = <span class="hljs-number"><span class="hljs-number">3000</span></span>;\n\n<span class="code-keyword"><span class="code-keyword">const</span></span> server = http.createServer((req, res) -&gt; {\n  res.statusCode = <span class="hljs-number"><span class="hljs-number">200</span></span>;\n  res.setHeader(<span class="code-string"><span class="code-string">\'Content-Type\'</span></span>, <span class="code-string"><span class="code-string">\'text/plain\'</span></span>);\n  res.end(<span class="code-string"><span class="code-string">\'Hello World Nodejs\\n\'</span></span>);\n});\n\nserver.listen(port, hostname, () =&gt; {\n  <span class="code-built_in"><span class="code-built_in">console</span></span>.log(<span class="code-string"><span class="code-string">`Server running at http://</span><span class="hljs-subst"><span class="code-string"><span class="hljs-subst">${hostname}</span></span></span><span class="code-string">:</span><span class="hljs-subst"><span class="code-string"><span class="hljs-subst">${port}</span></span></span><span class="code-string">/`</span></span>);\n});</code></pre>\n<p>然后在当前文件下打开一个cmd运行以下命令：</p>\n<pre class="css"><code class="language-bash"><span class="code-selector-tag">node</span> <span class="code-selector-tag">example</span><span class="code-selector-class">.js</span></code></pre>\n<p>可以看到输出：</p>\n<pre class="php"><code class="language-bash"><span class="code-variable">$node</span> example.js\n\nServer running at http:<span class="code-comment">//127.0.0.1:3000</span></code></pre>\n'},316:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h2 id="h2-1">Web组件</h2>\n<p>从概念上说，React 和 <a title="Web组件" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components" rel="nofollow">Web组件</a>&nbsp;分别用于解决不同的问题。Web组件提供了强大的封装特性来支持其可重复使用性，而React提供了一系列声明性（declarative）接口保证Dom结构和数据同步。但是某些时候这2个目标是互补的。对于开发人员来说将React用于Web组件、或将Web组件用于React、或2者皆有并非难事。\n</p>\n<p>虽然大部分使用React的开发人员并不需要使用Web组件，但是在某些情况，特别是引入了某些第三方库，还是需要使用到相关机制。</p>\n\n<h3 id="h3-1">在React中使用Web组件</h3>\n<pre class="scala"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span\n        class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span\n        class="code-title"><span class="hljs-class"><span class="code-title">HelloMessage</span></span></span><span\n        class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="xml"><span class="code-tag">&lt;<span\n            class="code-name">div</span>&gt;</span><span class="code-type">Hello</span> <span class="code-tag">&lt;<span\n            class="code-name">x-search</span>&gt;</span>{<span class="code-keyword">this</span>.props.name}<span\n            class="code-tag">&lt;/<span class="code-name">x-search</span>&gt;</span>!<span class="code-tag">&lt;/<span\n            class="code-name">div</span>&gt;</span>;\n  }\n}</span></code></pre>\n<blockquote>\n    <p>Web组件常会暴露一些必要的API接口，例如一个 video Web组件可能会暴露&nbsp;&nbsp;<code>play()</code>&nbsp;和&nbsp;<code>pause()</code>&nbsp;方法。为了获取Web组件暴露的这些API接口，需要在React编码使用Refs特性来直接获取真实的Dom节点。如果引入第三方的Web组件，最好的解决方案使用一个React组件来包装引入的Web组件并最终作为一个React组件来使用。\n    </p>\n    <p>由第三方Web组件触发的事件也许并不能通过React的渲染树传递，此时需要在组件中去手工的触发事件。&nbsp;</p>\n</blockquote>\n<p>一个经常导致混乱的地方是，Web组件使用的是“class”而React使用的是“className”，例如：</p>\n<pre class="javascript"><code class="language-javascript"><span class="hljs-function"><span class="code-keyword"><span\n        class="hljs-function"><span class="code-keyword">function</span></span></span><span\n        class="hljs-function"> </span><span class="code-title"><span class="hljs-function"><span class="code-title">BrickFlipbox</span></span></span><span\n        class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span\n        class="hljs-params"></span>) </span></span>{\n  <span class="code-keyword"><span class="code-keyword">return</span></span> (\n    <span class="xml"><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span\n            class="code-name">brick-flipbox</span></span></span></span><span class="xml"><span class="code-tag"> </span></span><span\n            class="hljs-attr"><span class="xml"><span class="code-tag"><span\n            class="hljs-attr">class</span></span></span></span><span class="xml"><span\n            class="code-tag">=</span></span><span class="code-string"><span class="xml"><span class="code-tag"><span\n            class="code-string">"demo"</span></span></span></span><span class="xml"><span\n            class="code-tag">&gt;</span></span></span><span class="xml">\n      </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">div</span></span></span></span><span\n            class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">front</span><span\n            class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span\n            class="xml"><span class="code-tag"><span class="code-name">div</span></span></span></span><span class="xml"><span\n            class="code-tag">&gt;</span></span></span><span class="xml">\n      </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">div</span></span></span></span><span\n            class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">back</span><span\n            class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span\n            class="xml"><span class="code-tag"><span class="code-name">div</span></span></span></span><span class="xml"><span\n            class="code-tag">&gt;</span></span></span><span class="xml">\n    </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span\n            class="code-name">brick-flipbox</span></span></span></span><span class="xml"><span\n            class="code-tag">&gt;</span></span></span><span class="xml">\n  );\n}</span></span></code></pre>\n\n<h3 id="h3-2">在Web组件中使用React</h3>\n<pre class="javascript"><code class="language-javascript"><span class="code-keyword"><span\n        class="code-keyword">const</span></span> proto = <span class="code-built_in"><span\n        class="code-built_in">Object</span></span>.create(HTMLElement.prototype, {\n  attachedCallback: {\n    value: <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">function</span></span></span><span class="hljs-function">(</span><span\n            class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{\n      <span class="code-keyword"><span class="code-keyword">const</span></span> mountPoint = <span\n            class="code-built_in"><span class="code-built_in">document</span></span>.createElement(<span\n            class="code-string"><span class="code-string">\'span\'</span></span>);\n      <span class="code-keyword"><span class="code-keyword">this</span></span>.createShadowRoot().appendChild(mountPoint);\n\n      <span class="code-keyword"><span class="code-keyword">const</span></span> name = <span class="code-keyword"><span\n            class="code-keyword">this</span></span>.getAttribute(<span class="code-string"><span class="code-string">\'name\'</span></span>);\n      <span class="code-keyword"><span class="code-keyword">const</span></span> url = <span class="code-string"><span\n            class="code-string">\'https://www.google.com/search?q=\'</span></span> + <span class="code-built_in"><span\n            class="code-built_in">encodeURIComponent</span></span>(name);\n      ReactDOM.render(<span class="xml"><span class="code-tag"><span class="xml"><span\n            class="code-tag">&lt;</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span\n            class="code-name">a</span></span></span></span><span class="xml"><span class="code-tag"> </span></span><span\n            class="hljs-attr"><span class="xml"><span class="code-tag"><span class="hljs-attr">href</span></span></span></span><span\n            class="xml"><span class="code-tag">=</span></span><span class="code-string"><span class="xml"><span\n            class="code-tag"><span class="code-string">{url}</span></span></span></span><span class="xml"><span\n            class="code-tag">&gt;</span></span></span><span class="xml">{name}</span><span class="code-tag"><span\n            class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span class="xml"><span\n            class="code-tag"><span class="code-name">a</span></span></span></span><span class="xml"><span\n            class="code-tag">&gt;</span></span></span></span>, mountPoint);\n    }\n  }\n});\n<span class="code-built_in"><span class="code-built_in">document</span></span>.registerElement(<span\n            class="code-string"><span class="code-string">\'x-search\'</span></span>, {prototype: proto});</code></pre>\n\n<h3 id="h3-3">React整合Jquery这一类直接操作Dom的技术</h3>\n<p>\n    React在发生真实Dom渲染之前都会先产生与之对应的虚拟Dom结构，然后再“合适”的时候将虚拟Dom的内容渲染到真实Dom上，完成渲染之后componentDidMount会被调用。Jquery这一类真实Dom的操作技术投入实际使用时最好在componentDidMount中使用，然后保证这个组件不会的虚拟Dom不发生任何改变。</p>'},336:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<p>Vert.x可以使用Zookeeper和Ignite等框架来创建集群，但是首选框架还是Hazelcast。此外，码友们也可以通过<em>ClusterManager</em>接口实现或引入需要的集群管理工具。本文将说明Vert.x是如何利用Hazelcast来创建和管理集群的，同时你也会了解到Vertx如何创建单机实例。</p>\n<h2 id="h2-1"><strong>集群创建</strong></h2>\n<p>在创建Vert.x集调用群时，调用方法和创建单机实例是有差异的。集群需要调<em>Vertx.clusteredVertx</em>异步方法创建。集群可以完全新建和引入已有的Hazelcast实例二种方式来创建。如下：</p>\n<p>1.新建实例</p>\n<blockquote>\n    <p>ClusterManager mgr = new HazelcastClusterManager();</p>\n</blockquote>\n<p>2.引入Hazelcast实例</p>\n<blockquote>\n    <p>ClusterManager mgr = new HazelcastClusterManager(hazelcastInstance);</p>\n</blockquote>\n<p>详情可以参考官方手册<a title="Hazelcast" href="http://vertx.io/docs/vertx-hazelcast/java/" rel="nofollow">http://vertx.io/docs/vertx-hazelcast/java/</a>。</p>\n\n<h2 id="h2-2">新建集群过程</h2>\n<p>调用<em>Vertx.clusteredVertx</em>静态方法后，Vert.x会利用Vertx工厂方法创建Vertx实例。如下</p>\n<p>其中简单直白的使用 <em>new&nbsp;VertxImpl();</em>来创建Vertx实例。</p>\n<pre class="gradle"><code class="gradle">VertxFactoryImpl.clusteredVertx(VertxOptions <span class="code-keyword"><span class="code-keyword">options</span></span>, <span class="code-keyword"><span class="code-keyword">final</span></span> Handler&lt;AsyncResult&lt;Vertx&gt;&gt; resultHandler) {\n    <span class="code-keyword"><span class="code-keyword">options</span></span>.setClustered(<span class="code-keyword"><span class="code-keyword">true</span></span>);<span class="code-comment"><span class="code-comment">//设置参数，启用集群</span></span>\n    <span class="code-keyword"><span class="code-keyword">new</span></span> VertxImpl(<span class="code-keyword"><span class="code-keyword">options</span></span>, resultHandler);<span class="code-comment"><span class="code-comment">//创建Vertx实例</span></span>\n}</code></pre>\n<p style="text-align:center">图1启动集群</p>\n<p>在<em>VertxImpl</em>的构造方法中，若需要创建集群，则执行：</p>\n<pre class="gradle"><code class="gradle">VertxImpl(VertxOptions <span class="code-keyword"><span class="code-keyword">options</span></span>, Handler&lt;AsyncResult&lt;Vertx&gt;&gt; resultHandler) {\n    <span class="code-comment"><span class="code-comment">// some code</span></span>\n    <span class="code-keyword"><span class="code-keyword">if</span></span> (<span class="code-keyword"><span class="code-keyword">options</span></span>.isClustered()) {\n      <span class="code-keyword"><span class="code-keyword">this</span></span>.clusterManager = getClusterManager(<span class="code-keyword"><span class="code-keyword">options</span></span>);<span class="code-comment"><span class="code-comment">//1.获取集群管理对象</span></span>\n      <span class="code-keyword"><span class="code-keyword">this</span></span>.clusterManager.setVertx(<span class="code-keyword"><span class="code-keyword">this</span></span>);<span class="code-comment"><span class="code-comment">//2. 设置实例</span></span>\n      <span class="code-keyword"><span class="code-keyword">this</span></span>.clusterManager.<span class="code-keyword"><span class="code-keyword">join</span></span>(ar -&gt; {<span class="code-comment"><span class="code-comment">//3. 加入集群</span></span>\n        <span class="code-keyword"><span class="code-keyword">if</span></span> (ar.failed()) {\n          log.error(<span class="code-string"><span class="code-string">"Failed to join cluster"</span></span>, ar.cause());\n        } <span class="code-keyword"><span class="code-keyword">else</span></span> {\n          <span class="code-comment"><span class="code-comment">// Provide a memory barrier as we are setting from a different thread</span></span>\n          <span class="code-keyword"><span class="code-keyword">synchronized</span></span> (VertxImpl.<span class="code-keyword"><span class="code-keyword">this</span></span>) {\n            haManager = <span class="code-keyword"><span class="code-keyword">new</span></span> HAManager(<span class="code-keyword"><span class="code-keyword">this</span></span>, deploymentManager, clusterManager, <span class="code-keyword"><span class="code-keyword">options</span></span>.getQuorumSize(),\n                                      <span class="code-keyword"><span class="code-keyword">options</span></span>.getHAGroup(), haEnabled);\n            createAndStartEventBus(<span class="code-keyword"><span class="code-keyword">options</span></span>, resultHandler);\n          }\n        }\n      });\n    } <span class="code-keyword"><span class="code-keyword">else</span></span> {\n      <span class="code-keyword"><span class="code-keyword">this</span></span>.clusterManager = <span class="code-keyword"><span class="code-keyword">null</span></span>;\n      createAndStartEventBus(<span class="code-keyword"><span class="code-keyword">options</span></span>, resultHandler);\n    }\n    <span class="code-comment"><span class="code-comment">// some code</span></span>\n  }</code></pre>\n<p style="text-align:center">图2</p>\n<p>这里会分3部来创建集群，首先调用<em>getClusterManager</em>来获取集群的配置管理实例。如下：</p>\n<pre class="gradle"><code class="language-java">getClusterManager(VertxOptions <span class="code-keyword">options</span>) {\n    <span class="code-keyword"><span class="code-keyword">if</span></span> (<span class="code-keyword">options</span>.isClustered()) {\n      <span class="code-keyword"><span class="code-keyword">if</span></span> (<span class="code-keyword">options</span>.getClusterManager() != <span class="code-keyword"><span class="code-keyword">null</span></span>) {<span class="code-comment"><span class="code-comment">//判断是否已经创建集群管理对方</span></span>\n        <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="code-keyword">options</span>.getClusterManager();<span class="code-comment"><span class="code-comment">//若已创建，直接使用这个对象。</span></span>\n      } <span class="code-keyword"><span class="code-keyword">else</span></span> {<span class="code-comment"><span class="code-comment">//若无创建，执行新建过程。</span></span>\n        ClusterManager mgr;\n        String clusterManagerClassName = System.getProperty(<span class="code-string"><span class="code-string">"vertx.cluster.managerClass"</span></span>);<span class="code-comment"><span class="code-comment">/*通过系统参数设置集群管理对象*/</span></span>\n        <span class="code-keyword"><span class="code-keyword">if</span></span> (clusterManagerClassName != <span class="code-keyword"><span class="code-keyword">null</span></span>) {<span class="code-comment"><span class="code-comment">//clusterManagerClassName变量指定的类名存在，开始加载</span></span>\n          <span class="code-comment"><span class="code-comment">// We allow specify a sys prop for the cluster manager factory which overrides ServiceLoader</span></span>\n          <span class="code-keyword"><span class="code-keyword">try</span></span> {\n            <span class="code-keyword">Class</span>&lt;?&gt; clazz = <span class="code-keyword">Class</span>.forName(clusterManagerClassName);\n            mgr = (ClusterManager)clazz.newInstance();\n          } <span class="code-keyword"><span class="code-keyword">catch</span></span> (Exception e) {\n            <span class="code-keyword"><span class="code-keyword">throw</span></span> <span class="code-keyword"><span class="code-keyword">new</span></span> IllegalStateException(<span class="code-string"><span class="code-string">"Failed to instantiate "</span></span> + clusterManagerClassName, e);\n          }\n        } <span class="code-keyword"><span class="code-keyword">else</span></span> {<span class="code-comment"><span class="code-comment">//clusterManagerClassName指定的变量null,使用默认加载器。</span></span>\n          ServiceLoader&lt;ClusterManager&gt; mgrs = ServiceLoader.load(ClusterManager.<span class="code-keyword">class</span>);\n          <span class="code-keyword"><span class="code-keyword">if</span></span> (!mgrs.iterator().hasNext()) {\n            <span class="code-keyword"><span class="code-keyword">throw</span></span> <span class="code-keyword"><span class="code-keyword">new</span></span> IllegalStateException(<span class="code-string"><span class="code-string">"No ClusterManagerFactory instances found on classpath"</span></span>);\n          }\n          mgr = mgrs.iterator().<span class="code-keyword">next</span>();\n        }\n        <span class="code-keyword"><span class="code-keyword">return</span></span> mgr;\n      }\n    } <span class="code-keyword"><span class="code-keyword">else</span></span> {\n      <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="code-keyword"><span class="code-keyword">null</span></span>;\n    }\n  }</code></pre>\n<p style="text-align:center">图3，获取集群管理类<br> 从源码看，<em><code>getClusterManager</code></em>并没有什么特殊的地方。首先检查用户在创建Vertx实例之前，是否创建了集群的管理对象<code><em>ClusterManager</em>。创建了，则使用这个管理对象，没有创建则自行新建一个。</code></p>\n<p>注意</p>\n<blockquote>\n    <p>String clusterManagerClassName = System.getProperty("vertx.cluster.managerClass");</p>\n</blockquote>\n<p>这行代码 ，这说明可以通过JVM环境参数（<em>-Dvertx.cluster.managerClass=[className]</em>）来指定Vertx加载集群管理对象类。这在官方手册中并没有任何一个地方说明。</p>\n<p>如果指定了managerClass，则会使用默认加载方式加载指定的类，并转换成<em>ClusterManager</em>接口。</p>\n<p>如果没有指定managerClass，则使用默认集群加载类启动集群。</p>\n<blockquote>\n    <p>ServiceLoader&lt;ClusterManager&gt; mgrs = ServiceLoader.load(ClusterManager.class);&nbsp;</p>\n</blockquote>\n<p>ServiceLoader是Java在1.6定义的聚群接口类，有点类似于spring的Ioc容器。其过程也是加载类。详细说明请查阅&nbsp;<a href="http://my.oschina.net/hanzhankang/blog/109794" rel="nofollow">通过ServiceLoader实现链式处理</a>&nbsp;一文，解释得很清楚。</p>\n<p>可以看到在<em>vertx-hazelcast-[vertsion].jar</em>包中，<em>META-INF/services/io.vertx.core.spi.cluster.ClusterManager</em>指定了<em>ClusterManager</em>要<em>ServiceLoader</em>加载<em>HazelcastClusterManager。</em></p>\n<blockquote>\n    <p>io.vertx.spi.cluster.hazelcast.HazelcastClusterManager</p>\n</blockquote>\n<p>回到图2，Vert.x接下来使用</p>\n<blockquote>\n    <p>clusterManager.setVertx(this)</p>\n</blockquote>\n<p>将vertx实例设置到集群管理类中。 随后调用</p>\n<blockquote>\n    <p>clusterManager.join</p>\n</blockquote>\n<p>来加入集群。 下面是<em>clusterManager.join</em>的源码</p>\n<pre class="less"><code class="less"><span class="code-selector-tag"><span class="code-selector-tag">synchronized</span></span> <span class="code-selector-tag"><span class="code-selector-tag">void</span></span> <span class="code-selector-tag"><span class="code-selector-tag">join</span></span>(Handler&lt;AsyncResult&lt;Void&gt;&gt; resultHandler) {\n    <span class="code-selector-tag"><span class="code-selector-tag">vertx</span></span><span class="code-selector-class"><span class="code-selector-class">.executeBlocking</span></span>(fut -&gt; {\n      <span class="code-selector-tag"><span class="code-selector-tag">if</span></span> (!active) {<span class="code-comment"><span class="code-comment">//确保只初始化一次</span></span>\n        active = true;\n        <span class="code-selector-tag"><span class="code-selector-tag">if</span></span> (customHazelcastCluster) {<span class="code-comment"><span class="code-comment">//当使用的是用户自己创建的Hazelcast实例时</span></span>\n          nodeID = hazelcast<span class="code-selector-class"><span class="code-selector-class">.getLocalEndpoint</span></span>()<span class="code-selector-class"><span class="code-selector-class">.getUuid</span></span>();<span class="code-comment"><span class="code-comment">//获取节点编号</span></span>\n          membershipListenerId = hazelcast<span class="code-selector-class"><span class="code-selector-class">.getCluster</span></span>()<span class="code-selector-class"><span class="code-selector-class">.addMembershipListener</span></span>(this);<span class="code-comment"><span class="code-comment">//获取当前节点监听成员变换的事件的ID</span></span>\n          fut<span class="code-selector-class"><span class="code-selector-class">.complete</span></span>();\n          return;\n        }\n        if (conf == null) {<span class="code-comment"><span class="code-comment">//获取Hazelcast的Config</span></span>\n          conf = loadConfigFromClasspath();\n          <span class="code-selector-tag"><span class="code-selector-tag">if</span></span> (conf == null) {\n            log<span class="code-selector-class"><span class="code-selector-class">.warn</span></span>(<span class="code-string"><span class="code-string">"Cannot find cluster configuration on classpath and none specified programmatically. Using default hazelcast configuration"</span></span>);\n          }\n        }\n        <span class="code-comment"><span class="code-comment">//新建hazelcast实例</span></span>\n        hazelcast = Hazelcast.newHazelcastInstance(conf);\n        nodeID = hazelcast.getLocalEndpoint().getUuid();\n        membershipListenerId = hazelcast.getCluster().addMembershipListener(this);\n        fut.complete();\n      }\n    }, resultHandler);\n  }</code></pre>\n<p style="text-align:center">图4，新建hazelcast实例</p>\n<p>如果用户自己创建并传入Hazelcast实例，<em>ClusterManager</em>只是简单的从中获取需要的参数。如果未创建实例，则<em>ClusterManager</em>会自行创建。</p>\n<p>首先，loadConfigFromClasspath会用来加载本地的配置文件。</p>\n<pre class="cs"><code class="language-java"><span class="hljs-function"><span class="hljs-function">Config </span><span class="code-title"><span class="hljs-function"><span class="code-title">loadConfigFromClasspath</span></span></span><span class="hljs-params"><span class="hljs-function">(<span class="hljs-params"></span>)</span></span><span class="hljs-function"> </span></span>{\n    Config cfg = <span class="code-keyword"><span class="hljs-literal">null</span></span>;\n    <span class="code-keyword"><span class="code-keyword">try</span></span> (InputStream <span class="code-keyword">is</span> = getConfigStream();\n         InputStream bis = <span class="code-keyword"><span class="code-keyword">new</span></span> BufferedInputStream(<span class="code-keyword">is</span>)) {\n      <span class="code-keyword"><span class="code-keyword">if</span></span> (<span class="code-keyword">is</span> != <span class="code-keyword"><span class="hljs-literal">null</span></span>) {\n        cfg = <span class="code-keyword"><span class="code-keyword">new</span></span> XmlConfigBuilder(bis).build();<span class="code-comment"><span class="code-comment">//创建HazelcastConfig</span></span>\n      }\n    } <span class="code-keyword"><span class="code-keyword">catch</span></span> (IOException ex) {\n      log.error(<span class="code-string"><span class="code-string">"Failed to read config"</span></span>, ex);\n    }\n    <span class="code-keyword"><span class="code-keyword">return</span></span> cfg;\n  }</code></pre>\n<p style="text-align:center">图5，加载HazelcastConfig</p>\n<p>getConfigStream用来读取配置文件。</p>\n<pre class="kotlin"><code class="language-java"><span class="hljs-function">InputStream <span class="code-title">getConfigStream</span><span class="hljs-params">()</span> </span>{\n    ClassLoader ctxClsLoader = Thread.currentThread().getContextClassLoader();\n    InputStream <span class="code-keyword">is</span> = <span class="code-keyword"><span class="hljs-literal">null</span></span>;\n    <span class="code-keyword"><span class="code-keyword">if</span></span> (ctxClsLoader != <span class="code-keyword"><span class="hljs-literal">null</span></span>) {\n      <span class="code-keyword">is</span> = ctxClsLoader.getResourceAsStream(CONFIG_FILE);\n    }\n    <span class="code-keyword"><span class="code-keyword">if</span></span> (<span class="code-keyword">is</span> == <span class="code-keyword"><span class="hljs-literal">null</span></span>) {\n      <span class="code-keyword">is</span> = getClass().getClassLoader().getResourceAsStream(CONFIG_FILE);\n      <span class="code-keyword"><span class="code-keyword">if</span></span> (<span class="code-keyword">is</span> == <span class="code-keyword"><span class="hljs-literal">null</span></span>) {\n        <span class="code-keyword">is</span> = getClass().getClassLoader().getResourceAsStream(DEFAULT_CONFIG_FILE);\n      }\n    }\n    <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="code-keyword">is</span>;\n  }</code></pre>\n<p style="text-align:center">图6，读取配置文件</p>\n<p>如图5、图6的源码。<em>getConfigStream</em>会先加载classpath下的<em>cluster.xml（CONFIG_FILE）</em>文件。如果不存在，则加载jar包内的<em>default-cluster.xml（DEFAULT_CONFIG_FILE）</em>文件。读取完毕后，<em>loadConfigFromClasspath</em>使用Hazelcast的<em>XmlConfigBuilder</em>来构建<em>HazelcastConfig</em>。而后会用这个Config初始化Hazelcast。</p>\n<p>集群创建成功后， 会初始化一个<em>HAManager</em>实例，用于做verticle迁移。后面在详细说明HA模式。</p>\n<p>最后，在VertxImpl中，会调用<em>createAndStartEventBus</em>方法在集群环境运行的EventBus。</p>'}});