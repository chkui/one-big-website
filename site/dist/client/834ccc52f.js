webpackJsonp([8],{354:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<h2 id="h2-1">阅读之前</h2>\n<p>在了解<em>Next.js</em>之前，需要掌握<a href="https://www.chkui.com/category/react" title="React">React</a>的基本使用方法。</p>\n<p>参考代码：<a href="https://github.com/chkui/nextjs-getting-started">https://github.com/chkui/nextjs-getting-started</a> 。\n</p>\n<h2 id="h2-2">搭建</h2>\n<h3 id="h3-1">安装</h3>\n<pre><code class="bash"><span class="code-comment"># 创建项目目录</span>\nmkdir you_project\n<span class="code-comment"># 进入项目目录</span>\n<span class="code-built_in">cd</span> you_project\n<span class="code-comment"># 初始化package.json</span>\nnpm init -y\n<span class="code-comment"># 安装依赖包</span>\nnpm install --save react react-dom next\n<span class="code-comment"># 创建一个pages文件夹</span>\nmkdir pages\n</code></pre>\n<p>依次执行以上命令之后，<em>Next.js</em>运行所需的最基本的目录和依赖就创建好了。</p>\n<h3 id="h3-2">运行</h3>\n<p>将<em>package.json</em>里的“scripts"字段修改为：</p>\n<pre><code class="json">{\n  <span class="hljs-attr">"scripts"</span>: {\n    <span class="hljs-attr">"dev"</span>: <span class="code-string">"next"</span>,\n    <span class="hljs-attr">"build"</span>: <span class="code-string">"next build"</span>,\n    <span class="hljs-attr">"start"</span>: <span class="code-string">"next start"</span>\n  }\n}\n</code></pre>\n<p>运行以下命令启动<em>Next.js</em>：</p>\n<pre><code class="shell">npm run dev\n</code></pre>\n<p>在浏览器打开<a href="http://localhost:3000/">http://localhost:3000/</a> 看到输出"404 - This page could not be found"，表示<em>Next.js</em>安装成功。\n</p>\n<h3 id="h3-3">添加页面</h3>\n<p><em>./pages</em>是<em>Next.js</em>默认的网页路径，其中的<em>index.js</em>就代表整个网站的主页。创建一个*./pages/index.js*组件：</p>\n<pre><code class="JavaScript"><span class="code-keyword">const</span> Index = <span class="hljs-function"><span\n        class="hljs-params">()</span> =&gt;</span> (\n  <span class="xml"><span class="code-tag">&lt;<span class="code-name">div</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">p</span>&gt;</span>Hello World!<span class="code-tag">&lt;/<span\n              class="code-name">p</span>&gt;</span>\n  <span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>\n)\n<span class="code-keyword">export</span> <span class="code-keyword">default</span> Index\n</code></pre>\n<p>添加*./pages/index.js*后网站会自动刷新，呈现"Hello World!"。</p>\n<h2 id="h2-3">页面与导航栏</h2>\n<h3 id="h3-4">页面</h3>\n<p>添加<a href="http://localhost:3000/about">http://localhost:3000/about</a> 路径下的页面。</p>\n<p>创建*./pages/about.js*文件，添加以下内容：</p>\n<pre><code class="JavaScript"><span class="code-keyword">export</span> <span class="code-keyword">default</span> () =&gt; (\n  <span class="xml"><span class="code-tag">&lt;<span class="code-name">div</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">p</span>&gt;</span>About page<span class="code-tag">&lt;/<span\n              class="code-name">p</span>&gt;</span>\n  <span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>\n)\n</code></pre>\n<p>然后在浏览器输入<a href="http://localhost:3000/about">http://localhost:3000/about</a> 即可看到新增的About。</p>\n<h3 id="h3-5">导航栏</h3>\n<p>对*./pages/index.js*稍加修改引入导航栏功能：</p>\n<pre><code class="JavaScript"><span class="code-keyword">import</span> Link <span class="code-keyword">from</span> <span\n        class="code-string">\'next/link\'</span>\n\n<span class="code-keyword">const</span> Index = <span class="hljs-function"><span\n            class="hljs-params">()</span> =&gt;</span> (\n  <span class="xml"><span class="code-tag">&lt;<span class="code-name">div</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">Link</span> <span class="hljs-attr">href</span>=<span\n            class="code-string">"/about"</span>&gt;</span>\n      <span class="code-tag">&lt;<span class="code-name">a</span> <span class="hljs-attr">style</span>=<span\n              class="code-string">{{fontSize:</span> <span class="hljs-attr">20</span>}}&gt;</span>About Page<span\n              class="code-tag">&lt;/<span class="code-name">a</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">Link</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">p</span>&gt;</span>Hello Next.js<span class="code-tag">&lt;/<span\n              class="code-name">p</span>&gt;</span>\n  <span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>\n)\n\n<span class="code-keyword">export</span> <span class="code-keyword">default</span> Index\n</code></pre>\n<p><strong>注意</strong>：使用了<em>Next.js</em>作为服务端渲染工具，切记仅使用<em>next/link</em>中的Link组件。</p>\n<p>除了<code>&lt;a&gt;</code>标签，<code>&lt;button&gt;</code>或自定义的组件都可以被<code>Link</code>包装，只要传递<em>Click事件</em>即可，将上面的代码稍作修改实验这个效果：\n</p>\n<pre><code class="JavaScript"><span class="code-keyword">import</span> Link <span class="code-keyword">from</span> <span\n        class="code-string">\'next/link\'</span>\n\n<span class="code-keyword">const</span> Index = <span class="hljs-function"><span\n            class="hljs-params">()</span> =&gt;</span> (\n    <span class="xml"><span class="code-tag">&lt;<span class="code-name">div</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">Link</span> <span class="hljs-attr">href</span>=<span\n                class="code-string">"/about"</span>&gt;</span>\n            <span class="code-tag">&lt;<span class="code-name">button</span>&gt;</span>Click Me<span class="code-tag">&lt;/<span\n                class="code-name">button</span>&gt;</span>\n        <span class="code-tag">&lt;/<span class="code-name">Link</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">Link</span> <span class="hljs-attr">href</span>=<span\n                class="code-string">"/about"</span>&gt;</span>\n            <span class="code-tag">&lt;<span class="code-name">A</span>/&gt;</span>\n        <span class="code-tag">&lt;/<span class="code-name">Link</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">p</span>&gt;</span>Hello Next.js<span\n                class="code-tag">&lt;/<span class="code-name">p</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>\n)\n\n<span class="code-keyword">export</span> <span class="code-keyword">default</span> Index\n\n<span class="code-keyword">const</span> A = <span class="hljs-function"><span\n            class="hljs-params">props</span> =&gt;</span> (<span class="xml"><span class="code-tag">&lt;<span\n            class="code-name">div</span> <span class="hljs-attr">onClick</span>=<span class="code-string">{e</span> =&gt;</span> {\n    props.onClick(e)\n}}&gt;Click Me<span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>)\n</code></pre>\n<p>关于<em>Next.js</em>路由管理相关的细节内容，<a href="https://github.com/zeit/next.js#routing" title="可以到这里查看">可以到这里查看</a></p>\n<h2 id="h2-4">页面、资源与组件</h2>\n<p><em>./pages</em>是一个保留路径，在*/pages*路径下任何js文件中导出的默认React组件都被视作一个页面。</p>\n<p>除了*./pages*，<em>Next.js</em>还有一个保留路径是*./static*，它用来存放图片等静态资源。</p>\n<p><em>Next.js</em>会对*./pages<em>中的React组件进行“包装"，所以</em>./pages*内外的React组件在呈现结果上有一些差异，看下面的例子。</p>\n<h3 id="h3-6">创建网站结构</h3>\n<p>在工程根目录创建*/components*文件夹，然后添加以下组件：</p>\n<pre><code class="JavaScript"><span class="code-keyword">import</span> Link <span class="code-keyword">from</span> <span\n        class="code-string">\'next/link\'</span>\n\n<span class="code-keyword">const</span> linkStyle = {\n    <span class="hljs-attr">marginRight</span>: <span class="hljs-number">15</span>\n}\n\n<span class="code-keyword">const</span> Header = <span class="hljs-function"><span\n            class="hljs-params">()</span> =&gt;</span> (\n    <span class="xml"><span class="code-tag">&lt;<span class="code-name">div</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">Link</span> <span class="hljs-attr">href</span>=<span\n                class="code-string">"/"</span>&gt;</span>\n            <span class="code-tag">&lt;<span class="code-name">a</span> <span class="hljs-attr">style</span>=<span\n                    class="code-string">{linkStyle}</span>&gt;</span>Home<span class="code-tag">&lt;/<span\n                class="code-name">a</span>&gt;</span>\n        <span class="code-tag">&lt;/<span class="code-name">Link</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">Link</span> <span class="hljs-attr">href</span>=<span\n                class="code-string">"/about"</span>&gt;</span>\n            <span class="code-tag">&lt;<span class="code-name">a</span> <span class="hljs-attr">style</span>=<span\n                    class="code-string">{linkStyle}</span>&gt;</span>About<span class="code-tag">&lt;/<span\n                class="code-name">a</span>&gt;</span>\n        <span class="code-tag">&lt;/<span class="code-name">Link</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>\n)\n\n<span class="code-keyword">export</span> <span class="code-keyword">default</span> Header\n</code></pre>\n<p>然后将<code>Header</code>整合到<code>about.js</code>和<code>index.js</code>中：</p>\n<pre><code class="JavaScript"><span class="code-keyword">import</span> Header <span\n        class="code-keyword">from</span> <span class="code-string">\'../components/Header\'</span>\n<span class="code-keyword">export</span> <span class="code-keyword">default</span> () =&gt; (\n    <span class="xml"><span class="code-tag">&lt;<span class="code-name">div</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">Header</span> /&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">p</span>&gt;</span>Hello Next.js<span\n                class="code-tag">&lt;/<span class="code-name">p</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>\n)\n</code></pre>\n<p>再次进行页面操作，就会出现表头静止页面变换的效果。</p>\n<h3 id="h3-7">网站布局</h3>\n<p>通常情况下，开发一个网站先制定一个通用的布局（尤其是响应式布局的网站），然后再向布局中的添加各个部分的内容。使用<em>Next.js</em>可以通过组件的方式来设计一个布局，看下面的例子。\n    在*/components*中增加<code>Layout</code>和<code>Footer</code>组件:</p>\n<pre><code class="JavaScript"><span class="code-comment">// componments/layout.js</span>\n<span class="code-keyword">import</span> Header <span class="code-keyword">from</span> <span class="code-string">\'./header\'</span>\n<span class="code-keyword">import</span> Footer <span class="code-keyword">from</span> <span class="code-string">\'./footer\'</span>\n\n<span class="code-keyword">const</span> layoutStyle = {\n    <span class="hljs-attr">margin</span>: <span class="hljs-number">20</span>,\n    <span class="hljs-attr">padding</span>: <span class="hljs-number">20</span>,\n    <span class="hljs-attr">border</span>: <span class="code-string">\'1px solid #DDD\'</span>\n}\n\n<span class="code-keyword">const</span> Layout = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> (\n    <span class="xml"><span class="code-tag">&lt;<span class="code-name">div</span> <span class="hljs-attr">style</span>=<span\n            class="code-string">{layoutStyle}</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">Header</span> /&gt;</span>\n        {props.children}\n        <span class="code-tag">&lt;<span class="code-name">Footer</span> /&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>\n)\n\n<span class="code-keyword">export</span> <span class="code-keyword">default</span> Layout\n</code></pre>\n<pre><code class="JavaScript"><span class="code-comment">// components/footer.js</span>\n<span class="code-keyword">const</span> Footer = <span class="hljs-function"><span\n            class="hljs-params">()</span> =&gt;</span> (\n    <span class="xml"><span class="code-tag">&lt;<span class="code-name">div</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">p</span> <span class="hljs-attr">style</span>=<span\n                class="code-string">{{color:</span>\'<span class="hljs-attr">blue</span>\'}}&gt;</span>Footer<span\n                class="code-tag">&lt;/<span class="code-name">p</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>\n)\n\n<span class="code-keyword">export</span> <span class="code-keyword">default</span> Footer\n</code></pre>\n<p>然后将*/pages/index.js*修改为：</p>\n<pre><code class="JavaScript"><span class="code-keyword">import</span> Layout <span\n        class="code-keyword">from</span> <span class="code-string">\'../components/layout\'</span>\n\n<span class="code-keyword">export</span> <span class="code-keyword">default</span> () =&gt; (\n    <span class="xml"><span class="code-tag">&lt;<span class="code-name">Layout</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">p</span>&gt;</span>Hello Next.js<span\n                class="code-tag">&lt;/<span class="code-name">p</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">Layout</span>&gt;</span></span>\n)\n</code></pre>\n<p>这样，页面的内容和布局就完全隔离开了。</p>\n<h2 id="h2-5">页面跳转</h2>\n<h3 id="h3-8">传递参数</h3>\n<p>在实际应用中，经常需要在页面间传递参数，可以使用<a href="https://www.chkui.com/article/react/react_high_order_component"\n                              title="高阶组件">高阶组件</a><code>withRouter</code>来实现。\n    下面的代码对*/pages/index.js<em>进行了一些修改，使其在跳转时携带</em>query*参数：</p>\n<pre><code class="JavaScript"><span class="code-keyword">const</span> SubLink = <span class="hljs-function"><span\n        class="hljs-params">props</span> =&gt;</span> (\n    <span class="xml"><span class="code-tag">&lt;<span class="code-name">li</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">Link</span> <span class="hljs-attr">href</span>=<span\n                class="code-string">{</span>`/<span class="hljs-attr">post</span>?<span\n                class="hljs-attr">title</span>=<span class="code-string">${props.title}</span>`}&gt;</span>\n            <span class="code-tag">&lt;<span class="code-name">a</span>&gt;</span>{props.title}<span class="code-tag">&lt;/<span\n                class="code-name">a</span>&gt;</span>\n        <span class="code-tag">&lt;/<span class="code-name">Link</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">li</span>&gt;</span></span>\n)\n\n<span class="code-keyword">export</span> <span class="code-keyword">default</span> () =&gt; (\n    &lt;Layout&gt;\n        &lt;h2&gt;Information&lt;/h2&gt;\n        &lt;SubLink title="First Post"/&gt;\n        &lt;SubLink title="Second Post"/&gt;\n        &lt;SubLink title="Third Post"/&gt;\n    &lt;/Layout&gt;\n)\n</code></pre>\n<p>点击<em>First Post</em>之后浏览器的URL会出现这样的路径：“<a href="http://localhost:3000/post?title=First%20Post”">http://localhost:3000/post?title=First%20Post”</a>\n    。接下来利用<code>withRouter</code>来获取这个参数。创建*./pages/post.js*的文件：</p>\n<pre><code class="JavaScript"><span class="code-keyword">import</span> {withRouter} <span\n        class="code-keyword">from</span> <span class="code-string">\'next/router\'</span>\n<span class="code-keyword">import</span> Layout <span class="code-keyword">from</span> <span class="code-string">\'../components/layout\'</span>\n\n<span class="code-keyword">const</span> Page = withRouter(<span class="hljs-function">(<span\n            class="hljs-params">props</span>) =&gt;</span> (\n    <span class="xml"><span class="code-tag">&lt;<span class="code-name">Layout</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">h3</span>&gt;</span>Post Page<span\n                class="code-tag">&lt;/<span class="code-name">h3</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">p</span>&gt;</span>Info:{props.router.query.title}<span\n                class="code-tag">&lt;/<span class="code-name">p</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">Layout</span>&gt;</span></span>\n))\n<span class="code-keyword">export</span> <span class="code-keyword">default</span> Page\n</code></pre>\n<p>现在点击<em>First Post</em>链接之后，跳转的页面会显示<em>First Post</em>。</p>\n<h3 id="h3-9">路径隐藏</h3>\n<p>\n    <em>Next.js</em>提供了一个让URL更加清晰干净的特性功能——URL隐藏（官网直译的话应该叫“URL遮挡”），他的作用是可以隐藏原来比较复杂的URL，让网站路径更加清晰，有利于SEO等。实现这个特性非常简单，在使用<code>Link</code>组件时传递一个<em>as</em>参数。下面将继续修改*./pages/index.js*中的内容以实现这个特性：\n</p>\n<pre><code class="JavaScript"><span class="code-keyword">const</span> SubLink = <span class="hljs-function"><span\n        class="hljs-params">props</span> =&gt;</span> (\n    <span class="xml"><span class="code-tag">&lt;<span class="code-name">li</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">Link</span> <span class="hljs-attr">as</span>=<span\n                class="code-string">{</span>`<span class="hljs-attr">p</span>/${<span class="hljs-attr">props.as</span>}`} <span\n                class="hljs-attr">href</span>=<span class="code-string">{</span>`/<span\n                class="hljs-attr">post</span>?<span class="hljs-attr">title</span>=<span class="code-string">${props.title}</span>`}&gt;</span>\n            <span class="code-tag">&lt;<span class="code-name">a</span>&gt;</span>{props.title}<span class="code-tag">&lt;/<span\n                class="code-name">a</span>&gt;</span>\n        <span class="code-tag">&lt;/<span class="code-name">Link</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">li</span>&gt;</span></span>\n)\n\n<span class="code-keyword">export</span> <span class="code-keyword">default</span> () =&gt; (\n    &lt;Layout&gt;\n        &lt;h2&gt;Information&lt;/h2&gt;\n        &lt;SubLink as="first-post" title="First Post"/&gt;\n        &lt;SubLink as="first-post" title="Second Post"/&gt;\n        &lt;SubLink as="first-post" title="Third Post"/&gt;\n    &lt;/Layout&gt;\n)\n</code></pre>\n<p>注意观察<code>SubLink</code>组件中的修改，为<code>Link</code>增加了一个as参数，这个参数传递的内容将会在浏览器的地址栏显示。例如点击<em>FIrst\n    Post</em>后，浏览器的地址栏会显示<a href="http://localhost:3000/p/first-post">http://localhost:3000/p/first-post</a>\n    ，但是我们通过<code>withRouter</code>组件获取的URL还是<em>href</em>传递的路径。</p>\n<h2 id="h2-6">服务端渲染</h2>\n<p>只要运行了<em>Next.js</em>，他时时刻刻都在执行服务端渲染，可以通过刷新页面看到效果。如果没有太多需求，不进行任何调整<em>Next.js</em>能为我们完成静态页面的服务端渲染，但是通常情况下，还需要处理异步请求等等情况。\n</p>\n<h3 id="h3-10">二次服务端渲染</h3>\n<p>前面介绍了在<code>Link</code>组件上使用<em>as</em>参数可以设置浏览器路径栏上显示的内容。但是这个时候仅仅支持客户端跳转，如果进行页面刷新会出现404页面。导致这个问题出现的原因是在服务端并不知道*/p/first-post<em>对应</em>/pages*文件夹中的哪个文件。为了解决这个问题，需要在服务端进行二次渲染。\n</p>\n<p>首先需要添加<em>Express</em>服务：</p>\n<pre><code class="bash">npm install --save express\n</code></pre>\n<p>安装完成之后在根目录添加一个<em>server.js</em>文件，其内容如下：</p>\n<pre><code class="JavaScript"><span class="code-keyword">const</span> express = <span\n        class="code-built_in">require</span>(<span class="code-string">\'express\'</span>)\n<span class="code-keyword">const</span> next = <span class="code-built_in">require</span>(<span class="code-string">\'next\'</span>)\n\n<span class="code-comment">// 不等于\'production\'则表示运行的是开发环境</span>\n<span class="code-keyword">const</span> dev = process.env.NODE_ENV !== <span class="code-string">\'production\'</span>\n<span class="code-comment">// 创建一个服务端运行的Next app</span>\n<span class="code-keyword">const</span> app = next({dev})\n<span class="code-comment">// 请求处理器</span>\n<span class="code-keyword">const</span> handle = app.getRequestHandler()\n\napp.prepare()\n    .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n        <span class="code-keyword">const</span> server = express()\n\n        server.get(<span class="code-string">\'/p/:id\'</span>, (req, res) =&gt; {\n            <span class="code-comment">//将/p/:id的路径切换成/post?title=req.params.id的路径</span>\n            app.render(req, res, <span class="code-string">\'/post\'</span>, {<span class="hljs-attr">title</span>: req.params.id})\n        })\n\n        server.get(<span class="code-string">\'*\'</span>, (req, res) =&gt; {\n            <span class="code-keyword">return</span> handle(req, res)\n        })\n\n        server.listen(<span class="hljs-number">3000</span>, (err) =&gt; {\n            <span class="code-keyword">if</span> (err) <span class="code-keyword">throw</span> err\n            <span class="code-built_in">console</span>.log(<span class="code-string">\'&gt; Ready on http://localhost:3000\'</span>)\n        })\n    })\n    .catch(<span class="hljs-function">(<span class="hljs-params">ex</span>) =&gt;</span> {\n        <span class="code-built_in">console</span>.error(ex.stack)\n        process.exit(<span class="hljs-number">1</span>)\n    })\n</code></pre>\n<p>然后修改<em>package.json</em>的“scripts"字段，将启动方式方式指向<em>server.js</em>：</p>\n<pre><code class="json"><span class="code-string">"scripts"</span>: {\n    <span class="hljs-attr">"dev"</span>: <span class="code-string">"node server.js"</span>,\n    <span class="hljs-attr">"build"</span>: <span class="code-string">"next build"</span>,\n    <span class="hljs-attr">"start"</span>: <span class="code-string">"NODE_ENV=production node server.js"</span>\n  }\n</code></pre>\n<p>完成这2步网站服务端也可以正常跳转，实现功能的位置是这段代码：</p>\n<pre><code class="JavaScript">server.get(<span class="code-string">\'/p/:id\'</span>, (req, res) =&gt; {\n\tapp.render(req, res, <span class="code-string">\'/post\'</span>, {<span class="hljs-attr">title</span>: req.params.id})\n})\n</code></pre>\n<p>他将原来的请求“/p/:id”转换为请求"/post?title=id"。</p>\n<p>更多的<a href="https://github.com/zeit/next.js#custom-server-and-routing" title="服务端渲染的配置">服务端渲染的配置说明请看这里</a>。</p>\n<h3 id="h3-11">数据异步请求</h3>\n<p>对于一个前后端分离的系统来说，异步数据请求是几乎每个页面都需要的。<em>Next.js</em>通过<code>getInitialProps</code>来实现。\n    下面的示例数据来自<a href="https://www.tvmaze.com/api">https://www.tvmaze.com/api</a> 。创建*./pages/tvshows.js*的文件：</p>\n<pre><code class="JavaScript"><span class="code-keyword">import</span> Layout <span\n        class="code-keyword">from</span> <span class="code-string">\'../components/layout.js\'</span>\n<span class="code-keyword">import</span> Link <span class="code-keyword">from</span> <span class="code-string">\'next/link\'</span>\n<span class="code-keyword">import</span> fetch <span class="code-keyword">from</span> <span class="code-string">\'isomorphic-unfetch\'</span>\n\n<span class="code-keyword">const</span> TvShow = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> (\n    <span class="xml"><span class="code-tag">&lt;<span class="code-name">Layout</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">h1</span>&gt;</span>Batman TV Shows<span class="code-tag">&lt;/<span\n                class="code-name">h1</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">ul</span>&gt;</span>\n            {props.shows.map(({show}) =&gt; (\n                <span class="code-tag">&lt;<span class="code-name">li</span> <span class="hljs-attr">key</span>=<span\n                        class="code-string">{show.id}</span>&gt;</span>\n                    <span class="code-tag">&lt;<span class="code-name">Link</span> <span\n                            class="hljs-attr">href</span>=<span class="code-string">{</span>`/<span\n                            class="hljs-attr">tv</span>?<span class="hljs-attr">id</span>=<span class="code-string">${show.id}</span>`}&gt;</span>\n                        <span class="code-tag">&lt;<span class="code-name">a</span>&gt;</span>{show.name}<span\n                class="code-tag">&lt;/<span class="code-name">a</span>&gt;</span>\n                    <span class="code-tag">&lt;/<span class="code-name">Link</span>&gt;</span>\n                <span class="code-tag">&lt;/<span class="code-name">li</span>&gt;</span>\n            ))}\n        <span class="code-tag">&lt;/<span class="code-name">ul</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">Layout</span>&gt;</span></span>\n)\n\nTvShow.getInitialProps = <span class="code-keyword">async</span> <span class="hljs-function"><span class="code-keyword">function</span>(<span\n            class="hljs-params"></span>) </span>{\n    <span class="code-comment">//contxt是衔接Next.js包装组件和自定义主键的上下文，包含的参数有asPath、pathname、query</span>\n\n    <span class="code-comment">// 发送异步请求</span>\n    <span class="code-keyword">const</span> res = <span class="code-keyword">await</span> fetch(<span\n            class="code-string">\'https://api.tvmaze.com/search/shows?q=batman\'</span>)\n\n    <span class="code-comment">// 从response中异步读取数据流</span>\n    <span class="code-keyword">const</span> data = <span class="code-keyword">await</span> res.json()\n\n    <span class="code-built_in">console</span>.log(<span class="code-string">`Show data fetched. Count: <span\n            class="hljs-subst">${data.length}</span>`</span>)\n\n    <span class="code-comment">// 返回已获取的数据</span>\n    <span class="code-keyword">return</span> {\n        <span class="hljs-attr">shows</span>: data\n    }\n}\n\n<span class="code-keyword">export</span> <span class="code-keyword">default</span> TvShow\n</code></pre>\n<p><code>TvShow</code>组件的作用是异步请求数据并组装成列表展示。</p>\n<p>然后再创建一个查看详情的页面——<em>./pages/tv.js</em>，实现过程和上面一样：</p>\n<pre><code class="JavaScript"><span class="code-keyword">import</span> Layout <span\n        class="code-keyword">from</span> <span class="code-string">\'../components/layout\'</span>\n<span class="code-keyword">import</span> fetch <span class="code-keyword">from</span> <span class="code-string">\'isomorphic-unfetch\'</span>\n\n<span class="code-keyword">const</span> Tv =  <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> (\n    <span class="xml"><span class="code-tag">&lt;<span class="code-name">Layout</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">h1</span>&gt;</span>{props.show.name}<span class="code-tag">&lt;/<span\n                class="code-name">h1</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">p</span>&gt;</span>{props.show.summary.replace(/<span\n                class="code-tag">&lt;<span class="code-name">[</span>/]?<span class="hljs-attr">p</span>&gt;</span>/g, \'\')}<span\n                class="code-tag">&lt;/<span class="code-name">p</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">img</span> <span class="hljs-attr">src</span>=<span\n                class="code-string">{props.show.image.medium}/</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">Layout</span>&gt;</span>\n)\n\nTv.getInitialProps = async function (context) {\n    const { id } = context.query\n    const res = await fetch(`https://api.tvmaze.com/shows/${id}`)\n    const show = await res.json()\n\n    console.log(`Fetched show: ${show.name}`)\n\n    return { show }\n}\nexport default Tv\n</span></code></pre>\n<p>按照这个套路可以解决绝大部分数据异步请求的问题。不过如果数据组装过慢，会出页面现卡顿的问题，可以通过服务端缓存或异步页面加载实现，后续的篇幅会介绍。</p>\n<h2 id="h2-7">样式</h2>\n<h3 id="h3-12">源生添加样式</h3>\n<p>一个页面永远离不开样式，在<em>Next.js</em>中推荐一种简介高效的方法——<code>&lt;style jsx&gt;</code>。</p>\n<p>为的主页添加一些样式：</p>\n<pre><code class="JavaScript">(\n    &lt;Layout&gt;\n        &lt;h2&gt;Information&lt;/h2&gt;\n        &lt;SubLink as="first-post" title="First Post"/&gt;\n        &lt;SubLink as="first-post" title="Second Post"/&gt;\n        &lt;SubLink as="first-post" title="Third Post"/&gt;\n        &lt;style jsx&gt;{`\n            h2{\n                font-family: "Arial";\n            }\n        `}&lt;/style&gt;\n        &lt;style jsx global&gt;{`\n            .list{\n                list-style: none;\n                margin: 5px 0;\n            }\n        `}&lt;/style&gt;\n    &lt;/Layout&gt;\n)\n</code></pre>\n<p><code>&lt;style jsx&gt;</code>的作用就是为当前组件声明样式，需要注意的是在这个标签内声明的样式只能覆盖当前组件，子组件是不会出现层叠效果的。而<code>&lt;style jsx\n    global&gt;</code>标签的效果则是和标准的css层叠效果一致，在这个标签中声明的样式会影响到子组件。</p>\n<h3 id="h3-13">Loader添加载样式</h3>\n<p><em>Next.js</em>可以加载各种样式文件，下面以<em>Sass/Scss</em>为例。</p>\n<p>首先添加相关依赖：</p>\n<pre><code class="bash">npm install --save @zeit/next-sass node-sass\n</code></pre>\n<p>在项目根目录添加<em>next.config.js</em>文件，用于指示<em>Next</em>加载对用的功能：</p>\n<pre><code class="bash">const withSass = require(<span class="code-string">\'@zeit/next-sass\'</span>)\nmodule.exports = withSass()\n</code></pre>\n<p>现在就可以加载*.scss<em>文件了，添加一个</em>/pages/post.scss*文件：</p>\n<pre><code class="css">$<span class="code-selector-tag">font-size</span>: 50<span class="code-selector-tag">px</span>;\n<span class="code-selector-class">.header</span>{\n  <span class="code-attribute">font-size</span>: $font-size;\n  <span class="code-attribute">color</span>:red;\n}\n</code></pre>\n<p>修改*/pages/post.js*加载样式：</p>\n<pre><code class="JavaScript"><span class="code-keyword">import</span> {withRouter} <span\n        class="code-keyword">from</span> <span class="code-string">\'next/router\'</span>\n<span class="code-keyword">import</span> Layout <span class="code-keyword">from</span> <span class="code-string">\'../components/layout\'</span>\n<span class="code-comment">//加载样式</span>\n<span class="code-keyword">import</span> <span class="code-string">\'./post.scss\'</span>\n\n<span class="code-keyword">const</span> Page = withRouter(<span class="hljs-function">(<span\n            class="hljs-params">props</span>) =&gt;</span> (\n    <span class="xml"><span class="code-tag">&lt;<span class="code-name">Layout</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">h3</span> <span class="hljs-attr">className</span>=<span\n                class="code-string">"header"</span>&gt;</span>Post Page<span class="code-tag">&lt;/<span\n                class="code-name">h3</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">p</span>&gt;</span>Info:{props.router.query.title}<span\n                class="code-tag">&lt;/<span class="code-name">p</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">Layout</span>&gt;</span></span>\n))\n\n<span class="code-keyword">export</span> <span class="code-keyword">default</span> Page\n</code></pre>\n<p>由于是使用的<em>webpack</em>的<em>Loader</em>，可以根据需要在<em>next.config.js</em>文件中进行一些相关的设置：</p>\n<pre><code class="JavaScript"><span class="code-built_in">module</span>.exports = withSass({\n  <span class="hljs-attr">cssModules</span>: <span class="hljs-literal">true</span>,\n  <span class="hljs-attr">cssLoaderOptions</span>: {\n    <span class="hljs-attr">importLoaders</span>: <span class="hljs-number">1</span>,\n    <span class="hljs-attr">localIdentName</span>: <span class="code-string">"[local]___[hash:base64:5]"</span>,\n  }\n})\n</code></pre>\n<p>然后在组件中直接以对象的方式使用：</p>\n<pre><code class="JavaScript"><span class="code-keyword">import</span> style <span\n        class="code-keyword">from</span> <span class="code-string">\'./post.scss\'</span>\n<span class="code-keyword">const</span> Page = withRouter(<span class="hljs-function">(<span\n            class="hljs-params">props</span>) =&gt;</span> {\n    <span class="code-built_in">console</span>.log(style)\n    <span class="code-keyword">return</span> (\n        <span class="xml"><span class="code-tag">&lt;<span class="code-name">Layout</span>&gt;</span>\n            <span class="code-tag">&lt;<span class="code-name">h3</span> <span class="hljs-attr">className</span>=<span\n                    class="code-string">{style.header}</span>&gt;</span>Post Page<span class="code-tag">&lt;/<span\n                    class="code-name">h3</span>&gt;</span>\n            <span class="code-tag">&lt;<span class="code-name">p</span>&gt;</span>Info:{props.router.query.title}<span\n                    class="code-tag">&lt;/<span class="code-name">p</span>&gt;</span>\n        <span class="code-tag">&lt;/<span class="code-name">Layout</span>&gt;</span></span>\n    )\n})\n</code></pre>\n<p>更多关于cssLoaderOptions的参数说明可以查看<a href="https://github.com/webpack-contrib/css-loader#options"\n                                   title="webpack里css-loader的options说明">webpack里css-loader的options说明</a>。除了scss,<a\n        href="https://github.com/zeit/next.js#css-in-js" title="*Next.js*还支持css、less、post css的Loader"><em>Next.js</em>还支持css、less、post\n    css的Loader</a>。</p>\n<h2 id="h2-8">发布</h2>\n<p>在了解以上内容之后，已经可以开发一个网站了，接下来介绍如何发布生产包。</p>\n<p><em>package.json</em>中的“scripts"字段可以设置打包和生产运行方式：</p>\n<pre><code class="json">  <span class="code-string">"scripts"</span>: {\n    <span class="hljs-attr">"dev"</span>: <span class="code-string">"node server.js"</span>,\n    <span class="hljs-attr">"build"</span>: <span class="code-string">"next build"</span>,\n    <span class="hljs-attr">"start"</span>: <span class="code-string">"NODE_ENV=production node server.js"</span>\n  }\n</code></pre>\n<p>首先进行打包：</p>\n<pre><code class="bash">npm run build\n</code></pre>\n<p>打包完毕之后可以启动生产环境：</p>\n<pre><code class="bash">npm start\n</code></pre>\n<p>现在用浏览器打开<a href="http://localhost:3000/">http://localhost:3000/</a> 地址可以发现运行的是生产环境（可以使用React工具查看，也可以打开开发人员模式）。\n    由于之前了在<em>server.js</em>中引入了Express，所以现在启动的是一个Express服务器。打包之后的文件都在*./.next*\n    路径下，可以仅仅拷贝<strong>依赖包（node_module）</strong>、<strong>package.json</strong>、<strong>server.js</strong>以及**./.next**来运行生产环境。\n</p>\n<p>除了使用<em>Express</em>这一类第三方nodejs服务器，<a href="https://zeit.co/now" title="*Next.js*还提供了许多其他方式来部署和方法"><em>Next.js</em>还提供了许多其他方式来部署和方法</a>\n</p>'},369:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<h2 id="h2-1">3.0新增容器启动方法</h2>\n<p>在3.0之前的Spring核心框架中，我们启动一个Spring容器必须使用一个XML文件。而到了3.X之后的版本Spring为创建容器新增了一个入口类——<strong><em>AnnotationConfigApplicationContext</em></strong>。\n</p>\n<p>\n    AnnotationConfigApplicationContext和过去的ClassPathXmlApplicationContext、FileSystemXmlApplicationContext等方法不同的是他不用再指定任何XML配置文件，而是可以通过指定类向容器添加Bean。我们通过几个简单的例子来说明他的使用。</p>\n<p>（以下例子只用于说明问题，源码<a href="https://gitee.com/chkui-com/spring-core-sample" rel="nofollow">请到 gitee&nbsp;自行 clone</a>，本节的代码在&nbsp;chkui.springcore.example.javabase.simple\n    包中）。</p>\n\n<h3 id="h3-1">直接添加Bean</h3>\n<p>我们可以通过AnnotationConfigApplicationContext直接向容器添加指定的类作为Bean，先定义我们的class：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.simple.pureBean;\n\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">LolBean</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">toString</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"I AM LOL!"</span>;\n\t}\n}\n\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">WowBean</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">toString</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"I AM WOW!"</span>;\n\t}\n}</code></pre>\n<p>然后向容器添加这些Bean：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.simple;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">WithoutAnnotation</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(WowBean.class, LolBean.class);\n\t\tSystem.out.println(ctx.getBean(WowBean.class));\n\t\tSystem.out.println(ctx.getBean(LolBean.class));\n\t}\n}</code></pre>\n<p>这样就启动了一个Spring的容器，并且容器中包含了WowBean和LolBean这两个类的单例。</p>\n\n<h3 id="h3-2">替代&lt;beans&gt;标签</h3>\n<p>@Configuration在之前介绍Spring核心容器的文章中出现过一两次，配合各种注解的使用@Configuration可以替代&lt;beans&gt;配置中的所有功能。基本上AnnotationConfigApplicationContext和@Configuration组合使用就可以实现Spring容器纯Java启动。请看下面的例子。</p>\n<p>我们在前面例子的基础上增加几个类：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.simple.bean;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">DotaBean</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">toString</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"I AM Dota!"</span>;\n\t}\n}\n\n<span class="code-meta">@Component</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">PseBean</span> </span>{\n\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">toString</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"I AM PSE!"</span>;\n\t}\n}</code></pre>\n<p>注意DotaBean上是没有@Component注解的。然后添加@Configuration配置：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.simple.bean;\n\n<span class="code-meta">@Configuration</span>\n<span class="code-meta">@ComponentScan</span>(<span\n            class="code-string">"chkui.springcore.example.javabase.simple.bean"</span>)\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Config</span> </span>{\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> DotaBean <span\n            class="code-title">dotaBean</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> DotaBean();\n\t}\n}</code></pre>\n<p>最后运行他们：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.simple;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">WithScan</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(Config.class, WowBean.class, LolBean.class);\n\t\tSystem.out.println(ctx.getBean(Config.class));\n\t\tSystem.out.println(ctx.getBean(PseBean.class));\n\t\tSystem.out.println(ctx.getBean(WowBean.class));\n\t\tSystem.out.println(ctx.getBean(LolBean.class));\n\t\tSystem.out.println(ctx.getBean(DotaBean.class));\n\t}\n}</code></pre>\n<p>@Component已经在&nbsp;<a href="https://www.chkui.com/article/spring/spring_core_stereotype_component_and_bean_scan"\n                         title="Stereotype组件与Bean扫描">Stereotype组件与Bean扫描</a>&nbsp;这篇文章介绍过，@ComponentScan的作用等价于&lt;context:component-scan/&gt;标签，属性参数都是一一对应的，只不过前者是驼峰命名规则（camelCase）——@ComponentScan(basePackages="...")，后者是短横线命名规则（kebab-case）——&lt;context:component-scan\n    base-package="..."/&gt;。实际上使用Annotation来替换XML配置中的内容，大部分都使用这种转换方式。</p>\n<p>@Configuration和@Bean标签会在后续的内容中详细介绍。@Bean主要用于方法标记，表明这个方法返回一个要添加到容器中的Bean。</p>\n\n<h3 id="h3-3">AnnotationConfigApplicationContext的其他使用方法</h3>\n<p>除了以上常规的使用方法，AnnotationConfigApplicationContext还有其他方式向容器添加Bean。</p>\n<p>可以使用AnnotationConfigApplicationContext::register方法来添加配置和Bean：</p>\n<pre><code class="java"><span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n        class="code-keyword">void</span> <span class="code-title">main</span><span\n        class="hljs-params">(String[] args)</span> </span>{\n    AnnotationConfigApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext();\n    <span class="code-comment">//动态添加配置文件</span>\n    ctx.register(Config1.class, Config2.class);\n    <span class="code-comment">//动态添加Bean</span>\n    ctx.register(Bean1.class);\n    <span class="code-comment">//刷新</span>\n    ctx.refresh();\n}</code></pre>\n<p>\n    注意最后的refresh方法，这个方法来源于ConfigurableApplicationContext接口，然后是在AbstractApplicationContext中实现的。他的过程相当于销毁之前已经创建的资源，然后再重新创建了一个新的容器。这里的代码会执行以下几步：</p>\n<ol>\n    <li><em>new AnnotationConfigApplicationContext()</em>：创建一个新的容器，容器中没有自定义的Bean。</li>\n    <li>AnnotationConfigApplicationContext::register：向容器添加<a\n            href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/config/BeanDefinition.html"\n            rel="nofollow">BeanDefinition</a>，但是这些<a\n            href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/config/BeanDefinition.html"\n            rel="nofollow">BeanDefinition</a>并没有转化为容器中的Bean。\n    </li>\n    <li>ConfigurableApplicationContext::refresh()：纳入新添加的<a\n            href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/config/BeanDefinition.html"\n            rel="nofollow">BeanDefinition</a>重建容器。\n    </li>\n</ol>\n<p>还可以直接使用AnnotationConfigApplicationContext::scan方法扫描指定的路径：</p>\n<pre><code class="java"><span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n        class="code-keyword">void</span> <span class="code-title">main</span><span\n        class="hljs-params">(String[] args)</span> </span>{\n    AnnotationConfigApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext();\n    ctx.scan(<span class="code-string">"com.acme"</span>);\n    ctx.refresh();\n}</code></pre>\n<p>执行原理和上面介绍的一样。</p>\n<p>\n    按照以上介绍的内容。如果你的工程中需要使用AnnotationConfigApplicationContext::register、AnnotationConfigApplicationContext::scan等方法创建容器和其中Bean的依赖关系，最好是所有的Bean都在register或scan中添加。因为重建一批Bean会花费不少时间，尤其是Bean中还有销毁方法要回收资源时。</p>\n\n<h2 id="h2-2">@Bean注解</h2>\n<p>@Bean注解等价于配置文件中的&lt;bean&gt;标签，对应的参数也是将短横线命名切换为驼峰命名——&lt;bean init-method="..."&gt; =&gt;\n    @Bean(initMethod="...")。@Bean注解只能使用在方法上，方法必须是在@Configuration标记的类或者其他Bean中，两者存在的差异会在后续的文章中介绍。下面通过一个例子来说明Bean的使用。</p>\n<p>（以下例子只用于说明问题，源码<a href="https://gitee.com/chkui-com/spring-core-sample" rel="nofollow">请到 gitee&nbsp;自行 clone</a>，本节的代码在&nbsp;chkui.springcore.example.javabase.beanAnnotation\n    包中）。</p>\n<p>定义两个要添加到容器中的Bean：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.beanAnnotation.bean;\n\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">FinalFantasy</span> </span>{\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">toString</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"Final Fantasy 1~15"</span>;\n\t}\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">init</span><span class="hljs-params">()</span> </span>{\n\t\tSystem.out.println(<span class="code-string">"Final Fantasy init!"</span>);\n\t}\n\t\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">destroy</span><span class="hljs-params">()</span> </span>{\n\t\tSystem.out.println(<span class="code-string">"Final Fantasy destroy!"</span>);\n\t}\n}\n\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">DragonQuest</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">toString</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"Dragon Quest 1~11"</span>;\n\t}\n\t\n\t<span class="code-meta">@PostConstruct</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">init</span><span class="hljs-params">()</span> </span>{\n\t\tSystem.out.println(<span class="code-string">"Dragon Quest init!"</span>);\n\t}\n\t\n\t<span class="code-meta">@PreDestroy</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">destroy</span><span class="hljs-params">()</span> </span>{\n\t\tSystem.out.println(<span class="code-string">"Dragon Quest destroy!"</span>);\n\t}\n}\n</code></pre>\n<p>定义一个功能接口及其实现类：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.beanAnnotation.bean;\n\n<span class="hljs-class"><span class="code-keyword">interface</span> <span class="code-title">Support</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">void</span> <span\n            class="code-title">setFinalFantasy</span><span class="hljs-params">(FinalFantasy ff)</span></span>;\n\t<span class="hljs-function">FinalFantasy <span class="code-title">getFinalFantasy</span><span\n            class="hljs-params">()</span></span>;\n}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">SupportImpl</span> <span\n        class="code-keyword">implements</span> <span class="code-title">Support</span> </span>{\n\t<span class="code-keyword">private</span> FinalFantasy ff; \n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setFinalFantasy</span><span class="hljs-params">(FinalFantasy ff)</span> </span>{\n\t\t<span class="code-keyword">this</span>.ff = ff;\n\t}\n\t<span class="hljs-function"><span class="code-keyword">public</span> FinalFantasy <span class="code-title">getFinalFantasy</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> ff;\n\t}\n}</code></pre>\n<p>然后顶一个@Configuration类：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.javabase.beanAnnotation.bean;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">BeanAnnotationConfig</span> </span>{\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> Support <span class="code-title">support</span><span\n            class="hljs-params">(FinalFantasy ff)</span> </span>{\n\t\tSupport support = <span class="code-keyword">new</span> SupportImpl();\n\t\tsupport.setFinalFantasy(ff);\n\t\t<span class="code-keyword">return</span> support;\n\t}\n\t\n\t<span class="code-meta">@Bean</span>(initMethod=<span class="code-string">"init"</span>, destroyMethod=<span\n            class="code-string">"destroy"</span>)\n\t<span class="code-meta">@Description</span>(<span class="code-string">"Final Fantasy"</span>)\n\t<span class="hljs-function"><span class="code-keyword">public</span> FinalFantasy <span class="code-title">finalFantasy</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> FinalFantasy();\n\t}\n\t\n\t<span class="code-meta">@Bean</span>(name= {<span class="code-string">"dragon-quest"</span>, <span\n            class="code-string">"DragonQuest"</span>})\n\t<span class="hljs-function"><span class="code-keyword">public</span> DragonQuest <span class="code-title">dragonQuest</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> DragonQuest();\n\t}\n}</code></pre>\n<p>最后运行他们：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">BeanAnnotApp</span> </span>{\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(BeanAnnotationConfig.class);\n\t\tSupport support = ctx.getBean(Support.class);\n\t\tSystem.out.println(support.getFinalFantasy());\n\t\tSystem.out.println(ctx.getBean(DragonQuest.class));\n\t}\n\n}</code></pre>\n<p>在配置类BeanAnnotationConfig中，我们配置了3个Bean。这里的写在方法上的@Bean注解和写在配置文件中的&lt;bean&gt;注解一个效果：</p>\n<ul>\n    <li>\n        <strong><em>@Bean</em></strong>中的<strong><em>initMethod</em></strong>和<strong><em>destroyMethod</em></strong>对应<strong><em>&lt;bean&gt;</em></strong>标签中的<strong><em>init-method</em></strong>和<strong><em>destroy-method</em></strong>属性。\n    </li>\n    <li><strong><em>@Bean</em></strong>中的<strong><em>name</em></strong>参数只有一个值时相当于id，有多个的时候相当于设置了多个别名</li>\n    <li><strong><em>Support support(FinalFantasy ff)</em></strong>：我们可以直接在方法中暴露参数来引入其他Bean，这就类似于配置中<strong><em>ref</em></strong>的功能。\n    </li>\n    <li>如果不指定<strong><em>initMethod</em></strong>和<strong><em>destroyMethod</em></strong>，使用JSR-330的生命周期注解（@PostConstruct、@PreDestroy）同样有效\n    </li>\n</ul>\n'},379:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<p>在<a href="https://www.chkui.com/article/spring/spring_core_string_to_entity" title="字符串到实体转换">字符串到实体转换</a>一文中介绍了Spring核心框架中使用PropertyEditor将任何字符串转换为数字、实体的方法。除了字符串到实体，Spring还提供了更加通用的功能在对象和对象之间进行数据转换。\n</p>\n\n<h2 id="h2-1">Converter&lt;S, T&gt;</h2>\n<p>Spring的类型转换的基础是Converter&lt;S, T&gt;（以下简称转换器）接口：</p>\n<pre><code class="java"><span class="code-keyword">package</span> org.springframework.core.convert.converter;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n            class="code-title">Converter</span>&lt;<span class="code-title">S</span>, <span class="code-title">T</span>&gt; </span>{\n    <span class="hljs-function">T <span class="code-title">convert</span><span\n            class="hljs-params">(S source)</span></span>;\n}</code></pre>\n<p>\n    光是看他的结构就很清晰的明白这个接口是要做什么。S表示Source（来源）、T表示Target（目标），所以这个接口的2个范型参数就是数据从S转换为T，Converter::convert方法正是输入一个“S”类型的实例，返回一个“T”类型的实例。</p>\n<p>可以通过这个接口实现规范化、可复用的类型转换功能。下面通过转换器实现字符串到PC实体类相互转换的过程。</p>\n<p>Pc实体：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">PC</span> <span class="code-keyword">extends</span> <span\n        class="code-title">Device</span> </span>{\n\tString cpu;\n\tString graphic;\n\tString ram;\n    <span class="code-comment">//Getter &amp; Setter ...</span>\n}</code></pre>\n<p>在基类Device中通过反射实现字符串到实体类的转换：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="code-keyword">abstract</span> <span\n        class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">Device</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">pares</span><span class="hljs-params">(String text)</span></span>{ <span\n            class="code-comment">//字符串转换为实体</span>\n\t\tField[] fields = <span class="code-keyword">this</span>.getClass().getDeclaredFields();\n\t\t<span class="code-keyword">for</span> (Field field : fields) {\n\t\t\t<span class="code-keyword">int</span> begIndex = text.indexOf(field.getName());\n\t\t\t<span class="code-keyword">int</span> endIndex = text.indexOf(<span class="code-string">";"</span>, begIndex);\n\t\t\tString sub = text.substring(begIndex, endIndex), value = sub.split(<span\n            class="code-string">"="</span>)[<span class="hljs-number">1</span>];\n\t\t\tfield.setAccessible(<span class="code-keyword">true</span>);\n\t\t    field.set(<span class="code-keyword">this</span>, value);\n\t\t}\n\t};\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span\n            class="code-title">value</span><span class="hljs-params">()</span></span>{ <span class="code-comment">//实体转换为字符串</span>\n\t\tField[] fields = <span class="code-keyword">this</span>.getClass().getDeclaredFields();\n\t\tStringBuilder sb = <span class="code-keyword">new</span> StringBuilder();\n\t\t<span class="code-keyword">for</span> (Field field : fields) {\n\t\t\tsb.append(field.getName());\n\t\t\tsb.append(<span class="code-string">"="</span>);\n\t\t\tsb.append(field.get(<span class="code-keyword">this</span>).toString());\n\t\t\tsb.append(<span class="code-string">";"</span>);\n\t\t}\n\t\t<span class="code-keyword">return</span> sb.toString();\n\t}\n}</code></pre>\n<p>然后声明两个转换器的实现类：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">String2PcConverter</span> <span class="code-keyword">implements</span> <span\n        class="code-title">Converter</span>&lt;<span class="code-title">String</span>, <span\n        class="code-title">PC</span>&gt; </span>{\n    <span class="code-comment">//字符串转换为PC对象</span>\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> PC <span class="code-title">convert</span><span\n            class="hljs-params">(String source)</span> </span>{\n\t\tPC pc = <span class="code-keyword">new</span> PC();\n\t\tpc.pares(source);\n\t\t<span class="code-keyword">return</span> pc;\n\t}\n}</code></pre>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">PC2StringConverter</span> <span class="code-keyword">implements</span> <span\n        class="code-title">Converter</span>&lt;<span class="code-title">PC</span>, <span\n        class="code-title">String</span>&gt;  </span>{\n    <span class="code-comment">//PC对象转换为字符串</span>\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span\n            class="code-title">convert</span><span class="hljs-params">(PC source)</span> </span>{\n\t\t<span class="code-keyword">return</span> source.value();\n\t}\n}</code></pre>\n<p>最后使用这两个转换器：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">ConversionApp</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">void</span> <span\n            class="code-title">singletonConversion</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">final</span> String text = <span class="code-string">"cpu=amd;ram=kingston;graphic=Navidia;"</span>;\n\t\tConverter&lt;String, PC&gt; string2Pc = <span class="code-keyword">new</span> String2PcConverter();\n\t\tPC pc = string2Pc.convert(text);\n\t\tConverter&lt;PC, String&gt; pc2String = <span class="code-keyword">new</span> PC2StringConverter();\n\t\tString string = pc2String.convert(pc);\n\t}\n}</code></pre>\n<p>以上就是Spring最基本的类型转换功能——围绕着转换器（<em>Converter&lt;S, T&gt;）</em>接口实现数据类型转换。看到这里可能有些码友就要问了：这到底有什么用？直接用使用Device::pares和Device::value方法不就完事了？为什么还要引入转换器兜一圈？？！\n</p>\n<p>\n    如果系统仅仅只有1个或几个类型转换确实没必要引入转换器。但是业务总是繁杂多样的，模块与模块之前也会存在数据结构的差异，因此我们需要适配器（Adapter）、外观（Facade）等模式来应对变化多端的外部输入而无需改动业务逻辑。实际上从更高的层次看，Converter接口就是Spring为类型转换提供的一个适配器。后面会看到Spring已经为程序的顺利运行提供了大量的转换器，即使在阅读本文内容之前不知道这些转换器的存在，但Spring框架时时刻刻都在使用他们。</p>\n\n<h2 id="h2-2">ConverterFactory&lt;S, R&gt;</h2>\n<p>转换器只能对单一类型进行转换，如果有大量相同类别的数据需要转换可以使用ConverterFactory（一下简称转换工厂）：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">ConverterFactory</span>&lt;<span class="code-title">S</span>, <span\n        class="code-title">R</span>&gt; </span>{\n\n    &lt;T extends R&gt; <span class="hljs-function">Converter&lt;S, T&gt; <span\n            class="code-title">getConverter</span><span class="hljs-params">(Class&lt;T&gt; targetType)</span></span>;\n}</code></pre>\n<p>ConverterFactory::getConverter是返回一个转换器，这里范型标记“T”是“R”的子类。看下面转换工厂的例子，他可以将字符串转换成Device的子类：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">String2DeviceConverterFactory</span> <span class="code-keyword">implements</span> <span\n        class="code-title">ConverterFactory</span>&lt;<span class="code-title">String</span>, <span class="code-title">Device</span>&gt; </span>{\n\t<span class="code-keyword">public</span> &lt;T extends Device&gt; <span class="hljs-function">Converter&lt;String, T&gt; <span\n            class="code-title">getConverter</span><span class="hljs-params">(Class&lt;T&gt; targetType)</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> String2DeviceConverter(targetType);\n\t}\n\n    <span class="code-comment">// Device的通用转换器</span>\n\t<span class="code-keyword">static</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">String2DeviceConverter</span>&lt;<span class="code-title">T</span> <span\n            class="code-keyword">extends</span> <span class="code-title">Device</span>&gt; <span class="code-keyword">implements</span> <span\n            class="code-title">Converter</span>&lt;<span class="code-title">String</span>, <span class="code-title">Device</span>&gt; </span>{\n\t\t<span class="code-keyword">private</span> Class&lt;? extends Device&gt; klass;\n\t\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-title">String2DeviceConverter</span><span\n                class="hljs-params">(Class&lt;? extends Device&gt; klass)</span> </span>{\n\t\t\t<span class="code-keyword">this</span>.klass = klass;\n\t\t}\n\n\t\t<span class="hljs-function"><span class="code-keyword">public</span> T <span\n                class="code-title">convert</span><span class="hljs-params">(String source)</span> </span>{\n\t\t\tDevice device = <span class="code-keyword">null</span>;\n\t\t\tdevice = klass.newInstance();\n\t\t\tdevice.pares(source);\n\t\t\t<span class="code-keyword">return</span> (T) device;\n\t\t}\n\t}\n}</code></pre>\n<p>然后可以使用这个转换工厂按照目标类型进行转换：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">ConversionApp</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">factoryConversion</span><span\n            class="hljs-params">()</span> </span>{\n\t\tString2DeviceConverterFactory factory = <span class="code-keyword">new</span> String2DeviceConverterFactory();\n\t\tConverter&lt;String, PC&gt; pcConverter = factory.getConverter(PC.class);\n\t\t<span class="code-comment">//将字符串转换为PC</span>\n\t\tPC pc = pcConverter.convert(<span class="code-string">"cpu=amd;ram=kingston;graphic=Navidia;"</span>);\n\n\t\tConverter&lt;String, Phone&gt; phoneConverter = factory.getConverter(Phone.class);\n\t\t<span class="code-comment">//将字符串转换为Phone</span>\n\t\tPhone phone = phoneConverter.convert(<span class="code-string">"name=HUAWEIP20;cpu=Kirin970;ram=64G;"</span>);\n\t}\n}</code></pre>\n<p>Phone是另外一个继承了Device的实体类：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">Phone</span> <span class="code-keyword">extends</span> <span class="code-title">Device</span> </span>{\n\tString name;\n\tString cpu;\n\tString ram;\n    <span class="code-comment">// Getter &amp; Setter</span>\n}</code></pre>\n\n<h2 id="h2-3">数据转换服务</h2>\n<p>\n    Spring已经为数据转换预设了大量的Converter，这些Converter可以通过ConversionService直接使用。ConversionService中包含了几乎所有Java常规类型的数据格式转换，看下面的案例。</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">ConversionApp</span> </span>{<span class="hljs-function">ConversionApp <span\n        class="code-title">registConversionService</span><span class="hljs-params">()</span> </span>{\n\t\tConfigurableApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(ConversionConfig.class);\n        <span class="code-comment">// 获取ConversionService</span>\n\t\tConversionService service = ctx.getBean(ConversionService.class);\n\t\t<span class="code-comment">// 字符串转换为整型</span>\n\t\t<span class="code-keyword">int</span> i = service.convert(<span class="code-string">"123456"</span>, Integer.class);\n\t\t<span class="code-comment">// 字符串转换为浮点</span>\n\t\t<span class="code-keyword">float</span> f = service.convert(<span class="code-string">"1234.56"</span>, Float.class);\n\t\t<span class="code-comment">// 源生列表转换为List</span>\n\t\tList&lt;?&gt; list = service.convert(<span class="code-keyword">new</span> <span class="code-keyword">int</span>[] { <span\n            class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span\n            class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span> }, List.class);\n\t\t<span class="code-comment">// 源生列表转换为Set</span>\n\t\tSet&lt;?&gt; set = service.convert(<span class="code-keyword">new</span> <span class="code-keyword">int</span>[] { <span\n            class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span\n            class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span> }, Set.class);\n\t\t<span class="code-comment">// 枚举转换</span>\n\t\tGender gender = service.convert(<span class="code-string">"Male"</span>, Gender.class);\n\t\t<span class="code-comment">// 使用自定义转换器</span>\n\t\tPC pc = service.convert(<span class="code-string">"cpu=amd;ram=kingston;graphic=Navidia;"</span>, PC.class);\n\t\t<span class="code-comment">// UUID转换</span>\n\t\tUUID uuid = service.convert(<span class="code-string">"f51b4b95-0925-4ad0-8c62-4daf3ea7918f"</span>, UUID.class);\n\t\t<span class="code-comment">// 字符串转换为Optional&lt;PC&gt;</span>\n\t\tOptional&lt;PC&gt; options = service.convert(<span\n            class="code-string">"cpu=amd;ram=kingston;graphic=Navidia;"</span>, Optional.class);\n\t\t<span class="code-comment">// 使用TypeDescriptor描述进行转换</span>\n\t\tString source = <span class="code-string">"123456789"</span>;\n\t\t<span class="code-keyword">int</span> result = (<span class="code-keyword">int</span>) service.convert(source, TypeDescriptor.valueOf(source.getClass()),\n\t\t\t\tTypeDescriptor.valueOf(Integer.class));\n\t\t_G.print(result);\n\t}\n\n\t<span class="code-keyword">enum</span> Gender {\n\t\tMale, Female, Other\n\t}\n}</code></pre>\n<p>\n    除了上面的转换，ConversionService还提供了其他转换器，详情请看org.springframework.core.convert.support.DefaultConversionService的JavaDoc文档。</p>\n<p>需要通过ConversionServiceFactoryBean来启用ConversionService，下面的代码是在@Configurable中向IoC容器添加ConversionServiceFactoryBean：</p>\n<pre><code class="java"><span class="code-meta">@Configurable</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">ConversionConfig</span> </span>{\n\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> ConversionServiceFactoryBean <span\n            class="code-title">ConversionServiceFactoryBean</span><span class="hljs-params">()</span> </span>{\n\t\tConversionServiceFactoryBean factoryBean = <span class="code-keyword">new</span> ConversionServiceFactoryBean();\n\t\tSet&lt;Converter&gt; converters = <span class="code-keyword">new</span> HashSet&lt;&gt;();\n\t\t<span class="code-comment">// 添加自定义转换器</span>\n\t\tconverters.add(<span class="code-keyword">new</span> String2PcConverter());\n\t\tconverters.add(<span class="code-keyword">new</span> PC2StringConverter());\n\t\tfactoryBean.setConverters(converters);\n\t\t<span class="code-keyword">return</span> factoryBean;\n\t}\n}</code></pre>\n<p>也可以通过XML文件配置来引入ConversionService：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"conversionService"</span>\n        <span class="hljs-attr">class</span>=<span class="code-string">"org.springframework.context.support.ConversionServiceFactoryBean"</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"converters"</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">set</span>&gt;</span>\n            <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n                    class="code-string">"chkui.springcore.example.javabase.conversion.support.PC2StringConverter"</span>/&gt;</span>\n            <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n                    class="code-string">"chkui.springcore.example.javabase.conversion.support.String2PcConverter"</span>/&gt;</span>\n        <span class="code-tag">&lt;/<span class="code-name">set</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">property</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span></code></pre>\n<p>ConversionService在Spring MVC中的作用很大，可以全局注册统一的类型转换器，详情请见&nbsp;<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/web.html#mvc-config-conversion"\n        rel="nofollow">Conversion and Formatting</a>。&nbsp;</p>\n                                            '}});