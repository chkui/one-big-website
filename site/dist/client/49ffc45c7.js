webpackJsonp([4],{379:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<h3 id="h3-1">性能优化</h3>\n<p>在React内部已经使用了许多巧妙的技术来最小化由于Dom变更导致UI渲染所耗费的时间。对于很多应用来说，使用React后无需太多工作就会让客户端执行性能有质的提升。然而，还是很其他更多的办法来加速React程序。</p>\n<h4 id="h4-1">使用生产模式来构建应用</h4>\n<p>如果在开发和使用的过程中感觉了React应用有明显的性能问题，请先确认是否已经构建了压缩后的生产包：</p>\n<ul>\n    <li>在单页面用中，打包之后的生产文件应该是.min.js版本。</li>\n    <li>对于Brunch（html打包工具：http://brunch.io/），打包命令需要包含-p标记。</li>\n    <li>对于Browserify（UMD规范打包工具：http://browserify.org/），打包时需要增加生产配置参数——&nbsp;<code>NODE_ENV=production</code>。</li>\n    <li>对于在创建React App时，需要执行&nbsp;<code>npm run build</code>&nbsp;命令，并按照说明操作。</li>\n    <li>对于Rollup（JavaScript代码高效压缩工具：https://rollupjs.org/），生产打包时需要在&nbsp;<a title="commonjs插件"\n            href="https://github.com/rollup/rollup-plugin-commonjs" rel="nofollow">commonjs</a>&nbsp;插件之前使用&nbsp;<a title="replace插件"\n            href="https://github.com/rollup/rollup-plugin-replace" rel="nofollow">replace</a>&nbsp;插件：\n        <pre class="javascript"><code class="language-javascript">plugins: [\n  <span class="code-built_in"><span class="code-built_in">require</span></span>(<span class="code-string"><span\n                    class="code-string">\'rollup-plugin-replace\'</span></span>)({\n    <span class="code-string"><span class="code-string">\'process.env.NODE_ENV\'</span></span>: <span\n                    class="code-built_in"><span class="code-built_in">JSON</span></span>.stringify(<span\n                    class="code-string"><span class="code-string">\'production\'</span></span>)\n  }),\n  <span class="code-built_in"><span class="code-built_in">require</span></span>(<span class="code-string"><span\n                    class="code-string">\'rollup-plugin-commonjs\'</span></span>)(),\n  <span class="code-comment"><span class="code-comment">// ...</span></span>\n]</code></pre>\n        <p>可以在这里看到 一个完整的例子：<a title="Rollup生产优化的案例" href="https://gist.github.com/Rich-Harris/cb14f4bc0670c47d00d191565be36bf0"\n                              rel="nofollow">see this gist</a>。</p></li>\n    <li><p>使用Webpack打包，需要在打生产包的配置脚本中增加以下配置和插件：</p>\n        <pre class="javascript"><code class="language-javascript"><span class="code-keyword"><span class="code-keyword">new</span></span> webpack.DefinePlugin({\n  <span class="code-string"><span class="code-string">\'process.env\'</span></span>: {\n    NODE_ENV: <span class="code-built_in"><span class="code-built_in">JSON</span></span>.stringify(<span\n                    class="code-string"><span class="code-string">\'production\'</span></span>)\n  }\n}),\n<span class="code-keyword"><span class="code-keyword">new</span></span> webpack.optimize.UglifyJsPlugin()</code></pre>\n        <p>。</p></li>\n</ul>\n<p>切记不要将开发模式的包发布到生产环境，因为开发包中额外包含了许多用于辅助的测试的信息，无论在加载还是执行时，它都比较慢。</p>\n\n<h4 id="h4-2">使用chrome分析组件的渲染时间线</h4>\n<p>在开发模式中下你可以直接在chrome的性能工具中看到组件是如何装载、更新和卸载的。例如下面的图片展示的效果：</p>\n<p style="text-align:center"><img alt="React 渲染性能优化" height="228"\n                                  src="https://file.mahoooo.com/res/file/react_optimizing_performance_1.png"\n                                  width="651"></p>\n<p>在chrome中按照以下步骤执行：</p>\n<ol>\n    <li>使用?react_perf作为url参数（例如：http://localhost:3000/?react_perf）</li>\n    <li>打开chrome的开发工具Timeline，然后点击Record（左上角的红色按钮）。</li>\n    <li>执行你要监控的操作。请不要记录超过20秒，这可能会导致chrome假死。</li>\n    <li>停止记录。</li>\n    <li>React事件将会批量记录在User Timing标签里。</li>\n</ol>\n<p>关于分析的数据，需要明确的是：渲染的时间只是一个相对的参考值，在构建成生产包之后，渲染的速度会更快。尽管如此，这些数据仍然能够帮助我们分析是否有不相关的UI被错误的更新，以及UI更新的频率和深度。</p>\n<p>目前只有Chrome、Edge和IE支持这个特性，但是官方正在使用<a title="浏览器性能优化分析工具标准" href="https://developer.mozilla.org/en-US/docs/Web/API/User_Timing_API"\n                                       rel="nofollow">User Timing API&nbsp;标准</a>&nbsp;让更多浏览器支持这个特性。</p>\n\n<h4 id="h4-3">手工避免重复渲染</h4>\n<p>\n    React构建和维护了一个内部的虚拟Dom，这个Dom和真实的UI是相互映射的关系，他包含从用户自定义组件中返回的各种React元素。这个虚拟的Dom使得React可以避免重复渲染相同的Dom节点并在访问存在的节点时直接使用React的虚拟层数据，这样设计的原因是重复渲染浏览器或web\n    view的UI比操作一个JavaScript的对象要慢许多。在React Native也采用同样的处理方式。</p>\n<p>当组件的props和state变更时，React会将最新返回的元素与之前旧的元素进行对比来确定是否真的需要重新渲染真实的Dom。当他们不相等时，React会更新真实的Dom。</p>\n<p>在某些情况下，可以在自定义组件中重载<code>shouldComponentUpdate</code>方法来加速触发渲染的比对的过程。该方法的默认实现返回参数为true，此时React将按照原来的方式进行比对和渲染：</p>\n<pre class="kotlin"><code class="language-javascript">shouldComponentUpdate(nextProps, nextState) {\n  <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="hljs-literal"><span\n            class="hljs-literal">true</span></span>;\n}</code></pre>\n<p>如果在某些情况下能够清晰的明确组件不需要重新渲染，可以在&nbsp;<code>shouldComponentUpdate</code>&nbsp;方法中返回&nbsp;false，这样会让让组件跳过整个渲染过程，包括不再调用当前组件和子组件的render()方法。\n</p>\n\n<h4 id="h4-4">shouldComponentUpdate 的执行过程</h4>\n<p>下面是一个组件结构树。图中，“SCU”表示&nbsp;<code>shouldComponentUpdate</code>&nbsp;方法返回的值（绿色true，红色fasle），“vDOMEq”表示React的匹配是否一致（绿色true，红色fasle），有颜色的红圈表示是否执行了UI重绘（绿色表示没重绘，红色表示执行重绘）。\n</p>\n<p style="text-align:center"><img alt="React 渲染性能优化" height="371"\n                                  src="https://static.oschina.net/uploads/space/2017/0406/182936_ZTAG_2649413.png"\n                                  width="555"></p>\n<p style="text-align:left">在C2组件中，<code>shouldComponentUpdate</code>&nbsp;方法返回了false，所以React不会判断是否需要重新渲染C2并且不执行render()方法，&nbsp;因此在C4和C5中不再执行<code>shouldComponentUpdate</code>&nbsp;方法。\n</p>\n<p style="text-align:left">对于C1和C3，<code>shouldComponentUpdate</code>&nbsp;都返回了true，所以React必须对着2个组件进行比对。对于C6，<code>shouldComponentUpdate</code>&nbsp;返回true，而且比对的结果是需要UI重绘，因此C6会更新他们的真实Dom。\n</p>\n<p style="text-align:left">还有一个值得关心的组件是C8，React在这个组件中执行了render()方法，但是由于虚拟Dom并没有发生变更，前后比对一致，所以并没有发生真实Dom渲染。</p>\n<p style="text-align:left">在整个过程中React仅仅变更了C6组件的UI样式，C8由于前后虚拟Dom一致因此没有真正的执行UI渲染。C2、C2的子组件以及C7没有执行render()方法。</p>\n\n<h4 id="h4-5">一个shouldComponentUpdate的例子</h4>\n<p>在例子中，当props.color和state.count发生变更时进行UI渲染，我们在&nbsp;<code>shouldComponentUpdate</code>&nbsp;方法中进行检查：</p>\n<pre class="kotlin"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span\n        class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span\n        class="code-title"><span class="hljs-class"><span class="code-title">CounterButton</span></span></span><span\n        class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span\n        class="code-title">extends</span></span></span><span class="hljs-class"> </span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">React</span></span></span><span class="hljs-class">.</span><span\n        class="code-title"><span class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  <span class="code-keyword"><span class="code-keyword">constructor</span></span>(props) {\n    <span class="code-keyword"><span class="code-keyword">super</span></span>(props);\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.state = {count: <span\n            class="hljs-number"><span class="hljs-number">1</span></span>};\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    <span class="code-comment"><span class="code-comment">//只判断props.color和nextState.count是否变更，其他情况均不渲染</span></span>\n    <span class="code-keyword"><span class="code-keyword">if</span></span> (<span class="code-keyword"><span\n            class="code-keyword">this</span></span>.props.color !== nextProps.color) {\n      <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="hljs-literal"><span\n            class="hljs-literal">true</span></span>;\n    }\n    <span class="code-keyword"><span class="code-keyword">if</span></span> (<span class="code-keyword"><span\n            class="code-keyword">this</span></span>.state.count !== nextState.count) {\n      <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="hljs-literal"><span\n            class="hljs-literal">true</span></span>;\n    }\n    <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="hljs-literal"><span\n            class="hljs-literal">false</span></span>;\n  }\n\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> (\n      <span class="xml"><span class="code-tag">&lt;<span class="code-name">button</span>\n        <span class="hljs-attr">color</span>=<span class="code-string">{<span class="code-keyword">this</span>.props.color}</span>\n        <span class="hljs-attr">onClick</span>=<span class="code-string">{()</span> =&gt;</span> <span\n              class="code-keyword">this</span>.setState(state =&gt; ({count: state.count + <span\n              class="hljs-number">1</span>}))}&gt;\n        Count: {<span class="code-keyword">this</span>.state.count}\n      <span class="code-tag">&lt;/<span class="code-name">button</span>&gt;</span></span>\n    );\n  }\n}</code></pre>\n<p>在这段代码中，<code>shouldComponentUpdate</code>&nbsp;仅仅检查&nbsp;<code>props.color</code>和&nbsp;<code>state.count</code>是否发生变更，如果他们的值没有修改，组件将不会发生任何更新。在实际使用中，组件往往比这个复杂，我们可以使用类似于“浅比较”（关于浅比较可以参看：\n    <a title="shallow compare模式" href="https://facebook.github.io/react/docs/shallow-compare.html" rel="nofollow">Shallow Compare</a>）的模式来比对所有的属性或状态是否发生变更。React提供了这个模式的一个实现组件，只要让组件继承自&nbsp;<code>React.PureComponent</code>即可。我们可以将代码进行下面的修改：\n</p>\n<pre class="scala"><code class="language-javascript"><span class="code-comment"><span class="code-comment">//继承自React.PureComponent</span></span>\n<span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span\n        class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">CounterButton</span></span></span><span\n        class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{\n  <span class="code-keyword">constructor</span>(props) {\n    <span class="code-keyword"><span class="code-keyword">super</span></span>(props);\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.state = {count: <span\n            class="hljs-number"><span class="hljs-number">1</span></span>};\n  }\n\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> (\n      <span class="xml"><span class="code-tag">&lt;<span class="code-name">button</span>\n        <span class="hljs-attr">color</span>=<span class="code-string">{<span class="code-keyword">this</span>.props.color}</span>\n        <span class="hljs-attr">onClick</span>=<span class="code-string">{()</span> =&gt;</span> <span\n              class="code-keyword">this</span>.setState(state =&gt; ({count: state.count + <span\n              class="hljs-number">1</span>}))}&gt;\n        <span class="code-type">Count</span>: {<span class="code-keyword">this</span>.state.count}\n      <span class="code-tag">&lt;/<span class="code-name">button</span>&gt;</span></span>\n    );\n  }\n}</code></pre>\n<p>在大部分情况下，只要使用&nbsp;<code>React.PureComponent</code>&nbsp;就可以代替我们自己重载&nbsp;<code>shouldComponentUpdate</code>方法，但是它仅仅适用于“浅比较”，所以这个组件不适用于props和state数据发生突变的情况。\n</p>\n<p><span style="color:#FF0000">附：数据突变（mutated）是指变量的引用没有改变（指针地址未改变），但是引用指向的数据发生了变化（指针指向的数据发生变更）。例如const x = {foo:\'foo\'}。x.foo=\'none\' 就是一个突变。</span>\n</p>\n<p>在更复杂的数据结构中还会存在一些问题。例如下面的代码，我们希望<code>ListOfWords</code>&nbsp;组件将words参数渲染成一个逗号分隔的字符串，而父组件监控点击事件，每次点击都会增加一个单词到列表中，但是下面的代码并不会正确工作：\n</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span\n        class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span\n        class="code-title"><span class="hljs-class"><span class="code-title">ListOfWords</span></span></span><span\n        class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="xml"><span class="code-tag">&lt;<span\n            class="code-name">div</span>&gt;</span>{<span class="code-keyword">this</span>.props.words.join(\',\')}<span\n            class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>;\n  }\n}\n\n<span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span\n        class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">WordAdder</span></span></span><span class="hljs-class"> </span><span\n        class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  <span class="code-keyword">constructor</span>(props) {\n    <span class="code-keyword"><span class="code-keyword">super</span></span>(props);\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.state = {\n      words: [<span class="code-string"><span class="hljs-symbol">\'markla</span>r\'</span>]\n    };\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.handleClick = <span\n            class="code-keyword"><span class="code-keyword">this</span></span>.handleClick.bind(<span\n            class="code-keyword"><span class="code-keyword">this</span></span>);\n  }\n\n  handleClick() {\n    <span class="code-comment"><span class="code-comment">// 这段内容会导致代码不按照预期工作。</span></span>\n    <span class="code-keyword">const</span> words = <span class="code-keyword"><span\n            class="code-keyword">this</span></span>.state.words;\n    words.push(<span class="code-string"><span class="hljs-symbol">\'markla</span>r\'</span>);\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.setState({words: words});\n  }\n\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> (\n      &lt;div&gt;\n        &lt;button onClick={<span class="code-keyword">this</span>.handleClick} /&gt;\n        &lt;<span class="code-type">ListOfWords</span> words={<span class="code-keyword">this</span>.state.words} /&gt;\n      &lt;/div&gt;\n    );\n  }\n}</code></pre>\n<p>导致代码无法正常工作的原因是&nbsp;<code>PureComponent</code>&nbsp;仅仅对 this.props.words的新旧值进行“浅比较”。在words值在<code>handleClick</code>中被修改之后，即使有新的单词被添加到数组中，但是this.props.words的新旧值在进行比较时是一样的（引用对象比较），因此&nbsp;<code>ListOfWords</code>&nbsp;一直不会发生渲染。\n</p>\n\n<h4 id="h4-6">非突变数据的价值</h4>\n<p>有一个简单的方法预防上面提到的问题，就是在使用prop和state时防止数据发生突变。例如下面的例如，我们用数组的concat方法来代替等号“=”，这样在concat后会产生一个新的数组赋值给this.state.words：</p>\n<pre class="less"><code class="language-javascript"><span class="code-selector-tag">handleClick</span>() {\n  <span class="code-keyword"><span class="code-selector-tag">this</span></span><span class="code-selector-class">.setState</span>(prevState =&gt; ({\n    <span class="code-attribute">words</span>: prevState.words.concat([<span class="code-string"><span\n            class="code-string">\'marklar\'</span></span>])\n  }));\n}</code></pre>\n<p>ES6支持列表扩展语法，因此我们更容易在es6中实现非突变的数据赋值，例如：</p>\n<pre class="less"><code class="language-javascript"><span class="code-selector-tag">handleClick</span>() {\n  <span class="code-keyword"><span class="code-selector-tag">this</span></span><span class="code-selector-class">.setState</span>(prevState =&gt; ({\n    <span class="code-attribute">words</span>: [...prevState.words, <span class="code-string"><span class="code-string">\'marklar\'</span></span>],\n  }));\n};</code></pre>\n<p>可以重写传统的赋值语句防止对象中的数据发生数据突变。下面的例子有一个名为&nbsp;<code>colormap</code>&nbsp;的对象，我们想在修改&nbsp;<code>colormap.right</code>&nbsp;的值时渲染组件，我们可以这样重写组件：\n</p>\n<pre class="actionscript"><code class="language-javascript"><span class="hljs-function"><span class="code-keyword"><span\n        class="hljs-function"><span class="code-keyword">function</span></span></span><span\n        class="hljs-function"> </span><span class="code-title"><span class="hljs-function"><span class="code-title">updateColorMap</span></span></span><span\n        class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-params"><span\n        class="hljs-function"><span class="hljs-params">colormap</span></span></span><span class="hljs-function"><span\n        class="hljs-params">)</span> </span></span>{\n  colormap.right = <span class="code-string"><span class="code-string">\'blue\'</span></span>; <span class="code-comment"><span\n            class="code-comment">//浅拷贝，指针地址未变，数据发生变化。</span></span>\n}</code></pre>\n<p>可以使用&nbsp;<a title="ES6 Object.assign方法" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign"\n                rel="nofollow">Object.assign</a>&nbsp;方法来防止数据突变：</p>\n<pre class="javascript"><code class="language-javascript"><span class="hljs-function"><span class="code-keyword"><span\n        class="hljs-function"><span class="code-keyword">function</span></span></span><span\n        class="hljs-function"> </span><span class="code-title"><span class="hljs-function"><span class="code-title">updateColorMap</span></span></span><span\n        class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">colormap</span></span></span><span\n        class="hljs-function">) </span></span>{\n  <span class="code-comment"><span class="code-comment">// 深拷贝，修改返回对象的地址</span></span>\n  <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="code-built_in"><span\n            class="code-built_in">Object</span></span>.assign({}, colormap, {right: <span class="code-string"><span\n            class="code-string">\'blue\'</span></span>});\n}</code></pre>\n<p>修改后&nbsp;<code>updateColorMap</code>&nbsp;方法返回一个新的实例。需要注意的是某些浏览器不支持&nbsp;<code>Object.assign</code>方法，我们需要使用polyfill（差异化抹平，比如我们引入了babel-polyfill）来解决这个问题。\n</p>\n<p>有一个新的JavaScript方案是使用 扩展传播特性（见 <a title="扩展传播性能" href="https://github.com/sebmarkbage/ecmascript-rest-spread" rel="nofollow">object\n    spread properties</a>&nbsp;）来解决数据突变问题，实现如下：</p>\n<pre class="lua"><code class="language-javascript"><span class="hljs-function"><span class="code-keyword"><span\n        class="hljs-function"><span class="code-keyword">function</span></span></span><span\n        class="hljs-function"> </span><span class="code-title"><span class="hljs-function"><span class="code-title">updateColorMap</span></span></span><span\n        class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-params"><span\n        class="hljs-function"><span class="hljs-params">colormap</span></span></span><span class="hljs-function"><span\n        class="hljs-params">)</span></span> </span>{\n  <span class="code-keyword"><span class="code-keyword">return</span></span> {...colormap, right: <span\n            class="code-string"><span class="code-string">\'blue\'</span></span>};\n}</code></pre>\n<p>如果是构建React的App应用，那么以上方法都能够很好的支持，如果是在浏览器环境使用，需要引入polyfill机制。</p>\n\n<h4 id="h4-7">使用不可变的数据结构</h4>\n<p><a title="Immutable.js Github" href="https://github.com/facebook/immutable-js" rel="nofollow">Immutable.js</a>&nbsp;是解决数据突变问题的另外一种解决方案。它提供不可变、持久化的集合。集合包含下列结构：\n</p>\n<ul>\n    <li><em>Immutable</em>：一旦数据被创建，改集合不能在任何其他地方修改。</li>\n    <li><em>Persistent</em>：可以从已有的的数据集合（例如set）来创建新的数据集合。在创建新的数据集合后，已有的数据集合依然有效。</li>\n    <li>结构分享（<em>Structural Sharing</em>）：使用和原始数据尽可能相似的结构创建新的数据集合，并将复制降至最低，尽可能的提高效率。</li>\n</ul>\n<p>数据结构不可变的特性使跟踪数据变化变得很简单。任何变更将始终导致创建一个新的对象，所以我们只需要检查引用（指针地址）是否已经被修改即可确定数据是否已经修改。例如在常规的JavaScript代码中：</p>\n<pre class="actionscript"><code class="language-javascript"><span class="code-keyword"><span\n        class="code-keyword">const</span></span> x = { foo: <span class="code-string"><span\n        class="code-string">"bar"</span></span> };\n<span class="code-keyword"><span class="code-keyword">const</span></span> y = x;\ny.foo = <span class="code-string"><span class="code-string">"baz"</span></span>;\nx === y; <span class="code-comment"><span class="code-comment">// true</span></span></code></pre>\n<p>尽管y的值已经被修改，但是它和x都是同一个引用（指向相同的地址），因此最后的比较语句会返回true。我们可以使用&nbsp;immutable.js来修改代码：</p>\n<pre class="cs"><code class="language-javascript"><span class="code-keyword"><span\n        class="code-keyword">const</span></span> SomeRecord = Immutable.Record({ foo: <span class="hljs-literal"><span\n        class="hljs-literal">null</span></span>});\n<span class="code-keyword"><span class="code-keyword">const</span></span> x = <span class="code-keyword"><span\n            class="code-keyword">new</span></span> SomeRecord({ foo: <span class="code-string"><span\n            class="code-string">\'bar\'</span></span>});\n<span class="code-keyword"><span class="code-keyword">const</span></span> y = x.<span\n            class="code-keyword">set</span>(<span class="code-string"><span\n            class="code-string">\'foo\'</span></span>, <span class="code-string"><span\n            class="code-string">\'baz\'</span></span>);\nx === y; <span class="code-comment"><span class="code-comment">// false</span></span></code></pre>\n<p>在这个例子中，由于x突变时使用了新的引用，我们可以安全的假设x已经发生改变。</p>\n<p>还有两个库可以帮我们构建不可变数据：&nbsp;<a title="seamless-immutable" href="https://github.com/rtfeldman/seamless-immutable"\n                              rel="nofollow">seamless-immutable</a>&nbsp;and&nbsp;<a title="immutability-helper"\n        href="https://github.com/kolodny/immutability-helper" rel="nofollow">immutability-helper</a>。</p>\n<p>不可变的数据结构为我们跟踪数据对象变更提供了更加简便的方式，这是我们快速实现<code>shouldComponentUpdate</code>方法的基础。使用不可变数据后，可以为React提供不错的性能提升。</p>'},408:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<h3 id="h3-1">依赖注入</h3>\n<p>在<a href="https://www.chkui.com/article/spring/spring_core_design_pattern_and_ioc" rel="nofollow">设计模式与IoC</a>这篇文章中，介绍了Spring基础的三大支柱的两项内容——IoC、Bean。本篇将继续围绕着Bean的创建时的注入方式来介绍Spring的核心思想与设计模式。\n</p>\n<p>天底下所有面向对象的语言都不可能只用一个类来解决问题，即使是最简单的应用程序都存在类与类之间的依存关系。如下面这个人人都理解的组合例子：</p>\n<pre><code class="java"><span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">Foo</span></span>{\n   <span class="code-keyword">private</span> Other other;\n   <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-title">Foo</span><span\n           class="hljs-params">()</span></span>{\n      other = <span class="code-keyword">new</span> Other();\n   }\n}\n\n<span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">Other</span></span>{}</code></pre>\n<p>在设计模式上关于类的组合与继承的适用性不属于本篇的讨论范围，但是从Spring框架非侵入式的设计思路来看，组合才是使用Spring的正确姿势。</p>\n<p>官方将这种组合的关系叫做“依赖注入（DI——<em>Dependency injection</em>）”。从名字上来看这也是一种依托Ioc容器很自然的实现方式——所有的Bean都放置在容器中，然后通过一些配置来告诉容器bean与bean之间的依存关系。一个类除了在内部块中通过new关键字实现一个组合关系，也可以通过构造方法传参或接口方法设置。\n</p>\n<p>由于IoC容器不可能去修改一个类内部的代码，所以类与类的组合方式通过构造方法（Constructor）和set方法（Setter）来实现。此外，Ioc可以根据接口（interface）来注入对应的实现类（class extands\n    interface）,所以从设计模式的角度来说，依赖注入的方式很好的规避了<strong>标准组合模式</strong>中new关键字违反<strong>依赖倒置原则</strong>的问题。</p>\n\n<h3 id="h3-2">构造方法注入</h3>\n<p>直接通过构造方法注入组合数据。</p>\n<p>class：</p>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">A</span> </span>{\n    <span class="code-keyword">private</span> B b;\n    <span class="code-keyword">private</span> C c;\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-title">Foo</span><span\n            class="hljs-params">(B b, C c)</span> </span>{\n       <span class="code-keyword">this</span>.b = b;\n       <span class="code-keyword">this</span>.c = c;\n    }\n}\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">B</span> </span>{}\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">C</span> </span>{}\n</code></pre>\n<p>xml：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n            class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.A"</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">constructor-arg</span> <span\n                class="hljs-attr">ref</span>=<span class="code-string">"b"</span>/&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">constructor-arg</span> <span\n                class="hljs-attr">ref</span>=<span class="code-string">"c"</span>/&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n            class="code-string">"b"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.B"</span>/&gt;</span>\n\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n            class="code-string">"c"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.C"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>如果是源生类型的参数，可以通过指定类型来注入数据：</p>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">A</span> </span>{\n    <span class="code-keyword">private</span> <span class="code-keyword">int</span> b;\n    <span class="code-keyword">private</span> String c;\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-title">Foo</span><span\n            class="hljs-params">(<span class="code-keyword">int</span> b, String c)</span> </span>{\n       <span class="code-keyword">this</span>.b = b;\n       <span class="code-keyword">this</span>.c = c;\n    }\n}\n</code></pre>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.A"</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span\n            class="code-string">"int"</span> <span class="hljs-attr">value</span>=<span class="code-string">"1"</span>/&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span\n            class="code-string">"java.lang.String"</span> <span class="hljs-attr">value</span>=<span\n            class="code-string">"42"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span></code></pre>\n<p>也可以通过索引的方式：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.A"</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span\n            class="code-string">"0"</span> <span class="hljs-attr">value</span>=<span class="code-string">"1"</span>/&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span\n            class="code-string">"1"</span> <span class="hljs-attr">value</span>=<span class="code-string">"42"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span></code></pre>\n<p>配合<a href="http://download.oracle.com/javase/6/docs/api/java/beans/ConstructorProperties.html" rel="nofollow">@ConstructorProperties</a>注解，还可以直接使用名称来注入：\n</p>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">A</span> </span>{\n    <span class="code-keyword">private</span> <span class="code-keyword">int</span> b;\n    <span class="code-keyword">private</span> String c;\n    <span class="code-meta">@ConstructorProperties</span>({<span class="code-string">"b"</span>, <span\n            class="code-string">"c"</span>})\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-title">Foo</span><span\n            class="hljs-params">(<span class="code-keyword">int</span> b, String c)</span> </span>{\n       <span class="code-keyword">this</span>.b = b;\n       <span class="code-keyword">this</span>.c = c;\n    }\n}\n</code></pre>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"exampleBean"</span> <span class="hljs-attr">class</span>=<span class="code-string">"examples.ExampleBean"</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"b"</span> <span class="hljs-attr">value</span>=<span class="code-string">"1"</span>/&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"c"</span> <span class="hljs-attr">value</span>=<span class="code-string">"42"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span></code></pre>\n<p>在Debug模式下不用这个注解也可以实现按名字注入，但是千万别这样做。</p>\n\n<h3 id="h3-3">Set方法注入</h3>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">A</span> </span>{\n    <span class="code-keyword">private</span> B b;\n    <span class="code-keyword">private</span> C c;\n    <span class="code-keyword">private</span> String value;\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setA</span><span class="hljs-params">(A a)</span></span>{<span\n            class="code-keyword">this</span>.a = a;}\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setB</span><span class="hljs-params">(B b)</span></span>{<span\n            class="code-keyword">this</span>.b = b;}\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setB</span><span class="hljs-params">(String value)</span></span>{<span\n            class="code-keyword">this</span>.value = value;}\n}\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">B</span> </span>{}\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">C</span> </span>{}\n</code></pre>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.A"</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"b"</span> <span class="hljs-attr">ref</span>=<span class="code-string">"b"</span>/&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"c"</span> <span class="hljs-attr">ref</span>=<span class="code-string">"c"</span>/&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"value"</span> <span class="hljs-attr">value</span>=<span class="code-string">"1"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"b"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.B"</span>/&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"c"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.C"</span>/&gt;</span></code></pre>\n\n<h3 id="h3-4">使用&nbsp;Constructor还是Setter？</h3>\n<p>\n    2种注入方法在使用的过程中我们应该如何选取呢？Spring官方给出的答案是如果注入的数据或bean是一个“必要依赖”那么使用构造方法注入，如果属于配置性的非必须数据，使用Set方法注入。但是在实际应用时，会发现绝大部分注入方式都是通过Setter实现的，包括一些很流行的开源工具，例如下面的druid：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"ds"</span> <span class="hljs-attr">class</span>=<span class="code-string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span>\n     <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n             class="code-string">"driverClass"</span> <span class="hljs-attr">value</span>=<span class="code-string">"com.mysql.jdbc.Driver"</span>/&gt;</span>\n     <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n             class="code-string">"jdbcUrl"</span> <span class="hljs-attr">value</span>=<span class="code-string">"jdbc:mysql://localhost:3306/c3p0jdbctemplate"</span>/&gt;</span>\n     <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n             class="code-string">"user"</span> <span class="hljs-attr">value</span>=<span\n             class="code-string">"admin"</span>/&gt;</span>\n     <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n             class="code-string">"password"</span> <span class="hljs-attr">value</span>=<span class="code-string">"123456"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span></code></pre>\n<p>话说你不提供账户和密码能链接到数据库吗？这算必要依赖还是配置性依赖？所以也不用死守这些规则。下面是一些关键性的建议：</p>\n<ol>\n    <li>数据配置类使用constructor注入的方法来实现，因为这样可以将bean设置为一个不可变对象（<em>immutable objects</em>）。这样结合单例模式能够很好实现享元模式共享数据，结合原型模式可以创建“浅对比”对象（变更则替换）。\n    </li>\n    <li>如果构造函数要传入的参数太多，证明你的类要完成的责任太多，这个时候用Setter当然比较合理，但是建议回头去看看类当中是不是有可以拆分的功能。</li>\n    <li>Setter注入主要用于可选的依赖关系，如果没有设置值，类应该提供默认值。所以Setter方法应该检查传入值的有效性（not null、not blank等）。</li>\n    <li>如果出现了循环依赖，其实可以通过一个bean使用setter注入另外一个bean使用constructor注入来解决，不过最好检查一下代码为什么会循环，这是设计模式上的大忌。</li>\n    <li>最有一个建议最重要。如果用第三方类，别人给什么你只能用什么，没得选。</li>\n</ol>\n\n<h3 id="h3-5">注入参数</h3>\n<p>在XML配置中，用来设定注入方式和注入数据的XML标签很多，详细内容就不一一复述了，常规用法可以到官网&nbsp;<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-properties-detailed"\n        rel="nofollow">Dependencies and configuration in detail</a>&nbsp; 一节了解。这里仅仅说明一些要点：</p>\n<ol>\n    <li>父子Bean。Ioc容器提供Bean的父子关系配置。父子关系Bean可以进行数据合并，但是很少看见什么地方有实际应用。</li>\n    <li>&lt;idref&gt;标签和&lt;ref&gt;标签的差异：1)前者只能通过id引入，后者可以通过id或name引入；2)前者可以直接用value属性替换，但是value属性的效率会差很多；3)前者只能适用与当前配置文件或当前容器，后者可以引入任何位置的内容。</li>\n    <li>当需要设置一个null值时，用&lt;null&gt;标签代替value=""。在执行代码时直接传入一个null。</li>\n</ol>\n\n<h3 id="h3-6">自动装配</h3>\n<p>这里所说的自动装配是通过&lt;bean&gt;上的autowire属性实现的功能，与@Autowired注解并不是一回事，但是他的一些参数会影像@Autowired注解的行为。</p>\n<p>\n    在有@Autowired注解的情况下，autowire属性现在用得很少。基本上他实现的结果和@Autowired差不多，就是让Ioc容器根据bean的类型或者bean名称等自动将容器中其他能对应得上的bean注入到对于的构造方法或者set方法中。详情了解&nbsp;<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire"\n        rel="nofollow">Autowiring collaborators</a>。</p>\n\n<h3 id="h3-7">方法注入</h3>\n<p>如果每一个Bean都是单例模式，那么我们通过常规的XML配置引用的手段就可以实现所有的依赖组合关系。但是每个bean都有不同的生命周期，常规配置方法很难实现某些应用不同生命周期bean的依赖关系。</p>\n<p>第一种方式是通过继承&nbsp;ApplicationContextAware 类，继承后可以直接使用&nbsp;applicationContext 的 getBean 接口来获取任何一个 bean。</p>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n<span class="code-keyword">import</span> org.springframework.beans.BeansException;\n<span class="code-keyword">import</span> org.springframework.context.ApplicationContext;\n<span class="code-keyword">import</span> org.springframework.context.ApplicationContextAware;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">BeanManagerFoo</span> <span class="code-keyword">implements</span> <span\n            class="code-title">ApplicationContextAware</span> </span>{\n\n    <span class="code-keyword">private</span> ApplicationContext applicationContext;\n\n    <span class="code-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span\n            class="code-title">getBean</span><span class="hljs-params">(Class&lt;T&gt; type)</span></span>{\n\t\t<span class="code-keyword">return</span> applicationContext.getBean(type);\n\t}\n\n    <span class="hljs-function"><span class="code-keyword">public</span> Object <span\n            class="code-title">getBean</span><span class="hljs-params">(String id)</span></span>{\n\t\t<span class="code-keyword">return</span> springContext.getBean(id);\n\t}\n\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setApplicationContext</span><span class="hljs-params">(\n            ApplicationContext applicationContext)</span> <span\n            class="code-keyword">throws</span> BeansException </span>{\n        <span class="code-keyword">this</span>.applicationContext = applicationContext;\n    }\n}</code></pre>\n<p>第二种方法是使用Lookup Method。</p>\n<p>Lookup Method的实现思路是使用CGLIB生成了动态代理类并放置到Ioc中代替源生的类。看下面的例子。</p>\n<p>首先实现我们的抽象类，抽象的要求至少有一个抽象方法：</p>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n\n<span class="code-keyword">public</span> <span class="code-keyword">abstract</span> <span class="hljs-class"><span\n            class="code-keyword">class</span> <span class="code-title">A</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> String <span\n            class="code-title">getName</span><span class="hljs-params">()</span> </span>{\n        B b = <span class="code-keyword">this</span>.createB();\n        <span class="code-keyword">return</span> b.getName();\n    }\n\n    <span class="hljs-function"><span class="code-keyword">protected</span> <span class="code-keyword">abstract</span> B <span\n            class="code-title">createB</span><span class="hljs-params">()</span></span>;\n}\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">B</span> </span>{\n    <span class="code-keyword">private</span> String name = <span class="code-string">"B class"</span>;\n    <span class="hljs-function"><span class="code-keyword">public</span> String <span\n            class="code-title">getName</span><span class="hljs-params">()</span></span>{\n        <span class="code-keyword">return</span> <span class="code-keyword">this</span>.name;\n    }\n}</code></pre>\n<p>然后通过&lt;lookup-method&gt;标签来指定获取bean的方式：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"b"</span> <span class="hljs-attr">class</span>=<span\n        class="code-string">"x.y.B"</span> <span class="hljs-attr">scope</span>=<span\n        class="code-string">"prototype"</span> /&gt;</span>\n\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.A"</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">lookup-method</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"createB"</span> <span class="hljs-attr">bean</span>=<span\n            class="code-string">"b"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span></code></pre>\n<p>现在，在调用A.getName方法时都会创建一个新的B类实例。需要注意scope属性，如果修改为<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-singleton"\n        rel="nofollow">singleton</a>则每次都获取同一个B实例。</p>\n<p>使用动态代理由于是字节码级别的变换，所有有很多限制需要注意：方法和类都不能用fina关键字；测试用例需要自己实现代理模式，否则抽象类没有实现；</p>\n<p>第三种方法是使用委派模式，即我们执行A.compute方法时，实际执行的是被委派的B.reimplement方法。</p>\n<p>先定义2个基础类——Origin、Replace：</p>\n<pre><code class="java"><span class="code-keyword">package</span> x.y\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Origin</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">int</span> <span\n            class="code-title">compute</span><span class="hljs-params">(<span class="code-keyword">int</span> in1, <span\n            class="code-keyword">int</span> in2)</span> </span>{\n        <span class="code-keyword">return</span> in1+in2;\n    }\n}\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Replace</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">int</span> <span\n            class="code-title">reimplement</span><span\n            class="hljs-params">(Object o, Method m, Object[] args)</span> </span>{\n        <span class="code-keyword">int</span> in1 = (<span class="code-keyword">int</span>)args[<span\n            class="hljs-number">0</span>];\n        <span class="code-keyword">int</span> in2 = (<span class="code-keyword">int</span>)args[<span\n            class="hljs-number">1</span>];\n        <span class="code-keyword">return</span> in1+in2;\n    }\n}</code></pre>\n<p>然后定义Spring配置：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"origin"</span> <span class="hljs-attr">class</span>=<span\n        class="code-string">"x.y.Origin"</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">replaced-method</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"compute"</span> <span class="hljs-attr">replacer</span>=<span class="code-string">"replace"</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">arg-type</span>&gt;</span>int<span\n            class="code-tag">&lt;/<span class="code-name">arg-type</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">arg-type</span>&gt;</span>int<span\n            class="code-tag">&lt;/<span class="code-name">arg-type</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">replaced-method</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"replace"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.Replace"</span>/&gt;</span></code></pre>\n<p>这个时候，在任何时候执行“origin”这个bean的compute方法，实际上都是执行的Replace::reimplement方法。</p>\n<p>上面&lt;arg-type/&gt;的参数用全称或简写都可以，例如java.lang.String，使用String，Str都是指向这个类型。</p>\n<p>\n    使用委派模式的好处是限制少、灵活，并且不会用到CGLIB这种重量级工具。但是委派之后委派方法的真实参数和被委派方法的参数完全不一样，开发时需要时时刻刻紧跟委派类的结构来修改代码。一旦委派类发生任何修改而没有相应的调整被委派类，可能会出现意想不到的问题。</p>'},409:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<p>在前面两篇介绍Sring核心与设计模式的文章中，分别介绍了<a title="Ioc容器"\n                                   href="https://www.chkui.com/article/spring/spring_core_design_pattern_and_ioc">Ioc容器</a>和\n    <a title="Bean的依赖关系" href="https://www.chkui.com/article/spring/spring_core_design_pattern_and_ioc">Bean的依赖关系</a>。如果阅读过前2文就会知道，Spring的整个运转机制就是围绕着IoC容器以及Bean展开的。IoC就是一个篮子，所有的Bean都向里面扔。除了提供篮子功能创建并存放Bean之外，IoC还要负责管理Bean与Bean之间的关系——依赖注入。之前也提到Bean是Spring核心容器的最小工作单元，Spring一些更高级的功能（例如切面、代理）都是在Bean的基础上实现。\n</p>\n<p>除了管理Bean与Bean之间的关系，IoC还提供了对Bean自身进行控制的各项功能，本文将介绍Bean的<strong>生命周期功能</strong>以及<strong>状态定义功能。</strong></p>\n\n<h2 id="h2-1">前置依赖</h2>\n<p>\n    Bean与Bean之间存在依赖关系，可以是强依赖（通过XML和注解直接声明依赖）、也可以是弱依赖（ApplicationContextAware等方式获取）。当一个Bean需要另外一个Bean完成初始化后自身才能工作时，例如一个Bean依赖DataSoruce，但是DataSource的初始化需要较长时间。这个时候用<em>depends-on</em>声明前置依赖即可：\n</p>\n<pre><code class="xml"><span class="code-comment">&lt;!-- 依赖多个Bean使用,号分割 --&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"beanOne"</span> <span class="hljs-attr">class</span>=<span class="code-string">"ExampleBean"</span> <span\n        class="hljs-attr">depends-on</span>=<span class="code-string">"manager,accountDao"</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"manager"</span> <span class="hljs-attr">ref</span>=<span\n            class="code-string">"manager"</span> /&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"manager"</span> <span class="hljs-attr">class</span>=<span class="code-string">"ManagerBean"</span> /&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"accountDao"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.jdbc.JdbcAccountDao"</span> /&gt;</span></code></pre>\n\n<h2 id="h2-2">延迟加载</h2>\n<p>通常情况下，所有的&nbsp;<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-singleton"\n        rel="nofollow">singleton</a>&nbsp;类型的Bean都会在容器创建后进行初始化，简单的说就是启动Jvm就开始创建（实际上是创建ApplicationContext的某个实现类实例之后）。</p>\n<p>IoC支持所有的&nbsp;<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-singleton"\n        rel="nofollow">singleton</a>&nbsp;Bean在使用时再加载，这样做的好处是可以大大节省初始化的时间。<span style="color:#e74c3c">但是如果你的应用对启动时间的长短并不敏感，建议让所有的&nbsp;</span><a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-singleton"\n        rel="nofollow"><span style="color:#e74c3c">singleton</span></a><span style="color:#e74c3c">&nbsp;都启动时加载。这样可以在启动时就发现一些问题，而不是在运行很久直到使用时才由用户去触发这个问题</span>。或者可以根据场景来使用决定是否延迟，例如开发时使用延迟加载，而在集成测试或上生产时关闭。\n</p>\n<p>可以设置全局延迟加载，也可以设置某个Bean延迟加载：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span> <span class="hljs-attr">default-lazy-init</span>=<span\n        class="code-string">"true"</span>&gt;</span>\n    <span class="code-comment">&lt;!-- 所有的Bean知道使用的时候才会进行加载... --&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<pre><code class="xml"><span class="code-comment">&lt;!-- 只有lazy类延迟加载 --&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"lazy"</span> <span class="hljs-attr">class</span>=<span class="code-string">"com.foo.ExpensiveToCreateBean"</span> <span\n        class="hljs-attr">lazy-init</span>=<span class="code-string">"true"</span>/&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">name</span>=<span\n        class="code-string">"not.lazy"</span> <span class="hljs-attr">class</span>=<span class="code-string">"com.foo.AnotherBean"</span>/&gt;</span></code></pre>\n<p>需要注意的是，在设置某个单独的Bean延迟加载时，如果有某个没有延迟加载的Bean要依赖他，那实际上也会在初始化的时候就加载。</p>\n<p>还要强调一下，这里的“加载”仅仅是为了表示一个类被Ioc创造并放置容器中，和classLoad方法将class文件中的字节码加载到方法区的加载是两个概念。</p>\n<p>延迟加载在设计模式上是单例模式一种延伸，通常也被称为懒汉模式。单例通常有双重锁+volatile、静态类和枚举三种方式实现。在<a\n        href="http://www.baidu.com/link?url=kGkdnL7l_ll3LfLYL8dxNgxmZdGW-wKRbUh6i8wRu2CERbWLWDBkpLtu38Jg9qTx0-KOIOBr6FXsjRwJigZmxa"\n        target="_blank" rel="nofollow">Effective&nbsp;<em>Java</em></a>一书中对三种模式都有深入的解析。而对于Spring容器而言，枚举的方式肯定不好用了，静态类由于属于自身代码级别应该也不会用，所以双重锁的实现方式较为可信。不过我没去看过源码，仅属于猜测。\n</p>\n\n<h2 id="h2-3">生命周期方法</h2>\n<p>一个Bean的创建、使用再到最后销毁称为"Bean的生命周期"。Spring框架为Bean的生命周期各个阶段提供了多种回掉方法来处理各种状态或者数据。</p>\n\n<h3 id="h3-1">初始化方法</h3>\n<p>\n    当一个Bean完成初始化并注入各项参数之后，初始化回掉方法会被调用，简单的说就是完成创建之后会被调用。实现初始化回调方法有2个路径：1.继承org.springframework.beans.factory.InitializingBean接口，然后实现\n    afterPropertiesSet方法。2.在Bean的XML配置上使用init-method属性来制定要调用的初始化：</p>\n<p>继承实现：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.A"</span> /&gt;</span></code></pre>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">A</span> <span class="code-keyword">implements</span> <span class="code-title">InitializingBean</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">afterPropertiesSet</span><span class="hljs-params">()</span></span>{\n        <span class="code-comment">// init</span>\n    }\n}</code></pre>\n<p>配置实现：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span\n        class="code-string">"x.y.A"</span> <span class="hljs-attr">init-method</span>=<span\n        class="code-string">"init"</span> /&gt;</span></code></pre>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">A</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">init</span><span class="hljs-params">()</span></span>{}\n}</code></pre>\n<p>2种方法都等效，实际使用是我们应该使用哪一种方法呢？</p>\n<p>InitializingBean是Spring早期实现的一个生命周期回调方法。但是在JCP推出JSR-250和<a title="JSR-330"\n                                                             href="https://www.chkui.com/article/java/java_jsr330"\n>JSR-330</a>规范之后，Spring的大神们开始意识到基于元编程思想和配置手段来实现非侵入式框架（Not\n    Coupled）才是正道。所以现在都是推荐使用配置文件和JSR-250的@PostConstruct（关于各种Annotation的使用请关注后续的文章）。现在依然保留InitializingBean应该是考虑到兼容问题。</p>\n\n<h3 id="h3-2">销毁方法</h3>\n<p>与创建方法相对应的是销毁方法。当一个类将要被销毁之前，对应的销毁回调方法会被调用。销毁方法也有一个继承实现和配置+注解实现：</p>\n<p>继承实现：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.A"</span> /&gt;</span></code></pre>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">A</span> <span class="code-keyword">implements</span> <span class="code-title">DisposableBean</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">destroy</span><span class="hljs-params">()</span></span>{\n        <span class="code-comment">// 销毁资源</span>\n    }\n}</code></pre>\n<p>配置实现：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span\n        class="code-string">"x.y.A"</span> <span class="hljs-attr">destroy-method</span>=<span class="code-string">"cleanUp"</span> /&gt;</span></code></pre>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">A</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">cleanUp</span><span class="hljs-params">()</span></span>{\n        <span class="code-comment">// 销毁资源</span>\n    }\n}</code></pre>\n<p>依然建议销毁手段也使用配置或@PreDestroy来设定销毁方法。</p>\n\n<h3 id="h3-3">全局配置初始化与销毁方法</h3>\n<p>IoC容器还提供了全局配置初始化与销毁方法的配置：</p>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">A</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">init</span><span class="hljs-params">()</span></span>{\n        <span class="code-comment">// 初始化资源</span>\n    }\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">destroy</span><span class="hljs-params">()</span></span>{\n        <span class="code-comment">// 销毁资源</span>\n    }\n}</code></pre>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span> <span class="hljs-attr">default-init-method</span>=<span\n        class="code-string">"init"</span> <span class="hljs-attr">default-destroy-method</span>=<span\n        class="code-string">"destroy"</span>&gt;</span>\n     <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n             class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span\n             class="code-string">"x.y.A"</span>/&gt;</span>\n     <span class="code-comment">&lt;!-- bean configuration --&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>通过在&lt;beans&gt;标签上使用<em>default-init-method</em>和<em>default-destroy-method</em>&nbsp;属性参数，可以为容器中所有的Bean统一指定初始化和销毁的生命周期方法。\n</p>\n<p>如果在&lt;beans&gt;上设定2个默认的生命周期方法，同时在&lt;bean&gt;上也指定了<em>init-method</em>或<em>destroy-method，</em>回调方法会以&lt;bean&gt;上的配置为准。这样就保证全局配置与单独配置可以共存。\n</p>\n<p>使用初始化或销毁2个生命周期方法注意的要点：</p>\n<ol>\n    <li>\n        初始化和销毁都提供了3种手段：XML配置、注解、以及实现接口。系统的各个部分会交由不同的团队开发，不遵循统一的规范，建议使用满足JSR规范的注解——@PostConstruct、@PreDestroy。如果是统一的团队，准训一致的规范，建议使用&lt;beans&gt;的属性统一名称使用全局配置。\n    </li>\n    <li>如果Bean设计到代理模式时（例如使用了AOP），那么生命周期方法被调用时，有可能代理类还没有被创建出来。因为生命周期方法是实体类完成对应工作之后就会被调用，而与代理类无关。</li>\n</ol>'},410:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<p>前面3篇分别介绍了<a href="https://www.chkui.com/article/spring/spring_core_design_pattern_and_ioc" title="IoC容器与Bean的关系">IoC容器与Bean的关系</a>、<a\n        href="https://www.chkui.com/article/spring/spring_core_dependency_injection_of_bean" title="Bean与Bean之间的关系">Bean与Bean之间的关系</a>以及<a\n        href="https://www.chkui.com/article/spring/spring_core_bean_lifecycle_callback" title="Bean自身的控制和管理">Bean自身的控制和管理</a>。在了解Spinrg核心模式时，一定要谨记他的基本工作元素就是IoC容器和Bean，所有的功能是围绕着这2者展开的。要实现的内容无非就是通过设计模式来解决<strong>IoC与Bean的关系</strong>、<strong>Bean与Bean的关系</strong>、<strong>IoC与IoC的关系，</strong>以及对Ioc和Bean的控制<strong>。</strong>\n</p>\n\n<h2 id="h2-1">IoC控制入口</h2>\n<p>看完整个<em>Spring Core</em>的<em>API\n    Doc</em>，你也不会发现任何一个名为<em>IoC</em>的类或者接口。唯一一个提到<em>IoC</em>这个词的是<strong>spring-beans</strong>工程下关于<em>org.springframework.beans.factory</em>这个包的介绍——"<em>The\n    core package implementing Spring\'s lightweight Inversion of Control (IoC)\n    container.</em>"。实际上<em>Spring</em>核心框架将对<em>IoC</em>容器的控制都交给了<em>BeanFactory</em>和<em>ApplicationContext</em>两个接口。\n</p>\n<p>这个2个接口有什么关系吗？一个叫<em>Factory</em>，一个叫<em>Context</em>，概念上完全是两码事，前者是创建模式的FLAG，后者是行为模式的FLAG。并且在工程结构上，一个属于spring-beans，另外一个属于spring-context。不过仔细看会发现<em>ApplicationContext</em>继承自<em>BeanFactory</em>的派生接口<em>（</em>\n    ListableBeanFactory、HierarchicalBeanFactory <em>）。</em>要想理解他们的关系和作用，还得一个一个来说。</p>\n\n<h2 id="h2-2">factory包中的接口</h2>\n<p>\n    在Spring核心工程中，BeanFactory及其派生被定义为“Ioc容器的轻量级实现”。这也是Spring最基础的IoC容器和Bean的管理接口。factory包中主要涉及5个接口BeanFactory、ListableBeanFactory、HierarchicalBeanFactory、ConfigurableBeanFactory和ConfigurableListableBeanFactory<strong>。</strong>初来咋到看到这5个接口八成懵逼，少数牛逼的码友估计能从名字猜测出他们的功能。其实他们有很清晰的层次结构，一层继承一层，一层扩展一层的功能。\n</p>\n<p style="text-align:center"><img alt="Spring核心——上下文与IoC" height="300"\n                                  src="https://oscimg.oschina.net/oscnet/c5634f6073bb56eae08c276f589ba14dcbb.jpg"\n                                  width="469"></p>\n<p style="text-align:center">（图片来源于他人博客，如有侵权请告知)</p>\n<p><strong>BeanFactory</strong>是IoC容器最基本的功能，他就是前面文章中一直提到的IoC设计模式的具体实现——处理IoC与Bean，Bean与Bean的关系。可以理解BeanFactory自身就是一个IoC容器，然后提供了getter、is、contains接口来获取和判断Bean的状态。对于单例或多例，BeanFactory只提供了BeanFactory::isSingleton和BeanFactory::isPrototype2个方法，这也是为什么我在<a\n        href="https://www.chkui.com/article/spring/spring_core_design_pattern_and_ioc">设计模式与IoC</a>一文中会说从设计模式的角度来说，Bean除了工厂方法外，只涉及<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-singleton"\n        rel="nofollow">singleton</a>和<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-prototype"\n        rel="nofollow">prototype</a>2个创建模式。</p>\n<p><strong>ListableBeanFactory</strong>继承自<strong>BeanFactory</strong>接口。看方法会发现，BeanFactory只提供单个Bean的操作，而ListableBeanFactory都是支持列表操作，比如获取Bean的总数、获取Bean的name列表、通过Bean的Type获取Bean的列表、根据注解获取Bean的列表等。从字面上的Listable也可以看出来其是在基本Factory的基础上扩展了相同类型、相同名称Bean的功能。\n</p>\n<p><strong>HierarchicalBeanFactory</strong>从字面上就应该大概知道他的作用的解决层级问题，提供子父容器的管理方法。</p>\n<p>再往下就是<strong>ConfigurableListableBeanFactory</strong>接口，这个接口提供的IoC控制功能，从子字面<strong>Configurable</strong>来看意思就是可以配置的。顶层的几个接口（<strong>BeanFactory、ListableBeanFactory</strong>）都没提供Setter或Creater的功能，而<strong>ConfigurableListableBeanFactory</strong>集成的3个接口ListableBeanFactory、AutowireCapableBeanFactor、ConfigurableBeanFactory提供了Setter、Creater的功能。实际上<strong>ConfigurableListableBeanFactory</strong>就是提供了Beans的“增改”功能，以及一些附加的依赖控制。\n</p>\n<p>网上关于<em><strong>BeanFactory</strong></em>及其派生结构介绍的资料很多，大部分都是从源码的角度详细说明他们之间的依存关系。不过从使用者的角度，实际上从总体上去了解他的组合模式思路，比你一个一个的去看源码有意义得多，更何况就算你现在看了源码，一年不碰你还能记得？总不能天天还复习吧？看源码主要是要理解作者针对实现所用设计模式。当然你要是要参加什么面试的话，还真得复习复习。记得以前我作为面试官曾叫别人当场写出ConfigurableListableBeanFactory的继承关系。现在想想当时自己有多脑残，被面试的那些小哥估计想拍我吧？开发能力的好坏是一种思维方式，而不是谁记得2个\n    new String("A")到底创建了几个String实例，或者Integer的0到128会被预设。</p>\n<p>实际上进经过多年的发展，Spring Core\n    的BeanFactory这块已经发生了多次改变。从最基础的BeanFactory到ConfigurableListableBeanFactory层层向下推进全是接口或抽象类，每一个接口都在父接口的基础上包装了的新的接口方法。通过多层继承，官方的代码中只有一个名为DefaultListableBeanFactory的类将所有的接口功能都实现了，然后XmlFactory又继承实现了资源读写的功能。XmlFactory并没有多少代码，Ioc的核心功能都在DefaultListableBeanFactory。</p>\n<p>从设计模式上来说，很难去定义这么多接口派生但是一个实现类提供所有功能的模式到底算什么。我个人认为这很像外观模式（Facade&nbsp;Pattern）和装饰模式（Decorator\n    Pattern）结合。现实中我们没也没必要像教科书似的模式来理解应用。下面解释这个思路。</p>\n<p>首先我们来看看效果。</p>\n<p>例如现在你用BeanFactory来“装载”ConfigurableListableBeanFactory的实例：</p>\n<pre><code class="java">BeanFactory ioc = <span\n        class="code-keyword">new</span> ConfigurableListableBeanFactory();</code></pre>\n<p>\n    这个时候对你来说，这个BeanFactory就是一个装饰器或外观，如果BeanFactory接口不发生改变，你所能用的功能仅仅是BeanFactory提供的几个接口方法。即使可能有人在之后的任何时间修改增加了ConfigurableListableBeanFactory的方法。此时尽管ConfigurableListableBeanFactory这个实现类的本质发生了改变，但是对于BeanFactory的使用位置来说一切照旧，他通过&nbsp;BeanFactory这个外观装饰接口看到的效果和之前一模一样。&nbsp;而扩展了接口之后的实现类，新的代码可以用新的接口。例如：</p>\n<pre><code class="java">ConfigurableListableBeanFactory ioc = <span class="code-keyword">new</span> ConfigurableListableBeanFactory();</code></pre>\n<p>然后我们还可以继续向下扩展接口和功能。</p>\n<p>如果你看过源码，你会发现spring\n    beans的BeanFactory代码最早的编写时间停留在2001年4月13号，距今已经很长的历史了。相信之后肯定不断演进扩展了大量的功能。而通过接口派生的实现外观的方式，让古老的代码和后续的新功能友好的共存。对于我们自己的设计系统或实现“代码级别的迭代”这是一个极好的例子——仅维护一个实现，通过增加外观或装饰器来演进功能，使用者一直都是看到的外观。虽然这样做似乎会违背类的单一职责的原则。</p>\n<p>在接下来介绍ApplicationContext之前先要说明，我们现在创建一个Spring应该不使用任何BeanFactory相关的接口了，关于这一点<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#context-introduction-ctx-vs-beanfactory"\n        rel="nofollow">官方文档</a>有明确的说明。除了在少数对内存大小有严苛要求的受限制的设备上进行嵌入式开发，其他时候都应该使用ApplicationContext。ApplicationContext实现了BeanFactory的所有功能，并对应用开发提供了很多有用的扩展。BeanFactory现在存在的主要作用是为一些历史第三方库提供支持，现在对于大多数使用Spring的用户来说他是一个历史性的接口。\n</p>\n\n<h2 id="h2-3">ApplicationContext</h2>\n<p>\n    不知道别人在学习编程开发的早年看到Context这个词是什么感觉，反正我是蒙逼了很久。也不知道这词最早是哪位哥翻译的，译成“上下文”?!英文里con-前缀表示聚集、集合吗，context的字面意思明明就是一堆数据的集合吧。其实码界类似让人翻译的翻译还真不少，handle=句柄（deal\n    with，处理器）、socket=套接字（就使用原意插座还好理解）。更狠的是Robustness，真不知道在哪年是哪位大爷出于什么原因把他翻成“鲁棒性”的。</p>\n<p>\n    回到正题，我真正理解Context是在开始了解设计模式之后。在设计模式中Context的概念出现在“策略模式”，该模式的标准解释是执行一个方法会根据当前的状态和对象执行不同的“策略”，“策略”因为实现类的性质不同而发生改变。实际上就是用一个Context对“策略”进行包装，而“策略”可以根据需要调整（细节请度娘）。我直接用Spring的ApplicationContext来说明。</p>\n<p style="text-align: center;"><img alt="Spring核心——上下文与IoC" height="400"\n                                    src="https://oscimg.oschina.net/oscnet/2eb09f38d1ad275a1297fd165e6bd07fb4c.jpg"\n                                    width="464"></p>\n<p style="text-align: center;">(图片来源于网络，如有侵权请告知)</p>\n<p>\n    ApplictionContext的继承思路和BeanFactory类似，就不再介绍了。在核心包中，Spring提供的ApplicationContext实现类目前有FileSystemXmlApplication和ClassPathXmlApplicationContext（Web包里还有Web环境专用的ApplicationContext）。</p>\n<p>\n    FileSystemXmlApplication和ClassPathXmlApplicationContext分别代表了2个不同的“策略”，在我们使用的时候在创建ApplicationContext时确定，并且在运行时也可以调整。</p>\n<pre><code class="java"><span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">App</span> <span class="code-keyword">implements</span> <span class="code-title">ApplicationContextAware</span></span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span\n            class="hljs-params">()</span> </span>{\n        <span class="code-comment">// 初始化为策略1</span>\n\t\tApplicationContext springContext = <span class="code-keyword">new</span> ClassPathXmlApplicationContext(<span\n            class="code-string">"myXml.xml"</span>);\n        <span class="code-comment">// 使用策略1的方法，使用者不用知道实现细节</span>\n        System.out.println(springContext.getApplicationName());\n\n        <span class="code-comment">// 修改为策略2</span>\n        springContext = <span class="code-keyword">new</span> FileSystemXmlApplicationContext(<span class="code-string">"/myProject/myXml.xml"</span>);\n        <span class="code-comment">// 使用策略2的方法，使用者不用知道实现细节</span>\n        System.out.println(springContext.getApplicationName());\n\t}\n}</code></pre>\n<p>如上面的代码，我们可以根据我们需要指定不同的“策略”。ClassPath和FIleSystem两个类功能都差不多，最大的区别就是加载文件路径的差异——一个从当前工作目录、一个从整个磁盘路径。理论上策略模式还有一个&nbsp;<em>Strategy</em>接口来包装策略，Spring直接将<em>Context</em>设定为一个接口，然后通过不同的实现类整合到了一起。从实现上来看策略模式并没有什么太神奇的东西，实际上还是一个接口多个实现类。那么看到这里你肯定已经忍不住要吼了：这到底有什么用？不就是创建一个实例给一个接口吗？\n</p>\n<p>实际上策略模式和Context是针对分层应用而设计的，很多设计模式的资料只会说模式是什么，但是不会提到模式的来源和立意。我所知道在设计模式中Context的最早概念是来源是来自这篇论文——<a\n        href="https://www.cse.wustl.edu/~schmidt/PDF/Context-Object-Pattern.pdf" rel="nofollow">Context Object A Design\n    Pattern for Efficient Information Sharing across Multiple System Layers</a>（直译为《上下文对象——多层系统的高效信息共享的设计模式》），它大致的结论是在分层应用系统中（例如MVC——view-controller-service-dao）层之间传递（共享）数据时，将相同适用范围和生命周期的所有数据组合到一个Context中去传递可以大大的提升分层之后开发效率——大概就是反正我所有东西都往里面放，你用得着就用，用不着就算，也不用来和我商量要什么了。\n</p>\n<p><span style="color:#e74c3c">所以Context实际上就是按照适用范围（Scope）而不是应用功能（functionality</span><span style="color:#e74c3c">）划分的一个数据对象。</span><span\n        > 这样在层与层之间传递数据的时候，无论有多少个接口都传递同一个的Context。</span></p>\n<p style="text-align: center;"><span><img alt="Spring核心——上下文与IoC" height="500"\n                                                             src="https://oscimg.oschina.net/oscnet/b54ba49ded2c3d92ef130edfc418a4a81ac.jpg"\n                                                             width="331"></span></p>\n<p>\n    例如Spring全局应用就是ApplicatonContext，把IoC和其他全局操作方法的丢到这个Context中。所以最后我们看到除了IoC的Bean控制接口（BeanFactory）外，他还提供资源控制接口（ResourcePatternResolver）、国际化接口（MessageSource）&nbsp;、事件发布管理接口（ApplicationEventPublisher）。这些功能并没有直接的联系，但是他们的适用范围都是Applicaton级别的，所以都被整合到了ApplicatonContext中。</p>\n<p>再例如在WebApplicationContext中，一次请求相关的所有资源以及相关的接口都会整合RequestContext中，RequestContext用于Servlet到我们自定义的Controller层传递数据。</p>\n<p>ApplicationContext继承了BeanFactory，其核心功能还是管理IoC以及Bean。前面也提到ApplicationContext还扩展了许多功能。下图来自于官方，表现了2者的功能差异。</p>\n<table>\n    <tbody>\n    <tr>\n        <th>Feature</th>\n        <th><code>BeanFactory</code></th>\n        <th><code>ApplicationContext</code></th>\n    </tr>\n    </tbody>\n    <tbody>\n    <tr>\n        <td><p>Bean 初始化与设定</p></td>\n        <td><p>Yes</p></td>\n        <td><p>Yes</p></td>\n    </tr>\n    <tr>\n        <td><code>BeanPostProcessor注册</code></td>\n        <td><p>No</p></td>\n        <td><p>Yes</p></td>\n    </tr>\n    <tr>\n        <td><code>BeanFactoryPostProcessor注册</code></td>\n        <td><p>No</p></td>\n        <td><p>Yes</p></td>\n    </tr>\n    <tr>\n        <td><p>国际化支持</p></td>\n        <td><p>No</p></td>\n        <td><p>Yes</p></td>\n    </tr>\n    <tr>\n        <td><p><span style="font-size:13px">事件发布与注册</span></p></td>\n        <td><p>No</p></td>\n        <td><p>Yes</p></td>\n    </tr>\n    </tbody>\n</table>\n<p>后续的文章会继续展开介绍这些功能以及背后设计模式的含义。</p>'},420:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<h2 id="h2-1"><span style="font-family:微软雅黑,microsoft yahei">调用堆栈</span></h2>\n<p><em>&nbsp;&nbsp;&nbsp;&nbsp;io.vertx.ext.mongo.impl.MongoClientImpl；</em></p>\n<p><em>&nbsp;&nbsp;&nbsp;&nbsp;io.vertx.ext.mongo.impl.MongoHolder;</em></p>\n<p><em>&nbsp;&nbsp;&nbsp;&nbsp;io.vertx.ext.mongo.impl.config.MongoClientOptionsParser;</em></p>\n\n<h2 id="h2-2">实现过程</h2>\n<p>当调用<em>MongoClient::createShared()</em>或<em>MongoClient::createNonShared()</em>方法创建<em>mongo</em>的客户端时，最终都会调用到<em>MongoClientImpl</em>的构造函数。</p>\n<pre class="kotlin"><code class="language-java"> <span class="hljs-function"><span class="code-keyword"><span class="code-keyword">public</span></span> <span class="code-title">MongoClientImpl</span><span class="hljs-params">(Vertx vertx, JsonObject config, String dataSourceName)</span> </span>{\n    Objects.requireNonNull(vertx);\n    Objects.requireNonNull(config);\n    Objects.requireNonNull(dataSourceName);\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.vertx = vertx;\n    <span class="code-comment"><span class="code-comment">// 检查或创建新的MongHolder</span></span>\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.holder = lookupHolder(dataSourceName, config);\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.mongo = holder.mongo();\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.useObjectId = config.getBoolean(<span class="code-string"><span class="code-string">"useObjectId"</span></span>, <span class="code-keyword"><span class="hljs-literal">false</span></span>);\n  }</code></pre>\n<p>如果是通过<em>createNonShared</em>方法创建client时，这里传入的<em>dataSourceName</em>是一个UUID。当使用<em>createShared</em>创建<em>client</em>,会在<em>lookupHolder</em>方法中检查是否已经创建了同名的客户端，否则新建。</p>\n<p>下图是检查数据源的过程。会根据传入的&nbsp;<em>datasourceName </em>从 <em>vertx </em>实例的共享数据实例（<em>io.vertx.core.shareddata.SharedData</em>）中获取同名的 <em>MongoHolder </em>实例。</p>\n<pre class="cpp"><code class="language-java"> <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">private</span></span></span><span class="hljs-function"> MongoHolder </span><span class="code-title"><span class="hljs-function"><span class="code-title">lookupHolder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String datasourceName, JsonObject config)</span></span></span><span class="hljs-function"> </span></span>{\n    <span class="code-keyword">synchronized</span> (vertx) {\n      <span class="code-comment"><span class="code-comment">// 获取共享数据实例中的map</span></span>\n      LocalMap&lt;String, MongoHolder&gt; <span class="code-built_in">map</span> = vertx.sharedData().getLocalMap(DS_LOCAL_MAP_NAME);\n\n      <span class="code-comment"><span class="code-comment">// 检查datasourceName对应的MongoHolder 是否存在</span></span>\n      MongoHolder theHolder = <span class="code-built_in">map</span>.get(datasourceName);\n\n      <span class="code-comment"><span class="code-comment">// 不存在则新构建，并将构建的结果放入sharedData的map中</span></span>\n      <span class="code-keyword"><span class="code-keyword">if</span></span> (theHolder == <span class="code-keyword">null</span>) {\n        theHolder = <span class="code-keyword"><span class="code-keyword">new</span></span> MongoHolder(config, () -&gt; removeFromMap(<span class="code-built_in">map</span>, datasourceName));\n        <span class="code-built_in">map</span>.put(datasourceName, theHolder);\n      } <span class="code-keyword"><span class="code-keyword">else</span></span> {\n        <span class="code-comment"><span class="code-comment">// 递增被引用的计数</span></span>\n        theHolder.incRefCount();\n      }\n      <span class="code-keyword"><span class="code-keyword">return</span></span> theHolder;\n    }\n  }</code></pre>\n<p>如果实例不存在，则会创建新的&nbsp;<em>MongoHolder </em>实例。<span style="color:#FF8C00">个人认为这里有个很不完美的地方是为了解决懒汉模式的问题，增加了一个线程锁。在高并发请求数据库连接资源时，这里会有阻塞。因此我在自己的实现类中存储了MongoClient的实例。不过这个线程锁可以有效减少数据库连接池的爆发式增长，在数据库连接池资源较少的情况下，有不错的效果（比如我们某个项目使用了阿里云的mongDB，最低配置只有200个连接）</span>。</p>\n<p>下图是&nbsp;<em>MongoHolder </em>的构造方法。</p>\n<pre class="kotlin"><code class="language-java"><span class="hljs-function"><span class="code-keyword"><span class="code-keyword">public</span></span> <span class="code-title">MongoHolder</span><span class="hljs-params">(JsonObject config, Runnable closeRunner)</span> </span>{\n      <span class="code-keyword"><span class="code-keyword">this</span></span>.config = config;\n      <span class="code-keyword"><span class="code-keyword">this</span></span>.closeRunner = closeRunner;\n    }</code></pre>\n<p><em>&nbsp;&nbsp;&nbsp;&nbsp;MongoHolder&nbsp;</em>构造方法只是简单的设置了成员变量 <em>config&nbsp;</em>和 <em>closeRunner </em>的值。<em>closeRunner</em>当调用<em>MongoClient::close()</em>方法时，用于回调销毁<em>SharedData::localMap</em>中的对应索引数据。<em>config </em>是用户传入的配置参数，需要注意的是，<em>config </em>传递到这里一直没有被改变。</p>\n<p>创建&nbsp;<em>MongoHolder&nbsp;</em>的实例成功后，接下来会调用&nbsp;<em>MongoHolder::mongo() </em>来创建一个真正&nbsp;<em>com.mongodb.async.client.MongoClient</em> 实例。这里同样使用了懒汉模式，存在线程锁，如果MongoClient的实例存在直接返回，如果不存在，则新建一个实例。</p>\n<pre class="java"><code class="language-java"><span class="code-keyword"><span class="code-keyword">synchronized</span></span> com.mongodb.async.client.<span class="hljs-function"><span class="hljs-function">MongoClient </span><span class="code-title"><span class="hljs-function"><span class="code-title">mongo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{\n      <span class="code-keyword"><span class="code-keyword">if</span></span> (mongo == <span class="code-keyword"><span class="code-keyword">null</span></span>) {\n        <span class="code-comment"><span class="code-comment">// 解析外部传递的config</span></span>\n        MongoClientOptionsParser parser = <span class="code-keyword"><span class="code-keyword">new</span></span> MongoClientOptionsParser(config);\n\n        <span class="code-comment"><span class="code-comment">// 将解析结果用于创建新的com.mongodb.async.client.MongoClient实例</span></span>\n        mongo = MongoClients.create(parser.settings());\n        String dbName = config.getString(<span class="code-string"><span class="code-string">"db_name"</span></span>, DEFAULT_DB_NAME);\n        db = mongo.getDatabase(dbName);\n      }\n      <span class="code-keyword"><span class="code-keyword">return</span></span> mongo;\n    }</code></pre>\n<p><em>&nbsp;&nbsp;&nbsp;&nbsp;MongoClientOptionsParser 对象</em>是创建Mongo客户端的关键，他会解析用户传递的参数来创建mongDB客户端，理解他的解析方法有利于创建合适的客户端。</p>\n<p><em>&nbsp;&nbsp;&nbsp;&nbsp;MongoClientOptionsParser </em>的构造方法共有60行，这里分几段说明。为了更好的理解创建过程，建议了解下<a title="MongoDB异步Java驱动" href="http://mongodb.github.io/mongo-java-driver/3.2/driver-async" rel="nofollow">MongoDB异步Java驱动</a>。下面的构造客户端参数的第一部分。</p>\n<pre class="gradle"><code class="language-java"> <span class="hljs-function"><span class="code-keyword"><span class="code-keyword">public</span></span> <span class="code-title">MongoClientOptionsParser</span><span class="hljs-params">(JsonObject config)</span> </span>{\n    Objects.requireNonNull(config);\n    \n    <span class="code-comment"><span class="code-comment">// 创建mongoDB的构建对象</span></span>\n    MongoClientSettings.Builder <span class="code-keyword">options</span> = MongoClientSettings.builder();\n\n    <span class="code-comment"><span class="code-comment">// 注册对象数据的存储规则</span></span>\n    <span class="code-keyword">options</span>.codecRegistry(CodecRegistries.fromRegistries(commonCodecRegistry, CodecRegistries.fromCodecs(<span class="code-keyword"><span class="code-keyword">new</span></span> JsonObjectCodec(config))));\n\n    <span class="code-comment"><span class="code-comment">// 获取连接串，所有的定义参数都来自连接串</span></span>\n    String cs = config.getString(<span class="code-string"><span class="code-string">"connection_string"</span></span>);\n\n    <span class="code-comment"><span class="code-comment">// 解析连接串</span></span>\n    ConnectionString connectionString = (cs == <span class="code-keyword"><span class="code-keyword">null</span></span>) ? <span class="code-keyword"><span class="code-keyword">null</span></span> : <span class="code-keyword"><span class="code-keyword">new</span></span> ConnectionString(cs);\n\n    <span class="code-comment"><span class="code-comment">// 解析集群参数</span></span>\n    ClusterSettings clusterSettings = <span class="code-keyword"><span class="code-keyword">new</span></span> ClusterSettingsParser(connectionString, config).settings();\n    <span class="code-keyword">options</span>.clusterSettings(clusterSettings);\n\n    <span class="code-comment"><span class="code-comment">// 解析连接池参数</span></span>\n    ConnectionPoolSettings connectionPoolSettings = <span class="code-keyword"><span class="code-keyword">new</span></span> ConnectionPoolSettingsParser(connectionString, config).settings();\n    <span class="code-keyword">options</span>.connectionPoolSettings(connectionPoolSettings);\n\n    <span class="code-comment"><span class="code-comment">// some code</span></span>\n}</code></pre>\n<p>首先创建&nbsp;<em>MongoClientSettings </em>的构造对象。</p>\n<p>然后根据传递的参数构建&nbsp;<em>CodecRegistry </em>实例。<em>CodecRegistry </em>的说明见 <a title="mongDB官网CodecRegistry的API说明" href="http://api.mongodb.com/java/3.2/?com/mongodb/async/client/MongoClientSettings.html" rel="nofollow">mongDB官网CodecRegistry的API说明</a>。<em>CodecRegistry 用于指定相关的对象在mongoDB的读写实现类，</em>例如官方已经源生实现了<em>&nbsp;StringCodec、IntegerCodec</em>来处理Java的<em>String、Integer</em>对象<em>。</em></p>\n<p>这段代码的最后部分，创建一个&nbsp;<em>ConnectionString&nbsp;</em>实例来分解和存储连接串的解析结果。<em>ConnectionString </em>是&nbsp;<em>mongoDB&nbsp;</em>官方实现的解析连接串参数方法<em>。</em>可以将http协议串解析成对应的初始化参数，例如设置连接池最小连接数为20，最大连接数为200：&nbsp;<span style="color:#FF8C00"><em>mongodb://host:27017/?minPoolSize=20&amp;maxPoolSize=200 </em></span>。详细说明见&nbsp;<a title="ConnectionString API" href="http://api.mongodb.com/java/3.2/?com/mongodb/ConnectionString.html" rel="nofollow"><em>ConnectionString&nbsp;</em>的API文档</a> &nbsp;和 <a title="mongoDB官方指引手册" href="http://mongodb.github.io/mongo-java-driver/3.2/driver-async/reference/connecting/connection-settings/" rel="nofollow">mongoDB官方指引手册</a>&nbsp;。</p>\n<p>下面的代码是&nbsp;<em>ClusterSettingsParser&nbsp;</em>对传入的数据进行解析，<em>vertx-mongdb</em>解析连接参数都是采用类似的思路：优先使用mongodb源生连接串中指定的参数，如果参数不存在，则使用用户传入的参数。因此，在我们设计mongodb的连接参数时，可以在传入的JsonObject实例中统一在key="connection_string"的参数中一次性制定mongdb风格的连接字符串，还可以在这个实例中通过key值设置vertx风格的各种连接参数。如果2个参数都存在，则优先使用连接字符串。</p>\n<pre class="java"><code class="java"><span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">public</span></span></span><span class="hljs-function"> </span><span class="code-title"><span class="hljs-function"><span class="code-title">ClusterSettingsParser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ConnectionString connectionString, JsonObject config)</span></span></span><span class="hljs-function"> </span></span>{\n\n    <span class="code-comment"><span class="code-comment">// 创建mongdb集群builder方法</span></span>\n    ClusterSettings.Builder settings = ClusterSettings.builder();\n\n    <span class="code-comment"><span class="code-comment">// 优先从连接字符串中使用mongdb源生方法解析相关参数 </span></span>\n    <span class="code-keyword"><span class="code-keyword">if</span></span> (connectionString != <span class="code-keyword"><span class="code-keyword">null</span></span>) {\n      settings.applyConnectionString(connectionString);\n    } <span class="code-keyword"><span class="code-keyword">else</span></span> {\n      <span class="code-comment"><span class="code-comment">// 如果连接字符串中相关的参数不存在，则从用户传入的config中提取指定的数据</span></span>\n      <span class="code-comment"><span class="code-comment">// 设置host列表</span></span>\n      <span class="code-comment"><span class="code-comment">// 在parseHosts中优先解析config是否存在包含key=hosts的JsonArray实例，如果有则会即系多个连接服务器</span></span>\n      <span class="code-comment"><span class="code-comment">// 如果没有key=hosts，则解析host和port是否存在</span></span>\n      List&lt;ServerAddress&gt; hosts = parseHosts(config);\n      settings.hosts(hosts);\n\n      <span class="code-comment"><span class="code-comment">// 设置mongdb的运行模式和replica模式</span></span>\n      String replicaSet = config.getString(<span class="code-string"><span class="code-string">"replicaSet"</span></span>);\n      <span class="code-keyword"><span class="code-keyword">if</span></span> (hosts.size() == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; replicaSet == <span class="code-keyword"><span class="code-keyword">null</span></span>) {\n        settings.mode(ClusterConnectionMode.SINGLE);\n      } <span class="code-keyword"><span class="code-keyword">else</span></span> {\n        settings.mode(ClusterConnectionMode.MULTIPLE);\n      }\n      <span class="code-keyword"><span class="code-keyword">if</span></span> (replicaSet != <span class="code-keyword"><span class="code-keyword">null</span></span>) {\n        settings.requiredReplicaSetName(replicaSet);\n      }\n    }\n\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.settings = settings.build();\n  }</code></pre>\n<p>这里就不一一说明每一个解析方法，基本上都是一样的套路。</p>\n<p>解析完连接参数后，用这些参数直接调用<em>MongoClients::create</em>来创建mongdb的客户端实例。然后从客户端从获取mongodb的连接。</p>\n\n<h2 id="h2-3"><span style="font-family:微软雅黑,microsoft yahei">总结</span></h2>\n<p>至此，mongdb的创建过程完毕。在创建的过程中，可以实现mongdb源生的连接串，也可以使用vertx风格的JsonObject。mongdb自身已经实现了全异步接口，因此vertx-mongdb只是在此基础上进行了一层封装。下面的附表是vertx-mongdb相关的设置参数。可以在建立vertx-mongdb实例时，通过JsonObject传入。</p>\n<pre class="actionscript"><code class="actionscript">{\n  <span class="code-comment"><span class="code-comment">// 设置单个mongdb服务时使用host、port指定主机和端口</span></span>\n  <span class="code-string"><span class="code-string">"host"</span></span> : <span class="code-string"><span class="code-string">"17.0.0.1"</span></span>, <span class="code-comment"><span class="code-comment">// string --mongdb实例所在的地址</span></span>\n  <span class="code-string"><span class="code-string">"port"</span></span> : <span class="hljs-number"><span class="hljs-number">27017</span></span>,      <span class="code-comment"><span class="code-comment">// int --mongdb实例的端口号</span></span>\n\n  <span class="code-comment"><span class="code-comment">// 设置集群mongdb服务器时使用队列</span></span>\n  <span class="code-string"><span class="code-string">"hosts"</span></span> : [\n    {\n      <span class="code-string"><span class="code-string">"host"</span></span> : <span class="code-string"><span class="code-string">"cluster1"</span></span>, <span class="code-comment"><span class="code-comment">// string --集群1地址</span></span>\n      <span class="code-string"><span class="code-string">"port"</span></span> : <span class="hljs-number"><span class="hljs-number">27000</span></span>       <span class="code-comment"><span class="code-comment">// int --集群1端口号</span></span>\n    },\n    {\n      <span class="code-string"><span class="code-string">"host"</span></span> : <span class="code-string"><span class="code-string">"cluster2"</span></span>, <span class="code-comment"><span class="code-comment">// string --集群2地址</span></span>\n      <span class="code-string"><span class="code-string">"port"</span></span> : <span class="hljs-number"><span class="hljs-number">28000</span></span>       <span class="code-comment"><span class="code-comment">// int --集群2端口号</span></span>\n    },\n    ...\n  ],\n\n  <span class="code-comment"><span class="code-comment">// 数据库分布式方法</span></span>\n  <span class="code-string"><span class="code-string">"replicaSet"</span></span> :  <span class="code-string"><span class="code-string">"foo"</span></span>    <span class="code-comment"><span class="code-comment">// string</span></span>\n\n  <span class="code-comment"><span class="code-comment">// 连接池参数</span></span>\n  <span class="code-string"><span class="code-string">"maxPoolSize"</span></span> : <span class="hljs-number"><span class="hljs-number">100</span></span>,                <span class="code-comment"><span class="code-comment">// int --最大连接数</span></span>\n  <span class="code-string"><span class="code-string">"minPoolSize"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>,                <span class="code-comment"><span class="code-comment">// int --最小连接数</span></span>\n  <span class="code-string"><span class="code-string">"maxIdleTimeMS"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>,          <span class="code-comment"><span class="code-comment">// long --单个连接空闲释放时间，0时表示没有时间限制</span></span>\n  <span class="code-string"><span class="code-string">"maxLifeTimeMS"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>,         <span class="code-comment"><span class="code-comment">// long --单个连接最大存活时间，0时表示灭有时间限制</span></span>\n  <span class="code-string"><span class="code-string">"waitQueueMultiple"</span></span>  : <span class="hljs-number"><span class="hljs-number">500</span></span>,         <span class="code-comment"><span class="code-comment">// int --等待获取连接的排队队列最大数量。</span></span>\n  <span class="code-string"><span class="code-string">"waitQueueTimeoutMS"</span></span> : <span class="hljs-number"><span class="hljs-number">120000</span></span>,      <span class="code-comment"><span class="code-comment">// long --等待获取连接的最大等待时间。</span></span>\n  <span class="code-string"><span class="code-string">"maintenanceFrequencyMS"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>,   <span class="code-comment"><span class="code-comment">// long</span></span>\n  <span class="code-string"><span class="code-string">"maintenanceInitialDelayMS"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="code-comment"><span class="code-comment">// long</span></span>\n\n  <span class="code-comment"><span class="code-comment">// 账户、密码、连接信息</span></span>\n  <span class="code-string"><span class="code-string">"username"</span></span>   : <span class="code-string"><span class="code-string">"john"</span></span>,     <span class="code-comment"><span class="code-comment">// string</span></span>\n  <span class="code-string"><span class="code-string">"password"</span></span>   : <span class="code-string"><span class="code-string">"passw0rd"</span></span>, <span class="code-comment"><span class="code-comment">// string</span></span>\n  <span class="code-string"><span class="code-string">"authSource"</span></span> : <span class="code-string"><span class="code-string">"some.db"</span></span>   <span class="code-comment"><span class="code-comment">// string</span></span>\n  <span class="code-string"><span class="code-string">"authMechanism"</span></span>     : <span class="code-string"><span class="code-string">"GSSAPI"</span></span>,        <span class="code-comment"><span class="code-comment">// string --认证机制相关配置，详情见http://docs.mongodb.org/manual/core/authentication/</span></span>\n  <span class="code-string"><span class="code-string">"gssapiServiceName"</span></span> : <span class="code-string"><span class="code-string">"myservicename"</span></span>, <span class="code-comment"><span class="code-comment">// string --Kerberos单点登录相关接口API配置。</span></span>\n\n  <span class="code-comment"><span class="code-comment">// 联网相关的配置</span></span>\n  <span class="code-string"><span class="code-string">"connectTimeoutMS"</span></span> : <span class="hljs-number"><span class="hljs-number">10000</span></span> , <span class="code-comment"><span class="code-comment">// int // --连接到mongdb数据库实例返回的等待时间</span></span>\n  <span class="code-string"><span class="code-string">"socketTimeoutMS"</span></span>  : <span class="hljs-number"><span class="hljs-number">0</span></span>,    <span class="code-comment"><span class="code-comment">// int // --通过socket完成数据库相关操作的等待与返回时间，0时表示没有限制。</span></span>\n  <span class="code-string"><span class="code-string">"sendBufferSize"</span></span>    : <span class="hljs-number"><span class="hljs-number">0</span></span>,  <span class="code-comment"><span class="code-comment">// int // --设置通过socket发送数据的缓存大小,0时表示使用操作系统默认值。</span></span>\n  <span class="code-string"><span class="code-string">"receiveBufferSize"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>,  <span class="code-comment"><span class="code-comment">// int --设置通过socket获取数据的缓存大小,0时表示使用操作系统默认值。</span></span>\n  <span class="code-string"><span class="code-string">"keepAlive"</span></span> : <span class="hljs-literal"><span class="hljs-literal">false</span></span>       <span class="code-comment"><span class="code-comment">// boolean --设置是否保持数据库连接，默认为false</span></span>\n\n  <span class="code-comment"><span class="code-comment">// 设置集群之间的心跳配置</span></span>\n  <span class="code-string"><span class="code-string">"heartbeat.socket"</span></span> : {\n  <span class="code-string"><span class="code-string">"connectTimeoutMS"</span></span> : <span class="hljs-number"><span class="hljs-number">300000</span></span>, <span class="code-comment"><span class="code-comment">// int </span></span>\n  <span class="code-string"><span class="code-string">"socketTimeoutMS"</span></span>  : <span class="hljs-number"><span class="hljs-number">100000</span></span>, <span class="code-comment"><span class="code-comment">// int</span></span>\n  <span class="code-string"><span class="code-string">"sendBufferSize"</span></span>    : <span class="hljs-number"><span class="hljs-number">8192</span></span>,  <span class="code-comment"><span class="code-comment">// int</span></span>\n  <span class="code-string"><span class="code-string">"receiveBufferSize"</span></span> : <span class="hljs-number"><span class="hljs-number">8192</span></span>,  <span class="code-comment"><span class="code-comment">// int</span></span>\n  <span class="code-string"><span class="code-string">"keepAlive"</span></span> : <span class="hljs-literal"><span class="hljs-literal">true</span></span>           <span class="code-comment"><span class="code-comment">// boolean</span></span>\n  }\n\n  <span class="code-comment"><span class="code-comment">// 设置客户端和mongdb实例的心跳测试</span></span>\n  <span class="code-string"><span class="code-string">"heartbeatFrequencyMS"</span></span> :    <span class="hljs-number"><span class="hljs-number">5000</span></span> <span class="code-comment"><span class="code-comment">// long 集群监视器监控到达每个mongdb实例的心跳频率</span></span>\n  <span class="code-string"><span class="code-string">"minHeartbeatFrequencyMS"</span></span> : <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="code-comment"><span class="code-comment">// long 当前客户端到服务器的监控频率</span></span>\n}</code></pre>\n'}});