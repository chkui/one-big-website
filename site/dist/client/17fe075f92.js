webpackJsonp([17],{389:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<p>笼统的说一个系统主要是由3个部分组成的：</p>\n<ol>\n    <li>执行程序：主要负责处理业务逻辑，对接用户操作。</li>\n    <li>内部数据：嵌套在源码中的数据，用于指导程序运行。</li>\n    <li>外部数据：业务数据，外部配置数据。</li>\n</ol>\n<p>\n    内部数据本身就是程序的一部分，在Java中这些数据通常停留在类的静态成员变量中。而外部数据往往与代码无关，所以对于程序而言要“读懂”它们需要进行一些前置处理。例如用户在前端页面提交的数据我们从RequestContext中获取的数据类型都是字符串，而我们的业务需要将字符串转换成数字、列表、对象等等，这就引入了我们接下来要介绍的内容——数据类型转换。</p>\n<p>JavaBean对于J2SE或者J2EE而言有着非常重要的意义，ORACLE为了统一各个组织对JavaBean的使用方式制定了详尽的JavaBean规范，包括<code><a\n        href="https://docs.oracle.com/javase/8/docs/api/java/beans/BeanInfo.html" target="_blank" rel="nofollow">BeanInfo</a>、<a\n        href="https://docs.oracle.com/javase/8/docs/api/java/beans/PropertyEditor.html" target="_blank" rel="nofollow">PropertyEditor</a>、</code><code><a\n        href="https://docs.oracle.com/javase/8/docs/api/java/beans/PropertyEditorSupport.html" target="_blank"\n        rel="nofollow">PropertyEditorSupport</a></code>等方面的内容。本文会涉及到JavaBean的一些规范，但是重点是介绍Spring的数据管理。</p>\n<p>（可执行代码请到本人gitee库下载，本文的代码在<em>chkui.springcore.example.hybrid.beanmanipulation</em>包）</p>\n\n<h2 id="h2-1">Properties结构转换为实体</h2>\n<p>标准资源文件*.properties是Java程序常用的数据存储文件，Spring提供了BeanWrapper接口将*.properties文件中的数据转换成一个标准的JavaBean对象。看下面的例子：</p>\n<p>有一个实体类Person：</p>\n<pre><code class="java"><span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">Person</span> </span>{\n\t<span class="code-keyword">private</span> String name;\n\t<span class="code-keyword">private</span> <span class="code-keyword">int</span> age;\n\t<span class="code-keyword">private</span> <span class="code-keyword">boolean</span> license;\n\t<span class="code-keyword">private</span> Date birtday;\n\t<span class="code-keyword">private</span> Address address;\n\t<span class="code-keyword">private</span> Map&lt;String, String&gt; otherInfo;\n\n    <span class="code-comment">// Getter &amp; Setter ......</span>\n}\n</code></pre>\n<p>然后可以通过BeanWrapper将Properties对象中的数据设置到对象中：</p>\n<pre><code class="java">   <span class="hljs-function"><span class="code-keyword">private</span> <span\n        class="code-keyword">void</span> <span class="code-title">simpleDataBind</span><span\n        class="hljs-params">()</span> </span>{\n\t\tBeanWrapper wrapper = <span class="code-keyword">new</span> BeanWrapperImpl(<span\n            class="code-keyword">new</span> Person());\n\t\t\n\t\t<span class="code-comment">//使用 BeanWrapper::setPropertyValue 接口设置数据</span>\n\t\twrapper.setPropertyValue(<span class="code-string">"name"</span>, <span class="code-string">"niubility"</span>);\n\t\twrapper.setPropertyValue(<span class="code-string">"age"</span>, <span class="hljs-number">18</span>);\n\t\twrapper.setPropertyValue(<span class="code-string">"license"</span>, <span class="code-keyword">true</span>);\n\t\tprint(wrapper.getWrappedInstance());\n\n\t\t<span class="code-comment">//使用 Properties对象设置数据，Properties实例可以来源于*.properties文件</span>\n\t\tProperties p = <span class="code-keyword">new</span> Properties();\n\t\tp.setProperty(<span class="code-string">"name"</span>, <span class="code-string">"From Properties"</span>);\n\t\tp.setProperty(<span class="code-string">"age"</span>, <span class="code-string">"25"</span>);\n\t\tp.setProperty(<span class="code-string">"license"</span>, <span class="code-string">"false"</span>);\n\t\tp.setProperty(<span class="code-string">"otherInfo[birthday]"</span>, <span\n            class="code-string">"2000-01-01"</span>);\n\t\twrapper.setPropertyValues(p);\n\t\tprint(wrapper.getWrappedInstance());\n\t}</code></pre>\n<p>这样，使用Spring的BeanWrapper接口，可以快速的将Properties数据结构转换为一个JavaBean实体。</p>\n<p>除了配置单个实体的数据，BeanWrapper还可以为嵌套结构的实体设置数据。现在增加一个实体Vehicle：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">Vehicle</span> </span>{\n\t<span class="code-keyword">private</span> String name;\n\t<span class="code-keyword">private</span> String manufacturer;\n\t<span class="code-keyword">private</span> Person person; <span class="code-comment">//Person对象</span>\n\n    <span class="code-comment">// Getter &amp; Setter ......</span>\n\n}</code></pre>\n<p>在Vehicle中有一个Person类型的成员变量（person域），我们可以利用下面具备嵌套结构的语法来设置数据：</p>\n<pre><code class="java">   <span class="hljs-function"><span\n        class="code-keyword">private</span> BeanManipulationApp <span class="code-title">nestedDataBind</span><span\n        class="hljs-params">()</span> </span>{\n\t\t<span class="code-comment">// 数据嵌套转换</span>\n\t\tBeanWrapper wrapper = <span class="code-keyword">new</span> BeanWrapperImpl(<span\n            class="code-keyword">new</span> Vehicle(<span class="code-keyword">new</span> Person()));\n\n\t\tProperties p = <span class="code-keyword">new</span> Properties();\n\t\tp.setProperty(<span class="code-string">"name"</span>, <span class="code-string">"Envision"</span>);\n\t\tp.setProperty(<span class="code-string">"manufacturer"</span>, <span class="code-string">"Buick"</span>);\n\t\t\n\t\t<span class="code-comment">//person.name表示设置person域的name变量数值</span>\n\t\tp.setProperty(<span class="code-string">"person.name"</span>, <span class="code-string">"Alice"</span>);\n\t\tp.setProperty(<span class="code-string">"person.age"</span>, <span class="code-string">"25"</span>);\n\t\tp.setProperty(<span class="code-string">"person.license"</span>, <span class="code-string">"true"</span>);\n\t\tp.setProperty(<span class="code-string">"person.otherInfo[license code]"</span>, <span class="code-string">"123456789"</span>);\n\t\twrapper.setPropertyValues(p);\n\t\tprint(wrapper.getWrappedInstance());\n\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>;\n\t}</code></pre>\n<p>在*.properties文件中，经常使用<em>path.name=param</em>的的语法来指定一个嵌套结构（比如LOG4J的配置文件），这里也使用类似的方式来指定嵌套结构。person.name在程序执行时会调用Vehicle::getPerson::setName方法来设定数据。\n</p>\n<p>除了设定单个数据BeanWrapper还提供了更丰富的方法来设置数据，以上面的Vehicle、person为例：</p>\n<table border="1" cellpadding="1" cellspacing="1" style="width:500px">\n    <tbody>\n    <tr>\n        <th>表达式</th>\n        <th>效果</th>\n    </tr>\n    </tbody>\n    <tbody>\n    <tr>\n        <td><em>p.setProperty("name", "Envision")</em></td>\n        <td>name域的数据设置为"Envision"</td>\n    </tr>\n    <tr>\n        <td><em>p.setProperty("person.name", "Alice")</em></td>\n        <td>将嵌套的person域下的name数据设置为"Alice"</td>\n    </tr>\n    <tr>\n        <td><em>p.setProperty("list[1]", "Step2")</em></td>\n        <td>list域是一个列表，将第二个数据设置为"Step2"</td>\n    </tr>\n    <tr>\n        <td><em>p.setProperty("otherInfo[birthday]", "2000-01-01")</em></td>\n        <td>otherInfo域是一个Map，将key=birthday、value="2000-01-01"的数据添加到Map中。</td>\n    </tr>\n    </tbody>\n</table>\n<p>上面这4条规则可以组合使用，比如<em>p.setProperty("person.otherInfo[license code]", "123456789")。</em></p>\n<p>关于在Java如何使用Properties有很多讨论（<a href="https://stackoverflow.com/questions/70471/no-properties-in-java" target="_blank" rel="nofollow">比如这篇stackoverflow的问答</a>），BeanWrapper不仅仅是针对资源文件，他还衍生扩展了数据类型转换等等功能。\n</p>\n\n<h2 id="h2-2">PropertyEditor转换数据</h2>\n<p>在JavaBean规范中定义了<em>java.beans.PropertyEditor，</em>他的作用简单的说就是将字符串转换为任意对象结构。</p>\n<blockquote>\n    <p>PropertyEditor最早是用来支持java.awt中的可视化接口编辑数据的（详情见<a\n            href="https://docs.oracle.com/javase/tutorial/javabeans/advanced/customization.html" target="_blank" rel="nofollow">Oracle关于IDE数据定制化的介绍</a>）。但是在Spring或其他应用场景中更多的仅仅是用来做字符串到特定数据格式的转换（毕竟java.awt应用不多），所以PropertyEditor提供的BeanWrapper::paintValue之类的支持awt的方法不用太去关心他，主要聚焦在BeanWrapper::setAsText方法上。\n    </p>\n</blockquote>\n<p>BeanWrapper继承了PropertyEditorRegistry接口用于注册PropertyEditor。BeanWrapperImpl已经预设了很多有价值的PropertyEditor，比如上面的例子的代码<em>p.setProperty("age",\n    "25");</em>，age域是一个数字整型，而Properties中的数据都是字符串，在设置数据时会自动启用CustomNumberEditor将字符串转换为数字。</p>\n<p>Spring已经提供的PropertyEditor可以看这里的<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-beans-conversion" target="_blank"\n        rel="nofollow">清单</a>。需要注意的是，这些PropertyEditor并不是每一个都默认启用，比如CustomDateEditor必须由开发者提供DateFormat才能使用，所以需要像下面这样将其添加注册到BeanWrapper中：\n</p>\n<pre><code class="java"><span class="hljs-function"><span class="code-keyword">private</span> <span\n        class="code-keyword">void</span> <span class="code-title">propertyEditor</span><span\n        class="hljs-params">()</span> </span>{\n\tBeanWrapper wrapper = <span class="code-keyword">new</span> BeanWrapperImpl(<span class="code-keyword">new</span> Person());\n\n\t<span class="code-comment">// 设定日期转换格式</span>\n\tDateFormat df = <span class="code-keyword">new</span> java.text.SimpleDateFormat(<span class="code-string">"yyyy-MM-dd"</span>);\n\t\t\n\t<span class="code-comment">// 将Editor与DateFormat进行帮顶，使用指定的格式</span>\n\tCustomDateEditor dateEditor = <span class="code-keyword">new</span> CustomDateEditor(df, <span class="code-keyword">false</span>);\n\t\t\n\t<span class="code-comment">// 注册dateEditor，将其与Date类进行绑定</span>\n\twrapper.registerCustomEditor(Date.class, dateEditor);\n\n\t<span class="code-comment">// CustomNumberEditor执行转换</span>\n\twrapper.setPropertyValue(<span class="code-string">"age"</span>, <span class="code-string">"18"</span>);\n\t<span class="code-comment">// CustomBooleanEditor执行转换</span>\n\twrapper.setPropertyValue(<span class="code-string">"license"</span>, <span class="code-string">"false"</span>);\n\t<span class="code-comment">// dateEditor执行转换</span>\n\twrapper.setPropertyValue(<span class="code-string">"birtday"</span>, <span class="code-string">"1999-01-30"</span>);\n\tprint(wrapper.getWrappedInstance());\n}</code></pre>\n<p>添加之后，设定<em>setPropertyValue("birtday", "1999-01-30")</em>时会自动使用指定的DateFormat转换日期。</p>\n\n<h2 id="h2-3">自定义PropertyEditor</h2>\n<p>除了预设的各种PropertyEditor，我们还可以开发自定义的PropertyEditor。Person中有一个类型为Address的成员变量：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">Address</span> </span>{\n\t<span class="code-keyword">private</span> String province; <span class="code-comment">//省</span>\n\t<span class="code-keyword">private</span> String city;  <span class="code-comment">//市</span>\n\t<span class="code-keyword">private</span> String district;  <span class="code-comment">//区</span>\n\n    <span class="code-comment">// Getter &amp; Setter</span>\n}</code></pre>\n<p>我们为Address实体添加一个PropertyEditor，将特定格式的字符串转换为Address结构：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">AddressEditor</span> <span class="code-keyword">extends</span> <span class="code-title">PropertyEditorSupport</span> </span>{\n\t<span class="code-keyword">private</span> String[] SPLIT_FLAG = { <span class="code-string">","</span>, <span\n            class="code-string">"-"</span>, <span class="code-string">";"</span>, <span class="code-string">":"</span> };\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setAsText</span><span class="hljs-params">(String text)</span> </span>{\n\t\t<span class="code-keyword">int</span> pos = -<span class="hljs-number">1</span>;\n\t\tAddress address = <span class="code-keyword">new</span> Address();\n\t\t<span class="code-keyword">for</span> (String flag : SPLIT_FLAG) {\n\t\t\tpos = text.indexOf(flag);\n\t\t\t<span class="code-keyword">if</span> (-<span class="hljs-number">1</span> &lt; pos) {\n\t\t\t\tString[] split = text.split(flag);\n\t\t\t\taddress.setProvince(split[<span class="hljs-number">0</span>]);\n\t\t\t\taddress.setCity(split[<span class="hljs-number">1</span>]);\n\t\t\t\taddress.setDistrict(split[<span class="hljs-number">2</span>]);\n\t\t\t\t<span class="code-keyword">break</span>;\n\t\t\t}\n\t\t}\n\t\t<span class="code-keyword">if</span> (-<span class="hljs-number">1</span> == pos) {\n\t\t\t<span class="code-keyword">throw</span> <span class="code-keyword">new</span> IllegalArgumentException(<span\n            class="code-string">"地址格式错误"</span>);\n\t\t}\n\t\tsetValue(address);<span class="code-comment">//设定Address实例</span>\n\t}\n}</code></pre>\n<p>\n    通过AddressEditor::setAsText方法，可以将输入的字符串最红转换为一个Address实例。通常情况下开发一个Editor转换器不会直接去实现PropertyEditor接口，而是继承PropertyEditorSupport。</p>\n<p>然后我们使用AddressEditor来将字符串转换为Address对象：</p>\n<pre><code class="java"><span class="hljs-function"><span class="code-keyword">private</span> BeanManipulationApp <span\n        class="code-title">propertyEditor</span><span class="hljs-params">()</span> </span>{\n\t<span class="code-comment">//使用预设转换工具和自定义转换工具</span>\n\tBeanWrapper wrapper = <span class="code-keyword">new</span> BeanWrapperImpl(<span class="code-keyword">new</span> Person());\n\n\t<span class="code-comment">// 创建AddressEditor实例</span>\n\tAddressEditor addressEditor = <span class="code-keyword">new</span> AddressEditor();\n\t\t\n\t<span class="code-comment">// 注册addressEditor，将其与Address类进行绑定</span>\n\twrapper.registerCustomEditor(Address.class, addressEditor);\n\n    <span class="code-comment">// 设置值自动进行转化</span>\n\twrapper.setPropertyValue(<span class="code-string">"address"</span>, <span class="code-string">"广东-广州-白云"</span>);\n\tprint(wrapper.getWrappedInstance());\n}</code></pre>\n<p>按照JavaBean规范，PropertyEditor和对应的JavaBean可以使用命名规则来表示绑定关系，而无需显式的调用注册方法。</p>\n<p>\n    绑定的规则是：有一个JavaBean命名为Tyre，在相同的包下（package）有一个实现了PropertyEditor接口并且命名为TyreEditor的类，那么框架认为TyreEditor就是Tyre的Editor，无需调用BeanWrapper::registerCustomEditor方法来声明Tyre和TyreEditor的绑定关系，详情请看源码中chkui.springcore.example.hybrid.beanmanipulation.bean.Tyre的使用。</p>\n\n<h2 id="h2-4">IoC与数据转换整合</h2>\n<p>对于Spring的ApplicationContext而言，BeanWrapper、PropertyEditor都是相对比较底层的功能，在使用Spring\n    Ioc容器的时候可以直接将这些功能嵌入到Bean初始化中或MVC的requestContext的数据转换中。</p>\n<p>从框架使用者的角度来看，Spring的XML配置数据或者通过MVC接口传递数据都是字符串，因此PropertyEditor在处理这些数据时有极大的用武之地。IoC容器使用<a\n        href="https://www.chkui.com/article/spring/spring_core_bean_post_processors" title="IOC处理器扩展">后置处理器</a>CustomEditorConfigurer来管理Bean初始化相关的PropertyEditor。通过CustomEditorConfigurer可以使用所有预设的Editor，还可以增加自定义的Editor，下面是使用@Configurable启用CustomEditorConfigurer的例子：\n</p>\n<pre><code class="java"><span class="code-meta">@Configurable</span>\n<span class="code-meta">@ImportResource</span>(<span\n            class="code-string">"classpath:hybrid/beanmanipulation/config.xml"</span>)\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">BeanManipulationConfig</span> </span>{\n\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function">CustomEditorConfigurer <span class="code-title">customEditorConfigurer</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-comment">// 构建CustomEditorConfigurer</span>\n\t\tCustomEditorConfigurer configurer = <span class="code-keyword">new</span> CustomEditorConfigurer();\n\t\t\n\t\tMap&lt;Class&lt;?&gt;, Class&lt;? extends PropertyEditor&gt;&gt; customEditors = <span\n            class="code-keyword">new</span> HashMap&lt;&gt;();\n\t\t\n\t\t<span class="code-comment">// 添加AddressEditor和Address的绑定</span>\n\t\tcustomEditors.put(Address.class, AddressEditor.class);\n\t\t\n\t\t<span class="code-comment">// 添加绑定列表</span>\n\t\tconfigurer.setCustomEditors(customEditors);\n\t\t\n\t\t<span class="code-comment">// 通过PropertyEditorRegistrar注册PropertyEditor</span>\n\t\tconfigurer.setPropertyEditorRegistrars(<span class="code-keyword">new</span> PropertyEditorRegistrar[] { <span\n            class="code-keyword">new</span> DateFormatRegistrar() });\n\t\t<span class="code-keyword">return</span> configurer;\n\t}\n}</code></pre>\n<p><em>CustomEditorConfigurer::setCustomEditors</em>和<em>CustomEditorConfigurer::setPropertyEditorRegistrars</em>都可以向容器中添加PropertyEditor，最主要区别在于：\n</p>\n<ol>\n    <li>前者是直接申明一对绑定关系的类对象（Class&lt;?&gt;），例如<em>customEditors.put(Address.class, AddressEditor.class);</em>\n        这行代码并没有实例化AddressEditor，而是将实例化交给后置处理器。\n    </li>\n    <li>\n        而后者是提供一个实例化的PropertyEditor，比前者更能实现更复杂的功能。比如下面的DateFormatRegistrar代码，由于需要组装DateFormat和CustomDateEditor，所以使用PropertyEditorRegistrar来实现这个过程更加合理，后置处理器会在某个时候调用这个注册方法。\n    </li>\n</ol>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">DateFormatRegistrar</span> <span class="code-keyword">implements</span> <span\n        class="code-title">PropertyEditorRegistrar</span> </span>{\n\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">registerCustomEditors</span><span\n            class="hljs-params">(PropertyEditorRegistry registry)</span> </span>{\n\t\tDateFormat df = <span class="code-keyword">new</span> java.text.SimpleDateFormat(<span class="code-string">"yyyy-MM-dd"</span>);\n\t\tCustomDateEditor editor = <span class="code-keyword">new</span> CustomDateEditor(df, <span class="code-keyword">false</span>);\n\t\tregistry.registerCustomEditor(Date.class, editor);\n\t}\n}</code></pre>\n<p>配置好CustomEditorConfigurer之后，就可以直接在配置Bean的时候直接使用预定的格式了，比如：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span>&gt;</span>\n\t<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n            class="code-string">"person"</span> <span class="hljs-attr">class</span>=<span class="code-string">"chkui.springcore.example.hybrid.beanmanipulation.bean.Person"</span>&gt;</span>\n\t\t<span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"name"</span> <span class="hljs-attr">value</span>=<span\n                class="code-string">"XML"</span> /&gt;</span>\n\t\t<span class="code-comment">&lt;!-- 使用CustomNumberEditor转换 --&gt;</span>\n\t\t<span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"age"</span> <span class="hljs-attr">value</span>=<span\n                class="code-string">"20"</span> /&gt;</span>\n\t\t<span class="code-comment">&lt;!-- 使用CustomBooleanEditor转换 --&gt;</span>\n\t\t<span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"license"</span> <span class="hljs-attr">value</span>=<span\n                class="code-string">"1"</span> /&gt;</span>\n\t\t<span class="code-comment">&lt;!-- 使用CustomDateEditor转换 --&gt;</span>\n\t\t<span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"birtday"</span> <span class="hljs-attr">value</span>=<span class="code-string">"1998-12-30"</span> /&gt;</span>\n\t\t<span class="code-comment">&lt;!-- 使用AddressEditor转换 --&gt;</span>\n\t\t<span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"address"</span> <span class="hljs-attr">value</span>=<span class="code-string">"广东,深圳,南山"</span> /&gt;</span>\n\t<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n\t\n\t<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"chkui.springcore.example.hybrid.beanmanipulation.bean.Vehicle"</span>&gt;</span>\n\t\t<span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"name"</span> <span class="hljs-attr">value</span>=<span class="code-string">"Mercedes-Benz C-Class"</span> /&gt;</span>\n\t\t<span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"manufacturer"</span> <span class="hljs-attr">value</span>=<span\n                class="code-string">"Mercedes-Benz"</span> /&gt;</span>\n\t\t<span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"person"</span> <span class="hljs-attr">ref</span>=<span class="code-string">"person"</span> /&gt;</span>\n\t<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>此外，在Spring MVC中，可以SimpleFormController::initBinder方法将外部传入的数据和某个Bean进行绑定：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="code-keyword">final</span> <span\n        class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MyController</span> <span\n        class="code-keyword">extends</span> <span class="code-title">SimpleFormController</span> </span>{\n\n    <span class="code-comment">// 通过任何方式获取PropertyEditorRegistrar</span>\n    <span class="code-meta">@Autowired</span>\n    <span class="code-keyword">private</span> MyPropertyEditorRegistrar editorRegistrar;\n\n    <span class="hljs-function"><span class="code-keyword">protected</span> <span class="code-keyword">void</span> <span\n            class="code-title">initBinder</span><span class="hljs-params">(HttpServletRequest request,\n            ServletRequestDataBinder binder)</span> <span class="code-keyword">throws</span> Exception </span>{\n        <span class="code-comment">// 将Editor与当前Controller进行绑定</span>\n        <span class="code-keyword">this</span>.editorRegistrar.registerCustomEditors(binder);\n    }\n}</code></pre>\n<p>Spring MVC并不属于Sring核心功能范畴，这里就不展开了，需要了解的话看看SimpleFormController的JavaDoc文档即可。</p>\n'},408:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<h2 id="h2-1"><span style="font-family:微软雅黑,microsoft yahei">调用堆栈</span></h2>\n<p><em>&nbsp;&nbsp;&nbsp;&nbsp;io.vertx.ext.mongo.impl.MongoClientImpl；</em></p>\n<p><em>&nbsp;&nbsp;&nbsp;&nbsp;io.vertx.ext.mongo.impl.MongoHolder;</em></p>\n<p><em>&nbsp;&nbsp;&nbsp;&nbsp;io.vertx.ext.mongo.impl.config.MongoClientOptionsParser;</em></p>\n\n<h2 id="h2-2">实现过程</h2>\n<p>当调用<em>MongoClient::createShared()</em>或<em>MongoClient::createNonShared()</em>方法创建<em>mongo</em>的客户端时，最终都会调用到<em>MongoClientImpl</em>的构造函数。</p>\n<pre class="kotlin"><code class="language-java"> <span class="hljs-function"><span class="code-keyword"><span class="code-keyword">public</span></span> <span class="code-title">MongoClientImpl</span><span class="hljs-params">(Vertx vertx, JsonObject config, String dataSourceName)</span> </span>{\n    Objects.requireNonNull(vertx);\n    Objects.requireNonNull(config);\n    Objects.requireNonNull(dataSourceName);\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.vertx = vertx;\n    <span class="code-comment"><span class="code-comment">// 检查或创建新的MongHolder</span></span>\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.holder = lookupHolder(dataSourceName, config);\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.mongo = holder.mongo();\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.useObjectId = config.getBoolean(<span class="code-string"><span class="code-string">"useObjectId"</span></span>, <span class="code-keyword"><span class="hljs-literal">false</span></span>);\n  }</code></pre>\n<p>如果是通过<em>createNonShared</em>方法创建client时，这里传入的<em>dataSourceName</em>是一个UUID。当使用<em>createShared</em>创建<em>client</em>,会在<em>lookupHolder</em>方法中检查是否已经创建了同名的客户端，否则新建。</p>\n<p>下图是检查数据源的过程。会根据传入的&nbsp;<em>datasourceName </em>从 <em>vertx </em>实例的共享数据实例（<em>io.vertx.core.shareddata.SharedData</em>）中获取同名的 <em>MongoHolder </em>实例。</p>\n<pre class="cpp"><code class="language-java"> <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">private</span></span></span><span class="hljs-function"> MongoHolder </span><span class="code-title"><span class="hljs-function"><span class="code-title">lookupHolder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String datasourceName, JsonObject config)</span></span></span><span class="hljs-function"> </span></span>{\n    <span class="code-keyword">synchronized</span> (vertx) {\n      <span class="code-comment"><span class="code-comment">// 获取共享数据实例中的map</span></span>\n      LocalMap&lt;String, MongoHolder&gt; <span class="code-built_in">map</span> = vertx.sharedData().getLocalMap(DS_LOCAL_MAP_NAME);\n\n      <span class="code-comment"><span class="code-comment">// 检查datasourceName对应的MongoHolder 是否存在</span></span>\n      MongoHolder theHolder = <span class="code-built_in">map</span>.get(datasourceName);\n\n      <span class="code-comment"><span class="code-comment">// 不存在则新构建，并将构建的结果放入sharedData的map中</span></span>\n      <span class="code-keyword"><span class="code-keyword">if</span></span> (theHolder == <span class="code-keyword">null</span>) {\n        theHolder = <span class="code-keyword"><span class="code-keyword">new</span></span> MongoHolder(config, () -&gt; removeFromMap(<span class="code-built_in">map</span>, datasourceName));\n        <span class="code-built_in">map</span>.put(datasourceName, theHolder);\n      } <span class="code-keyword"><span class="code-keyword">else</span></span> {\n        <span class="code-comment"><span class="code-comment">// 递增被引用的计数</span></span>\n        theHolder.incRefCount();\n      }\n      <span class="code-keyword"><span class="code-keyword">return</span></span> theHolder;\n    }\n  }</code></pre>\n<p>如果实例不存在，则会创建新的&nbsp;<em>MongoHolder </em>实例。<span style="color:#FF8C00">个人认为这里有个很不完美的地方是为了解决懒汉模式的问题，增加了一个线程锁。在高并发请求数据库连接资源时，这里会有阻塞。因此我在自己的实现类中存储了MongoClient的实例。不过这个线程锁可以有效减少数据库连接池的爆发式增长，在数据库连接池资源较少的情况下，有不错的效果（比如我们某个项目使用了阿里云的mongDB，最低配置只有200个连接）</span>。</p>\n<p>下图是&nbsp;<em>MongoHolder </em>的构造方法。</p>\n<pre class="kotlin"><code class="language-java"><span class="hljs-function"><span class="code-keyword"><span class="code-keyword">public</span></span> <span class="code-title">MongoHolder</span><span class="hljs-params">(JsonObject config, Runnable closeRunner)</span> </span>{\n      <span class="code-keyword"><span class="code-keyword">this</span></span>.config = config;\n      <span class="code-keyword"><span class="code-keyword">this</span></span>.closeRunner = closeRunner;\n    }</code></pre>\n<p><em>&nbsp;&nbsp;&nbsp;&nbsp;MongoHolder&nbsp;</em>构造方法只是简单的设置了成员变量 <em>config&nbsp;</em>和 <em>closeRunner </em>的值。<em>closeRunner</em>当调用<em>MongoClient::close()</em>方法时，用于回调销毁<em>SharedData::localMap</em>中的对应索引数据。<em>config </em>是用户传入的配置参数，需要注意的是，<em>config </em>传递到这里一直没有被改变。</p>\n<p>创建&nbsp;<em>MongoHolder&nbsp;</em>的实例成功后，接下来会调用&nbsp;<em>MongoHolder::mongo() </em>来创建一个真正&nbsp;<em>com.mongodb.async.client.MongoClient</em> 实例。这里同样使用了懒汉模式，存在线程锁，如果MongoClient的实例存在直接返回，如果不存在，则新建一个实例。</p>\n<pre class="java"><code class="language-java"><span class="code-keyword"><span class="code-keyword">synchronized</span></span> com.mongodb.async.client.<span class="hljs-function"><span class="hljs-function">MongoClient </span><span class="code-title"><span class="hljs-function"><span class="code-title">mongo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{\n      <span class="code-keyword"><span class="code-keyword">if</span></span> (mongo == <span class="code-keyword"><span class="code-keyword">null</span></span>) {\n        <span class="code-comment"><span class="code-comment">// 解析外部传递的config</span></span>\n        MongoClientOptionsParser parser = <span class="code-keyword"><span class="code-keyword">new</span></span> MongoClientOptionsParser(config);\n\n        <span class="code-comment"><span class="code-comment">// 将解析结果用于创建新的com.mongodb.async.client.MongoClient实例</span></span>\n        mongo = MongoClients.create(parser.settings());\n        String dbName = config.getString(<span class="code-string"><span class="code-string">"db_name"</span></span>, DEFAULT_DB_NAME);\n        db = mongo.getDatabase(dbName);\n      }\n      <span class="code-keyword"><span class="code-keyword">return</span></span> mongo;\n    }</code></pre>\n<p><em>&nbsp;&nbsp;&nbsp;&nbsp;MongoClientOptionsParser 对象</em>是创建Mongo客户端的关键，他会解析用户传递的参数来创建mongDB客户端，理解他的解析方法有利于创建合适的客户端。</p>\n<p><em>&nbsp;&nbsp;&nbsp;&nbsp;MongoClientOptionsParser </em>的构造方法共有60行，这里分几段说明。为了更好的理解创建过程，建议了解下<a title="MongoDB异步Java驱动" href="http://mongodb.github.io/mongo-java-driver/3.2/driver-async" rel="nofollow">MongoDB异步Java驱动</a>。下面的构造客户端参数的第一部分。</p>\n<pre class="gradle"><code class="language-java"> <span class="hljs-function"><span class="code-keyword"><span class="code-keyword">public</span></span> <span class="code-title">MongoClientOptionsParser</span><span class="hljs-params">(JsonObject config)</span> </span>{\n    Objects.requireNonNull(config);\n    \n    <span class="code-comment"><span class="code-comment">// 创建mongoDB的构建对象</span></span>\n    MongoClientSettings.Builder <span class="code-keyword">options</span> = MongoClientSettings.builder();\n\n    <span class="code-comment"><span class="code-comment">// 注册对象数据的存储规则</span></span>\n    <span class="code-keyword">options</span>.codecRegistry(CodecRegistries.fromRegistries(commonCodecRegistry, CodecRegistries.fromCodecs(<span class="code-keyword"><span class="code-keyword">new</span></span> JsonObjectCodec(config))));\n\n    <span class="code-comment"><span class="code-comment">// 获取连接串，所有的定义参数都来自连接串</span></span>\n    String cs = config.getString(<span class="code-string"><span class="code-string">"connection_string"</span></span>);\n\n    <span class="code-comment"><span class="code-comment">// 解析连接串</span></span>\n    ConnectionString connectionString = (cs == <span class="code-keyword"><span class="code-keyword">null</span></span>) ? <span class="code-keyword"><span class="code-keyword">null</span></span> : <span class="code-keyword"><span class="code-keyword">new</span></span> ConnectionString(cs);\n\n    <span class="code-comment"><span class="code-comment">// 解析集群参数</span></span>\n    ClusterSettings clusterSettings = <span class="code-keyword"><span class="code-keyword">new</span></span> ClusterSettingsParser(connectionString, config).settings();\n    <span class="code-keyword">options</span>.clusterSettings(clusterSettings);\n\n    <span class="code-comment"><span class="code-comment">// 解析连接池参数</span></span>\n    ConnectionPoolSettings connectionPoolSettings = <span class="code-keyword"><span class="code-keyword">new</span></span> ConnectionPoolSettingsParser(connectionString, config).settings();\n    <span class="code-keyword">options</span>.connectionPoolSettings(connectionPoolSettings);\n\n    <span class="code-comment"><span class="code-comment">// some code</span></span>\n}</code></pre>\n<p>首先创建&nbsp;<em>MongoClientSettings </em>的构造对象。</p>\n<p>然后根据传递的参数构建&nbsp;<em>CodecRegistry </em>实例。<em>CodecRegistry </em>的说明见 <a title="mongDB官网CodecRegistry的API说明" href="http://api.mongodb.com/java/3.2/?com/mongodb/async/client/MongoClientSettings.html" rel="nofollow">mongDB官网CodecRegistry的API说明</a>。<em>CodecRegistry 用于指定相关的对象在mongoDB的读写实现类，</em>例如官方已经源生实现了<em>&nbsp;StringCodec、IntegerCodec</em>来处理Java的<em>String、Integer</em>对象<em>。</em></p>\n<p>这段代码的最后部分，创建一个&nbsp;<em>ConnectionString&nbsp;</em>实例来分解和存储连接串的解析结果。<em>ConnectionString </em>是&nbsp;<em>mongoDB&nbsp;</em>官方实现的解析连接串参数方法<em>。</em>可以将http协议串解析成对应的初始化参数，例如设置连接池最小连接数为20，最大连接数为200：&nbsp;<span style="color:#FF8C00"><em>mongodb://host:27017/?minPoolSize=20&amp;maxPoolSize=200 </em></span>。详细说明见&nbsp;<a title="ConnectionString API" href="http://api.mongodb.com/java/3.2/?com/mongodb/ConnectionString.html" rel="nofollow"><em>ConnectionString&nbsp;</em>的API文档</a> &nbsp;和 <a title="mongoDB官方指引手册" href="http://mongodb.github.io/mongo-java-driver/3.2/driver-async/reference/connecting/connection-settings/" rel="nofollow">mongoDB官方指引手册</a>&nbsp;。</p>\n<p>下面的代码是&nbsp;<em>ClusterSettingsParser&nbsp;</em>对传入的数据进行解析，<em>vertx-mongdb</em>解析连接参数都是采用类似的思路：优先使用mongodb源生连接串中指定的参数，如果参数不存在，则使用用户传入的参数。因此，在我们设计mongodb的连接参数时，可以在传入的JsonObject实例中统一在key="connection_string"的参数中一次性制定mongdb风格的连接字符串，还可以在这个实例中通过key值设置vertx风格的各种连接参数。如果2个参数都存在，则优先使用连接字符串。</p>\n<pre class="java"><code class="java"><span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">public</span></span></span><span class="hljs-function"> </span><span class="code-title"><span class="hljs-function"><span class="code-title">ClusterSettingsParser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ConnectionString connectionString, JsonObject config)</span></span></span><span class="hljs-function"> </span></span>{\n\n    <span class="code-comment"><span class="code-comment">// 创建mongdb集群builder方法</span></span>\n    ClusterSettings.Builder settings = ClusterSettings.builder();\n\n    <span class="code-comment"><span class="code-comment">// 优先从连接字符串中使用mongdb源生方法解析相关参数 </span></span>\n    <span class="code-keyword"><span class="code-keyword">if</span></span> (connectionString != <span class="code-keyword"><span class="code-keyword">null</span></span>) {\n      settings.applyConnectionString(connectionString);\n    } <span class="code-keyword"><span class="code-keyword">else</span></span> {\n      <span class="code-comment"><span class="code-comment">// 如果连接字符串中相关的参数不存在，则从用户传入的config中提取指定的数据</span></span>\n      <span class="code-comment"><span class="code-comment">// 设置host列表</span></span>\n      <span class="code-comment"><span class="code-comment">// 在parseHosts中优先解析config是否存在包含key=hosts的JsonArray实例，如果有则会即系多个连接服务器</span></span>\n      <span class="code-comment"><span class="code-comment">// 如果没有key=hosts，则解析host和port是否存在</span></span>\n      List&lt;ServerAddress&gt; hosts = parseHosts(config);\n      settings.hosts(hosts);\n\n      <span class="code-comment"><span class="code-comment">// 设置mongdb的运行模式和replica模式</span></span>\n      String replicaSet = config.getString(<span class="code-string"><span class="code-string">"replicaSet"</span></span>);\n      <span class="code-keyword"><span class="code-keyword">if</span></span> (hosts.size() == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; replicaSet == <span class="code-keyword"><span class="code-keyword">null</span></span>) {\n        settings.mode(ClusterConnectionMode.SINGLE);\n      } <span class="code-keyword"><span class="code-keyword">else</span></span> {\n        settings.mode(ClusterConnectionMode.MULTIPLE);\n      }\n      <span class="code-keyword"><span class="code-keyword">if</span></span> (replicaSet != <span class="code-keyword"><span class="code-keyword">null</span></span>) {\n        settings.requiredReplicaSetName(replicaSet);\n      }\n    }\n\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.settings = settings.build();\n  }</code></pre>\n<p>这里就不一一说明每一个解析方法，基本上都是一样的套路。</p>\n<p>解析完连接参数后，用这些参数直接调用<em>MongoClients::create</em>来创建mongdb的客户端实例。然后从客户端从获取mongodb的连接。</p>\n\n<h2 id="h2-3"><span style="font-family:微软雅黑,microsoft yahei">总结</span></h2>\n<p>至此，mongdb的创建过程完毕。在创建的过程中，可以实现mongdb源生的连接串，也可以使用vertx风格的JsonObject。mongdb自身已经实现了全异步接口，因此vertx-mongdb只是在此基础上进行了一层封装。下面的附表是vertx-mongdb相关的设置参数。可以在建立vertx-mongdb实例时，通过JsonObject传入。</p>\n<pre class="actionscript"><code class="actionscript">{\n  <span class="code-comment"><span class="code-comment">// 设置单个mongdb服务时使用host、port指定主机和端口</span></span>\n  <span class="code-string"><span class="code-string">"host"</span></span> : <span class="code-string"><span class="code-string">"17.0.0.1"</span></span>, <span class="code-comment"><span class="code-comment">// string --mongdb实例所在的地址</span></span>\n  <span class="code-string"><span class="code-string">"port"</span></span> : <span class="hljs-number"><span class="hljs-number">27017</span></span>,      <span class="code-comment"><span class="code-comment">// int --mongdb实例的端口号</span></span>\n\n  <span class="code-comment"><span class="code-comment">// 设置集群mongdb服务器时使用队列</span></span>\n  <span class="code-string"><span class="code-string">"hosts"</span></span> : [\n    {\n      <span class="code-string"><span class="code-string">"host"</span></span> : <span class="code-string"><span class="code-string">"cluster1"</span></span>, <span class="code-comment"><span class="code-comment">// string --集群1地址</span></span>\n      <span class="code-string"><span class="code-string">"port"</span></span> : <span class="hljs-number"><span class="hljs-number">27000</span></span>       <span class="code-comment"><span class="code-comment">// int --集群1端口号</span></span>\n    },\n    {\n      <span class="code-string"><span class="code-string">"host"</span></span> : <span class="code-string"><span class="code-string">"cluster2"</span></span>, <span class="code-comment"><span class="code-comment">// string --集群2地址</span></span>\n      <span class="code-string"><span class="code-string">"port"</span></span> : <span class="hljs-number"><span class="hljs-number">28000</span></span>       <span class="code-comment"><span class="code-comment">// int --集群2端口号</span></span>\n    },\n    ...\n  ],\n\n  <span class="code-comment"><span class="code-comment">// 数据库分布式方法</span></span>\n  <span class="code-string"><span class="code-string">"replicaSet"</span></span> :  <span class="code-string"><span class="code-string">"foo"</span></span>    <span class="code-comment"><span class="code-comment">// string</span></span>\n\n  <span class="code-comment"><span class="code-comment">// 连接池参数</span></span>\n  <span class="code-string"><span class="code-string">"maxPoolSize"</span></span> : <span class="hljs-number"><span class="hljs-number">100</span></span>,                <span class="code-comment"><span class="code-comment">// int --最大连接数</span></span>\n  <span class="code-string"><span class="code-string">"minPoolSize"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>,                <span class="code-comment"><span class="code-comment">// int --最小连接数</span></span>\n  <span class="code-string"><span class="code-string">"maxIdleTimeMS"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>,          <span class="code-comment"><span class="code-comment">// long --单个连接空闲释放时间，0时表示没有时间限制</span></span>\n  <span class="code-string"><span class="code-string">"maxLifeTimeMS"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>,         <span class="code-comment"><span class="code-comment">// long --单个连接最大存活时间，0时表示灭有时间限制</span></span>\n  <span class="code-string"><span class="code-string">"waitQueueMultiple"</span></span>  : <span class="hljs-number"><span class="hljs-number">500</span></span>,         <span class="code-comment"><span class="code-comment">// int --等待获取连接的排队队列最大数量。</span></span>\n  <span class="code-string"><span class="code-string">"waitQueueTimeoutMS"</span></span> : <span class="hljs-number"><span class="hljs-number">120000</span></span>,      <span class="code-comment"><span class="code-comment">// long --等待获取连接的最大等待时间。</span></span>\n  <span class="code-string"><span class="code-string">"maintenanceFrequencyMS"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>,   <span class="code-comment"><span class="code-comment">// long</span></span>\n  <span class="code-string"><span class="code-string">"maintenanceInitialDelayMS"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="code-comment"><span class="code-comment">// long</span></span>\n\n  <span class="code-comment"><span class="code-comment">// 账户、密码、连接信息</span></span>\n  <span class="code-string"><span class="code-string">"username"</span></span>   : <span class="code-string"><span class="code-string">"john"</span></span>,     <span class="code-comment"><span class="code-comment">// string</span></span>\n  <span class="code-string"><span class="code-string">"password"</span></span>   : <span class="code-string"><span class="code-string">"passw0rd"</span></span>, <span class="code-comment"><span class="code-comment">// string</span></span>\n  <span class="code-string"><span class="code-string">"authSource"</span></span> : <span class="code-string"><span class="code-string">"some.db"</span></span>   <span class="code-comment"><span class="code-comment">// string</span></span>\n  <span class="code-string"><span class="code-string">"authMechanism"</span></span>     : <span class="code-string"><span class="code-string">"GSSAPI"</span></span>,        <span class="code-comment"><span class="code-comment">// string --认证机制相关配置，详情见http://docs.mongodb.org/manual/core/authentication/</span></span>\n  <span class="code-string"><span class="code-string">"gssapiServiceName"</span></span> : <span class="code-string"><span class="code-string">"myservicename"</span></span>, <span class="code-comment"><span class="code-comment">// string --Kerberos单点登录相关接口API配置。</span></span>\n\n  <span class="code-comment"><span class="code-comment">// 联网相关的配置</span></span>\n  <span class="code-string"><span class="code-string">"connectTimeoutMS"</span></span> : <span class="hljs-number"><span class="hljs-number">10000</span></span> , <span class="code-comment"><span class="code-comment">// int // --连接到mongdb数据库实例返回的等待时间</span></span>\n  <span class="code-string"><span class="code-string">"socketTimeoutMS"</span></span>  : <span class="hljs-number"><span class="hljs-number">0</span></span>,    <span class="code-comment"><span class="code-comment">// int // --通过socket完成数据库相关操作的等待与返回时间，0时表示没有限制。</span></span>\n  <span class="code-string"><span class="code-string">"sendBufferSize"</span></span>    : <span class="hljs-number"><span class="hljs-number">0</span></span>,  <span class="code-comment"><span class="code-comment">// int // --设置通过socket发送数据的缓存大小,0时表示使用操作系统默认值。</span></span>\n  <span class="code-string"><span class="code-string">"receiveBufferSize"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>,  <span class="code-comment"><span class="code-comment">// int --设置通过socket获取数据的缓存大小,0时表示使用操作系统默认值。</span></span>\n  <span class="code-string"><span class="code-string">"keepAlive"</span></span> : <span class="hljs-literal"><span class="hljs-literal">false</span></span>       <span class="code-comment"><span class="code-comment">// boolean --设置是否保持数据库连接，默认为false</span></span>\n\n  <span class="code-comment"><span class="code-comment">// 设置集群之间的心跳配置</span></span>\n  <span class="code-string"><span class="code-string">"heartbeat.socket"</span></span> : {\n  <span class="code-string"><span class="code-string">"connectTimeoutMS"</span></span> : <span class="hljs-number"><span class="hljs-number">300000</span></span>, <span class="code-comment"><span class="code-comment">// int </span></span>\n  <span class="code-string"><span class="code-string">"socketTimeoutMS"</span></span>  : <span class="hljs-number"><span class="hljs-number">100000</span></span>, <span class="code-comment"><span class="code-comment">// int</span></span>\n  <span class="code-string"><span class="code-string">"sendBufferSize"</span></span>    : <span class="hljs-number"><span class="hljs-number">8192</span></span>,  <span class="code-comment"><span class="code-comment">// int</span></span>\n  <span class="code-string"><span class="code-string">"receiveBufferSize"</span></span> : <span class="hljs-number"><span class="hljs-number">8192</span></span>,  <span class="code-comment"><span class="code-comment">// int</span></span>\n  <span class="code-string"><span class="code-string">"keepAlive"</span></span> : <span class="hljs-literal"><span class="hljs-literal">true</span></span>           <span class="code-comment"><span class="code-comment">// boolean</span></span>\n  }\n\n  <span class="code-comment"><span class="code-comment">// 设置客户端和mongdb实例的心跳测试</span></span>\n  <span class="code-string"><span class="code-string">"heartbeatFrequencyMS"</span></span> :    <span class="hljs-number"><span class="hljs-number">5000</span></span> <span class="code-comment"><span class="code-comment">// long 集群监视器监控到达每个mongdb实例的心跳频率</span></span>\n  <span class="code-string"><span class="code-string">"minHeartbeatFrequencyMS"</span></span> : <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="code-comment"><span class="code-comment">// long 当前客户端到服务器的监控频率</span></span>\n}</code></pre>\n'}});