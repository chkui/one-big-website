webpackJsonp([2],{342:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<p>本文将一点一滴的累计记录Java中的一些细节知识。不只是加以说明，而是所有的细节都找到来源，以官方文档、知名社区的介绍为主。</p>\n<h2 id="h2-1"><strong>StringTokenizer和String.split</strong></h2>\n<pre class="gradle"><code class="gradle">&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-comment"><span class="code-comment">//Use&nbsp;StringTokenizer&nbsp;</span></span>\n&nbsp;&nbsp;&nbsp;&nbsp;StringTokenizer&nbsp;st&nbsp;=&nbsp;<span class="code-keyword"><span\n            class="code-keyword">new</span></span>&nbsp;StringTokenizer(<span class="code-string"><span\n            class="code-string">"this&nbsp;is&nbsp;a&nbsp;test"</span></span>);\n&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-keyword"><span class="code-keyword">while</span></span>&nbsp;(st.hasMoreTokens())&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.<span class="code-keyword"><span\n            class="code-keyword">println</span></span>(st.nextToken());\n&nbsp;&nbsp;&nbsp;&nbsp;}</code></pre>\n<pre class="javascript"><code class="javascript">&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-comment"><span\n        class="code-comment">//Use&nbsp;split</span></span>\n&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-built_in"><span class="code-built_in">String</span></span>[]&nbsp;results&nbsp;=&nbsp;<span\n            class="code-string"><span class="code-string">"this&nbsp;is&nbsp;a&nbsp;test"</span></span>.split(<span\n            class="code-string"><span class="code-string">"\\\\s"</span></span>);\n&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-keyword"><span class="code-keyword">for</span></span>&nbsp;(<span\n            class="code-built_in"><span class="code-built_in">String</span></span>&nbsp;result：results){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(result);\n&nbsp;&nbsp;&nbsp;&nbsp;}</code></pre>\n<p></p>\n<p>关于StringTokenizer和String.split的差异说法很多。官方文档<a\n        href="http://docs.oracle.com/javase/6/docs/api/java/util/StringTokenizer.html有定型说明：" rel="nofollow">http://docs.oracle.com/javase/6/docs/api/java/util/StringTokenizer.html</a>&nbsp;有定性说明（附注：最新的JDK8\n    API文档中也是相同的说明）。</p>\n<blockquote>\n    <p><span style="font-size:11px"><span style="font-family:微软雅黑,microsoft yahei">StringTokenizer</span><span\n            style="background-color:rgb(255, 255, 255); font-family:微软雅黑,microsoft yahei">&nbsp;is a legacy class that is retained for compatibility reasons although its use is discouraged in new code. It is recommended that anyone seeking this functionality use the&nbsp;</span><span\n            style="font-family:微软雅黑,microsoft yahei">split</span><span\n            style="background-color:rgb(255, 255, 255); font-family:微软雅黑,microsoft yahei">&nbsp;method of&nbsp;</span><span\n            style="font-family:微软雅黑,microsoft yahei">String</span><span\n            style="background-color:rgb(255, 255, 255); font-family:微软雅黑,microsoft yahei">&nbsp;or the java.util.regex package instead.</span></span>\n    </p>\n</blockquote>\n<p>大意是StringTokenizer是一个历史遗留类，为了保证向后兼容性而保留这个类。推荐在新的代码中使用split或regex替换。</p>\n<p>至于网上的测评资料说<strong>StringTokenizer比<strong>String.split</strong></strong>效率更高，由于没有亲测就不妄加评论了。作为项目管理者，从风险和可靠性的角度考虑，在项目规范和代码review的过程中，还是以官方文档为准。\n</p>\n<h2 id="h2-2"><strong>transient和volatile关键词的使用</strong></h2>\n<pre class="java"><code class="java"><span class="code-keyword"><span class="code-keyword">transient</span></span>&nbsp;<span\n        class="code-keyword"><span class="code-keyword">volatile</span></span>&nbsp;Set&lt;K&gt;&nbsp;keySet&nbsp;=&nbsp;<span\n        class="code-keyword"><span class="code-keyword">null</span></span>;\n<span class="code-keyword"><span class="code-keyword">transient</span></span>&nbsp;<span class="code-keyword"><span\n            class="code-keyword">volatile</span></span>&nbsp;Collection&lt;V&gt;&nbsp;values&nbsp;=&nbsp;<span\n            class="code-keyword"><span class="code-keyword">null</span></span>;</code></pre>\n<p>transient是变量修饰符，表明该字段不是对象持久状态的一部分，储存的时候不用储存，比如序列化这个对象时，该字段是不会储存的。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;volatile也是变量修饰符，只能用来修饰变量。volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。&nbsp;而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。<br>\n    在此解释一下Java的内存机制：<br>\n    Java使用一个主内存来保存变量当前值，而每个线程则有其独立的工作内存。线程访问变量的时候会将变量的值拷贝到自己的工作内存中，这样，当线程对自己工作内存中的变量进行操作之后，就造成了工作内存中的变量拷贝的值与主内存中的变量值不同。<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java语言规范中指出：为了获得最佳速度，允许线程保存共享成员变量的私有拷贝，而且只当线程进入或者离开同步代码块时才与共享成员变量的原始值对比。这样当多个线程同时与某个对象交互时，就必须要注意到要让线程及时地得到共享成员变量的变化。而volatile关键字就是提示VM：对于这个成员变量不能保存它的私有拷贝，而应直接与共享成员变量交互。<br>\n    使用建议：在两个或者更多的线程访问的成员变量上使用volatile。当要访问的变量已在synchronized代码块中，或者为常量时，不必使用。由于使用volatile屏蔽掉了VM中必要的代码优化，所以在效率上比较低，因此一定在必要时才使用此关键字。\n</p>'},348:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h2 id="h2-1">安装</h2>\n\n<h3 id="h3-1">安装SDKMAN</h3>\n<p>Gradle在安装之前可以选择很多安装方式，这里选择SDKMAN。其他方式见<a href="https://gradle.org/install/#install" rel="nofollow">安装说明</a>。</p>\n<p>linux安装SDKMAN，分别执行：</p>\n<pre><code class="bash"><span class="code-comment"># 下载安装执行</span>\n$ curl -s <span class="code-string">"https://get.sdkman.io"</span> | bash\n<span class="code-comment"># 自行设置</span>\n$ <span class="code-built_in">source</span> <span class="code-string">"<span class="code-variable">$HOME</span>/.sdkman/bin/sdkman-init.sh"</span></code></pre>\n<p>安装结果测试。</p>\n<p>输入：</p>\n<pre><code class="bash">$ sdk version </code></pre>\n<p>成功安装会输出：</p>\n<pre><code class="bash">==== BROADCAST =================================================================\n* 02/07/18: Kscript 2.4.5 released on SDKMAN! <span class="code-comment">#kscript</span>\n* 28/06/18: Micronaut 1.0.0.M2 released on SDKMAN! <span class="code-comment">#micronautfw</span>\n* 27/06/18: Infrastructor 0.2.0 rolling out. With stronger encryption and new task progress UI.\n================================================================================\n\nSDKMAN 5.6.4+305</code></pre>\n\n<h3 id="h3-2">安装Gradle</h3>\n<p>Gradle需要JDK7以上才能运行，请先使用 <strong><em>java -version</em></strong> 命令确定环境。&nbsp;</p>\n<p>使用SDKMAN安装Gradle：</p>\n<pre><code class="bash"><span class="code-comment"># 4.8.1是当前gradle的版本，根据需要调整</span>\n$ sdk install gradle 4.8.1</code></pre>\n<p>安装完成后输入gradle -v检查安装结果：</p>\n<pre><code class="bash">$ gradle -v\n------------------------------------------------------------\nGradle 4.8.1\n------------------------------------------------------------</code></pre>\n\n<h3 id="h3-3">Gradle基础要点知识</h3>\n<ul>\n    <li>一个Gradle文件（例如build.gradle）视为一个project。在Gradle的项目组织中就2个层级——Project和Task。</li>\n    <li>在Gradle中有3个重要的概念Project、Plug、Task。三者的关系：Project就是一个容器，里面可以放置各种类型的Task，Plug是一堆Task的集合。</li>\n    <li>Gradle中所有的功能都是以一个Task实现的，包括Jar包的依赖。</li>\n    <li>Properties：Project和Task都有自己的属性（Properties）。Project级别的属性可以设置，也可以通过外部传入。</li>\n</ul>\n\n<h3 id="h3-4">一个配置案例</h3>\n<pre><code class="groovy cs"><span class="code-comment">/**\nbuild.gradle\n这是一个使用 gradle init --type java-application创建的Gradle Project，进行了一些修改\n整个文件的范围都是一个Project。\n**/</span>\n<span class="code-comment">// ---------------------------------------------------------------------</span>\n<span class="code-comment">// 引入预设的Plug</span>\n<span class="code-comment">// 一个plug中会包含多个Task</span>\n<span class="code-comment">// plugins是Project的一个方法</span>\n<span class="code-comment">// 里面的id实际上也是一个方法。</span>\nplugins {\n    id <span class="code-string">\'java\'</span>\n    id <span class="code-string">\'application\'</span>\n}\n\n<span class="code-comment">// 资源路径的设置参数。用于java plug中的task</span>\n<span class="code-comment">// Gradle的资源路径和Maven的几乎一样，也可以单独配置</span>\nsourceSets {\n   main {\n      java {\n         srcDir <span class="code-string">\'src/main/java\'</span>\n      }\n      resources {\n         srcDir <span class="code-string">\'src/main/resources\'</span>\n      }\n   }\n}\n<span class="code-comment">//-----------------------------------</span>\n<span class="code-comment">/**\n如果不设置，资源路径默认为：\nsrc {\n   main{\n      java\n      res\n   }\n   test{\n      java\n      res\n   }\n}\n**/</span>\n<span class="code-comment">//-----------------------------------</span>\n\n<span class="code-comment">// mainClassName可以理解为一个变量</span>\n<span class="code-comment">// 定义这个程序的Main Class，实际上这也是在设定一个Project的属性</span>\nmainClassName = <span class="code-string">\'App\'</span>\n\n<span class="code-comment">//预设一个用于装载结构的类，Gradle使用groovy语法</span>\n<span class="code-keyword">class</span> <span class="code-title">GroupAndVersion</span> {\n\tString <span class="code-keyword">group</span>\n\tString version\n}\n\n<span class="code-comment">// 向project添加一个名为“spring”的属性，属性的值是一个GroupAndVersion的一个实例。</span>\n<span class="code-comment">// ext是Project的一个方法，作用就是添加一个属性。</span>\next {\n\tspring = <span class="code-keyword">new</span> GroupAndVersion(<span class="code-keyword">group</span>:<span\n            class="code-string">\'org.springframework\'</span>, version:<span class="code-string">\'5.0.7.RELEASE\'</span>)\n}\n\n<span class="code-comment">// dependencies 是由某个plug中的预设的“方法”，</span>\n<span class="code-comment">// Gradle是groovy语法，这里就是执行Project.dependencies方法</span>\n<span class="code-comment">// Plug中可以用project.extensions.create扩展Project中的定义方法</span>\ndependencies {\n    <span class="code-comment">//compile表示引入包的执行域</span>\n    compile <span class="code-string">\'com.google.guava:guava:23.0\'</span>\n\n    <span class="code-comment">//使用定义好的属性引入包</span>\n\tcompile <span class="code-keyword">group</span>: spring.<span class="code-keyword">group</span>, name: <span\n            class="code-string">\'spring-core\'</span>, version: spring.version\n\tcompile <span class="code-keyword">group</span>: spring.<span class="code-keyword">group</span>, name: <span\n            class="code-string">\'spring-beans\'</span>, version: spring.version\n\tcompile <span class="code-keyword">group</span>: spring.<span class="code-keyword">group</span>, name: <span\n            class="code-string">\'spring-context\'</span>, version: spring.version\n\n    testCompile <span class="code-string">\'junit:junit:4.12\'</span>\n}\n\n<span class="code-comment">// repositories与dependencies一样的性质，同样会被用于某个task</span>\n<span class="code-comment">// repositories用于指定依赖仓库</span>\nrepositories {\n    jcenter()\n}\n\n<span class="code-comment">// 自定义的一个任务，用于呈现当前依赖包的物理地址</span>\ntask show &lt;&lt; {\n\tprintln configurations.compile.asPath\n}</code></pre>\n<p>配置文件对应的工程结构：</p>\n<pre><code class="bash">project\n--bin IDE动态编译的文件（Eclipse）\n----main\n----<span class="code-built_in">test</span>\n--build 运行gradle build命令生成的文件\n---- classes Java 工程目录对应的.class文件\n---- distributions 打包之后的压缩包\n---- lib 打包之后的jar\n---- report 测试报告\n---- scripts 打包之后的启动脚本\n---- <span class="code-built_in">test</span>-result 测试结果\n---- tmp 临时文件，比如会在打包jar之前临时存放MANIFEST.MF\n--gradle gradle执行相关的文件，比如gradle-wrapper\n--src 源码和资源\n----main\n----text\n--build.gradle\n--gradlew\n--settings.gradle</code></pre>\n\n<h3 id="h3-5">设置仓库源</h3>\n<p>默认情况下Gradle会使用Maven或Ivy的中央仓库，在当前用户的${home}.gradle文件下新建一个init.gradle文件，然后写入：</p>\n<pre><code class="groovy ruby">allprojects{\n  repositories {\n    <span class="hljs-function"><span class="code-keyword">def</span> <span class="code-title">REPOSITORY_URL</span> = \'<span\n            class="code-title">http</span>:<span class="code-title">/</span><span class="code-title">/</span><span\n            class="code-title">maven</span>.<span class="code-title">aliyun</span>.<span\n            class="code-title">com</span><span class="code-title">/</span><span class="code-title">nexus</span><span\n            class="code-title">/</span><span class="code-title">content</span><span class="code-title">/</span><span\n            class="code-title">groups</span><span class="code-title">/</span><span class="code-title">public</span><span\n            class="code-title">/</span>\'</span>\n      all { ArtifactRepository repo -&gt;\n        <span class="code-keyword">if</span>(repo instanceof MavenArtifactRepository){\n          <span class="hljs-function"><span class="code-keyword">def</span> <span class="code-title">url</span> = <span\n                  class="code-title">repo</span>.<span class="code-title">url</span>.<span\n                  class="code-title">toString</span><span class="hljs-params">()</span></span>\n          <span class="code-keyword">if</span> (url.startsWith(<span class="code-string">\'https://repo1.maven.org/maven2\'</span>) <span\n            class="hljs-params">||</span> url.startsWith(<span class="code-string">\'https://jcenter.bintray.com/\'</span>)) {\n            project.logger.lifecycle <span\n            class="code-string">"Repository ${repo.url} replaced by $REPOSITORY_URL."</span>\n            remove repo\n          }\n       }\n    }\n    maven {\n      url REPOSITORY_URL\n    }\n  }\n}</code></pre>\n<p>这样链接的仓库会执行国内的阿里镜像。</p>\n\n<h3 id="h3-6">快速初始化项目</h3>\n<p>Gradle提供了初始化各自类型项目的命令：</p>\n<pre><code class="bash">$ gradle init --<span class="code-built_in">type</span> &lt;name&gt;\n<span class="code-comment"># &lt;name&gt;取以下值</span>\n<span class="code-comment"># java-application java应用程序</span>\n<span class="code-comment"># java-library jar包</span>\n<span class="code-comment"># scala-library scala包</span>\n<span class="code-comment"># groovy-library groovy包</span>\n<span class="code-comment"># basic 基本工程</span>\n<span class="code-comment"># 配置出来的工程结构都可以在后期通过修改build.gradle修改</span></code></pre>\n<p></p>'},365:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h2 id="h2-1">为什么要用Fragments</h2>\n<p>在我们使用React开发组件的时候，每个React组件都必须返回一个根元素。例如下面这样：</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">Table</span></span></span><span class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span class="hljs-class"><span class="code-title">Component</span></span></span><span class="hljs-class"> </span></span>{\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> (\n      <span class="xml"><span class="code-tag">&lt;<span class="code-name">table</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">tr</span>&gt;</span>\n          <span class="code-tag">&lt;<span class="code-name"><span class="code-type">Columns</span></span> /&gt;</span>\n        <span class="code-tag">&lt;/<span class="code-name">tr</span>&gt;</span>\n      <span class="code-tag">&lt;/<span class="code-name">table</span>&gt;</span>\n    );\n  }\n}\n\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">Columns</span> <span class="code-keyword">extends</span> <span class="code-title">React</span>.<span class="code-title">Component</span> </span>{\n  render() {\n    <span class="code-keyword">return</span> (\n      <span class="code-tag">&lt;<span class="code-name">div</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">td</span>&gt;</span><span class="code-type">Hello</span><span class="code-tag">&lt;/<span class="code-name">td</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">td</span>&gt;</span><span class="code-type">World</span><span class="code-tag">&lt;/<span class="code-name">td</span>&gt;</span>\n      <span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span>\n    );\n  }\n}</span></code></pre>\n<p>在正常的HTML行文中，&lt;tr&gt;标签与&lt;td&gt;标签之间的&lt;div&gt;标签是不应该存在的。</p>\n<p>虽然在这个小小的例子中，我们可以将tr标签移入到Columns中去解决这个问题，但是在错综复杂的业务层级代码中，我们经常会遇到希望一个组件返回多个并列标签的情况。</p>\n<p>为了解决这个问题，React在16.x版本新推出了一个Fragments特性——组件碎片化。Fragments的使用方法非常简单，我们将Column组件稍作改造即可：</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">Columns</span></span></span><span class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span class="hljs-class"><span class="code-title">Component</span></span></span><span class="hljs-class"> </span></span>{\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> (\n      <span class="xml"><span class="code-tag">&lt;<span class="code-name"><span class="code-type">React</span>.<span class="code-type">Fragment</span></span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">td</span>&gt;</span><span class="code-type">Hello</span><span class="code-tag">&lt;/<span class="code-name">td</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">td</span>&gt;</span><span class="code-type">World</span><span class="code-tag">&lt;/<span class="code-name">td</span>&gt;</span>\n      <span class="code-tag">&lt;/<span class="code-name"><span class="code-type">React</span>.<span class="code-type">Fragment</span></span>&gt;</span>\n    );\n  }\n}</span></code></pre>\n<p>这样，在最终渲染成Dom后，并不会出现任何与HTML行文不符的标签。</p>\n\n<h2 id="h2-2">简写与注意事项</h2>\n<p>除了React.Fragment这样的写法，React还推荐使用更加明了的简短写法：</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">Columns</span></span></span><span class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span class="hljs-class"><span class="code-title">Component</span></span></span><span class="hljs-class"> </span></span>{\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> (\n      <span class="xml"><span class="code-tag">&lt;&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">td</span>&gt;</span><span class="code-type">Hello</span><span class="code-tag">&lt;/<span class="code-name">td</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">td</span>&gt;</span><span class="code-type">World</span><span class="code-tag">&lt;/<span class="code-name">td</span>&gt;</span>\n      <span class="code-tag">&lt;/&gt;</span>\n    );\n  }\n}</span></code></pre>\n<p>需要注意的是：<span style="color:#FF0000">这样的写法不支持传递任何参数，而且某些编译器或者编译工具并不支持这种写法</span>。</p>\n\n<h2 id="h2-3">在队列中使用</h2>\n<p>一个React元素除了直接写成一个组件，也可以在队列中返回。Fragment标签使用到队列中同样也要<a href="https://www.chkui.com/article/react/react_list_key_and_form" title="列表与组件的键值">使用key属性来标记队列的位置</a>：</p>\n<pre class="javascript"><code class="language-javascript"><span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span class="code-keyword">function</span></span></span><span class="hljs-function"> </span><span class="code-title"><span class="hljs-function"><span class="code-title">Glossary</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{\n  <span class="code-keyword"><span class="code-keyword">return</span></span> (\n    <span class="xml"><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">dl</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n      {props.items.map(item =&gt; (\n        </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">React.Fragment</span></span></span></span><span class="xml"><span class="code-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="code-tag"><span class="hljs-attr">key</span></span></span></span><span class="xml"><span class="code-tag">=</span></span><span class="code-string"><span class="xml"><span class="code-tag"><span class="code-string">{item.id}</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n          </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">dt</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">{item.term}</span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">dt</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n          </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">dd</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">{item.description}</span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">dd</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n        </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">React.Fragment</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n      ))}\n    </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">dl</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n  );\n}</span></span></code></pre>\n<p></p>'},395:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h2 id="h2-1">WebFLux与WebMvc的差异</h2>\n<p><em>WebFlux</em>读写<em>Cookie</em>不像<em>WebMvc</em>那么直接，最主要的原因是<em>WebMvc</em>是基于<em>Servlet</em>规范的，而<em>WebFlux</em>仅仅遵守的是<em>HTTP</em>协议。所以在使用的时候会发现<code>HttpServletRequest</code>、<code>HttpServletResponse</code>这些<em>Servlet</em>层级的接口根本就无法使用。\n</p>\n<p><em>Cookie</em>与<em>Servlet</em>并没有太直接的关系，前者是属于<em>HTTP</em>规范的而后者是一个<em>J2EE</em>的规范，在应用层面仅有的联系就是<em>Servlet</em>会读写<em>Cookie</em>中的<em>JSESSIONID</em>来标记与前端浏览器和服务端的关系。而<code>HttpServletRequest</code>、<code>HttpServletResponse</code>仅是<em>Servlet</em>为请求和响应提供<em>header</em>、<em>body</em>管理的接口。\n</p>\n<h2 id="h2-2">WebFlux的Cookie管理</h2>\n<p><em>WebFlux</em>目前并没有为写<em>Cookie</em>提供任何工具。这就需要开发者按照<em>HTTP</em>的规范来写<em>Cookie</em>。\n    在HTTP协议交互的过程中，服务端可以通过在<em>response</em>中添加<strong>Set-Cookie</strong>头来让浏览器记录<em>Cookie</em>，而浏览器则在<em>request</em>中使用<strong>Cookie</strong>头来传递cookie。\n</p>\n<h2 id="h2-3">写Cookie</h2>\n<p>写<em>cookie</em>使用<code>ResponseEntity</code>向response头中添加<strong>Set-Cookie</strong>即可。<code>CookieBuilder</code>的代码比较长，它是用于构建一个<em>cookie</em>字符串，<strong>Set-Cookie</strong>头除了设置<em>key=value</em>，还可以设置过期日期<em>expires</em>，域名<em>domain</em>，路径<em>path</em>等。\n</p>\n<pre><code class="java"><span class="code-meta">@RestController</span>\n<span class="code-meta">@RequestMapping</span>(<span class="code-string">"/cookie"</span>)\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">CookieReadAWriteController</span> </span>{\n\t<span class="code-meta">@GetMapping</span>(<span class="code-string">"/write"</span>)\n\t<span class="hljs-function"><span class="code-keyword">public</span> ResponseEntity&lt;String&gt; <span\n            class="code-title">cookieWrite</span><span class="hljs-params">()</span> </span>{\n\t\tHttpHeaders headers = <span class="code-keyword">new</span> HttpHeaders();\n\t\tString cookie = <span class="code-keyword">new</span> CookieBuilder().setKey(<span class="code-string">"cookie-text"</span>)\n\t\t\t.setValue(cookieText)\n\t\t\t.setMaxAge(<span class="hljs-number">840000</span>)\n\t\t\t.setPath(<span class="code-string">"/"</span>)\n\t\t\t.build();\n\t\theaders.add(<span class="code-string">"Set-Cookie"</span>, cookie);\n\t\t<span class="code-keyword">return</span> <span\n            class="code-keyword">new</span> ResponseEntity&lt;String&gt;(<span class="code-string">"hi,"</span> + userName, headers, HttpStatus.OK);\n\t}\n}\n\n\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">CookieBuilder</span> </span>{\n\t<span class="code-keyword">private</span> String key;\n\t<span class="code-keyword">private</span> String value;\n\t<span class="code-keyword">private</span> String expires;\n\t<span class="code-keyword">private</span> String domain;\n\t<span class="code-keyword">private</span> String path;\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> CookieBuilder <span\n            class="code-title">setKey</span><span class="hljs-params">(String key)</span> </span>{\n\t\t<span class="code-keyword">this</span>.key = key;\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>;\n\t}\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> CookieBuilder <span\n            class="code-title">setValue</span><span class="hljs-params">(String value)</span> </span>{\n\t\t<span class="code-keyword">this</span>.value = value;\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>;\n\t}\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> CookieBuilder <span class="code-title">setMaxAge</span><span\n            class="hljs-params">(<span class="code-keyword">long</span> ms)</span> </span>{\n\t\t<span class="code-comment">//cookie的过期日期为GMT格式的时间。</span>\n\t\tDate date = <span class="code-keyword">new</span> Date(<span class="code-keyword">new</span> Date().getTime() + ms);\n\t\tSimpleDateFormat sdf = <span class="code-keyword">new</span> SimpleDateFormat(<span class="code-string">"EEE d MMM yyyy HH:mm:ss \'GMT\'"</span>, Locale.US);\n\t\tsdf.setTimeZone(TimeZone.getTimeZone(<span class="code-string">"GMT"</span>));\n\t\t<span class="code-keyword">this</span>.expires = sdf.format(date);\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>;\n\t}\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> CookieBuilder <span class="code-title">setDomain</span><span\n            class="hljs-params">(String domain)</span> </span>{\n\t\t<span class="code-keyword">this</span>.domain = domain;\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>;\n\t}\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> CookieBuilder <span\n            class="code-title">setPath</span><span class="hljs-params">(String path)</span> </span>{\n\t\t<span class="code-keyword">this</span>.path = path;\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>;\n\t}\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span\n            class="code-title">build</span><span class="hljs-params">()</span> </span>{\n\t\tStringBuilder sb = <span class="code-keyword">new</span> StringBuilder();\n\t\tsb.append(<span class="code-keyword">this</span>.key);\n\t\tsb.append(<span class="code-string">"="</span>);\n\t\tsb.append(<span class="code-keyword">this</span>.value);\n\t\tsb.append(<span class="code-string">";"</span>);\n\t\t<span class="code-keyword">if</span> (<span class="code-keyword">null</span> != <span\n            class="code-keyword">this</span>.expires) {\n\t\t\tsb.append(<span class="code-string">"expires="</span>);\n\t\t\tsb.append(<span class="code-keyword">this</span>.expires);\n\t\t\tsb.append(<span class="code-string">";"</span>);\n\t\t}\n\t\t<span class="code-keyword">if</span> (<span class="code-keyword">null</span> != <span\n            class="code-keyword">this</span>.domain) {\n\t\t\tsb.append(<span class="code-string">"domain="</span>);\n\t\t\tsb.append(<span class="code-keyword">this</span>.domain);\n\t\t\tsb.append(<span class="code-string">";"</span>);\n\t\t}\n\t\t<span class="code-keyword">if</span> (<span class="code-keyword">null</span> != <span\n            class="code-keyword">this</span>.path) {\n\t\t\tsb.append(<span class="code-string">"path="</span>);\n\t\t\tsb.append(<span class="code-keyword">this</span>.path);\n\t\t\tsb.append(<span class="code-string">";"</span>);\n\t\t}\n\t\t<span class="code-keyword">return</span> sb.toString();\n\t}\n}\n</code></pre>\n<h2 id="h2-4">读cookie</h2>\n<p>获取<em>cookie</em>就比较直观，可以直接使用<code>@CookieValue</code>这个<em>Annotation</em>来获取：</p>\n<pre><code class="java"><span class="code-meta">@RestController</span>\n<span class="code-meta">@RequestMapping</span>(<span class="code-string">"/cookie"</span>)\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">CookieReadAWriteController</span> </span>{\n\t<span class="code-meta">@GetMapping</span>(<span class="code-string">"/read/annotation"</span>)\n\t<span class="code-comment">/**\n\t * <span class="hljs-doctag">@param</span> value\n\t * <span class="hljs-doctag">@return</span>\n\t */</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">cookieReadAnnotation</span><span\n            class="hljs-params">(@CookieValue(<span\n            class="code-string">"cookie-text"</span>)</span> String value) </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"当前Cookie中的内容"</span> + value;\n\t}\n}\n</code></pre>\n<p>也可以直接从<em>Request的Header</em>中获取：</p>\n<pre><code class="java"><span class="code-meta">@RestController</span>\n<span class="code-meta">@RequestMapping</span>(<span class="code-string">"/cookie"</span>)\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">CookieReadAWriteController</span> </span>{\n\t<span class="code-meta">@GetMapping</span>(<span class="code-string">"/read/annotation"</span>)\n\t<span class="code-comment">/**\n\t * <span class="hljs-doctag">@param</span> value\n\t * <span class="hljs-doctag">@return</span>\n\t */</span>\n\t<span class="code-meta">@GetMapping</span>(<span class="code-string">"/read/entity"</span>)\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">cookieReadEntity</span><span\n            class="hljs-params">(RequestEntity&lt;String&gt; entity)</span> </span>{\n\t\tHttpHeaders headers = entity.getHeaders();\n\t\tList&lt;String&gt; cookie = headers.get(<span class="code-string">"Cookie"</span>);\n\t\t<span class="code-keyword">return</span> <span class="code-string">"当前Cookie中的内容"</span> + cookie;\n\t}\n}\n</code></pre>\n<p>\n    使用<em>Annotatin</em>是直接标记<em>Cookie</em>的<em>key</em>来获取<em>value</em>。而使用<em>RequestEntity</em>需要从头中先获取<em>Cookie</em>的内容，然后再解析<em>key</em>和<em>value</em>，存在一个<em>key</em>对应多个<em>value</em>的情况需要使用<em>RequestEntity</em>。\n</p>                                    '},407:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h2 id="h2-1">非侵入式框架</h2>\n<p>\n    Spring一直标注自己是一个非侵入式框架。非侵入式设计的概念并不新鲜，目标就是降低使用者和框架代码的耦合，毕竟框架的开发者和使用者几乎肯定不是同一个团队。Spring最早的非侵入式实现就是他的一系列XML配置，理想状态下Spring框架的所有的功能都应该是通过配置实现的。元编程在Java中的使用现给非侵入式的设计提供了更好的解决方案，在Java中通过注解（Annotation）即可标记某个类、方法、域的附加功能，而无需通过继承的方式来扩展原始框架没有的功能。下面通过3段代码的例子来说明侵入式与非侵入式的区别。</p>\n<p><span style="color:#e74c3c">文章中的代码仅仅用于说明原理，已经删除了一些无关代码，无法执行。可执行代码在：<a\n        href="https://github.com/chkui/spring-core-example"\n        rel="nofollow">https://github.com/chkui/spring-core-example</a>，如有需要请自行clone，仅支持gradle依赖。</span></p>\n\n<h3 id="h3-1">一个基本的容器</h3>\n<p>下面的代码是大致模仿的IoC容器创建Bean的过程。BeanFactory::createBeans方法传入Bean的类型列表，而迭代器遍历列表完成每一个类的实例创建：</p>\n<pre><code class="java"><span class="code-comment">/**框架代码*/</span>\n<span class="code-keyword">package</span> chkui.springcore.example.xml.beanpostprocessor.nopluging;\n\n<span class="code-comment">//创建Bean的工厂类,由框架开发者开发</span>\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">BeanFactory</span> </span>{\n\t<span class="code-comment">//创建一系列的Bean</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> List&lt;Object&gt; <span class="code-title">createBeans</span><span\n            class="hljs-params">(List&lt;Class&lt;?&gt;&gt; clslist)</span></span>{\n\t\t<span class="code-keyword">return</span> clslist.stream().map(cls-&gt;{\n\t\t\t<span class="code-keyword">return</span> createBean(cls);\n\t\t}).collect(Collectors.toList());\n\t}\n\t<span class="code-comment">//创建一个Bean</span>\n\t<span class="hljs-function">Object <span class="code-title">createBean</span><span class="hljs-params">(Class&lt;?&gt; cls)</span></span>{\n\t\t<span class="code-comment">//添加到容器</span>\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> BeanWrapper(cls.newInstance());\n\t}\n}\n\n<span class="code-comment">//包装代理</span>\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">BeanWrapper</span> </span>{\n\t<span class="code-keyword">private</span> Object bean;\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span\n            class="code-title">BeanWrapper</span><span class="hljs-params">(Object bean)</span> </span>{\n\t\t<span class="code-keyword">this</span>.bean = bean;\n\t}\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">toString</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"Wrapper("</span> + <span\n            class="code-keyword">this</span>.bean.toString() + <span class="code-string">")"</span>;\n\t}\n}</code></pre>\n<p>下面的代码是框架使用者的代码——将Bean1和Bean2交给BeanFactory来完成初始化：</p>\n<pre><code class="java"><span class="code-comment">/**使用端代码*/</span>\n<span class="code-keyword">package</span> chkui.springcore.example.xml.beanpostprocessor.nopluging;\n\n<span class="code-comment">//import ...</span>\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">IocExtensionSampleNoPluging</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n    \tList&lt;Class&lt;?&gt;&gt; classes = Arrays.asList(<span class="code-keyword">new</span> Class&lt;?&gt;[]{MyBean1.class, MyBean2.class});\n    \tList&lt;Object&gt; ins = <span class="code-keyword">new</span> BeanFactory().createBeans(classes);\n    \tSystem.out.println(<span class="code-string">"Result:"</span> + ins.toString());\n    }\n}\n\n<span class="code-comment">//Bean1，由使用者编码</span>\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MyBean1</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">toString</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"MyBean1 Ins"</span>;\n\t}\n}\n\n<span class="code-comment">//Bean2，使用者编码</span>\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MyBean2</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">toString</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"MyBean2 Ins"</span>;\n\t}\n}</code></pre>\n<p>classpath：chkui.springcore.example.xml.beanpostprocessor.nopluging.IocExtensionSample。<a\n        href="https://github.com/chkui/spring-core-example/blob/master/src/main/java/chkui/springcore/example/xml/beanpostprocessor/nopluging/IocExtensionSample.java"\n        rel="nofollow">源码地址</a>。</p>\n<p>某个时刻，框架的使用者有个新需求是在要在每个Bean创建的前后进行一些处理。我们可以通过继承的方式来实现功能。下面我们修改使用端代码实现这个功能。</p>\n\n<h3 id="h3-2">继承实现功能扩展</h3>\n<p>通过继承类BeanFactory，并修改createBean方法可以实现我们的需求：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.xml.beanpostprocessor.extend;\n\n<span class="code-comment">//执行</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">IocExtensionSampleNoPluging</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n    \tList&lt;Class&lt;?&gt;&gt; classes = Arrays.asList(<span class="code-keyword">new</span> Class&lt;?&gt;[]{MyBean1.class, MyBean2.class});\n    \tList&lt;Object&gt; ins = <span class="code-keyword">new</span> ModifyBeanFactory().createBeans(classes);\n    \tSystem.out.println(<span class="code-string">"Result:"</span> + ins.toString());\n    }\n}\n\n<span class="code-comment">//新建一个BeanFactory的派生类，并修改createBean的实现，添加使用者的处理逻辑</span>\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">ModifyBeanFactory</span> <span\n        class="code-keyword">extends</span> <span class="code-title">BeanFactory</span> </span>{\n\t<span class="hljs-function">Object <span class="code-title">createBean</span><span class="hljs-params">(Class&lt;?&gt; cls)</span></span>{\n\t\tObject ins = cls.newInstance();\n\t\t<span class="code-comment">//添加容器之前的处理</span>\n\t\tBeanWrapper wrapper = <span class="code-keyword">new</span> BeanWrapper(ins);\n\t\t<span class="code-comment">//添加容器之后的处理</span>\n\t\t<span class="code-keyword">return</span> wrapper;\n\t}\n}</code></pre>\n<p>classpath：chkui.springcore.example.xml.beanpostprocessor.extend.IocExtensionSample。<a\n        href="https://github.com/chkui/spring-core-example/blob/master/src/main/java/chkui/springcore/example/xml/beanpostprocessor/extend/IocExtensionSample.java"\n        rel="nofollow">源码地址</a>。</p>\n<p>这里在使用者的代码里新增了一个ModifyBeanFactory类，并重写了createBean方法。在重写的方法中实现我们需要的功能逻辑。但是这样开发会出现以下2点问题：</p>\n<ol>\n    <li>导致使用者的代码与框架代码产生了极强的耦合性。如果某天框架进行了调整，例如将方法名改为buildBean、或者增加了更多的代理模式会出现一些意想不到的问题。更麻烦的是可能会遇到一些到运行期才出现的问题。</li>\n    <li>我们需要先理解框架的源码才能植入我们的功能，这和很多设计模式的原则是背道而驰的。也会大大影响我们的开发效率。</li>\n</ol>\n<p>出现这些问题就叫做“侵入式”——框架代码侵入到使用者的工程代码，导致2者严重耦合，对未来的升级、扩展、二次开发都有深远的影响。</p>\n\n<h2 id="h2-2">通过注解（Annotation）扩展功能</h2>\n<p>实际上注解和在XML进行配置都是一样的思路，只是注解讲关系写在了源码上，而使用XML是将关系通过XML来描述。这里实现的功能就类似于在<a\n        href="https://www.chkui.com/article/spring/spring_core_bean_lifecycle_callback"\n        rel="nofollow">&nbsp;Bean的定义与控制</a>&nbsp;一文中介绍的Bean的生命周期方法。</p>\n<p>使用注解最大的价值就是非侵入式。非侵入式的好处显而易见：</p>\n<ol>\n    <li>无需和框架代码耦合，更新升级框架风险和成本都很小。</li>\n    <li>任何时候我们需要需要更换框架，只需修改配置或注解，而无需再去调整我们自己的功能代码。</li>\n</ol>\n<p>非侵入式也有一个问题，那就是接入的功能还是需要框架预设，而不可能像继承那样随心所欲。</p>\n<p>我们将前面的代码进行一些修改，支持通过注解来指定扩展的功能：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.xml.beanpostprocessor.annotation;\n\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">BeanFactory</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> List&lt;Object&gt; <span class="code-title">createBeans</span><span\n            class="hljs-params">(List&lt;Class&lt;?&gt;&gt; clslist)</span></span>{\n\t\t<span class="code-comment">//同前文...</span>\n\t}\n\t<span class="hljs-function">Object <span class="code-title">createBean</span><span class="hljs-params">(Class&lt;?&gt; cls)</span></span>{\n\t\tBeanWrapper wrapper = <span class="code-keyword">null</span>;\n\t\tObject ins = cls.newInstance();\n        <span class="code-comment">/**这里增加了一个Handle对象。\n           Handle会对注解进行处理，确定添加容器前后的执行方法。*/</span>\n\t\tHandle handle = processBeforeAndAfterHandle(ins);\n\t\thandle.exeBefore();\n\t\twrapper = <span class="code-keyword">new</span> BeanWrapper(ins);\n\t\thandle.exeAfter();\n\t\t<span class="code-keyword">return</span> wrapper;\n\t}\n\t\n    <span class="code-comment">// 通过反射来确定Bean被添加到容器前后的执行方法。</span>\n\t<span class="hljs-function"><span class="code-keyword">private</span> Handle <span class="code-title">processBeforeAndAfterHandle</span><span\n            class="hljs-params">(Object obj)</span> </span>{\n\t\tMethod[] methods = obj.getClass().getDeclaredMethods();\n\t\tHandle handle = <span class="code-keyword">new</span> Handle(obj);\n\t\t<span class="code-keyword">for</span>(Method method : methods) {\n\t\t\tAnnotation bef = method.getAnnotation(before.class);\n\t\t\tAnnotation aft = method.getAnnotation(after.class);\n\t\t\t<span class="code-keyword">if</span>(<span class="code-keyword">null</span> != bef) handle.setBefore(method);\n\t\t\t<span class="code-keyword">if</span>(<span class="code-keyword">null</span> != aft) handle.setBefore(method);\n\t\t}\n\t\t<span class="code-keyword">return</span> handle;\n\t}\n}</code></pre>\n<p>下面是Handle处理器和对应的注解的代码：</p>\n<pre><code class="java"><span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">Handle</span></span>{\n\tObject instance;\n\tMethod before;\n\tMethod after;\n\tHandle(Object ins){\n\t\t<span class="code-keyword">this</span>.instance = ins;\n\t}\n\t<span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">setBefore</span><span\n            class="hljs-params">(Method method)</span> </span>{\n\t\t<span class="code-keyword">this</span>.before = method;\n\t}\n\t<span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">setAfter</span><span\n            class="hljs-params">(Method method)</span> </span>{\n\t\t<span class="code-keyword">this</span>.after = method;\n\t}\n\t<span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">exeBefore</span><span\n            class="hljs-params">()</span></span>{\n\t\t<span class="code-keyword">if</span>(<span class="code-keyword">null</span> != <span\n            class="code-keyword">this</span>.before) {\n\t\t\t<span class="code-keyword">this</span>.before.invoke(<span class="code-keyword">this</span>.instance, <span\n            class="code-keyword">null</span>);\n\t\t}\n\t}\n\t<span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">exeAfter</span><span\n            class="hljs-params">()</span></span>{\n\t\t<span class="code-keyword">if</span>(<span class="code-keyword">null</span> != <span\n            class="code-keyword">this</span>.after) {\n\t\t\t<span class="code-keyword">this</span>.after.invoke(<span class="code-keyword">this</span>.instance, <span\n            class="code-keyword">null</span>);\n\t\t}\n\t}\n}\n\n<span class="code-comment">//注解----------------------------------------</span>\n<span class="code-meta">@Target</span>({ElementType.METHOD})\n<span class="code-meta">@Retention</span>(RetentionPolicy.RUNTIME)\n<span class="code-meta">@interface</span> before {}\n\n<span class="code-meta">@Target</span>({ElementType.METHOD})\n<span class="code-meta">@Retention</span>(RetentionPolicy.RUNTIME)\n<span class="code-meta">@interface</span> after{}</code></pre>\n<p>使用者的代码，我们将注解添加到Bean的对应的方法上：</p>\n<pre><code class="java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">IocExtensionSampleNoPluging</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n    \tList&lt;Class&lt;?&gt;&gt; classes = Arrays.asList(<span class="code-keyword">new</span> Class&lt;?&gt;[]{MyBean1.class, MyBean2.class});\n    \tList&lt;Object&gt; ins = <span class="code-keyword">new</span> BeanFactory().createBeans(classes);\n    \tSystem.out.println(<span class="code-string">"Result:"</span> + ins.toString());\n    }\n}\n\n<span class="code-comment">//预设的Bean1</span>\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MyBean1</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">toString</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"MyBean1 Ins"</span>;\n\t}\n\t\n\t<span class="code-meta">@before</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">init</span><span class="hljs-params">()</span> </span>{\n    \tSystem.out.println(<span class="code-string">"Before Init:"</span> + <span class="code-keyword">this</span>.toString());\n\t}\n}\n\n<span class="code-comment">//预设的Bean2</span>\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MyBean2</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">toString</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"MyBean2 Ins"</span>;\n\t}\n\t\n\t<span class="code-meta">@after</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">post</span><span class="hljs-params">()</span> </span>{\n    \tSystem.out.println(<span class="code-string">"After Init:"</span> + <span class="code-keyword">this</span>.toString());\n\t}\n}</code></pre>\n<p>我们为MyBean1和MyBean2分别添加了init、post方法和对应的@before、@after注解。执行之后输出一下内容：</p>\n<pre><code class="apache"><span class="code-attribute">Before</span> Init:MyBean1 Ins\n<span class="code-attribute">After</span> Init:MyBean2 Ins\n<span class="code-attribute">Result</span>:[Wrapper(MyBean1 Ins), Wrapper(MyBean2 Ins)]</code></pre>\n<p>classpath：chkui.springcore.example.xml.beanpostprocessor.annotation.IocExtensionSample。<a\n        href="https://github.com/chkui/spring-core-example/blob/master/src/main/java/chkui/springcore/example/xml/beanpostprocessor/annotation/IocExtensionSample.java"\n        rel="nofollow">源码地址</a>。</p>\n<p>注解对应的方法都顺利执行。</p>\n<p>通过注解，我们实现了扩展功能，任何时候只需要通过添加或修改注解即可向容器扩展功能。在Spring核心功能里，<a\n        href="http://www.chkui.com/article/spring/spring_core_bean_lifecycle_callback" title="Bean的生命周期管理">Bean的生命周期管理</a>都是通过这种思路实现的，除了注解之外还有XML支持。\n</p>\n<p>\n    在使用spring的过程中，我想各位码友多多少少都通过继承Spring某些类来实现了一些需要扩展的功能。而且我发现网上很多使用spring某些功能的例子也是通过继承实现的。建议尽量不要去采用这种加深耦合的方式实现扩展，Spring提供了多种多样的容器扩展机制，后面的文章会一一介绍。</p>\n\n<h2 id="h2-3">后置处理器</h2>\n<p>\n    后置处理器——BeanPostProcessor是Spring核心框架容器扩展功能之一，作用和Bean的生命周期方法类似，也是在Bean完成初始化前后被调用。但是和生命周期方法不同的是，他无需在每一个Bean上去实现代码，而是通过一个独立的Bean来处理全局的初始化过程。</p>\n<p>BeanPostProcessor与Bean生命周期方法体现出的差异是：<span style="color:#e74c3c">我们无论任何时候都可以加入处理器来实现扩展功能，这样做的好处是无需调整之前的Bean的任何代码也可以植入功能</span>。\n</p>\n<p>这种实现方式与切面（AOP）有一些相似的地方，但是实现的方式是完全不一样的，而且处理器会对所有Bean进行处理。</p>\n<p>BeanPostProcessor的实现非常简单，只添加一个Bean实现BeanPostProcessor接口即可：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.xml.beanpostprocessor;\n<span class="code-keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Processor</span> <span class="code-keyword">implements</span> <span class="code-title">BeanPostProcessor</span> </span>{\n    <span class="code-comment">//初始化之前</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> Object <span class="code-title">postProcessBeforeInitialization</span><span\n            class="hljs-params">(Object bean, String beanName)</span> </span>{\n        <span class="code-keyword">return</span> bean;\n    }\n\t<span class="code-comment">//初始化之后</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> Object <span class="code-title">postProcessAfterInitialization</span><span\n            class="hljs-params">(Object bean, String beanName)</span> </span>{\n        System.out.println(<span class="code-string">"Bean \'"</span> + beanName + <span class="code-string">"\' created : "</span> + bean.toString());\n        <span class="code-keyword">return</span> bean;\n    }\n}</code></pre>\n<p>BeanPostProcessor的使用案例请查看<a href="https://github.com/chkui/spring-core-example" rel="nofollow">实例代码</a>中&nbsp;chkui.springcore.example.xml.beanpostprocessor\n    包中的代码，包含：</p>\n<p>一个实体类：<em>chkui.springcore.example.xml.entity.User</em></p>\n<p>一个服务接口和服务类：<em>chkui.springcore.example.xml.service.UserService</em></p>\n<p>处理器：<em>chkui.springcore.example.xml.beanpostprocessor.Processor</em></p>\n<p>Main入口：<em>chkui.springcore.example.xml.beanpostprocessor.BeanPostProcessor</em></p>\n<p>配置文件：<em>/src/main/resources/xml/config.xml</em></p>\n\n<h3 id="h3-3">更多的后置处理器说明</h3>\n<p>见：<a href="https://www.chkui.com/article/spring/spring_core_post_processor_of_official" title="spring后置处理器">https://www.chkui.com/article/spring/spring_core_post_processor_of_official</a>\n</p>'},408:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<p>实际上Ioc容器中的大量功能都是通过后置处理器实现的，这里介绍几个主要的处理器。</p>\n<h3 id="h3-1">RequiredAnnotationBeanPostProcessor</h3>\n<p>\n    官方的一些功能就是用后置处理器的方式实现的，例如RequiredAnnotationBeanPostProcessor，它用于处理@Required注解。当我们一个Setter方法加入@Required后，表示必须设置参数，如果未设置则抛出BeanInitializationException异常。</p>\n<p><strong>使用方法1</strong>，直接添加一个Bean：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span\n        class="hljs-attr">class</span>=<span class="code-string">"org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor"</span> /&gt;</span>\n<span class="code-comment">&lt;!-- 其他bean --&gt;</span></code></pre>\n<p>这相当于直接添加一个后置处理器，他会检查所有的被@Required标注的Setter方法。</p>\n<p><strong>使用方法2</strong>，设置context：</p>\n<pre><code class="xml"><span class="code-comment">&lt;!-- 如果使用了以下2个context级别的标签，则会启用RequiredAnnotationBeanPostProcessor的功能 --&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">context:annotation-config</span> /&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">context:component-scan</span> /&gt;</span></code></pre>\n<p><strong>使用技巧1</strong>，修改扫描的注解。处理器默认会识别@Required注解，但是可以通过RequiredAnnotationBeanPostProcessor::setRequiredAnnotationType修改生效的注解，例如：\n</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span\n        class="hljs-attr">class</span>=<span class="code-string">"org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor"</span>&gt;</span>\n   <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n           class="code-string">"requiredAnnotationType"</span> <span class="hljs-attr">value</span>=<span\n           class="code-string">"x.y.Require"</span> /&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span></code></pre>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n\n<span class="code-meta">@Target</span>(ElementType.METHOD)\n<span class="code-meta">@Retention</span>(RetentionPolicy.RUNTIME)\n<span class="code-keyword">public</span> <span class="code-meta">@interface</span> Require {}</code></pre>\n<p>使用技巧2，告知RequiredAnnotationBeanPostProcessor不处理某些Bean方法：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span\n        class="hljs-attr">class</span>=<span class="code-string">"x.y.A"</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">meta</span>  <span class="hljs-attr">key</span>=<span\n            class="code-string">"org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor.skipRequiredCheck"</span> <span\n            class="hljs-attr">value</span>=<span class="code-string">"true"</span> /&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span></code></pre>\n\n<h3 id="h3-2">AutowiredAnnotationBeanPostProcessor</h3>\n<p>这个后置处理器在3.x之后使用Spring框架的系统几乎都会使用，就是他在处理大名鼎鼎的@Autowired和@Value注解。此外他也支持JSR-330中的@Inject注解。当我们使用&lt;context:annotation-config\n    /&gt;<br> 或&lt;context:component-scan /&gt;时，IoC容器也会启用这个功能。</p>\n<p>\n    可以通过setAutowiredAnnotationType、setAutowiredAnnotationTypes方法设定对应的注解，可以通过setRequiredParameterName来设置@Autowired中的属性方法：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span\n        class="hljs-attr">class</span>=<span class="code-string">"org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"</span>&gt;</span>\n   <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n           class="code-string">"autowiredAnnotationType"</span> <span class="hljs-attr">value</span>=<span\n           class="code-string">"x.y.MyInjectAnnotation"</span> /&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span></code></pre>\n\n<h3 id="h3-3">CommonAnnotationBeanPostProcessor</h3>\n<p>\n    这个处理器继承InitDestroyAnnotationBeanPostProcessor实现JSR-250的@PostConstruct和@PreDestroy的处理，此外还支持@Resource注解。JSR-250和Resouce貌似没有什么太直接的关系，所以被命名为Common表示这是一个大杂烩一般的存在。同样使用annotation-config和component-scan会被自动启用（因为都是用于处理注解的）。</p>\n<p>同样也有initAnnotationType、destroyAnnotationType等Setter方法来设置自定义注解。</p>\n\n<h3 id="h3-4">InitDestroyAnnotationBeanPostProcessor</h3>\n<p>处理Bean的生命周期方法以及资源数据注入，CommonAnnotationBeanPostProcessor继承自它。</p>'},412:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h2 id="h2-1">条件概率</h2>\n<p>事物A独立发生的概率为<img alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=P(A)">，事物B独立发生的概率为<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=P(B)">，那么有：</p>\n<p><img alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=P(A%7CB)">表示事物B发生之后事物A发生的概率；</p>\n<p><img alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=P(B%7CA)">表示事物A发生之后事物B发生的概率；</p>\n\n<h2 id="h2-2">全概率</h2>\n<p>我们可以将公式写成全量的形式：</p>\n<p><img alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=B_k(k%3D1%2C2%2C3...%2Cn)">表示全量相互排斥且性质关联的事物，即：\n</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=B_i%5Ccap%20B_j%3D%5Coslash%20(%E7%A9%BA%E9%9B%86)">，<img\n        alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=B_1%5Ccup%20B_2%20%5Ccup%20.....B_i%20%3D%20%5COmega%20(%E5%85%A8%E9%9B%86%E7%9A%84%E5%AD%90%E9%9B%86)">\n</p>\n<p>那么可以得到</p>\n<p><img alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=P(A)%3D%5Csum_j%5EiP(B_j)P(A%7CB_j)">,这就是全概率公式。\n</p>\n<p>全概率公式的意义在于：无法知道一个事物独立发生的概率，但是我们可以将其在各种条件下发生的概率进行累加获得。</p>\n\n<h3 id="h3-1">全概率的例子</h3>\n<p>\n    例1，已知某种疾病的发病率是0.001，即1000人中会有1个人得病。现有一种试剂可以检验患者是否得病，它的准确率是0.99，即在患者确实得病的情况下，它有99%的可能呈现阳性。它的误报率是5%，即在患者没有得病的情况下，它有5%的可能呈现阳性。一个人检测为阳性的概率是多少。</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=%E8%AE%BEP(A)%3D0.001%E8%A1%A8%E7%A4%BA%E5%8F%91%E7%97%85%E7%8E%87%EF%BC%8C%E5%88%99P(%5Cbar%7BA%7D%20)%3D0.999%E8%A1%A8%E7%A4%BA%E4%B8%8D%E5%8F%91%E7%97%85%E7%8E%87%E3%80%82P(B)%E8%A1%A8%E7%A4%BA%E6%A3%80%E6%B5%8B%E4%B8%BA%E9%98%B3%E6%80%A7%E7%9A%84%E6%A6%82%E7%8E%87%E3%80%82%E6%89%80%E4%BB%A5%EF%BC%9A">\n</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=P(B)%3DP(A)P(B%7CA)%20%2B%20P(%5Cbar%7BA%7D)P(B%7C%5Cbar%7BA%7D)%EF%BC%8C%E4%B8%94P(B%7CA)%3D0.99%2CP(B%7C%5Cbar%7BA%7D)%3D0.05%2C%E6%89%80%E4%BB%A5">\n</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=P(B)%3D0.001%C3%970.99%20%2B%200.999%C3%970.05%3D0.05094"></p>\n<p>例2，袋子中50个球，20个黄球，30个白球。2个人一次从袋中各获取一个球，且不放回，求第二个人取得黄球的概率。</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=P(A)%3D%5Cfrac%7B2%7D%7B5%7D%E8%A1%A8%E7%A4%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%BA%BA%E5%8F%96%E5%BE%97%E9%BB%84%E7%90%83%E7%9A%84%E6%A6%82%E7%8E%87%2C%E5%88%99P(%5Cbar%7BA%7D)%3D%5Cfrac%7B3%7D%7B5%7D%E3%80%82">\n</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=B%E8%A1%A8%E7%A4%BA%E7%AC%AC%E4%BA%8C%E4%B8%AA%E4%BA%BA%E5%8F%96%E5%BE%97%E9%BB%84%E7%90%83%E7%9A%84%E4%BA%8B%E4%BB%B6%E3%80%82%E6%9C%89%EF%BC%9A%0A">\n</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=P(B)%3DP(A)P(B%7CA)%2BP(%5Cbar%7BA%7D)P(B%7C%5Cbar%7BA%7D)%3D%5Cfrac%7B2%7D%7B5%7D%C3%97%5Cfrac%7B19%7D%7B49%7D%2B%5Cfrac%7B3%7D%7B5%7D%C3%97%5Cfrac%7B20%7D%7B49%7D%3D%5Cfrac%7B2%7D%7B5%7D">\n</p>\n<p>从另外一个角度说，无论前面的人抽了多少次，后面的人抽签总体概率是不变的。</p>\n<p>例3，5张卡片上分别标记了1,2,3,4,5，每次取2张，连续取2次，取出后不放回。求第二次取出的卡片，比第一次取出的卡片大的概率。</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=A%E8%A1%A8%E7%A4%BA%E7%AC%AC%E4%BA%8C%E5%BC%A0%E7%89%8C%E5%A4%A7%E7%9A%84%E4%BA%8B%E4%BB%B6%E3%80%82B_i%2Ci%5Cin%5B1%2C5%5D%E8%A1%A8%E7%A4%BA%E7%AC%AC%E4%B8%80%E5%BC%A0%E6%8A%BD%E5%88%B01%E5%88%B05%E7%9A%84%E4%BA%8B%E4%BB%B6%E3%80%82">\n</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=%E7%AC%AC%E4%B8%80%E5%BC%A0%E6%8A%BD%E5%88%B0%E4%BB%BB%E4%BD%95%E4%B8%80%E5%BC%A0%E7%89%8C%E6%A6%82%E7%8E%87%E9%83%BD%E6%98%AF%E4%B8%80%E6%A0%B7%E7%9A%84%EF%BC%8C%E6%89%80%E4%BB%A5P(B_i)%3D%5Cfrac%7B1%7D%7B5%7D%E3%80%82">\n</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=%E7%AC%AC%E4%B8%80%E5%BC%A0%E7%89%8C%E6%8A%BD%E5%88%B01%E6%97%B6%EF%BC%8C%E7%AC%AC%E4%BA%8C%E5%BC%A0%E7%89%8C%E5%A4%A7%E7%9A%84%E6%A6%82%E7%8E%87%E4%B8%BAP(A%7CB_1)%3D1%E3%80%82">\n</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=%E7%AC%AC%E4%B8%80%E5%BC%A0%E7%89%8C%E6%8A%BD%E5%88%B02%E6%97%B6%EF%BC%8C%E7%AC%AC%E4%BA%8C%E5%BC%A0%E7%89%8C%E5%A4%A7%E7%9A%84%E6%A6%82%E7%8E%87%E4%B8%BAP(A%7CB_2)%3D%5Cfrac%7B3%7D%7B4%7D%E3%80%82">\n</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=%E4%BB%A5%E6%AD%A4%E7%B1%BB%E6%8E%A8P(A%7CB_3)%3D%5Cfrac%7B2%7D%7B4%7D%2CP(A%7CB_4)%3D%5Cfrac%7B1%7D%7B4%7D%2CP(A%7CB_5)%3D0%E3%80%82%E6%89%80%E4%BB%A5%EF%BC%9A">\n</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=P(A)%3D%5Csum_%7Bi%3D1%7D%5E%7B5%7DP(B_i)P(A%7CB_i)%3D%5Cfrac%7B1%7D%7B5%7D%C3%971%2B%5Cfrac%7B1%7D%7B5%7D%C3%97%5Cfrac%7B3%7D%7B4%7D%2B%5Cfrac%7B1%7D%7B5%7D%C3%97%5Cfrac%7B2%7D%7B4%7D%2B%5Cfrac%7B1%7D%7B5%7D%C3%97%5Cfrac%7B1%7D%7B4%7D%2B%5Cfrac%7B1%7D%7B5%7D%C3%970%3D%5Cfrac%7B1%7D%7B2%7D">\n</p>\n<p>例4，甲袋有5只白球、7个红球，乙袋有4只白球、2只红球。任意取一个袋子，求从袋子取得白球的概率。</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=%E8%AE%BEA%3A%E8%8E%B7%E5%8F%96%E7%9A%84%E7%99%BD%E7%90%83%E7%9A%84%E4%BA%8B%E4%BB%B6%EF%BC%8CB%3A%E8%8E%B7%E5%BE%97%E7%94%B2%E8%A2%8B%E5%AD%90%E7%9A%84%E4%BA%8B%E4%BB%B6%E3%80%81%5Cbar%7BB%7D%3A%E8%8E%B7%E5%8F%96%E4%B9%99%E8%A2%8B%E5%AD%90%E3%80%82%E9%82%A3%E4%B9%88%EF%BC%9A">\n</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=P(A)%3DP(B)P(A%7CB)%2BP(%5Cbar%7BB%7D)P(A%7C%5Cbar%7BB%7D)"></p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=P(B)%3DP(%5Cbar%7BB%7D)%3D%5Cfrac%7B1%7D%7B2%7D%2CP(A%7CB)%3D%5Cfrac%7B5%7D%7B12%7D%2CP(A%7C%5Cbar%7BB%7D)%3D%5Cfrac%7B4%7D%7B6%7D%2C%E6%89%80%E4%BB%A5%EF%BC%9A">\n</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=P(B)%3D%5Cfrac%7B1%7D%7B2%7D%C3%97%5Cfrac%7B5%7D%7B12%7D%2B%5Cfrac%7B1%7D%7B2%7D%C3%97%5Cfrac%7B4%7D%7B6%7D%3D%5Cfrac%7B13%7D%7B24%7D">\n</p>\n\n<h2 id="h2-3">*贝叶斯公式</h2>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=P(A%7CB)%3DP(A)%C3%97%5Cfrac%7BP(B%7CA)%7D%7BP(B)%7D"></p>\n<p><strong>贝叶斯公式的理解</strong>：</p>\n<p>可以理解他是全概率公式的反向应用，他是求某个条件出现时某个事件发生的概率。定义如下：</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=P(A)%E8%A1%A8%E7%A4%BA%E5%89%8D%E7%BD%AE%E6%A6%82%E7%8E%87%EF%BC%8C%E8%A1%A8%E7%A4%BA%E5%BD%93B%E4%BA%8B%E4%BB%B6%E6%9C%AA%E5%8F%91%E7%94%9F%E6%97%B6A%E4%BA%8B%E4%BB%B6%E5%8F%91%E7%94%9F%E7%9A%84%E6%A6%82%E7%8E%87%E3%80%82">\n</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=P(A%7CB)%E4%B8%BA%E5%90%8E%E7%BD%AE%E6%A6%82%E7%8E%87%EF%BC%8C%E8%A1%A8%E7%A4%BAB%E4%BA%8B%E4%BB%B6%E5%8F%91%E7%94%9F%E4%B9%8B%E5%90%8EA%E4%BA%8B%E4%BB%B6%E5%8F%91%E7%94%9F%E7%9A%84%E6%A6%82%E7%8E%87%E3%80%82">\n</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%85%AC%E5%BC%8F%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%81%9A%E6%98%AF%E4%BA%8B%E4%BB%B6B%E5%8F%91%E7%94%9F%E5%90%8E%E5%AF%B9%E5%89%8D%E7%BD%AE%E6%A6%82%E7%8E%87%E7%9A%84%E4%BF%AE%E6%AD%A3%EF%BC%8C%5Cfrac%7BP(B%7CA)%7D%7BP(B)%7D%E6%98%AF%E4%BF%AE%E6%AD%A3%E5%9B%A0%E5%AD%90%E3%80%82">\n</p>\n<p>沿用前面医学的例子：</p>\n<p><em>例1，已知某种疾病的发病率是0.001，即1000人中会有1个人得病。现有一种试剂可以检验患者是否得病，它的准确率是0.99，即在患者确实得病的情况下，它有99%的可能呈现阳性。它的误报率是5%，即在患者没有得病的情况下，它有5%的可能呈现阳性。一个人检测为阳性时候，他确切患病的几率是多少。</em>\n</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=%E8%AE%BEP(A)%3D0.001%E8%A1%A8%E7%A4%BA%E5%8F%91%E7%97%85%E7%8E%87%EF%BC%8C%E5%88%99P(%5Cbar%7BA%7D%20)%3D0.999%E8%A1%A8%E7%A4%BA%E4%B8%8D%E5%8F%91%E7%97%85%E7%8E%87%E3%80%82P(B%7CA)%3D0.99%2CP(B%7C%5Cbar%7BA%7D)%3D0.05%E3%80%82%E6%89%80%E4%BB%A5%EF%BC%9A"><img\n        alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=P(A%7CB)%3DP(A)%C3%97%5Cfrac%7BP(B%7CA)%7D%7BP(B)%7D%2C%E7%94%A8%E5%85%A8%E6%A6%82%E7%8E%87%E5%85%AC%E5%BC%8F%EF%BC%9A">\n</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=P(A%7CB)%3DP(A)%C3%97%5Cfrac%7BP(B%7CA)%7D%7BP(A)P(B%7CA)%2BP(%5Cbar%7BA%7D)P(B%7C%5Cbar%7BA%7D)%7D"><img\n        alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=P(A%7CB)%3D0.001%C3%97%5Cfrac%7B0.99%7D%7B0.001%C3%970.99%2B0.999*0.05%7D%5Capprox%200.01943%3D1.94%5C%25">\n</p>\n<p>从结论看，这个试剂挺不可靠的。</p>\n<p>将贝叶斯公式的底部展开为全概率公式：</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=P(A_k%7CB)%3DP(A_k)%C3%97%5Cfrac%7BP(B%7CA_k)%7D%7B%5Csum_%7Bj%3D1%7D%5EnP(A_j)P(B%7CA_j)%7D%2Cj%5Cin(0%2Cn)%2CA_j%E8%A1%A8%E7%A4%BA%E7%9B%B8%E4%BA%92%E7%8B%AC%E7%AB%8B%E7%9A%84%E4%BA%8B%E4%BB%B6%E3%80%82">\n</p>\n<p><strong>使用全概率公式展开之后有个很直观的发现：</strong>当我们考察某一个事件的条件概率时——事件<img alt="机器学习中的数学——概率与统计"\n                                                                 src="https://math.jianshu.com/math?formula=B">发生之后<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=A_k">发生的概率，需要将整个样本空间中其他概率事件也加入到其中来。</p>\n\n<h2 id="h2-4">似然函数</h2>\n<p>似然函数个人理解是一种更加“公式化”的条件概率表达式，因为他书写的形式和条件概率相比并没有太大区别——<img alt="机器学习中的数学——概率与统计"\n                                                           src="https://math.jianshu.com/math?formula=P(x%7C%5Ctheta%20)">,只是解读方式不同。这里的<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=x">表示样本特征数据，<img alt="机器学习中的数学——概率与统计"\n                                                                                          src="https://math.jianshu.com/math?formula=%5Ctheta%20">表示模型参数。\n</p>\n<p>如果<img alt="机器学习中的数学——概率与统计"\n          src="https://math.jianshu.com/math?formula=%5Ctheta%20">已知并且固定，那么表示这个是一个概率计算模型，表示：不同的样本<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=x">在固定的模型参数<img alt="机器学习中的数学——概率与统计"\n                                                                                         src="https://math.jianshu.com/math?formula=%5Ctheta%0A">的概率值。\n</p>\n<p>如果<img alt="机器学习中的数学——概率与统计"\n          src="https://math.jianshu.com/math?formula=x">已经并且固定，表示这是一个似然计算模型（统计模型），表示不同的样本用于求解模型参数<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=%5Ctheta">。</p>\n\n<h2 id="h2-5">极大似然估计</h2>\n<p>按照前面似然函数<img alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=P(x%7C%5Ctheta)">的介绍，似然函数可以看做<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=x">是已知的，<img alt="机器学习中的数学——概率与统计"\n                                                                                      src="https://math.jianshu.com/math?formula=%5Ctheta">是未知的，极大似然估计就是在已知<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=x">的情况下求取<img alt="机器学习中的数学——概率与统计"\n                                                                                       src="https://math.jianshu.com/math?formula=%5Ctheta%20">。\n</p>\n<p>在现实的生产生活中也常常会遇到这样的问题。我们以及有了<strong>样本</strong>以及对应的<strong>标签（结论）</strong>，如何根据这些样本来计算（推算）条件<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=%5Ctheta%20">是一件很困难的事情。而极大似然估计就是一个根据样本值<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=x">和结论数据<img alt="机器学习中的数学——概率与统计"\n                                                                                      src="https://math.jianshu.com/math?formula=P(x%7C%5Ctheta)">计算条件参数<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=%5Ctheta%20">的过程。</p>\n<p>总的来说，极大似然估计是一种<strong>参数估计算法</strong>。使用极大似然估计有一个很重要的先决条件——每<strong>一组样本都是独立的，并且有充分的训练样本</strong>。</p>\n<p>先看看样本独立的判断公式：<img alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=P(A%2CB)%3DP(A)%C3%97P(B)">，即2个事物同时发生的概率等于事物独立发生概率的乘积。\n</p>\n<p>极大似然评估的公式及像这个公式。</p>\n<p>设有一组样本<img alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=D%3D%5C%7Bx_1%2Cx_2%2Cx_3...x_n%5C%7D">,所有样本的联合概率密度<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=P(D%7C%5Ctheta)">称为相对于样本<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=%5C%7Bx_1%2Cx_2%2Cx_3...x_n%5C%7D">的似然函数。那么由独立判定公式推断出所有样本的概率为：\n</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=l(%5Ctheta)%3DP(D%7C%5Ctheta)%3DP(x_i%7C%5Ctheta)%3D%5Cprod_%7Bi%3D1%7D%5En%20P(x_i%7C%5Ctheta)">。\n</p>\n<p>设<img alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=%5Chat%7B%5Ctheta%7D">是使得<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=l(%5Ctheta)">取得最大值的<img alt="机器学习中的数学——概率与统计"\n                                                                                                 src="https://math.jianshu.com/math?formula=%5Ctheta%20">值，那么<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=%5Chat%7B%5Ctheta%7D%20">是<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=%5Ctheta%20">的极大似然估计量。可以使用下面的公式表示<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=%5Chat%7B%5Ctheta%7D%20">与<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=D">的关系：</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=%5Chat%7B%5Ctheta%7D%3Dd(D)%3DD%5C%7Bx_1%2Cx_2%2Cx_3...x_n%5C%7D">,<img\n        alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=P(x%7C%5Chat%7B%5Ctheta%7D)%E7%A7%B0%E4%B8%BA%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E8%AF%84%E4%BC%B0%E5%80%BC%E3%80%82">\n</p>\n<p>实际计算时，计算连乘比较麻烦，我们可以引入对数将其转换为一个求和的过程：</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=L(%5Ctheta)%3Dlnl(%5Ctheta)%3D%5Csum_i%5EnlnP(x_i%7C%5Ctheta)">,因为<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=lnxy%3Dlnx%2Blny">。<img alt="机器学习中的数学——概率与统计"\n                                                                                                 src="https://math.jianshu.com/math?formula=L(%5Ctheta)">也称为对数似然函数。\n</p>\n<p>如果<img alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=L(%5Ctheta)">连续可微，那么可以使用导数为0求函数的凸点。即：</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=%5Cfrac%7Bd(L(%5Ctheta))%7D%7Bd%5Ctheta%7D%20%3D%200">。</p>\n<p>将条件因子扩展为M个，即<img alt="机器学习中的数学——概率与统计"\n                    src="https://math.jianshu.com/math?formula=P(x_i%2C%5Ctheta_j)%2Ci%5Cin(0%2Cn%5D%2Cj%5Cin(0%2Cm%5D">,则似然函数（对数似然函数变成）：\n</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=L(%5Ctheta_j)%3D%5Csum_%7Bi%3D1%7D%5En%5Cln%20P(x_i%7C%5Ctheta_j)">\n</p>\n<p>此时每一个<img alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=%5Ctheta_j">的求导变成一个求偏导数的过程：</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=%5Cfrac%7B%E2%88%82L(%5Ctheta_j)%7D%7B%E2%88%82%5Ctheta_k%7D%20%3D%20%5Cfrac%7B%E2%88%82%5Csum_%7Bi%3D1%7D%5En%5Cln%20P(x_i%7C%5Ctheta_j)%7D%7B%E2%88%82%5Ctheta_k%7D">,每一个<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=%5Ctheta_j">都要对<img alt="机器学习中的数学——概率与统计"\n                                                                                             src="https://math.jianshu.com/math?formula=L(%5Ctheta_j)">求导。\n</p>\n\n<h3 id="h3-2">最大似然评估的案例</h3>\n\n<h4 id="h4-1">最大似然评估计算</h4>\n<p>\n    最大似然评估（也称为极大似然评估）的用处是什么？首先可以将每个字眼拆解开来看。<strong>最大</strong>就是要找最大值<strong>，似然</strong>说明并不精确似乎就是这个值<strong>，评估</strong>指的是这是一个过程。\n</p>\n<p>现实生活中的例子：2对夫妇<img alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=(A%2C%5Chat%7BA%7D)%20">和<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=(B%2C%5Chat%7BB%7D)%20">和一个小孩<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=C">。从外观上看，小孩<img alt="机器学习中的数学——概率与统计"\n                                                                                          src="https://math.jianshu.com/math?formula=C">长相比较接近夫妇<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=(A%2C%5Chat%7BA%7D)%20">，有点像<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=B">，不像<img alt="机器学习中的数学——概率与统计"\n                                                                                    src="https://math.jianshu.com/math?formula=%5Chat%7BB%7D%20">,让你猜测<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=C">是谁的小孩。思维正常一点的人肯定会说<img alt="机器学习中的数学——概率与统计"\n                                                                                                   src="https://math.jianshu.com/math?formula=C">是<img\n        alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=(A%2C%5Chat%7BA%7D)">的小孩，这本身就是一个自然而然的判断过程，用数学解释：\n</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=%E8%AE%BEP(A%7CC)%3EP(B%7CC)%EF%BC%8CP(%5Chat%7BA%7D%7CC)%3EP(%5Chat%7BB%7D%7CC)%E3%80%82P(x%7CC)%E8%A1%A8%E7%A4%BA%E5%B0%8F%E5%AD%A9%E6%9B%B4%E5%83%8F%E8%B0%81%EF%BC%8Cx%5Cin%5BA%2C%5Chat%7BA%7D%2CB%2C%5Chat%7BB%7D%5D%E3%80%82">\n</p>\n<p>使用似然评估，就可以断定小孩更像谁：</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=P(A%7CC)%C3%97P(%5Chat%7BA%7D%7CC)%20%3E%20P(B%7CC)%C3%97P(%5Chat%7BB%7D%7CC)">。\n</p>\n\n<h4 id="h4-2">参数&amp;模型评估</h4>\n<p>最大似然估计更多的应用是在有一定样本数据的情况下用于模型评估，更准确的说是模型中的参数评估。因为似然评估来自于概率独立判决公式——<img alt="机器学习中的数学——概率与统计"\n                                                                         src="https://math.jianshu.com/math?formula=P(A%2CB)%3DP(A)%C3%97P(B)">,所以要求用于评估的样本数据相互独立。\n</p>\n<p>先说一个很直观的案例解释这个问题：</p>\n<p><em>例1，从盒子里连续取球，已知取得红球的概率<img alt="机器学习中的数学——概率与统计"\n                                 src="https://math.jianshu.com/math?formula=P%5Cin%5B0.1%2C0.5%5D">,求当P取何值时最有可能连续三次拿到红球。</em>\n</p>\n<p>只管上来说，肯定是概率越高取得红球的几率越高，所以不做推断也知道<img alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=P%3D0.5">时拿到红球的几率更高。下面通过数学过程来说明这个问题。\n</p>\n<p>设条件<img alt="机器学习中的数学——概率与统计" src="https://math.jianshu.com/math?formula=Y_i%3D1">，表示取得红球，<img alt="机器学习中的数学——概率与统计"\n                                                                                                  src="https://math.jianshu.com/math?formula=Y_i%3D0">表示没取得红球，所以用最大似然评估来计算参数得：\n</p>\n<p><img alt="机器学习中的数学——概率与统计"\n        src="https://math.jianshu.com/math?formula=l(%5Ctheta)%3DP(Y_1)%C3%97P(Y_2)%C3%97P(Y_3)%3DP%5E3">，只管的看就知道取值0.5似然评估最大。\n</p>'}});