webpackJsonp([3],{363:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<p>在<a href="https://www.chkui.com/article/spring/spring_core_ioc_extension_points" title="IoC功能扩展点">IoC功能扩展点</a>这篇文章中介绍了BeanFactoryPostProcessor及其使用方法，本篇介绍Spring官方提供的典型BeanFactoryPostProcessor。\n</p>\n\n<h2 id="h2-1">占位符参数替换——PropertyPlaceholderConfigurer</h2>\n<p>\n    如果你的工程有很多配置内容放置到Java的标准配置文件*.properties中，当把Properties的内容整合到Spring中时就会用到PropertyPlaceholderConfigurer。PropertyPlaceholderConfigurer3个功能：</p>\n<ol>\n    <li>将配置中${property-name}格式的占位符换为加载的*.properties文件中的内容。</li>\n    <li>将配置中${property-name}格式的占位符替换为环境变量systemProperties（System.getProperty(key)）中的内容。</li>\n    <li>如果文件和环境中有相同的key，按照规则对数据进行合并。</li>\n</ol>\n\n<h3 id="h3-1">基本使用方法</h3>\n<p>PropertyPlaceholderConfigurer继承了配置BeanFactoryPostProcessor接口，在IoC开始初始化Bean之前修改对应<a\n        href="https://www.chkui.com/article/spring/spring_core_ioc_extension_points" title="IoC功能扩展点">BeanDefinition</a>。在使用时我们直接向容器添加一个PropertyPlaceholderConfigurer即可：\n</p>\n<pre><code class="xml"><span class="code-comment">&lt;!-- 启用占位符替换需要引入PropertyPlaceholderConfigurer --&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n        class="code-string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span>\n    <span class="code-comment">&lt;!-- 指定*.properties文件的路径 --&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"locations"</span> <span class="hljs-attr">value</span>=<span class="code-string">"classpath:project/config.properties"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n\n<span class="code-comment">&lt;!-- 替换Bean中的内容 --&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"A"</span> <span class="hljs-attr">class</span>=<span\n        class="code-string">"x.y.z.User"</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"name"</span> <span class="hljs-attr">value</span>=<span class="code-string">"${user.name}"</span>/&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"address"</span> <span class="hljs-attr">value</span>=<span class="code-string">"${user.address}"</span>/&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"age"</span> <span class="hljs-attr">value</span>=<span class="code-string">"${user.age}"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span></code></pre>\n<p>对应的config.properties文件中的内容：</p>\n<pre><code class="json">user.name=\'Alice\'\nuser.address=\'China\'\nuser.age=<span class="hljs-number">20</span></code></pre>\n<p>除了直接引入一个Bean，可以通过全局上下文配置启动这一项功能：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">context:property-placeholder</span> <span\n        class="hljs-attr">location</span>=<span\n        class="code-string">"classpath:project/config.properties"</span>/&gt;</span></code></pre>\n\n<h3 id="h3-2">设置环境变量加载行为</h3>\n<p>\n    前面说了PropertyPlaceholderConfigurer除了会用*.properties文件中的参数去替换占位符的内容，还会使用环境变量（System.getProperty(key)）中的参数去替换。如果一个参数在配置文件中和系统环境变量中都存在，那么默认会使用*.properties中的参数来替换配置中的占位符。可以使用PropertyPlaceholderConfigurer::systemPropertiesMode来修改这个行为。他接受3个参数：</p>\n<ul>\n    <li>PropertyPlaceholderConfigurer.SYSTEM_PROPERTIES_MODE_NEVER(0)：从不加载环境变量中的参数。</li>\n    <li>PropertyPlaceholderConfigurer.SYSTEM_PROPERTIES_MODE_FALLBACK(1)：优先使用*.properties文件中的变量，如果不存在再使用环境变量中的。</li>\n    <li>PropertyPlaceholderConfigurer.SYSTEM_PROPERTIES_MODE_OVERRIDE(2)：优先使用环境变量中的参数。</li>\n</ul>\n<p>可以这样设置：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span\n        class="hljs-attr">class</span>=<span class="code-string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span>\n    <span class="code-comment">&lt;!-- 优先使用环境变量中的参数 --&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"systemPropertiesMode"</span> <span class="hljs-attr">value</span>=<span\n            class="code-string">"2"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span></code></pre>\n\n<h3 id="h3-3">动态设置参数&amp;动态替换类</h3>\n<p>除了通过环境变量和*.properties配置文件引入参数，还可以直接写在XML的配置上：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span\n        class="hljs-attr">class</span>=<span class="code-string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span>\n    <span class="code-comment">&lt;!-- 加载资源文件位置 --&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"locations"</span>&gt;</span>\n        <span class="code-tag">&lt;<span\n                class="code-name">value</span>&gt;</span>classpath:myProject/config.properties<span class="code-tag">&lt;/<span\n            class="code-name">value</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">property</span>&gt;</span>\n    <span class="code-comment">&lt;!-- 动态添加配置参数 --&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"properties"</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">value</span>&gt;</span>define.runtime.class=x.y.z.A<span\n            class="code-tag">&lt;/<span class="code-name">value</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">property</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n<span class="code-comment">&lt;!-- 动态加载一个类 --&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span class="code-string">"${define.runtime.class}"</span>/&gt;</span></code></pre>\n<p>上面XML配置还展示了一个动态装载类的方法。</p>\n\n<h2 id="h2-2">按命名规则注入——PropertyOverrideConfigurer</h2>\n<p>\n    PropertyOverrideConfigurer就是在PropertyPlaceholderConfigurer的基础上扩展了一些功能节约一些写配置文件的时间。他可以让你不必在XML文件写占位符而直接注入数据。看下面的例子：</p>\n<p>通过&lt;bean&gt;标签引入了PropertyOverrideConfigurer类，然后有一个独立的User单例，以及将Cpu、Ram、Graphics单例组合到Pc中。</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span>&gt;</span>\n    <span class="code-comment">&lt;!-- 引入PropertyOverrideConfigurer --&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"org.springframework.beans.factory.config.PropertyOverrideConfigurer"</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"locations"</span> <span class="hljs-attr">value</span>=<span class="code-string">"classpath:xml/configoverride/config.properties"</span>/&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n    <span class="code-comment">&lt;!-- 配置Bean之间的组合关系 --&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n            class="code-string">"user"</span> <span class="hljs-attr">class</span>=<span class="code-string">"chkui.springcore.example.xml.configoverride.User"</span> /&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n            class="code-string">"cpu"</span> <span class="hljs-attr">class</span>=<span class="code-string">"chkui.springcore.example.xml.configoverride.entity.Cpu"</span> /&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n            class="code-string">"ram"</span> <span class="hljs-attr">class</span>=<span class="code-string">"chkui.springcore.example.xml.configoverride.entity.Ram"</span> /&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n            class="code-string">"graphics"</span> <span class="hljs-attr">class</span>=<span class="code-string">"chkui.springcore.example.xml.configoverride.entity.Graphics"</span> /&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n            class="code-string">"pc"</span> <span class="hljs-attr">class</span>=<span class="code-string">"chkui.springcore.example.xml.configoverride.entity.Pc"</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"cpu"</span> <span class="hljs-attr">ref</span>=<span\n                class="code-string">"cpu"</span>/&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"ram"</span> <span class="hljs-attr">ref</span>=<span\n                class="code-string">"ram"</span>/&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"graphics"</span> <span class="hljs-attr">ref</span>=<span class="code-string">"graphics"</span>/&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>对应的*.properties配置是这样的：</p>\n<pre><code class="bash">user.name=Alice\nuser.address=china\nuser.age=20\n\npc.cpu.brand=AMD\npc.graphics.brand=Nvdia\npc.ram.brand=Kingston</code></pre>\n<p>Cpu类的结构：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.xml.configoverride.entity;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Cpu</span> </span>{\n\t<span class="code-keyword">private</span> String brand;\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">getBrand</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> brand;\n\t}\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setBrand</span><span class="hljs-params">(String brand)</span> </span>{\n\t\t<span class="code-keyword">this</span>.brand = brand;\n\t}\n}</code></pre>\n<p>这个时候PropertyOverrideConfigurer会根据容器中Bean的id或name来注入数据，比如*.properties配置中的"pc"就对应XML中的&lt;bean id="pc"&gt;，接着pc中有一个域（成员变量）名为cpu那么它对应*.properties配置文件中"pc.cpu."，所以pc.cpu.brand=AMD的配置会告诉PropertyOverrideConfigurer向pc单例中的cpu实例的"brand"域注入数据"AMD"。</p>\n<p>所以使用PropertyOverrideConfigurer运行之后，不需要在XML使用${property-name}这样的参数它会按照id或name的结构注入数据，此时user.getName() ==\n    "Alice"。如果类的关系是这个多层的结构一样可以根据Properties的结构注入数据，例如 pc.getPc().getBrand() == "AMD"。</p>\n<p>例子的可执行代码见<strong><a\n        href="https://gitee.com/chkui-com/spring-core-sample/tree/master/src/main/java/chkui/springcore/example/xml/configoverride"\n        rel="nofollow">本人码云库中configoverride包</a>。</strong></p>'},370:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<p>在<a href="https://www.chkui.com/article/spring/spring_core_environment_management_of_profile" title="Profile管理环境">Profile管理环境</a>一文中介绍了环境的概念以及Spring\n    Profile特性控制Bean的添加。本文将进一步介绍Spring管理和控制操作系统变量、JVM变量和Java标准资源（properties文件）的相关功能。</p>\n<p>文章的代码仅仅用于说明问题，<a href="https://gitee.com/chkui-com/spring-core-sample" rel="nofollow">可执行代码请到我的gitee库clone</a>，本文的代码在<em>chkui.springcore.example.hybrid.propertsource</em>包中。\n</p>\n\n<h2 id="h2-1">PropertySource与优先级</h2>\n<p>在整个Jvm运行期间，我们可以随时随地获取到2个与环境相关的参数：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.propertsource;\n\n<span class="code-comment">//env是与操作系统相关的参数</span>\nMap&lt;String, String&gt; env = System.getenv();\n<span class="code-comment">//properties中是Jvm相关的参数</span>\nProperties p = System.getProperties();\nSystem.out.println(<span class="code-string">"env :"</span> + env);\nSystem.out.println(<span class="code-string">"properties :"</span> +  p);</code></pre>\n<p>如果没有人为的添加额外信息，<em>System::getEnv</em>获取的数据都与当前的操作系统相关（以下称为“操作系统参数”），而<em>System::getProperties</em>获取的内容都与Jvm相关（以下称为“JVM参数”）。\n</p>\n<p>Spring会将操作系统参数和Jvm参数都整合到自己的环境管理接口Environment中，例如下面的代码：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.propertsource;\n\n<span class="code-comment">//向系统级的properties设置一个参数</span>\nSystem.setProperty(<span class="code-string">"wow"</span>, <span class="code-string">"World of Warcraft"</span>);\nApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(PropertySourcesApp.class);\n<span class="code-comment">//通过spring的Environment获取参数</span>\nEnvironment springEnv = ctx.getEnvironment();\nSystem.out.println(springEnv.getProperty(<span class="code-string">"wow"</span>));\nSystem.out.println(springEnv.getProperty(<span class="code-string">"PATH"</span>));\n</code></pre>\n<p>除了我们自定义的"wow"，操作系统参数"PATH"也可以在Spring的<em>Environment</em>中获取。</p>\n<p>通常情况下，在<em>Environment</em>内部维护了2个<a\n        href="https://docs.spring.io/spring-framework/docs/5.0.8.RELEASE/javadoc-api/org/springframework/core/env/PropertySource.html"\n        rel="nofollow">PropertySources</a>的实例：一个是操作系统参数，另外一个是JVM参数。如果2者有同样的参数，那么我们在调用<em>Environment::getProperty</em>方法时，得到的是JVM参数（<em>System::getProperties</em>）,也就是说&nbsp;Jvm参数具有更高的优先级。\n</p>\n<p>除了通过外部设置，我们也可以直接使用Spring提供的接口来设置：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.propertsource;\n\n<span class="code-comment">//我们要对环境进行配置，需要使用ConfigurableApplicationContext接口</span>\nConfigurableApplicationContext configAbleCtx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(PropertySourcesApp.class);\n\n<span class="code-comment">//ConfigurableApplicationContext接口提供对应的可编辑Environment和PropertySources</span>\nMutablePropertySources ps = configAbleCtx.getEnvironment().getPropertySources();\nMap&lt;String, Object&gt; map = <span class="code-keyword">new</span> HashMap&lt;String, Object&gt;();\nmap.put(<span class="code-string">"wow"</span>, <span class="code-string">"Origin = World of Warcraft!But Edit it already!"</span>);\n<span class="code-comment">//添加到Spring的环境参数中</span>\nps.addFirst(<span class="code-keyword">new</span> MapPropertySource(<span class="code-string">"myPropertySource"</span>, map));\nSystem.out.println(springEnv.getProperty(<span class="code-string">"wow"</span>));</code></pre>\n<p>代码添加到<em>PropertySource</em>中，Environment会额外维护一个<a\n        href="https://docs.spring.io/spring-framework/docs/5.0.8.RELEASE/javadoc-api/org/springframework/core/env/PropertySource.html"\n        rel="nofollow">PropertySources</a>，而自己添加的<a\n        href="https://docs.spring.io/spring-framework/docs/5.0.8.RELEASE/javadoc-api/org/springframework/core/env/PropertySource.html"\n        rel="nofollow">PropertySources</a>优先级是最高的，所以最后Environment::getProperty获取到的值是最后设置的值。</p>\n<p>如果需要添加多个<a\n        href="https://docs.spring.io/spring-framework/docs/5.0.8.RELEASE/javadoc-api/org/springframework/core/env/PropertySource.html"\n        rel="nofollow">PropertySources</a>，可以通过<em>MutablePropertySources::addFirst</em>或<em>MutablePropertySources::addLast</em>方法来控制他们之间的优先级。\n</p>\n\n<h2 id="h2-2">引入资源文件</h2>\n<p><em>*.properties</em>是Java的标准资源文件，在Java的各种项目中常用来记录各种配置参数。Spring提供了注解和XML配置将<em>*.properties</em>文件中的数据整合到Spring的环境参数（Environment）中。\n</p>\n\n<h3 id="h3-1">@PropertySource</h3>\n<p>在<em>@Configuration</em>标记的类上使用<em>@PropertySource</em>注解可以引入0~n个<em>*.properties</em>配置文件。如下面的例子：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.propertsource;\n\n<span class="code-meta">@Configuration</span>\n<span class="code-meta">@PropertySource</span>(<span class="code-string">"classpath:/hybrid/propertysource/config.properties"</span>)\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">PropertySourcesApp</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(PropertySourcesApp.class); \n\t\tSystem.out.println(<span class="code-string">"Properties file params: "</span> + springEnv.getProperty(<span\n            class="code-string">"Gdi"</span>));\n\t}\n}</code></pre>\n<p>对应的<em>config.properties</em>文件：</p>\n<pre><code class="bash"><span class="code-comment">#hybrid.propertysource.config.properties</span>\n\nGdi=StarCraft</code></pre>\n<p>\n    同一个工程中支持使用多个@PropertySource注解来引入配置文件，也支持Ant风格（Ant-style，例如"classpath:a/b/**/config.properties"）以及Spring扩展的（比如"classpath*:"）的路径规则，资源路径控制会在后续的文章中介绍。</p>\n\n<h3 id="h3-2">XML配置</h3>\n<p>XML配置在之前介绍容器后置处理器——<a href="https://www.chkui.com/article/spring/spring_core_factory_post_processor_of_official"\n                         title="BeanFactoryPostProcessor">BeanFactoryPostProcessor</a>的文章中已经介绍了，他就是&nbsp;<em>PropertyPlaceholderConfigurer</em>&nbsp;，我们在XML配置文件中进行一下设置即可。\n</p>\n<p>引入Bean：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span\n        class="hljs-attr">class</span>=<span class="code-string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span>\n    <span class="code-comment">&lt;!-- 指定*.properties文件的路径 --&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"locations"</span> <span class="hljs-attr">value</span>=<span class="code-string">"classpath:/hybrid/propertysource/config.properties"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span></code></pre>\n<p>直接使用context进行全局设置：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">context:property-placeholder</span> <span\n        class="hljs-attr">location</span>=<span\n        class="code-string">"classpath:/hybrid/propertysource/config.properties"</span>/&gt;</span></code></pre>\n\n<h2 id="h2-3">占位符替换</h2>\n<p><em>PropertyPlaceholderConfigurer</em>继承了抽象类<em>PropertyPlaceholderConfigurer，</em>而<em>*.properties</em>文件的读写就是在<em>PropertyResourceConfigurer</em>类中实现的。<em>PropertyPlaceholderConfigurer</em>进一步实现了配置文件中占位符<em>（${...}）</em>替换功能<em>。</em>\n</p>\n<p>在Spring IoC容器执行Bean的扫描、加载之前添加一个环境变量（也可以动态添加然后再执行<em>ConfigurableApplicationContext::refresh</em>方法），就可以在很多资源路径的位置使用这个占位符，对上面的例子进行一些修改：\n</p>\n<pre><code class="java"><span class="code-meta">@Configuration</span>\n<span class="code-comment">//通过占位符来设置路径</span>\n<span class="code-meta">@PropertySource</span>(<span class="code-string">"classpath:${resource.propertiesPath}/config.properties"</span>)\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">PropertySourcesApp</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n        <span class="code-comment">//容器启动之前设置环境变量</span>\n\t\tSystem.setProperty(<span class="code-string">"resource.propertiesPath"</span>, <span class="code-string">"/hybrid/propertysource"</span>);\n\t\tApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(PropertySourcesApp.class);\n\t\t<span class="code-comment">//获取环境对象实例</span>\n\t\tEnvironment springEnv = ctx.getEnvironment();\n\t\tSystem.out.println(<span class="code-string">"Properties : "</span> + springEnv.getProperty(<span\n            class="code-string">"Gdi"</span>));\n\t}\n}</code></pre>\n<p>同样的，只要环境变量存在，也可以使用占位符替换配置文件中的数据，例如：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">context:property-placeholder</span> <span\n        class="hljs-attr">location</span>=<span class="code-string">"classpath:${resource.propertiesPath:/config}/config.properties"</span>/&gt;</span></code></pre>\n<p>XML中的占位符使用的格式是<em>${resource.propertiesPath:/config}</em>，它表示使用环境变量<em>resource.propertiesPath</em>进行替换，如果<em>resource.propertiesPath</em>不存在则使用值"/config"。\n</p>\n\n<h2 id="h2-4">@Value</h2>\n<p>我们可以在任何Bean中使用@Value注解来获取环境变量。如下面的例子：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.propertsource;\n\n<span class="code-meta">@Configuration</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">PropertySourcesApp</span> </span>{\n\t<span class="code-meta">@Value</span>(<span class="code-string">"${resource.propertiesPath}"</span>)\n\t<span class="code-keyword">private</span> String value;\n\t<span class="code-meta">@Value</span>(<span\n            class="code-string">"#{systemProperties[\'resource.propertiesPath\']}"</span>)\n\t<span class="code-keyword">private</span> String elValue;\n\t<span class="code-meta">@Value</span>(<span class="code-string">"Resource PropertiesPath"</span>)\n\t<span class="code-keyword">private</span> String staticValue;\n\t\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tSystem.setProperty(<span class="code-string">"resource.propertiesPath"</span>, <span class="code-string">"/hybrid/propertysource"</span>);\n\n\t\tApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(PropertySourcesApp.class);\n\t\t\n\t\tPropertySourcesApp app = ctx.getBean(PropertySourcesApp.class);\n\t\tSystem.out.println(<span class="code-string">"Value: "</span> + app.value);\n\t\tSystem.out.println(<span class="code-string">"EL Value: "</span> + app.elValue);\n\t\tSystem.out.println(<span class="code-string">"Static Value: "</span> + app.staticValue);\n\t}\n}</code></pre>\n<p>\n    @Value可以注入一个纯字面量，如上面示例代码中的staticValue，也可以使用占位符使用环境变量中的任何值。除了使用占位符${}，@Value还支持"#{systemProperties[\'resource.propertiesPath\']}"这样具备代码执行功能的复杂表达式来获取数据，这部分功能会在后续介绍EL表达式的文章中进行分享。</p>'},372:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<h2 id="h2-1">Spring的国际化</h2>\n<p>在<a href="https://www.chkui.com/article/spring/spring_core_context_and_ioc" title="上下文与IoC">上下文与IoC</a>对ApplicationContext以及Context相关的设计模式进行了介绍。ApplicationContext作为一个Context在应用的运行层提供了IoC容器、事件、国际化等功能接口。\n</p>\n<p>Spring的国际化（i18n）功能是通过MessageSource接口实现的，他提供了MessageSource::getMessage方法从预设的资源中获取对应的数据。</p>\n\n<h2 id="h2-2">Java标准资源绑定</h2>\n<p>\n    在介绍MessageSource之前，得先说清楚Java（J2SE）对国际化的基本实现——ResourceBundle，因为MessageSource是用它实现的。ResourceBundle很好理解，他就是按照规范的格式放置*.properties资源文件，然后根据输入的语言环境来返回资源。看一个代码例子就很容易明白了。</p>\n<p>（可执行代码请到<a href="https://gitee.com/chkui-com/spring-core-sample" rel="nofollow">gitee</a>下载，本文的示例代码在<em>chkui.springcore.example.hybrid.i18n</em>包中。）\n</p>\n<p>\n    我们有3个资源文件放置在<strong><em>classpath的根目录</em></strong>（本例是放在src/main/resource）中，文件名分别为<em>i18n_en_US.properties</em>、<em>i18n_zh_CN.properties</em>和<em>i18n_web_BASE64.properties。文件中的内容如下：</em>\n</p>\n<pre><code class="apache"><span class="code-comment">#i18n_en_US.properties</span>\n<span class="code-attribute">say</span>=Hallo world!\n\n<span class="code-comment">#i18n_zh_CN.properties</span>\n<span class="code-attribute">say</span>=大家好！\n\n<span class="code-comment">#i18n_web_BASE64.properties</span>\n<span class="code-attribute">say</span>=+-+-+-ABC</code></pre>\n<p>然后我们通过ResourceBundle类来使用这些i18n的资源文件：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.i18n;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">I18nApp</span> </span>{\n\t\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n        <span class="code-comment">//使用当前操作系统的语言环境</span>\n\t\tResourceBundle rb = ResourceBundle.getBundle(<span class="code-string">"i18n"</span>, Locale.getDefault());\n\t\tSystem.out.println(rb.getString(<span class="code-string">"say"</span>));\n\n        <span class="code-comment">//指定简体中文环境</span>\n        rb = ResourceBundle.getBundle(<span class="code-string">"i18n"</span>, <span class="code-keyword">new</span> Locale(<span\n            class="code-string">"zh"</span>, <span class="code-string">"CN"</span>));\n\t\tSystem.out.println(rb.getString(<span class="code-string">"say"</span>));\n        <span class="code-comment">//通过预设指定简体英文环境</span>\n\t\trb = ResourceBundle.getBundle(<span class="code-string">"i18n"</span>, Locale.SIMPLIFIED_CHINESE);\n\t\tSystem.out.println(rb.getString(<span class="code-string">"say"</span>));\n\n        <span class="code-comment">//指定美国英语</span>\n\t\trb = ResourceBundle.getBundle(<span class="code-string">"i18n"</span>, Locale.US);\n\t\tSystem.out.println(rb.getString(<span class="code-string">"say"</span>));\n\n        <span class="code-comment">//使用自定义的语言环境</span>\n\t\tLocale locale = <span class="code-keyword">new</span> Locale(<span class="code-string">"web"</span>, <span\n            class="code-string">"BASE64"</span>);\n\t\trb = ResourceBundle.getBundle(<span class="code-string">"i18n"</span>, locale);\n\t\tSystem.out.println(rb.getString(<span class="code-string">"say"</span>));\n\t}\n}\n</code></pre>\n<p>按照开发文档的要求，使用ResourceBundle加载的资源文件都必须放置在根目录，并且必须按照${<em>name}_${language}_${region}</em>的方式来命名。这个命名方式正好能对应ResourceBundle::getBundle方法中的参数，例如<em>ResourceBundle.getBundle("i18n",\n    new Locale("zh", "CN"))</em>。"i18n"对应${name}，"zh"定位${language}，而“CN”对应${<em>region</em>}。这样我们就可以通过传导参数来使用不同的资源。如果不指定<em>${language}</em>和<em>${region}</em>，该文件就是一个默认文件。\n</p>\n<p><em>Locale</em>类预设了很多资源类型，比如<em>Locale.SIMPLIFIED_CHINESE、Locale.US</em>，实际上他们就等价于<em>new Locale("zh", "CN")</em>和new\n    Locale<em>("en", "US")。</em>只是Java的开发人员做了一些静态的预设。</p>\n<p>除了预设内容的Locale，我们还可以像<em>Locale locale = new Locale("web", "BASE64")</em>这样添加自定义的内容，他对应名为<em>i18n_web_BASE64.properties</em>的资源文件。\n</p>\n\n<h2 id="h2-3">MessageSource的使用</h2>\n<p>MessageSource的功能就是用Java标准库的ResourceBundle实现的，所以使用起来也差不多。</p>\n<p>首先得将用于处理国际化资源的Bean添加到IoC容器中：</p>\n<pre><code class="java"><span class="code-meta">@Configuration</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">I18nApp</span> </span>{\n\t<span class="code-meta">@Bean</span>(<span class="code-string">"messageSource"</span>)\n\t<span class="hljs-function">ResourceBundleMessageSource <span\n            class="code-title">resourceBundleMessageSource</span><span class="hljs-params">()</span> </span>{\n\t\tResourceBundleMessageSource messageSource = <span class="code-keyword">new</span> ResourceBundleMessageSource();\n\t\tmessageSource.setBasenames(<span class="code-keyword">new</span> String[] { <span\n            class="code-string">"i18n"</span>, <span class="code-string">"extend"</span> });<span class="code-comment">//添加资源名称</span>\n\t\t<span class="code-keyword">return</span> messageSource;\n\t}\n}</code></pre>\n<p>或</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n            class="code-string">"messageSource"</span>\n            <span class="hljs-attr">class</span>=<span class="code-string">"org.springframework.context.support.ResourceBundleMessageSource"</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n                class="code-string">"basenames"</span>&gt;</span>\n            <span class="code-tag">&lt;<span class="code-name">list</span>&gt;</span>\n                <span class="code-tag">&lt;<span class="code-name">value</span>&gt;</span>i18n<span class="code-tag">&lt;/<span\n            class="code-name">value</span>&gt;</span>\n                <span class="code-tag">&lt;<span class="code-name">value</span>&gt;</span>extend<span class="code-tag">&lt;/<span\n            class="code-name">value</span>&gt;</span>\n            <span class="code-tag">&lt;/<span class="code-name">list</span>&gt;</span>\n        <span class="code-tag">&lt;/<span class="code-name">property</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>切记一定要标记<em>id=messageSource</em>。basenames这个Setter用于指定*.properties资源文件的名称，规则和前面介绍的ResourceBundle一样。然后就可以通过ApplicationContext::getMessage方法获取对应的资源了：\n</p>\n<pre><code class="java"><span class="code-meta">@Configuration</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">I18nApp</span> </span>{\n\t<span class="code-meta">@Bean</span>(<span class="code-string">"messageSource"</span>)\n\t<span class="hljs-function">ResourceBundleMessageSource <span\n            class="code-title">resourceBundleMessageSource</span><span class="hljs-params">()</span> </span>{\n\t\tResourceBundleMessageSource messageSource = <span class="code-keyword">new</span> ResourceBundleMessageSource();\n\t\tmessageSource.setBasenames(<span class="code-keyword">new</span> String[] { <span\n            class="code-string">"i18n"</span>, <span class="code-string">"extend"</span> });\n\t\t<span class="code-keyword">return</span> messageSource;\n\t}\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tApplicationContext context = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(I18nApp.class);\n\t\tSystem.out.println(<span class="code-string">"Spring Default 1:"</span> + context.getMessage(<span\n            class="code-string">"say"</span>, <span class="code-keyword">null</span>, Locale.getDefault()));\n\t\tSystem.out.println(<span class="code-string">"Spring Default 2:"</span> + context.getMessage(<span\n            class="code-string">"say"</span>, <span class="code-keyword">null</span>, <span\n            class="code-keyword">null</span>));\n\t\tSystem.out.println(<span class="code-string">"Spring Chinese:"</span> + context.getMessage(<span\n            class="code-string">"say"</span>, <span class="code-keyword">null</span>, Locale.SIMPLIFIED_CHINESE));\n\t\tSystem.out.println(<span class="code-string">"Spring Us English:"</span> + context.getMessage(<span\n            class="code-string">"say"</span>, <span class="code-keyword">null</span>, Locale.US));\n\t\tSystem.out.println(<span class="code-string">"Spring Custom:"</span> + context.getMessage(<span\n            class="code-string">"say"</span>, <span class="code-keyword">null</span>, <span\n            class="code-keyword">new</span> Locale(<span class="code-string">"web"</span>, <span class="code-string">"BASE64"</span>)));\n\t\tSystem.out.println(<span class="code-string">"Spring Argument:"</span> + context.getMessage(<span\n            class="code-string">"info"</span>, <span class="code-keyword">new</span> String[] {<span\n            class="code-string">"chkui"</span>},<span class="code-keyword">null</span>));\n\t\tSystem.out.println(<span class="code-string">"Spring Info:"</span> + context.getMessage(<span\n            class="code-string">"say"</span>, <span class="code-keyword">null</span>, <span\n            class="code-keyword">null</span>));\n\t}\n}</code></pre>\n\n<h2 id="h2-4">占位符替换</h2>\n<p>注意上面的示例代码的这一行：<em>context.getMessage("info", new String[] {"chkui"},null))，</em>这里的<em>getMessage</em>向方法传递了一个数组，他用于替换资源文件中的占位符号。在例子中我们除了i18n还加载了一个<em>extend.properties</em>文件，文件内容如下：\n</p>\n<pre><code class="ini"><span class="hljs-attr">info</span>={<span class="hljs-number">0</span>}帅的让人没脾气。</code></pre>\n<p>文件中的<em>{0}</em>表示这个位置用数组中的[0]位置的元素替换。</p>\n<p>还有一点需要注意的是，*.properties文件输入中文等UTF-8的符号时需要保留上面这种ACS的格式，现在大部分IDE都会自动处理的，切记不要为了方便看内容将*.properties的编码格式切换为UTF-8。</p>\n\n<h2 id="h2-5">获取MessageSource接口</h2>\n<p>我们有三种方式获取MessageSource接口：</p>\n<pre><code class="java"><span class="code-comment">//直接使用</span>\nApplicationContext context = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(I18nApp.class);\ncontext.getMessage(<span class="code-string">"say"</span>, <span class="code-keyword">null</span>, Locale.getDefault()));\n\n<span class="code-comment">//MessageSourceAware（ApplicationContextAware）接口</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">ExtendBean</span> <span class="code-keyword">implements</span> <span class="code-title">MessageSourceAware</span> </span>{\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setMessageSource</span><span\n            class="hljs-params">(MessageSource messageSource)</span> </span>{\n\t\t<span class="code-keyword">this</span>.setterMs = messageSource;\n\t}\n}\n\n<span class="code-comment">//从容器直接注入</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">ExtendBean</span> <span class="code-keyword">implements</span> <span class="code-title">MessageSourceAware</span> </span>{\n\t<span class="code-meta">@Autowired</span>\n\t<span class="code-keyword">private</span> MessageSource autowiredMs;\n}</code></pre>\n<p>需要注意的是，使用@Autowired等方式直接获取MessageSource类型的数据得到的是添加到容器的那个Bean，而其他方式获取到的是ApplicationContext。</p>'},377:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<p>在前面两篇介绍Sring核心与设计模式的文章中，分别介绍了<a title="Ioc容器"\n                                   href="https://www.chkui.com/article/spring/spring_core_design_pattern_and_ioc">Ioc容器</a>和\n    <a title="Bean的依赖关系" href="https://www.chkui.com/article/spring/spring_core_design_pattern_and_ioc">Bean的依赖关系</a>。如果阅读过前2文就会知道，Spring的整个运转机制就是围绕着IoC容器以及Bean展开的。IoC就是一个篮子，所有的Bean都向里面扔。除了提供篮子功能创建并存放Bean之外，IoC还要负责管理Bean与Bean之间的关系——依赖注入。之前也提到Bean是Spring核心容器的最小工作单元，Spring一些更高级的功能（例如切面、代理）都是在Bean的基础上实现。\n</p>\n<p>除了管理Bean与Bean之间的关系，IoC还提供了对Bean自身进行控制的各项功能，本文将介绍Bean的<strong>生命周期功能</strong>以及<strong>状态定义功能。</strong></p>\n\n<h2 id="h2-1">前置依赖</h2>\n<p>\n    Bean与Bean之间存在依赖关系，可以是强依赖（通过XML和注解直接声明依赖）、也可以是弱依赖（ApplicationContextAware等方式获取）。当一个Bean需要另外一个Bean完成初始化后自身才能工作时，例如一个Bean依赖DataSoruce，但是DataSource的初始化需要较长时间。这个时候用<em>depends-on</em>声明前置依赖即可：\n</p>\n<pre><code class="xml"><span class="code-comment">&lt;!-- 依赖多个Bean使用,号分割 --&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"beanOne"</span> <span class="hljs-attr">class</span>=<span class="code-string">"ExampleBean"</span> <span\n        class="hljs-attr">depends-on</span>=<span class="code-string">"manager,accountDao"</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"manager"</span> <span class="hljs-attr">ref</span>=<span\n            class="code-string">"manager"</span> /&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"manager"</span> <span class="hljs-attr">class</span>=<span class="code-string">"ManagerBean"</span> /&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"accountDao"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.jdbc.JdbcAccountDao"</span> /&gt;</span></code></pre>\n\n<h2 id="h2-2">延迟加载</h2>\n<p>通常情况下，所有的&nbsp;<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-singleton"\n        rel="nofollow">singleton</a>&nbsp;类型的Bean都会在容器创建后进行初始化，简单的说就是启动Jvm就开始创建（实际上是创建ApplicationContext的某个实现类实例之后）。</p>\n<p>IoC支持所有的&nbsp;<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-singleton"\n        rel="nofollow">singleton</a>&nbsp;Bean在使用时再加载，这样做的好处是可以大大节省初始化的时间。<span style="color:#e74c3c">但是如果你的应用对启动时间的长短并不敏感，建议让所有的&nbsp;</span><a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-singleton"\n        rel="nofollow"><span style="color:#e74c3c">singleton</span></a><span style="color:#e74c3c">&nbsp;都启动时加载。这样可以在启动时就发现一些问题，而不是在运行很久直到使用时才由用户去触发这个问题</span>。或者可以根据场景来使用决定是否延迟，例如开发时使用延迟加载，而在集成测试或上生产时关闭。\n</p>\n<p>可以设置全局延迟加载，也可以设置某个Bean延迟加载：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span> <span class="hljs-attr">default-lazy-init</span>=<span\n        class="code-string">"true"</span>&gt;</span>\n    <span class="code-comment">&lt;!-- 所有的Bean知道使用的时候才会进行加载... --&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<pre><code class="xml"><span class="code-comment">&lt;!-- 只有lazy类延迟加载 --&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"lazy"</span> <span class="hljs-attr">class</span>=<span class="code-string">"com.foo.ExpensiveToCreateBean"</span> <span\n        class="hljs-attr">lazy-init</span>=<span class="code-string">"true"</span>/&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">name</span>=<span\n        class="code-string">"not.lazy"</span> <span class="hljs-attr">class</span>=<span class="code-string">"com.foo.AnotherBean"</span>/&gt;</span></code></pre>\n<p>需要注意的是，在设置某个单独的Bean延迟加载时，如果有某个没有延迟加载的Bean要依赖他，那实际上也会在初始化的时候就加载。</p>\n<p>还要强调一下，这里的“加载”仅仅是为了表示一个类被Ioc创造并放置容器中，和classLoad方法将class文件中的字节码加载到方法区的加载是两个概念。</p>\n<p>延迟加载在设计模式上是单例模式一种延伸，通常也被称为懒汉模式。单例通常有双重锁+volatile、静态类和枚举三种方式实现。在<a\n        href="http://www.baidu.com/link?url=kGkdnL7l_ll3LfLYL8dxNgxmZdGW-wKRbUh6i8wRu2CERbWLWDBkpLtu38Jg9qTx0-KOIOBr6FXsjRwJigZmxa"\n        target="_blank" rel="nofollow">Effective&nbsp;<em>Java</em></a>一书中对三种模式都有深入的解析。而对于Spring容器而言，枚举的方式肯定不好用了，静态类由于属于自身代码级别应该也不会用，所以双重锁的实现方式较为可信。不过我没去看过源码，仅属于猜测。\n</p>\n\n<h2 id="h2-3">生命周期方法</h2>\n<p>一个Bean的创建、使用再到最后销毁称为"Bean的生命周期"。Spring框架为Bean的生命周期各个阶段提供了多种回掉方法来处理各种状态或者数据。</p>\n\n<h3 id="h3-1">初始化方法</h3>\n<p>\n    当一个Bean完成初始化并注入各项参数之后，初始化回掉方法会被调用，简单的说就是完成创建之后会被调用。实现初始化回调方法有2个路径：1.继承org.springframework.beans.factory.InitializingBean接口，然后实现\n    afterPropertiesSet方法。2.在Bean的XML配置上使用init-method属性来制定要调用的初始化：</p>\n<p>继承实现：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.A"</span> /&gt;</span></code></pre>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">A</span> <span class="code-keyword">implements</span> <span class="code-title">InitializingBean</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">afterPropertiesSet</span><span class="hljs-params">()</span></span>{\n        <span class="code-comment">// init</span>\n    }\n}</code></pre>\n<p>配置实现：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span\n        class="code-string">"x.y.A"</span> <span class="hljs-attr">init-method</span>=<span\n        class="code-string">"init"</span> /&gt;</span></code></pre>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">A</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">init</span><span class="hljs-params">()</span></span>{}\n}</code></pre>\n<p>2种方法都等效，实际使用是我们应该使用哪一种方法呢？</p>\n<p>InitializingBean是Spring早期实现的一个生命周期回调方法。但是在JCP推出JSR-250和<a title="JSR-330"\n                                                             href="https://www.chkui.com/article/java/java_jsr330"\n>JSR-330</a>规范之后，Spring的大神们开始意识到基于元编程思想和配置手段来实现非侵入式框架（Not\n    Coupled）才是正道。所以现在都是推荐使用配置文件和JSR-250的@PostConstruct（关于各种Annotation的使用请关注后续的文章）。现在依然保留InitializingBean应该是考虑到兼容问题。</p>\n\n<h3 id="h3-2">销毁方法</h3>\n<p>与创建方法相对应的是销毁方法。当一个类将要被销毁之前，对应的销毁回调方法会被调用。销毁方法也有一个继承实现和配置+注解实现：</p>\n<p>继承实现：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.A"</span> /&gt;</span></code></pre>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">A</span> <span class="code-keyword">implements</span> <span class="code-title">DisposableBean</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">destroy</span><span class="hljs-params">()</span></span>{\n        <span class="code-comment">// 销毁资源</span>\n    }\n}</code></pre>\n<p>配置实现：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span\n        class="code-string">"x.y.A"</span> <span class="hljs-attr">destroy-method</span>=<span class="code-string">"cleanUp"</span> /&gt;</span></code></pre>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">A</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">cleanUp</span><span class="hljs-params">()</span></span>{\n        <span class="code-comment">// 销毁资源</span>\n    }\n}</code></pre>\n<p>依然建议销毁手段也使用配置或@PreDestroy来设定销毁方法。</p>\n\n<h3 id="h3-3">全局配置初始化与销毁方法</h3>\n<p>IoC容器还提供了全局配置初始化与销毁方法的配置：</p>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">A</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">init</span><span class="hljs-params">()</span></span>{\n        <span class="code-comment">// 初始化资源</span>\n    }\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">destroy</span><span class="hljs-params">()</span></span>{\n        <span class="code-comment">// 销毁资源</span>\n    }\n}</code></pre>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span> <span class="hljs-attr">default-init-method</span>=<span\n        class="code-string">"init"</span> <span class="hljs-attr">default-destroy-method</span>=<span\n        class="code-string">"destroy"</span>&gt;</span>\n     <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n             class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span\n             class="code-string">"x.y.A"</span>/&gt;</span>\n     <span class="code-comment">&lt;!-- bean configuration --&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>通过在&lt;beans&gt;标签上使用<em>default-init-method</em>和<em>default-destroy-method</em>&nbsp;属性参数，可以为容器中所有的Bean统一指定初始化和销毁的生命周期方法。\n</p>\n<p>如果在&lt;beans&gt;上设定2个默认的生命周期方法，同时在&lt;bean&gt;上也指定了<em>init-method</em>或<em>destroy-method，</em>回调方法会以&lt;bean&gt;上的配置为准。这样就保证全局配置与单独配置可以共存。\n</p>\n<p>使用初始化或销毁2个生命周期方法注意的要点：</p>\n<ol>\n    <li>\n        初始化和销毁都提供了3种手段：XML配置、注解、以及实现接口。系统的各个部分会交由不同的团队开发，不遵循统一的规范，建议使用满足JSR规范的注解——@PostConstruct、@PreDestroy。如果是统一的团队，准训一致的规范，建议使用&lt;beans&gt;的属性统一名称使用全局配置。\n    </li>\n    <li>如果Bean设计到代理模式时（例如使用了AOP），那么生命周期方法被调用时，有可能代理类还没有被创建出来。因为生命周期方法是实体类完成对应工作之后就会被调用，而与代理类无关。</li>\n</ol>'}});