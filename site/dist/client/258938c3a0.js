webpackJsonp([25],{351:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<h1 id="h1-1">前言</h1>\n<p><em><strong>React </strong></em>作为一项热门的前端开发技术，现在使用它的团队越来越多。之前也介绍了<strong><em>react&nbsp;</em></strong>的所有的特性，但是仅仅了解怎么开发&nbsp;<em><strong>react&nbsp;</strong></em>只走了万里长征的第一步，将&nbsp;<strong><em>react&nbsp;</em></strong>投入到真实应用还会遇到各种各样的问题。\n</p>\n<p>例如SEO需要静态化怎么办？单页面应用一次性加载的资源过大怎么办？样式代码直接写在<em>.js</em>中影响加载怎么办？</p>\n<p>本文介绍如何将&nbsp;<em><strong>react&nbsp;</strong></em>整套技术投入到实际生产应用中，主要包括以下内容：</p>\n<ol>\n    <li>使用&nbsp;<strong><em>react&nbsp;</em></strong>实现单页面应用。</li>\n    <li>整合&nbsp;<em><strong>react-route&nbsp;</strong></em>在&nbsp;<strong><em>nodejs&nbsp;</em></strong>服务中实现页面静态化。\n    </li>\n    <li>使用&nbsp;<em><strong>require.ensure </strong></em>对代码、资源文件进行分片。</li>\n    <li>按需从服务器异步加载不同的&nbsp;<strong><em>react&nbsp;</em></strong>组件。</li>\n    <li>解决&nbsp;<em><strong>webpack&nbsp;</strong></em>中使用<em><strong> require.ensure </strong></em>加载闪现的问题。</li>\n    <li>解决&nbsp;<em><strong>react&nbsp;</strong></em>服务端渲染在浏览器重新渲染的问题。</li>\n    <li>通过&nbsp;<strong><em>redux&nbsp;</em></strong>实现在服务端异步加载数据，并同步前后端数据。</li>\n    <li>单独提取样式文件。</li>\n    <li>最大化分解和压缩所有资源文件。</li>\n</ol>\n<p><strong>在阅读之前需要了解的：</strong></p>\n<p><em><strong>React </strong></em>整个生态发展的非常迅速（混乱）。昨天还感觉在用 webpack1.x\n    ，现在都已经弄出3.0版本了。哥react-route3.x已经玩得贼溜，现在人家又推出了4.x版本了。而且这些关键组件或工具升级之后会导致之前已经写好的代码无法使用。</p>\n<p>本文所使用的所有第三方开源工具都在开发项目时使用的是最新版本（<strong><em>webpack&nbsp;</em></strong>官方已经升级到3.0，我们开发时最新版本还是2.6.1，不过配置上并没有多大改变）。\n</p>\n<p>特别要说明的是<em><strong>react-route&nbsp;</strong></em>。4.x版和3.x版在设计思路上发生了巨大的转变，4.x将dom部分独立出来&nbsp;都以高阶组件的方式提供各种功能。服务端异步渲染仅仅提供了一个&nbsp;<a\n        href="https://reacttraining.com/web/api/StaticRouter" rel="nofollow">&lt;StaticRouter&gt;</a>&nbsp;组件。代码分片异步加载组件需要开发者自己去实现，而在3.x时代\n    <em><strong>react-route </strong></em>提供了可配置的分片功能。</p>\n<p>本文将会从最简单的&nbsp;<em><strong>react&nbsp;</strong></em>静态化页面说起，到最后实现高效完整的 <strong><em>react nodejs</em></strong>\n    服务器。</p>\n<p><span style="color:#FF0000">在阅读之前务必将示例代码clone或下载到本地，本文的所有内容都是围绕示例代码说明的。如果你功力够，甚至可以不看本文直接通过代理理解。代码地址：https://github.com/chkui/react-server-demo。</span>\n</p>\n<pre class="php"><code class="language-bash">$ git <span class="code-built_in"><span\n        class="code-keyword">clone</span></span> https:<span class="code-comment">//github.com/chkui/react-server-demo.git</span>\n$ npm install\n$ <span class="code-comment"><span class="code-comment">#npm run demo</span></span></code></pre>\n<p>如果安装<strong><em>node-sass</em></strong>遇到问题，可以翻墙、<strong><em>cnpm</em></strong>或者用源码编译生成。请参考这里：<a\n       title="Node-Sass安装问题解决" href="https://www.chkui.com/article/nodeJs/install_node_sass">node-sass无法安装的各种解决方案</a>。</p>\n<p>本项目最开始使用的 <strong><em>nodejs </em></strong>版本是6.9.2，后来升级到8.14~8.20。在这些版本上运行均没有遇到问题，但是不保证在其他版本的\n    <strong><em>nodejs </em></strong>中可以顺利运行，尤其是6.9.2之前的版本。</p>\n<p>所写的示例代码没有进行过任何代码检查、浏览器兼容性测试和单元测试，本人在Chrome50以上运行和调试暂未发现问题。</p>\n\n<h1 id="h1-2">1，纯react组件服务端渲染</h1>\n<p>如果前端开发只有\n    <strong><em>react </em></strong>组件（没有&nbsp;<strong><em>redux</em></strong>、<strong><em>route&nbsp;</em></strong>等）且对性能也没有太高要求（无需分片、无需压缩、无需样式分离），实现服务端渲染是非常简单的，相关的介绍文档也多如繁星，基本都是围绕\n    <strong><em>react </em></strong>提供的2个支持输出<em>HTML</em>字符串的渲染方法来说的——\n    <em>ReactDOMServer.renderToStaticMarkup(element)</em><em> </em>和\n    <em>ReactDOMServer.renderToString(element)</em><em> </em>。为了实现前段不重复渲染，本项目使用后者生成HTML<em>。</em>&nbsp;</p>\n<p>同步的关键是 <strong><em>checksum。</em></strong>服务端渲染返回HTML字符串后，会有一个&nbsp;<em>checksum</em>\n    属性标记在根元素上，它是服务端生成<em>HTML</em>的指纹（<em>hash</em>计算）。到客户端进行<strong> 首屏渲染 </strong>时，会对这个 <em>checksum&nbsp;</em>进行校验，如果校验一致仅仅生成虚拟DOM而不会发生真实的DOM渲染<em>。\n        &nbsp;checksum如何确保不会重复渲染的原理</em>可以看这里——<a title="React前后端同构防止重复渲染"\n            href="https://www.chkui.com/article/react/react_server_render_with_checksum">React前后端同构防止重复渲染</a>。\n</p>\n<p>我们先从一个简单的模型开始——<strong><em>1_simple_server_render（以下简称 示例1 ）。示例1 </em></strong>仅用\n    <em><strong>react </strong></em>组件实现了一个非常简单网站，他提供了三种启动方式：</p>\n<ol>\n    <li>仅用于前端开发的<strong><em> webpack-dev </em></strong>启动。</li>\n    <li>用于本地开发的 <em><strong>nodejs </strong></em>开发模式启动。</li>\n    <li>用于发布生产的打包并用 <em><strong>nodejs </strong></em>启动。</li>\n</ol>\n<p><strong><em>示例1 </em></strong>的文件结构：</p>\n<blockquote>\n    <p>--browserEntry.js &nbsp;//浏览器端入口&nbsp;</p>\n    <p>--app.js &nbsp;//应用入口</p>\n    <p>--server.js //开发nodejs服务</p>\n    <p>--build.js //生产打包，用于生产nodejs服务</p>\n    <p>--koa.js //koa服务器启动代码</p>\n    <p>--middleware.js //服务端入口</p>\n    <p>--webpack //webpack相关的配置文件</p>\n    <p>----server-build.js //生产服务器打包</p>\n    <p>----server-dev.js //开发服务器运行</p>\n    <p>----static.js //使用webpack-dev运行React</p>\n    <p>--dist //打包后生成的文件</p>\n</blockquote>\n<p>请各位留意这个文件结构，在后面实现各种功能的时候这个结构很有大意义。</p>\n<p>首先，客户端展示分成了&nbsp;<em>browserEntry</em><em>.js</em> 和&nbsp;<em>app.js</em> 两个文件。在<em>\n    app.js </em>中实现了所有的页面效果，而<em> browserEntry.js </em>仅仅是使用&nbsp;<em>ReactDOM.render( element, container,\n    [callback] ) </em>方法渲染App组件：</p>\n<pre class="javascript"><code class="language-javascript"><span class="code-comment"><span class="code-comment">//index.js</span></span>\n<span class="code-keyword"><span class="code-keyword">import</span></span> App <span class="code-keyword"><span\n            class="code-keyword">from</span></span> <span class="code-string"><span\n            class="code-string">\'./app\'</span></span>\nrender(<span class="xml"><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">App</span></span></span></span><span\n            class="xml"><span class="code-tag"> /&gt;</span></span></span><span class="xml">, document.getElementById(\'root\'))</span></span></code></pre>\n<p>其实完全可以将2个文件合并成一个文件，先留着这个问题继续往下看。</p>\n<p>其次，服务端渲染关联了4个文件，<em> server.js 、 koa.js 、 middleware 、 app.js </em>。他们的关系是：<em>&nbsp;koa.js </em>提供了\n    <em><strong>koa</strong></em>\n    服务的基础功能（ <em><strong>koa</strong></em> 是 <strong><em>express</em></strong> 团队设计的新框架，没用过的可以理解\n    <em><strong>koa</strong></em> 就是一系列中间件，一个请求发送到服务器由这些中间件一个接一个的处理。&nbsp;需要了解请看：<a href="http://koajs.com/"\n                                                                                    rel="nofollow">http://koajs.com/</a>），<em>\n        server.js </em>一开始就require了<em> koa.js </em>获取 <em><strong>koa</strong></em> 服务的实例，然后向\n    <strong><em>koa</em></strong>\n    实例中增加了&nbsp;<em>middleware.js</em> 和其他中间件。</p>\n<pre class="php"><code class="language-javascript"><span class="code-comment"><span\n        class="code-comment">//server.js</span></span>\n<span class="code-keyword"><span class="code-keyword">const</span></span> koa = <span class="code-built_in"><span\n            class="code-keyword">require</span></span>(<span class="code-string"><span\n            class="code-string">\'./koa\'</span></span>),\n    middleware = <span class="code-built_in"><span class="code-keyword">require</span></span>(<span class="code-string"><span\n            class="code-string">\'./middleware\'</span></span>)\nkoa.<span class="code-keyword">use</span>(middleware) <span class="code-comment"><span class="code-comment">//注册</span></span>\nkoa.listen(<span class="hljs-number"><span class="hljs-number">8080</span></span>) <span class="code-comment"><span\n            class="code-comment">//启动监听8080端口</span></span></code></pre>\n<p><em>&nbsp;middleware.js </em>中使用 <em>ReactDOMServer.renderToString(element)</em>\n    对App组件进行渲染生成HTML结构的字符串，然后调用ctx.render通过模板生成页面：</p>\n<pre class="javascript"><code class="language-javascript"><span class="code-keyword"><span\n        class="code-keyword">import</span></span> React <span class="code-keyword"><span\n        class="code-keyword">from</span></span> <span class="code-string"><span\n        class="code-string">\'react\'</span></span>\n<span class="code-keyword"><span class="code-keyword">import</span></span> {renderToString} <span\n            class="code-keyword"><span class="code-keyword">from</span></span> <span class="code-string"><span\n            class="code-string">\'react-dom/server\'</span></span>\n<span class="code-keyword"><span class="code-keyword">import</span></span> App <span class="code-keyword"><span\n            class="code-keyword">from</span></span> <span class="code-string"><span\n            class="code-string">\'./app\'</span></span>\n\n<span class="code-comment"><span class="code-comment">//用于生成页面的中间件</span></span>\n<span class="code-keyword"><span class="code-keyword">async</span></span> <span class="hljs-function"><span\n            class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">function</span></span></span><span class="hljs-function"> </span><span\n            class="code-title"><span class="hljs-function"><span class="code-title">middleware</span></span></span><span\n            class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span\n            class="hljs-params">ctx, next</span></span></span><span class="hljs-function">) </span></span>{\n    <span class="code-keyword"><span class="code-keyword">if</span></span>(ctx.url === <span class="code-string"><span\n            class="code-string">\'/\'</span></span>){\n        <span class="code-comment"><span class="code-comment">//使用renderToString渲染&lt;App /&gt;组件得到一个字符串</span></span>\n        <span class="code-keyword"><span class="code-keyword">const</span></span> dom = renderToString(<span\n            class="xml"><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">App</span></span></span></span><span\n            class="xml"><span class="code-tag">/&gt;</span></span></span></span>)\n        <span class="code-comment"><span class="code-comment">//使用之前view中间件生成的模板渲染引擎生成HTML文本</span></span>\n        <span class="code-keyword"><span class="code-keyword">await</span></span> ctx.render(<span\n            class="code-string"><span class="code-string">\'index\'</span></span>, {\n            root: dom\n        })\n    }<span class="code-keyword"><span class="code-keyword">else</span></span> {<span class="code-comment"><span\n            class="code-comment">//如果不是访问的根目录，则交由下一个中间件</span></span>\n        <span class="code-keyword"><span class="code-keyword">return</span></span> next();\n    }\n}</code></pre>\n<p>在上面的过程，<em> app.js </em>在服务端和客户端渲染都使用到了，所以这一块是可以前后端同构的。而<em> browserEntry.js </em>和 <em>middleware.js </em>分别负责将app在浏览器和服务端渲染出来，他们分别是浏览器端的入口和服务端的入口。\n</p>\n<p>最后还剩下一个<em> build.js </em>，仔细观察会发现他的结构其实和<em>&nbsp;server.js </em>是一模一样的——都是先获取一个koa实例，然后添加中间件，只是去除了许多开发用的工具：</p>\n<pre class="javascript"><code class="language-javascript"><span class="code-keyword"><span\n        class="code-keyword">import</span></span> serve <span class="code-keyword"><span\n        class="code-keyword">from</span></span> <span class="code-string"><span class="code-string">\'koa-static\'</span></span>\n<span class="code-keyword"><span class="code-keyword">import</span></span> path <span class="code-keyword"><span\n            class="code-keyword">from</span></span> <span class="code-string"><span\n            class="code-string">\'path\'</span></span>\n<span class="code-keyword"><span class="code-keyword">import</span></span> views <span class="code-keyword"><span\n            class="code-keyword">from</span></span> <span class="code-string"><span\n            class="code-string">\'koa-views\'</span></span>\n<span class="code-keyword"><span class="code-keyword">import</span></span> koa <span class="code-keyword"><span\n            class="code-keyword">from</span></span> <span class="code-string"><span\n            class="code-string">\'./koa\'</span></span>\n<span class="code-keyword"><span class="code-keyword">import</span></span> middleware <span class="code-keyword"><span\n            class="code-keyword">from</span></span> <span class="code-string"><span\n            class="code-string">\'./middleware\'</span></span>\n<span class="code-keyword"><span class="code-keyword">const</span></span> dir = <span class="code-built_in"><span\n            class="code-built_in">eval</span></span>(<span class="code-string"><span\n            class="code-string">\'__dirname\'</span></span>),  <span class="code-comment"><span class="code-comment">//编译时不执行，运行时在打包之后的环境获取相对位置</span></span>\n    port = <span class="hljs-number"><span class="hljs-number">8080</span></span>,\n    maxAge = <span class="hljs-number"><span class="hljs-number">86000</span></span>,\n    gzip = <span class="hljs-literal"><span class="hljs-literal">true</span></span>,\n    viewsPath = path.resolve(dir, <span class="code-string"><span class="code-string">\'../views\'</span></span>),\n    staticPath = path.resolve(dir, <span class="code-string"><span class="code-string">\'../client\'</span></span>),\n    log = <span class="code-built_in"><span class="code-built_in">console</span></span>.log\n\nlog(<span class="code-string"><span class="code-string">\'views path:\'</span></span>, viewsPath)\nlog(<span class="code-string"><span class="code-string">\'static path:\'</span></span>, staticPath)\nlog(<span class="code-string"><span class="code-string">\'static cache age:\'</span></span>, maxAge, <span\n            class="code-string"><span class="code-string">\'milliseconds\'</span></span>)\nlog(gzip ? <span class="code-string"><span class="code-string">\'gzip able\'</span></span> : <span\n            class="code-string"><span class="code-string">\'gzip disable\'</span></span>)\n\n<span class="code-comment"><span class="code-comment">//页面模板</span></span>\nkoa.use(views(viewsPath, {map: {html: <span class="code-string"><span class="code-string">\'ejs\'</span></span>}}))\n<span class="code-comment"><span class="code-comment">//静态资源管理， js、css等</span></span>\nkoa.use(serve(staticPath, {\n    maxage: maxAge,\n    gzip: gzip\n}))\nkoa.use(middleware)\nkoa.listen(port || <span class="hljs-number"><span class="hljs-number">8080</span></span>)\n<span class="code-built_in"><span class="code-built_in">console</span></span>.log(<span class="code-string"><span\n            class="code-string">`\\n Open up http://localhost:</span><span class="hljs-subst"><span\n            class="code-string"><span class="hljs-subst">${port}</span></span></span><span class="code-string">/ in your browser.\\n`</span></span>)\n</code></pre>\n<p><em>&nbsp;build.js </em>是用来打包生产服务器的，打包完成后可以直接使用node启动。webpack文件夹里就包含了打包用的webpack配置。</p>\n<p>在工程根目录运行以下脚本 ：</p>\n<pre class="php"><code class="language-bash"><span class="code-comment"><span\n        class="code-comment">#-------------------</span></span>\n<span class="code-comment"><span class="code-comment">#使用webpack/static.js启动webpack-dev运行React组件。用于日常开发</span></span>\nnpm run <span class="hljs-number">1</span>-<span class="code-keyword">static</span>\n\n<span class="code-comment"><span class="code-comment">#--------------------</span></span>\n<span class="code-comment"><span\n        class="code-comment">#使用webpack/server-dev.js启动一个node服务器提供React渲染。用于需要服务端的开发。</span></span>\nnpm run <span class="hljs-number">1</span>-dev\n\n<span class="code-comment"><span class="code-comment">#---------------------</span></span>\n<span class="code-comment"><span\n        class="code-comment">#使用webpack/server-build.js打包服务，会在dist文件中生成view、client、server三个目录</span></span>\nnpm run <span class="hljs-number">1</span>-build\n<span class="code-comment"><span class="code-comment">#运行打包之后的服务器，可以将dist中的文件部署到服务器运行</span></span>\nnpm run <span class="hljs-number">1</span>-run </code></pre>\n<p>分别运行上面的脚本后，在浏览器输入<em> http:// localhost:8080 </em>均看到相同的页面，但是打开开发人员工具，可以看到许多有意思的东西。例如查看首屏传输的数据，服务端渲染的首屏已经包含了完成HTML文档以及用React用于校验文本一致性的\n    <em><strong>checksum</strong></em> ，而运行&nbsp;<span style="color:#FFFFFF"><em><span style="background-color:#000000">&nbsp; $&nbsp;npm run 1-static &nbsp;&nbsp;</span></em></span>&nbsp;的\n    <em>webpack-dev</em> 启动时什么都没有。</p>\n<p>服务端渲染，从服务器传递而来的HTML中#root中已经包含了DOM：</p>\n<p><img alt="React 构建用于生产的静态化单页面服务" height="385"\n        src="https://file.mahoooo.com/res/file/react_establish_server_render_for_production_1.png" width="955"></p>\n<p><em>webpack-dev </em>启动，仅引入js文件，需要等 <em><strong>react</strong></em> 开始运行后，才会向#id元素中添加DOM：</p>\n<p><img alt="React 构建用于生产的静态化单页面服务" height="378"\n        src="https://file.mahoooo.com/res/file/react_establish_server_render_for_production_2.png" width="623"></p>\n<p>至此，我们已经实现了非常简单的单页面应用服务端渲染。但是距离投入生产远远不够。我们的 <em>.css</em>\n    文件还没有分离；服务器只实现了渲染简单的dom，更多的情况是我们需要在服务端使用异步请求组装数据；单页面应用一次性加载资源过大怎么处理？我们需要将资源文件分离，并且按页面加载；我们还没有整合<strong><em>react-route</em></strong>\n    和 <strong><em>redux&nbsp;</em></strong>。如果你还有兴趣请接着往下看。</p>\n\n<h1 id="h1-3">2，完整可用的单页面应用服务端渲染</h1>\n<p>为了能将我们开发的工程投入实际生产应用，需要引入 <strong><em>react-route</em></strong> 来为单页面应用提供路由功能、引入<strong><em>redux</em></strong>\n    统一管理数据、将样式抽取到独立&nbsp;<em>.css</em>&nbsp;文件、在服务端异步组织数据。<em><strong>2_route_redux_render</strong></em>在前面所介绍的<strong><em>示例1 </em>&nbsp;</strong>的基础上实现了所有这些特性。\n</p>\n<p><strong><em>2_route_redux_render</em>（以下简称 <em>示例2 </em>）</strong>是一个非常简单的搜索网站，会针对 <em>github.com</em>\n    的内容进行搜索。<strong><em>示例2 </em></strong>只有2个页面，一个搜索首页、一个搜索的结果列表页，这样布局仅仅为了便于说明问题。<strong><em>示例2 </em></strong>在<strong><em>示例1</em></strong>&nbsp;的基础上增加了以下内容：\n</p>\n<ol>\n    <li>引入<a href="https://reacttraining.com/react-router/" rel="nofollow">react-router</a>，在config.js文件中配置路由列表（routes）。\n    </li>\n    <li>引入<a href="http://redux.js.org/" rel="nofollow">react-redux</a>，在config.js文件中配置reducer。</li>\n    <li>增加了样式。</li>\n</ol>\n<p>运行&nbsp;<span style="color:#FFFFFF"><span\n        style="background-color:#000000"> &nbsp;$ npm run 2-static &nbsp;</span></span> &nbsp;启动\n    <em>webpack-dev</em> 后在浏览器输入<em> http://localhost:8080/ </em>可以看到下图这样的静态页面的效果：</p>\n<p><img alt="React 构建用于生产的静态化单页面服务" height="334"\n        src="https://file.mahoooo.com/res/file/react_establish_server_render_for_production_3.png" width="886"></p>\n<p>在搜索框输入要搜索的内容按回车会跳转到搜索的结果列表页。</p>\n<p>首页提供了3个下拉菜单，前两项用于搜索而最后一个下拉菜单可以选择 <strong>前端跳转</strong> 还是通过 <strong>服务器跳转</strong>。</p>\n<p>现在我们停掉刚启动的 <em>webpack-dev ，</em>使用开发服务器启动。运行以下内容：</p>\n<pre class=""><span class="code-variable">$ </span>npm run <span class="hljs-number">2</span>-dev</pre>\n<p>启动成功后（输出类似“webpack built 8ab71feb1d9a410ffd00 in\n    4760ms”的内容）我们就可以分别尝试在浏览器端通过异步请求组装页面，以及在服务器端组装页面并以静态HTML页面的方式发送到浏览器。</p>\n<p>在首页（localhost:8080）最右边的下拉菜单选择“前端”然后进行搜索，会发现 <strong><em>nodejs</em></strong>\n    服务器没有接收到任何请求，而浏览器会出现一个加载效果，等待十几秒之后完成数据组装。如果选择“服务器”，搜索时会发现 <strong><em>nodejs</em></strong>\n    服务器输出很多内容，等待十几秒后浏览器直接出现了结果页面而没有任何加载效果。</p>\n<p>你也可以将代码打成生产包进行测试：</p>\n<pre class=""><code class="language-bash"><span class="code-variable">$ </span>npm run render-build\n<span class="code-comment"><span class="code-comment">#打包成功后</span></span>\n<span class="code-variable">$ </span>npm run render-run</code></pre>\n<p>浏览器渲染和服务端渲染最大的区别可以看HTML的源码。没有服务端渲染的浏览器HTML结构是这样的：</p>\n<p><img alt="React 构建用于生产的静态化单页面服务" height="237"\n        src="https://file.mahoooo.com/res/file/react_establish_server_render_for_production_4.png" width="1094"></p>\n<p>没有任何内容，只有要运行的 <em>.js</em> 文件，等待 <strong><em>react</em></strong> 向#root中添加DOM。</p>\n<p>而通过服务器去渲染HTML源码是这样的：</p>\n<p><img alt="React 构建用于生产的静态化单页面服务" height="301"\n        src="https://file.mahoooo.com/res/file/react_establish_server_render_for_production_5.png" width="1273"></p>\n<p>HTML源码已经有了实质内容。下面那一堆BASE64编码是首页的图片，已经通过后台加载好了。</p>\n<p>各位童鞋可以通过各种方式运行DEMO来验证效果。</p>\n<p><strong>如何实现？</strong></p>\n<p><strong>首先，和示例1一样，将浏览器端渲染和服务端渲染分为2个入口。</strong></p>\n<p><em>&nbsp;app.js </em>依然是仅仅使用 React 实现的页面组件，<em> browserEntry.js </em>是用于浏览器端渲染的入口，而<span\n        style="background-color:#A9A9A9"> </span><em>middleware/entry.js&nbsp;</em>是服务端渲染的入口。与\n    <em><strong>示例1</strong></em> 相比 <em>browserEntry.js </em>&nbsp;引入了<em> &lt;Provider&gt;</em> 和 <em>&lt;BrowserRourer&gt;</em>\n    组件，他们分别用于<a href="http://redux.js.org/docs/basics/UsageWithReact.html" rel="nofollow"> react-redux </a>和 <a\n            href="https://reacttraining.com/react-router/" rel="nofollow">react-router </a>：</p>\n<pre class="lisp"><code class="language-html xml">render(\n    <span class="code-tag"><span class="code-name">&lt;</span><span class="code-name"><span\n            class="code-name">Provider</span></span> <span class="hljs-attr">store</span>=<span class="code-string">{build(<span\n            class="code-name">reducers</span>,</span> <span class="hljs-attr">window.REDUX_STATE</span>)}&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">BrowserRouter</span>&gt;</span><span\n            class="code-tag">&lt;<span class="code-name">App</span>/&gt;</span><span class="code-tag">&lt;/<span\n            class="code-name">BrowserRouter</span>&gt;</span>\n    <span class="code-tag">&lt;/<span\n            class="code-name">Provider</span>&gt;</span>, document.getElementById(\'root\'))</code></pre>\n<p>服务端的入口将 <em>&lt;BrowserRourer&gt;</em> 组件更换为 <em>&lt;StaticRouter&gt;</em>，原因参看&nbsp;<a\n        href="https://reacttraining.com/react-router/web/guides/server-rendering" rel="nofollow">react-router官方关于服务端渲染的说明</a>。\n</p>\n<p><strong>其次，使用redux组装异步数据。</strong></p>\n<p><strong><em>redux </em></strong>在这里起到一个很核心的作用是同步前后端的数据。数据会在服务端渲染 <em><strong>react</strong></em>\n    组件之前就通过<em>action</em>\n    完成数据的组装，然后在渲染时传入携带数据的store进行渲染。</p>\n<p>所以 <strong><em>示例2</em></strong> 将koa的中间件分为2个，一个用于组装redux的数据，一个用于完成渲染。<em>middleware/store.js</em>用于组装\n    <strong><em>redux</em></strong> 数据：</p>\n<pre class="php"><code class="language-javascript"><span class="code-keyword">async</span> <span\n        class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span\n        class="code-keyword">function</span></span></span><span class="hljs-function"> </span><span\n        class="code-title"><span class="hljs-function"><span class="code-title">reduxStore</span></span></span><span\n        class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-params"><span\n        class="hljs-function"><span class="hljs-params">ctx, next</span></span></span><span class="hljs-function"><span\n        class="hljs-params">)</span> </span></span>{\n    ctx.isRoutes = isRoutes(ctx.url) <span class="code-comment"><span\n            class="code-comment">//判断当前请求是否属于路由列表</span></span>\n    <span class="code-keyword"><span class="code-keyword">if</span></span> (ctx.isRoutes) {\n        <span class="code-keyword"><span class="code-keyword">try</span></span> {\n            ctx.store = <span class="code-keyword">await</span> <span class="code-keyword"><span class="code-keyword">new</span></span> <span\n            class="code-built_in">Promise</span>((resolve, reject) =&gt; {\n                processStore(resolve, build(reducers), ctx.url) <span class="code-comment"><span class="code-comment">//使用process组装列表页面的数据</span></span>\n            })\n        } <span class="code-keyword"><span class="code-keyword">catch</span></span> (err) {\n            <span class="code-built_in">console</span>.error(<span class="code-string"><span class="code-string">\'process fluxStore error\'</span></span>, err)\n        }\n        <span class="code-keyword"><span class="code-keyword">return</span></span> next()\n    } <span class="code-keyword"><span class="code-keyword">else</span></span> {\n        <span class="code-keyword"><span class="code-keyword">return</span></span> next()\n    }\n}\n\n<span class="code-keyword"><span class="code-keyword">const</span></span> processStore = (resolve, store, url) =&gt; {\n    <span class="code-keyword"><span class="code-keyword">const</span></span> prefix = <span class="code-string"><span\n            class="code-string">\'/p/details/\'</span></span>, <span class="code-comment"><span class="code-comment">//用于判断是否是列表页面</span></span>\n        paramStr = url.replace(prefix, <span class="code-string"><span class="code-string">\'\'</span></span>)\n    url.startsWith(prefix) &amp;&amp; <span class="code-string"><span class="code-string">\'\'</span></span> !== paramStr ? (()=&gt;{\n        <span class="code-keyword"><span class="code-keyword">const</span></span> params = paramStr.split(<span\n            class="code-string"><span class="code-string">\'/\'</span></span>)\n        <span class="code-keyword"><span class="code-keyword">if</span></span>(<span class="hljs-number"><span\n            class="hljs-number">2</span></span> &lt; params.length){\n            store.subscribe(()=&gt;{ <span class="code-comment"><span class="code-comment">//监听store的数据变更</span></span>\n                <span class="code-keyword"><span class="code-keyword">const</span></span> <span class="code-keyword">list</span> = store.getState().detailList\n                <span class="code-keyword">list</span> &amp;&amp; <span class="hljs-number"><span\n            class="hljs-number">0</span></span> &lt; <span class="code-keyword">list</span>.length &amp;&amp; resolve(store) <span\n            class="code-comment"><span class="code-comment">//list获取数据后，执行next()</span></span>\n            })\n            store.dispatch(requestList(params[<span class="hljs-number"><span class="hljs-number">0</span></span>],params[<span\n            class="hljs-number"><span class="hljs-number">1</span></span>],params[<span class="hljs-number"><span\n            class="hljs-number">2</span></span>])) <span class="code-comment"><span\n            class="code-comment">//调用action更新数据</span></span>\n        } <span class="code-keyword"><span class="code-keyword">else</span></span> {\n            resolve(store)\n        }\n    })():resolve(store)\n}</code></pre>\n<p><em>reduxStore(ctx, next)</em> 方法是 <strong><em>koa</em></strong> 中间件的常规入口，而组装数据的关键是 <em>processStore(resolve,\n    store, url)&nbsp;</em>方法，执行以下内容：</p>\n<ol>\n    <li>判断是否为列表页面。</li>\n    <li>获取传递的 <em>restfull</em> 参数。</li>\n    <li>使用 <em>dispatch(action)</em> 方法来更新 <em>store</em> 中的数据。</li>\n    <li>使用 <em>subscribe(listener)</em> 方法监听数据的变更，发现列表完成更新之后调用 <em>promise</em> 的 <em>resolve</em>方法执行下一个中间件。</li>\n</ol>\n<p>当访问列表页时，通过以上过程会完成一次 <em>store</em> 的数据更新。然后在<em>&nbsp;&nbsp;middleware/entry.js\n    &nbsp;&nbsp;</em>中会将这个更新之后的store直接传入<em>&lt;Provider&gt; </em>用于组装组件。同时，<em>store</em>\n    中的数据也会通过页面模板写到页面上让前端也同时使用他初始化 <em>store</em> 数据。</p>\n<p><strong>最后，分离样式。</strong></p>\n<p>我们直接使用 <strong><em>webpack</em></strong> 的 <em>ExtractTextPlugin</em>\n    （https://www.npmjs.com/package/extract-text-webpack-plugin）插件提取出独立的CSS文件：</p>\n<pre class="clojure"><code class="language-javascript">{\n            test: <span class="hljs-regexp">/\\.scss$/</span>,\n            use: ExtractTextPlugin.extract({\n                fallback: <span class="code-string">\'style-loader\'</span>,\n                use: [\n                    <span class="code-string">\'css-loader?modules&amp;camelCase&amp;importLoaders=1&amp;localIdentName=[local][hash:base64:5]\'</span>,\n                    {\n                        loader: <span class="code-string">\'postcss-loader\'</span>,\n                        options: {\n                            plugins: <span class="hljs-function"><span class="code-keyword">function</span> (<span\n            class="hljs-params"></span>) </span>{\n                                <span class="code-keyword">return</span> [\n                                    <span class="code-built_in">require</span>(<span class="code-string"><span\n            class="code-name">\'autoprefixer\'</span></span>)()\n                                ]<span class="code-comment">;</span>\n                            }\n                        }\n                    },\n                    <span class="code-string">\'sass-loader\'</span>]\n            })\n        }</code></pre>\n<p>在转换成 <em>.css</em>\n    文件之前经过了4步处理：1）<strong><em>sass-loader&nbsp;</em></strong>转换&nbsp;<strong><em>sass</em></strong>；2）<em><strong>postcss-loader&nbsp;</strong></em>生成浏览器兼容样式(生成\n    <em>-ms-</em> 或 <em>-webkit-</em> 这样的前缀)；3）<strong><em>css-loader&nbsp;</em></strong>生成命名规则；4）生成 <em>css</em>\n    样式并统一提取到一个 <em>.css</em> 文件中。如果工程使用其他工具（比如 <em><strong>less</strong></em> 等）需要适当修改这个过程。</p>\n\n<h1 id="h1-4">3，代码分片、合并、压缩以及服务器管理</h1>\n<p>如果你的工程代码不多并且对性能要求不高，<strong><em>示例2 </em></strong>的介绍的方法基本够用了。但是如果代码量太大，单页面应用一次性加载所有的代码确实体验会比较差。最后这一部分会介绍如何再深入优化React单页面应用。\n</p>\n<p><strong><em>3_compress_ensure_render </em></strong>（以下简称 <strong><em>示例3</em></strong> ）在\n    <strong><em>示例2</em></strong> 的基础上进行了些许修改：</p>\n<ol>\n    <li>增加了一个新的页面——&nbsp;<em>localhost:8080/p/ext/page</em>。</li>\n    <li><em>config.js</em> 中的路由列表（routes）的 component 调整为使用 <em>require.ensure</em>&nbsp;异步加载组件。</li>\n    <li>修改 <em>webpack/server-build.js&nbsp;</em>的打包脚本配置，使之可以支持分片和压缩。</li>\n    <li>新增一个服务端中间件——<em>page</em>，用于在进行服务端渲染之前先生成当前页面的对象。</li>\n    <li>修改2个入口（<em>browserEntry.js</em>和 <em>middleware/entry.js</em>）以及&nbsp;<em>app.js</em>，以支持页面组件优先渲染功能。</li>\n    <li>实现了一个 <em>bundle</em> 高阶组件用于异步加载页面。</li>\n    <li>将 <em>fetch</em> 方法调整为异步获取。</li>\n</ol>\n\n<h2 id="h2-1">代码分片</h2>\n<p><em><strong>示例3</strong></em> 是优化最终发布上线的版本，所以我们仅仅关注打包和运行。执行以下命令：</p>\n<pre class=""><span class="code-variable">$ </span>npm run <span class="hljs-number">3</span>-build</pre>\n<p>打包完成后 <em>dist/client </em>目录中生成了以下文件：</p>\n<p><img alt="React 构建用于生产的静态化单页面服务" height="192"\n        src="https://file.mahoooo.com/res/file/react_establish_server_render_for_production_6.png" width="663"></p>\n<p>整个工程的前端打包后就这么多内容，一共8个资源文件，不到600KB。实际上黄色警告部分的分片是永远不会传输到浏览器端的，<strong><em>node-fetch</em></strong>只会在服务端使用，所以整个工程只有280KB左右（包括所有第三方组件、所有第三方工具以及一张图片）有可能会传递到前端。我们将分片之后的资源文件和\n    <strong><em>示例2</em></strong> 未分片的资源文件进行比较：</p>\n<p><img alt="React 构建用于生产的静态化单页面服务" height="104"\n        src="https://file.mahoooo.com/res/file/react_establish_server_render_for_production_7.png" width="693"></p>\n<p><em><strong>示例2</strong></em>\n    将除了样式之外的所有的资源都打包到了bundle.js中，并且整个文件有1.83MB。如果是一个移动端应用，一次加载1.83MB的内容确实会影响体验（使用gzip之后可以缩小到600KB左右，但是示例代码本来就很少，对于一个庞大的工程，显然是不可接受的）。\n</p>\n<p><strong>对于单页面应用我们需要什么？</strong></p>\n<ol>\n    <li>将所有的第三方组件单独打包到一个js文件中，因为这些组件几乎很少变动。浏览器可以长期缓存。</li>\n    <li>将自己工程中的公有组件单独打包到一个js文件中。虽然这些组件没有第三方组件稳定，但是相对业务代码还是比较稳定的，浏览器也可以长期缓存。</li>\n    <li>每一个页面的组件都按需加载，等待react-route打开这个页面时再加载对应的资源。因为按照产品的尿性理论80%的用户只会用到20%的功能，没必要一开始就加载TA根本用不到的资源。</li>\n    <li>将仅用于服务端的代码尽量隔离出去，没必要传输到浏览器。</li>\n</ol>\n<p>根据以上需求，我们使用webpack的分片功能进行打包。</p>\n<p><strong>首先，使用&nbsp;<em> require.ensure</em> &nbsp;标记需要异步加载的组件。</strong></p>\n<p><em>require.ensure</em>&nbsp;是CMD异步加载的规范，<strong><em>webpack</em></strong>里实现了这个功能。我们在路由列表中用&nbsp;<em>\n    require.ensure </em>异步加载每个页面：</p>\n<pre class="php"><code class="language-javascript">{\n    id:<span class="code-string"><span class="code-string">\'details\'</span></span>,\n    name:<span class="code-string"><span class="code-string">\'details\'</span></span>,\n    url:<span class="code-string"><span class="code-string">\'/p/details/:text/:language/:order\'</span></span>,\n    component: (call)=&gt; { <span class="code-comment"><span class="code-comment">//加载组件的回调</span></span>\n        <span class="code-built_in"><span class="code-keyword">require</span></span>.ensure([], <span\n            class="code-built_in"><span class="code-keyword">require</span></span> =&gt; {\n            call(<span class="code-built_in"><span class="code-keyword">require</span></span>(<span class="code-string"><span\n            class="code-string">\'./component/details\'</span></span>))\n        }, <span class="code-string"><span class="code-string">\'details\'</span></span>)\n    }\n}</code></pre>\n<p>修改&nbsp;<strong><em>react-route</em></strong> 的 <em>Route</em> 组件参数，用高阶组件 <em>bundle</em>&nbsp;将原始组件包裹住：</p>\n<pre class="xml"><code class="language-javascript"><span class="code-comment">//Route的component参数传递的是bundle组件</span>\n<span class="code-keyword">const</span> Section = props =&gt;\n    <span class="code-tag">&lt;<span class="code-name">section</span>&gt;</span>\n        {routes.map(i =&gt; <span class="code-tag">&lt;<span class="code-name">Context</span> <span class="hljs-attr">key</span>=<span\n            class="code-string">{i.id}</span> <span class="hljs-attr">path</span>=<span\n            class="code-string">{i.url}</span>\n                                  <span class="hljs-attr">component</span>=<span\n                class="code-string">{bundle(props.id,</span> <span class="hljs-attr">props.component</span>, <span\n                class="hljs-attr">i.component</span>)}/&gt;</span>)}\n    <span class="code-tag">&lt;/<span class="code-name">section</span>&gt;</span>\nconst Context = props =&gt;\n    <span class="code-tag">&lt;<span class="code-name">Route</span> <span class="hljs-attr">exact</span> <span\n            class="hljs-attr">path</span>=<span class="code-string">{props.path}</span> <span class="hljs-attr">component</span>=<span\n            class="code-string">{props.component}/</span>&gt;</span></code></pre>\n<p>在高阶组件&nbsp;<em>bundle</em> 中实现组件异步加载：</p>\n<pre class="kotlin"><code class="language-javascript"><span class="code-keyword">const</span> bundle = (initId, initComponent, getComponentFoo) =&gt; {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="hljs-class"><span\n            class="code-keyword"><span class="hljs-class"><span class="code-keyword">class</span></span></span><span\n            class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-title">extends</span></span></span><span\n            class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n            class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n            class="hljs-class"><span class="code-title">Component</span></span></span><span class="hljs-class"> </span></span>{\n        <span class="code-keyword"><span class="code-keyword">constructor</span></span>(...props) {\n            <span class="code-keyword"><span class="code-keyword">super</span></span>(...props)\n            <span class="code-keyword"><span class="code-keyword">this</span></span>.state = {Comp: {}}\n            <span class="code-keyword"><span class="code-keyword">this</span></span>.async = <span class="code-keyword"><span\n            class="code-keyword">this</span></span>.async.bind(<span class="code-keyword"><span class="code-keyword">this</span></span>)\n        }\n\n        <span class="code-keyword">async</span>(Comp) {\n            <span class="code-comment"><span class="code-comment">//组件获取成功后，将其设置到state中触发渲染</span></span>\n            <span class="code-keyword"><span class="code-keyword">this</span></span>.setState({Comp: Comp})\n        }\n\n        componentWillMount() {\n            <span class="code-comment"><span class="code-comment">//装载完成后，调用routes中配置的异步方法获取组件</span></span>\n            !<span class="code-keyword"><span class="code-keyword">this</span></span>.state.Comp &amp;&amp; getComponentFoo(<span\n            class="code-keyword"><span class="code-keyword">this</span></span>.async)\n        }\n\n        render() {\n            <span class="code-keyword">const</span> {Comp} = <span class="code-keyword"><span\n            class="code-keyword">this</span></span>.state\n            <span class="code-comment"><span class="code-comment">//如果组件已加载则渲染组件，如果未加载则不添加任何Dom</span></span>\n            <span class="code-keyword"><span class="code-keyword">return</span></span> Comp ? (<span class="xml"><span\n            class="code-tag">&lt;<span class="code-name">Comp</span> {<span class="hljs-attr">...<span\n            class="code-keyword">this</span>.props</span>}/&gt;</span>) : <span class="hljs-literal">null</span>\n        }\n    }\n}</span></code></pre>\n<p><em>bundle </em>第一次渲染时，会先装载一个 <em>null </em>然后使用 <em>routes</em> 列表的component方法异步获取组件。</p>\n<p><strong>其次，通过 <em>webpack</em> 配置标记分片规则。</strong></p>\n<p>在webpack的打包配置文件中（<em>./3_compress_ensure_render/webpack/server-build</em>）先指定2个入口和输出规则：</p>\n<pre class="less"><code class="language-javascript"><span class="code-comment"><span\n        class="code-comment">//20行</span></span>\n   <span class="code-attribute">entry</span>: {\n        <span class="code-attribute">bundle</span>: <span class="code-string"><span class="code-string">\'./browserEntry.js\'</span></span>,\n        <span class="code-attribute">vendor</span>: [\n            <span class="code-string"><span class="code-string">\'react\'</span></span>,\n            <span class="code-string"><span class="code-string">\'react-dom\'</span></span>,\n            <span class="code-string"><span class="code-string">\'react-redux\'</span></span>,\n            <span class="code-string"><span class="code-string">\'react-router\'</span></span>,\n            <span class="code-string"><span class="code-string">\'react-router-dom\'</span></span>,\n            <span class="code-string"><span class="code-string">\'redux\'</span></span>,\n            <span class="code-string"><span class="code-string">\'redux-logger\'</span></span>,\n            <span class="code-string"><span class="code-string">\'redux-thunk\'</span></span>\n        ]\n    }，\n    <span class="code-attribute">output</span>: {\n        <span class="code-attribute">path</span>: path.resolve(__dirname, <span class="code-string"><span\n            class="code-string">\'..\'</span></span>, <span class="code-string"><span\n            class="code-string">\'./dist/client\'</span></span>),\n        <span class="code-attribute">filename</span>: <span class="code-string"><span class="code-string">\'[name][hash:8].js\'</span></span>,\n        <span class="code-attribute">chunkFilename</span>: <span class="code-string"><span class="code-string">\'[name][chunkhash:8].js\'</span></span>,\n        <span class="code-attribute">publicPath</span>: <span class="code-string"><span\n            class="code-string">\'/\'</span></span>\n    },\n<span class="code-comment"><span class="code-comment">//</span></span></code></pre>\n<p><em>bundle</em>&nbsp;是我们业务代码的入口、<em>vendor </em>用来标记所有的第三方组件。输出部分增加了hash标记，这主要用于浏览器和CDN长期缓存。</p>\n<p>使用&nbsp;<em> CommonsChunkPlugin</em>&nbsp;插件对代码进行分片：</p>\n<pre class="actionscript"><code class="language-javascript">[\n<span class="code-comment"><span class="code-comment">//78行</span></span>\n<span class="code-keyword"><span class="code-keyword">new</span></span> webpack.optimize.CommonsChunkPlugin({\n    name: [<span class="code-string"><span class="code-string">\'bundle\'</span></span>, <span class="code-string"><span\n            class="code-string">\'vendor\'</span></span>],\n    filename: <span class="code-string"><span class="code-string">\'[name][chunkhash:8].js\'</span></span>\n}),\n<span class="code-keyword"><span class="code-keyword">new</span></span> webpack.optimize.CommonsChunkPlugin({\n    name: <span class="code-string"><span class="code-string">\'manifest\'</span></span>\n}),\n<span class="code-comment"><span class="code-comment">//</span></span>\n]</code></pre>\n<p>这里引入了2次插件。前者用于生成所有的代码分片，而后者用于生成manifest文件。</p>\n<blockquote>\n    <p><strong>为什么要生成manifest</strong>：webpack打包会通过编号来标记每个module，而打包编译之后的代码是通过编号来加载module的。这些编号即使代码没有修改每次打包也可能变动，因此引入一个\n        manifest 文件来保存变动部分，有利于缓存，详情可以 <a href="https://webpack.js.org/concepts/manifest/" rel="nofollow">查看官网关于manifest的说明</a>\n        。</p>\n</blockquote>\n<p><strong>最后，<em>webpack</em> 会根据&nbsp;<em>&nbsp;require.ensure </em>&nbsp;在代码中的标记以及配置生成上图中每一个分片</strong>：</p>\n<ul>\n    <li>node-fetch.js：仅用于服务器端的fetch工具。我们在加载它的代码中特别使用了&nbsp;<em>require.ensure目的就是将其分离出来。</em></li>\n    <li>home.js：首页对应的组件。</li>\n    <li>extPage.js：/p/ext/page页面对应的组件。</li>\n    <li>vendor.js：entry中指定要单独打包的第三方工具，包括react、react-route、redux等。</li>\n    <li>manifext.js：webpack runtime部分的代码。</li>\n    <li>bundle.js：工程自己的公用组件。</li>\n    <li>bundle.css：示例2 中已经介绍的使用&nbsp;<em>ExtractTextPlugin</em>&nbsp;抽取的CSS文件。</li>\n    <li>index.html：全站通用的html页面。</li>\n</ul>\n<p>除了仅用于服务端的 <em>node-fetch.js</em>（也不知道为啥这玩意能这么大），其他会传输到浏览器的资源文件都不大。结合gzip一起使用整个网站的资源的传输量不到100KB，如下图：</p>\n<p><img alt="React 构建用于生产的静态化单页面服务" height="188"\n        src="https://file.mahoooo.com/res/file/react_establish_server_render_for_production_8.png" width="487"></p>\n<p>细心的人看到这里一定会问：怎么 <em>details</em> 页面没有分片？个人推测这和代码的复用率有关。仔细观察<em>details/index.js </em>的代码，会发现几乎都是引用了外部组件，所以被一起合并到\n    <em>bundle.js</em> 里去了。还没有去考证，有人知道具体原因请告诉我。</p>\n<p><em><strong>webpack</strong></em> 分片的配置还有很多选项，有需要可以 <a href="https://webpack.js.org/plugins/commons-chunk-plugin/"\n                                                          rel="nofollow">查看官方分片插件的说明</a>。每一个项目都有不同的特性，所以配置也不可能完全一致，想要达到最佳效果最好是在了解每个参数作用的前提下，根据项目特点进行配置。\n</p>\n\n<h2 id="h2-2">首屏组件在渲染之前加载</h2>\n<p>在react-route4.x中使用<em>&nbsp;require.ensure</em>&nbsp;有一个问题，就是每次打开页面都会异步加载组件，导致页面闪现。在react-route3.x时代官方提供了一个配置解决方案，但是不知道为什么到4.x没了。官方给出的方法（<a\n        href="https://reacttraining.com/react-router/web/guides/code-splitting" rel="nofollow">官方原文</a>）是直接用&nbsp;<a\n        href="https://github.com/webpack-contrib/bundle-loader" rel="nofollow">bundle-loader</a>&nbsp;实现，但是我用它解决了纯浏览器的异步加载问题，但结合服务端渲染时出现页面闪现，所以才自己写了&nbsp;<em>./3_compress_ensure_render/component/highOrder/bundle.js&nbsp;</em>这个高阶组件。\n</p>\n<p>可以通过将配置文件 <em>config.js</em> 中的 <em>isInitComponent</em> 参数修改为false来复现这个问题：</p>\n<pre class="cpp"><code class="language-javascript"><span class="code-comment"><span\n        class="code-comment">//58行</span></span>\n<span class="code-comment"><span class="code-comment">/**\n * 初始化加载页面的开关，仅用于说明区别\n * @type {boolean}\n */</span></span>\n<span class="code-keyword"><span class="code-keyword">export</span></span> <span class="code-keyword"><span\n            class="code-keyword">const</span></span> isInitComponent = <span class="hljs-literal"><span\n            class="hljs-literal">false</span></span>\n<span class="code-comment"><span class="code-comment">//</span></span></code></pre>\n<p>然后启动开发nodejs服务器：</p>\n<pre class=""><code class=""><span class="code-variable"><span class="code-variable">$ </span></span>npm run <span\n        class="hljs-number"><span class="hljs-number">3</span></span>-dev</code></pre>\n<p>启动后刷新首页可以看到在浏览器的console中（本人使用的chrome）输出以下警告：</p>\n<p><img alt="React 构建用于生产的静态化单页面服务" height="85"\n        src="https://file.mahoooo.com/res/file/react_establish_server_render_for_production_9.png" width="790"></p>\n<p>意思就是服务器端渲染传递过来的HTML结构和浏览器端首次渲染的结构不一致。</p>\n<p>由于打包脚本和运行脚本设定的是生产环境（NODE_ENV=production），所以不会输出警告。将环境设定为 <em>test</em> 一样输出以上内容。即使不修改，按F5刷新一样会感觉到差别。</p>\n<p>观察警告输出的内容，在服务端已经渲染了 <em>home</em> 页面，但是到浏览器端首屏渲染的是一个"空元素"（&lt;!--react-empty --&gt;）。导致这个问题出现的原因是在\n    <em>bundle</em> 组件中需要异步加载组件，在加载之前会先返回一个 null，所以导致 <em><strong>react</strong></em> 首屏渲染这里获取的是一个"空组件"（首屏渲染的原理请看 <a\n            href="https://my.oschina.net/chkui/blog/1523410" rel="nofollow">这里</a> ）。</p>\n<p>解决这个问题并不算太麻烦，方法也很多，就是需要一些小技巧。</p>\n<p><strong>这里采用优先生成页面的方式。</strong></p>\n<p>首先，在服务端增加一个中间件——<em>middleware/page.js</em>用于在渲染之前生成当前页面组件。</p>\n<pre class="javascript"><code class="language-javascript"><span class="code-comment"><span class="code-comment">//page.js</span></span>\n<span class="code-keyword"><span class="code-keyword">async</span></span> <span class="hljs-function"><span\n            class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">function</span></span></span><span class="hljs-function"> </span><span\n            class="code-title"><span class="hljs-function"><span class="code-title">page</span></span></span><span\n            class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span\n            class="hljs-params">ctx, next</span></span></span><span class="hljs-function">) </span></span>{\n    <span class="code-keyword"><span class="code-keyword">if</span></span> (ctx.isRoutes) {\n        <span class="code-comment"><span class="code-comment">//matchRoute方法根据当前访问的url从路由列表中获取对应的route</span></span>\n        <span class="code-keyword"><span class="code-keyword">const</span></span> {id, name, component} = matchRoute(ctx.url),\n            Comp = <span class="code-keyword"><span class="code-keyword">await</span></span> <span class="code-keyword"><span\n            class="code-keyword">new</span></span> <span class="code-built_in"><span\n            class="code-built_in">Promise</span></span>((res, rej) =&gt; {\n                component((Comp) =&gt; { <span class="code-comment"><span class="code-comment">//异步获取组件</span></span>\n                    res(Comp)\n                })\n            })\n        <span class="code-comment"><span class="code-comment">//将获取的结果赋值到请求的上下文交由下一个中间件处理</span></span>\n        ctx.page = {id, name, component: Comp}\n        <span class="code-keyword"><span class="code-keyword">return</span></span> next()\n    } <span class="code-keyword"><span class="code-keyword">else</span></span> {\n        <span class="code-keyword"><span class="code-keyword">return</span></span> next()\n    }\n}</code></pre>\n<p>获取到这个组件后接着到&nbsp;<em>middleware/entry.js </em>中间件通过参数传入到app.js，同时使用模板工具将页面对应的id写到浏览器端。</p>\n<p>然后，在浏览器端的&nbsp;<em>browserEntry.js&nbsp;</em>也做同样的事，在渲染之前先加载页面组件。</p>\n<pre class="javascript"><code class="language-javascript"><span class="code-comment"><span class="code-comment">//browserEntry.js</span></span>\n<span class="code-comment"><span class="code-comment">//获取当前页面对应的路由id</span></span>\n<span class="code-keyword"><span class="code-keyword">const</span></span> id = <span class="code-built_in"><span\n            class="code-built_in">window</span></span>.Init_Page ? <span class="code-built_in"><span\n            class="code-built_in">window</span></span>.Init_Page.id : <span class="hljs-literal"><span\n            class="hljs-literal">false</span></span>\n<span class="code-comment"><span class="code-comment">//id存在则从路由列表中找到对应的组件，id不存在则直接渲染</span></span>\nid ? (()=&gt;{\n    <span class="code-keyword"><span\n            class="code-keyword">const</span></span> route = routes.filter(i=&gt;i.id === id)[<span class="hljs-number"><span\n            class="hljs-number">0</span></span>]\n    route &amp;&amp; route.component(cb=&gt;{\n        pageRender(id, cb)\n    })\n})(): pageRender()\n\n<span class="code-comment"><span class="code-comment">//异步渲染，通过参数传入已经加载完成的组件</span></span>\n<span class="code-keyword"><span class="code-keyword">const</span></span> pageRender = (id, component) =&gt;{\n    render(\n        <span class="xml"><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n                class="code-name"><span class="xml"><span class="code-tag"><span\n                class="code-name">Provider</span></span></span></span><span class="xml"><span class="code-tag"> </span></span><span\n                class="hljs-attr"><span class="xml"><span class="code-tag"><span\n                class="hljs-attr">store</span></span></span></span><span class="xml"><span\n                class="code-tag">=</span></span><span class="code-string"><span class="xml"><span class="code-tag"><span\n                class="code-string">{build(reducers,</span></span></span></span><span class="xml"><span\n                class="code-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="code-tag"><span\n                class="hljs-attr">window.REDUX_STATE</span></span></span></span><span class="xml"><span\n                class="code-tag">)}&gt;</span></span></span><span class="xml">\n            </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n                class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">BrowserRouter</span></span></span></span><span\n                class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n                </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n                class="code-name"><span class="xml"><span class="code-tag"><span\n                class="code-name">App</span></span></span></span><span class="xml"><span\n                class="code-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="code-tag"><span\n                class="hljs-attr">id</span></span></span></span><span class="xml"><span class="code-tag">=</span></span><span\n                class="code-string"><span class="xml"><span class="code-tag"><span\n                class="code-string">{id}</span></span></span></span><span class="xml"><span\n                class="code-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="code-tag"><span\n                class="hljs-attr">component</span></span></span></span><span class="xml"><span class="code-tag">=</span></span><span\n                class="code-string"><span class="xml"><span class="code-tag"><span\n                class="code-string">{component}/</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span\n                class="xml">\n            </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span\n                class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">BrowserRouter</span></span></span></span><span\n                class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n        </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span\n                class="code-name"><span class="xml"><span class="code-tag"><span\n                class="code-name">Provider</span></span></span></span><span class="xml"><span\n                class="code-tag">&gt;</span></span></span><span class="xml">, document.getElementById(\'root\'))\n}</span></span></code></pre>\n<p>最后，<em>App</em> 组件会将初始化的数据传递到 <em>bundle</em> 这个高阶组件，<em>bundle</em>会进行初始化判断，如果组件已经存在则不会去执行异步加载而直接渲染。</p>\n<pre class="scala"><code class="language-javascript"><span class="code-comment"><span class="code-comment">//bundle.js 片段</span></span>\n<span class="code-keyword">const</span> bundle = (initId, initComponent, getComponentFoo) =&gt; {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="hljs-class"><span\n            class="code-keyword"><span class="hljs-class"><span class="code-keyword">class</span></span></span><span\n            class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n            class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n            class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n            class="hljs-class"><span class="code-title">Component</span></span></span><span class="hljs-class"> </span></span>{\n        <span class="code-keyword">constructor</span>(...props) {\n            <span class="code-keyword"><span class="code-keyword">super</span></span>(...props)\n            <span class="code-comment"><span class="code-comment">//----------------</span></span>\n            <span class="code-comment"><span\n                    class="code-comment">//这一段用于初始化渲染，解决第一次打开网站时服务端完成渲染前端再异步加载闪现的问题</span></span>\n            <span class="code-comment"><span class="code-comment">//获取当前url对应的路由</span></span>\n            <span class="code-keyword">const</span> route = matchRoute(<span class="code-keyword"><span\n            class="code-keyword">this</span></span>.props.<span class="code-keyword">match</span>.url),\n\n            <span class="code-comment"><span class="code-comment">//根据判断规则获取初始化组件</span></span>\n            <span class="code-comment"><span class="code-comment">//规则1：initId是否存在</span></span>\n            <span class="code-comment"><span class="code-comment">//规则2：当前路由的id是否等于initId</span></span>\n            <span class="code-type">Comp</span> = initId &amp;&amp; route &amp;&amp; initId === route.id ? initComponent : <span\n            class="hljs-literal"><span class="hljs-literal">false</span></span>\n\n            <span class="code-comment"><span class="code-comment">//设定初始化组件，如果组件存在则不会进行异步加载</span></span>\n            <span class="code-keyword"><span class="code-keyword">this</span></span>.state = {<span class="code-type">Comp</span>: <span\n            class="code-type">Comp</span>}\n            <span class="code-comment"><span class="code-comment">//----------------</span></span>\n        }\n\n        componentWillMount() {\n            <span class="code-comment"><span class="code-comment">//如果在构造函数中已经设定了组件，则不会去异步加载组件</span></span>\n            !<span class="code-keyword"><span class="code-keyword">this</span></span>.state.<span\n            class="code-type">Comp</span> &amp;&amp; getComponentFoo(<span class="code-keyword"><span\n            class="code-keyword">this</span></span>.async)\n        }\n    }\n}</code></pre>\n\n<h2 id="h2-3">代码合并与压缩</h2>\n<p>代码合并压缩都是 <em><strong>webpack</strong></em> 提供的插件功能，下面是和合并、压缩相关的插件：</p>\n<pre class="groovy"><code class="language-javascript"><span class="code-comment"><span class="code-comment">//webpack/server-build.js 片段</span></span>\n   [    <span class="code-comment"><span class="code-comment">//压缩js</span></span>\n        <span class="code-keyword"><span class="code-keyword">new</span></span> webpack.optimize.UglifyJsPlugin({\n<span class="hljs-symbol">            compress:</span> {<span class="code-string">warnings:</span> <span\n            class="hljs-literal"><span class="hljs-literal">false</span></span>},\n<span class="hljs-symbol">            comments:</span> <span class="hljs-literal"><span\n            class="hljs-literal">false</span></span>\n        }),\n        <span class="code-comment"><span class="code-comment">//压缩css</span></span>\n        <span class="code-keyword"><span class="code-keyword">new</span></span> OptimizeCssAssetsPlugin({\n<span class="hljs-symbol">            assetNameRegExp:</span> <span class="hljs-regexp"><span class="hljs-regexp">/\\.css$/</span>g</span>,\n<span class="hljs-symbol">            cssProcessor:</span> <span class="code-built_in">require</span>(<span\n            class="code-string"><span class="code-string">\'cssnano\'</span></span>),\n<span class="hljs-symbol">            cssProcessorOptions:</span> {<span\n            class="code-string">discardComments:</span> {<span class="code-string">removeAll:</span> <span\n            class="hljs-literal"><span class="hljs-literal">true</span></span>}},\n<span class="hljs-symbol">            canPrint:</span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>\n        }),\n        <span class="code-comment"><span class="code-comment">//分片优化，开启后会根据设定来合并分片代码</span></span>\n        <span class="code-keyword"><span class="code-keyword">new</span></span> webpack.optimize.AggressiveMergingPlugin(),\n        <span class="code-comment"><span class="code-comment">//设定分片限制</span></span>\n        <span class="code-keyword"><span class="code-keyword">new</span></span> webpack.optimize.LimitChunkCountPlugin({\n<span class="hljs-symbol">            maxChunks:</span> <span class="hljs-number"><span\n            class="hljs-number">35</span></span>,\n<span class="hljs-symbol">            minChunkSize:</span> <span class="hljs-number"><span\n            class="hljs-number">1000</span></span>\n        }),\n        <span class="code-comment"><span class="code-comment">//设定最小分片条件</span></span>\n        <span class="code-keyword"><span class="code-keyword">new</span></span> webpack.optimize.MinChunkSizePlugin({\n<span class="hljs-symbol">            minChunkSize:</span> <span class="hljs-number"><span\n            class="hljs-number">10000</span></span>\n        })\n   ]</code></pre>\n<p>相关的参数说明请到官网查看API说明。</p>\n\n<h2 id="h2-4">服务器管理工具</h2>\n<p>最后介绍一下 <em><strong>nodejs</strong></em> 服务器管理工具。</p>\n<p>我们使用的是 <em><strong>pm2</strong></em>，当然还有其他各种工具可供选择。</p>\n<p>关于 <em><strong>pm2 </strong></em>的细节就不介绍了，有需要可以去 <a href="http://pm2.keymetrics.io/" rel="nofollow">官网</a> 了解。\n</p>\n<p><em><strong>pm2</strong></em> 的使用仅仅需要一个配置文件—— <em>pm2.config.js</em>：</p>\n<pre class="javascript"><code class="language-javascript"><span class="code-built_in"><span\n        class="code-built_in">module</span></span>.exports = {\n    apps: [\n        {\n            <span class="code-comment"><span class="code-comment">//名称</span></span>\n            name: <span class="code-string"><span class="code-string">\'react-server-render\'</span></span>,\n            <span class="code-comment"><span class="code-comment">//要启动的文件路径</span></span>\n            script: <span class="code-string"><span class="code-string">\'./3_compress_ensure_render/dist/server/server.js\'</span></span>,\n            <span class="code-comment"><span class="code-comment">/**设定进程\n             *0或\'max\'表示启用与cpu核心对应的进程.\n             *-1表示启动比cpu核心少一个的进程\n             *其他具体数字表示指定进程数目\n             **/</span></span>\n            instances: <span class="hljs-number"><span class="hljs-number">0</span></span>,\n            <span class="code-comment"><span class="code-comment">/**\n             * 模式.\n             * cluster：集群\n             *\n             */</span></span>\n            exec_mode: <span class="code-string"><span class="code-string">\'cluster\'</span></span>,\n            <span class="code-comment"><span class="code-comment">//环境配置</span></span>\n            env: {\n                NODE_ENV: <span class="code-string"><span class="code-string">\'production\'</span></span>\n            },\n            <span class="code-comment"><span class="code-comment">//日志时间格式</span></span>\n            log_date_format: <span class="code-string"><span class="code-string">\'YYYY-MM-DD HH:mm Z\'</span></span>,\n            <span class="code-comment"><span class="code-comment">//指定日志输出位置，Linux下注意权限问题</span></span>\n            out_file: <span class="code-string"><span class="code-string">\'./logs/out.log\'</span></span>,\n            error_file: <span class="code-string"><span class="code-string">\'./logs/err.log\'</span></span>\n        },\n    ]\n}\n</code></pre>\n<p><span style="color:#FF0000">注意！这个配置文件的名称必须按照 <em>*.config.js</em> 的方式命名，否则无法生效。</span>这真是个莫名奇妙的设定，官网的 <em>#Process\n    File&nbsp;</em>部分有说明——<em><a href="http://pm2.keymetrics.io/docs/usage/application-declaration/#process-file"\n                                 rel="nofollow">Note that using a Javascript configuration file requires to end the\n    file name with .config.js </a>。</em>不知道这个原因的人，死活配置都不生效。</p>\n<p><em>package.json&nbsp;</em>中已经写好 <em><strong>pm2</strong></em> 对应的启停脚本：</p>\n<pre class=""><code class="language-bash"><span class="code-comment"><span class="code-comment">#启动，启动之前先npm run 3-build 打包</span></span>\n<span class="code-variable">$ </span>npm run <span class="hljs-number">3</span>-start\n\n<span class="code-comment"><span class="code-comment">#停止</span></span>\n<span class="code-variable">$ </span>npm run <span class="hljs-number">3</span>-stop</code></pre>\n<p>启动成功之后会输出一下内容：</p>\n<p><img alt="React 构建用于生产的静态化单页面服务" height="232"\n        src="https://file.mahoooo.com/res/file/react_establish_server_render_for_production_10.png" width="647"></p>\n<p><em><strong>pm2</strong></em> 还提供了监控、统计、日志抽取等等实用工具。需要的可以去官网了解。以下是打开 <strong><em>pm2</em></strong> 监控的过程和效果。</p>\n<pre class=""><code class="language-bash"><span class="code-variable">$ </span>npm install pm2 -g\n<span class="code-variable">$ </span>pm2 monit</code></pre>\n<p>监控效果：</p>\n<p><img alt="React 构建用于生产的静态化单页面服务" height="428"\n        src="https://file.mahoooo.com/res/file/react_establish_server_render_for_production_11.png" width="730"></p>\n<p>至此，已经将服务端渲染相关的所有内容介绍完毕，因为篇幅的原因有很多东西无法深入。有问题或者对本片内容有任何不满请留言或在 <em>github</em> 提 <em>issue</em>。</p>\n<p>在写本文之前已经完成了一个可以快速应用到不同项目的 <em><strong>nodejs</strong></em>&nbsp;同构渲染服务。目前已经应用到团队的多个项目中，需要了解的请参看：</p>\n<p><em><strong>npm</strong></em>：<em>https://www.npmjs.com/package/pwfe-dom </em>和<em>&nbsp;https://www.npmjs.com/package/pwfe-server</em>\n</p>\n<p><em><strong>github源码</strong></em>：<em>https://github.com/palmg/pwfe-dom </em>和<em>&nbsp;https://github.com/palmg/pwfe-server</em>。\n</p>'}});