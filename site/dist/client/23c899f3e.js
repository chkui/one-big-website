webpackJsonp([2],{340:function(n,s,e){"use strict";Object.defineProperty(s,"__esModule",{value:!0});s.content='<p>JSR330是Jcp给出的官方标准反向依赖注入规范。Java大部分反向依赖注入的工具或者框架目前基本上都满足JSR330规范、例如spring、guice以及Dagger。</p>\n<p>以我们最常用的spring为例。</p>\n<p>JSR中<span style="color:#cc0000">@Inject</span>可以当做<span style="color:#cc0000">@AutoWired</span>来使用。而<span\n        style="color:#cc0000">@Named</span>可以当做<span style="color:#cc0000">@Component</span>来使用。</p>\n<p>使用JSR330首先要引入javax.inject包：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">dependency</span>&gt;</span>  \n    <span class="code-tag">&lt;<span class="code-name">groupId</span>&gt;</span>javax.inject<span class="code-tag">&lt;/<span\n            class="code-name">groupId</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">artifactId</span>&gt;</span>javax.inject<span class="code-tag">&lt;/<span\n            class="code-name">artifactId</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">version</span>&gt;</span>1<span class="code-tag">&lt;/<span\n            class="code-name">version</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">dependency</span>&gt;</span> </code></pre>\n<p>目前Maven中央仓库中就一个inject的jar。</p>\n<p>首先使用xml配置通过注解扫描添加bean。</p>\n<pre><code class="xml"><span class="php"><span class="code-meta">&lt;?</span>xml version=<span\n        class="code-string">"1.0"</span> encoding=<span class="code-string">"UTF-8"</span><span\n        class="code-meta">?&gt;</span></span>\n<span class="code-tag">&lt;<span class="code-name">beans</span> <span class="hljs-attr">xmlns</span>=<span\n        class="code-string">"http://www.springframework.org/schema/beans"</span>\n    <span class="hljs-attr">xmlns:xsi</span>=<span\n            class="code-string">"http://www.w3.org/2001/XMLSchema-instance"</span>\n    <span class="hljs-attr">xmlns:context</span>=<span class="code-string">"http://www.springframework.org/schema/context"</span>  \n    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="code-string">"http://www.springframework.org/schema/beans  \n    http://www.springframework.org/schema/beans/spring-beans-3.1.xsd  \n    http://www.springframework.org/schema/context  \n    http://www.springframework.org/schema/context/spring-context-3.1.xsd"</span>&gt;</span>  \n    <span class="code-tag">&lt;<span class="code-name">context:component-scan</span>  <span class="hljs-attr">base-package</span>=<span\n            class="code-string">"com.demo.jsr330"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span>  </code></pre>\n<p>然后像下面这个添加一个bean</p>\n<pre><code class="java"><span class="code-meta">@Named</span>  \n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">service</span> </span>{\n  <span class="hljs-function"><span class="code-keyword">public</span>  <span class="code-keyword">void</span>   <span\n          class="code-title">print</span><span class="hljs-params">()</span></span>{\n     System.out.println(<span class="code-string">"Service  print  method is invoked"</span>);  \n  }  \n}  </code></pre>\n<p>然后将这个bean注入到其他bean中去使用</p>\n<pre><code class="java"><span class="code-meta">@Named</span>  \n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Faction</span> </span>{\n  <span class="code-meta">@Inject</span>\n  Service service;\n\n  <span class="hljs-function"><span class="code-keyword">public</span>  <span class="code-keyword">void</span>  <span\n          class="code-title">show</span><span class="hljs-params">()</span></span>{\n     service.print()； \n  }  \n}  </code></pre>\n<p>JSR330还定义了<span style="color:#FF0000">@Qualifier</span>和<span style="color:#FF0000">@Provider</span>，对应到spring都给出了标准的实现。\n</p>\n<p>使用JSR330代替原注解的好处是无论使用任何反向依赖注入工具或框架，只要他是支持JSR330的，都可以平滑的切换。</p>'},346:function(n,s,e){"use strict";Object.defineProperty(s,"__esModule",{value:!0});s.content='<h2 id="h2-1">Maven生命周期阶段</h2>\n<p>Maven为打包过程提供了各种各样的生命周期功能，主要有：</p>\n<ol>\n    <li>Validate：验证，对工程的所有内容进行验证。</li>\n    <li>compile：编译。</li>\n    <li>test：运行测试用例。</li>\n    <li>package：将代码进行打包并生成到本地。</li>\n    <li>integration-test：与其他的工程进行集成测试，会将依赖内容放置到一个统一环境中。</li>\n    <li>verify：校验功能，检查包的质量。</li>\n    <li>install：将打包之后的文件放置到本地仓库。</li>\n    <li>deploy：将已经打包的文件放置到远程仓库。</li>\n    <li>clean：清除之前构建的内容。</li>\n    <li>site：针对当前的工程生成一个可视化的站点文档。</li>\n</ol>\n<h2 id="h2-2">常用命令</h2>\n<p>对应以上生命周期都有一个对应的命令。</p>\n<ol>\n    <li><code>mvn compile</code>，编译代码，编译之后代码会出现在/target目录中，整合了IDE会自动执行这个步骤。</li>\n    <li><code>mvn test</code>，运行单元测试。</li>\n    <li><code>mvn test-compile</code>, 编译测试用用欧，并执行。如果在IDE中通过IDE会自定对单元测试代码打包。</li>\n    <li><code>mvn package</code>，对项目进行打包，打包之后会出现在/targer目录下。</li>\n    <li><code>mvn install</code>，安装包，会将打包之后的包安装到本地仓库对应的位置。</li>\n    <li><code>mvn deploy</code>，将包发布到远程仓库。</li>\n</ol>\n<p>maven打包基本上就涉及以上命令，除此之外还有一些配套的命令：</p>\n<ol>\n    <li><code>mvn site</code>，输出到/target一个依赖视图文档。</li>\n    <li>``</li>\n</ol>\n<h2 id="h2-3">Xml文件元素定义</h2>\n<ol>\n    <li>project：整个XML文档的最顶层标签。</li>\n    <li>modelVersion：使用的maven模型版本<code>&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</code></li>\n    <li>groupId：组织Id。<code>&lt;groupId&gt;com.mycompany.app&lt;/groupId&gt;</code></li>\n    <li>artifactId：标识符号id。<code>&lt;artifactId&gt;my-app&lt;/artifactId&gt;</code></li>\n    <li>packaging：打包模式， 例如JAR, WAR, EAR。<code>&lt;packaging&gt;jar&lt;/packaging&gt;</code></li>\n    <li>version：当前的版本号。<code>&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</code></li>\n    <li>name：项目名称。<code>&lt;name&gt;Maven Quick Start Archetype&lt;/name&gt;</code></li>\n    <li>url：项目地址。<code>&lt;url&gt;http://maven.apache.org&lt;/url&gt;</code></li>\n    <li>description: 项目介绍。</li>\n</ol>\n<h2 id="h2-4">测试用例运行规则</h2>\n<p>测试用例在运行的时候装载和排除一下格式的文件。\n    包含：</p>\n<ol>\n    <li><code>**/*Test.java</code></li>\n    <li><code>**/Test*.java</code></li>\n    <li><code>**/*TestCase.java</code></li>\n</ol>\n<p>排除：</p>\n<ol>\n    <li><code>**/Abstract*Test.java</code></li>\n    <li><code>**/Abstract*TestCase.java</code></li>\n</ol>\n<h2 id="h2-5">SNAPSHOT（快照版本）</h2>\n<p>当版本号使用<code>-SNAPSHOT</code>结构的后缀时表示这是一个快照版本。快照版本一般用于开发分支，快照版本即使不改变版本号也会自动获取到最新版本。以只相对的是发布（<code>Release</code>）版本，只要不使用<code>-SNAPSHOT</code>结尾的都是发布版本。每一个发布版本只对应一个编号。\n</p>\n<h2 id="h2-6">插件使用</h2>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">build</span>&gt;</span>\n  <span class="code-tag">&lt;<span class="code-name">plugins</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">plugin</span>&gt;</span>\n      <span class="code-tag">&lt;<span class="code-name">groupId</span>&gt;</span>org.apache.maven.plugins<span\n            class="code-tag">&lt;/<span class="code-name">groupId</span>&gt;</span>\n      <span class="code-tag">&lt;<span class="code-name">artifactId</span>&gt;</span>maven-compiler-plugin<span\n            class="code-tag">&lt;/<span class="code-name">artifactId</span>&gt;</span>\n      <span class="code-tag">&lt;<span class="code-name">version</span>&gt;</span>3.3<span class="code-tag">&lt;/<span\n            class="code-name">version</span>&gt;</span>\n      <span class="code-tag">&lt;<span class="code-name">configuration</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">source</span>&gt;</span>1.5<span class="code-tag">&lt;/<span\n            class="code-name">source</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">target</span>&gt;</span>1.5<span class="code-tag">&lt;/<span\n            class="code-name">target</span>&gt;</span>\n      <span class="code-tag">&lt;/<span class="code-name">configuration</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">plugin</span>&gt;</span>\n  <span class="code-tag">&lt;/<span class="code-name">plugins</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">build</span>&gt;</span>\n</code></pre>\n<p>\n    上面是在<code>build</code>过程中使用插件的一个配置。插件的使用方式和依赖比较类似，也是2级菜单引入一个插件，插件也是要标记<code>groupId</code>、<code>artifactId</code>以及<code>version</code>等内容。<code>configuration</code>标签用于向插件传递参数（插件就好像一个方法执行一个任务，某些方法需要我们提供参数才能正常运行）。\n</p>\n<p>这个配置会在build阶段被运行（package，install，deploy）。</p>\n<p>插件可以在maven执行的各个生命周期被使用。（<a href="http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html"\n                              title="maven生命周期">maven生命周期</a>）插件的类型繁多，除了直接通过<code>&lt;plugin&gt;</code>引入，实际上maven的各种标签功能也是通过插件实现的，需要知道使用某个插件可以查看官方提供的<a\n        href="http://maven.apache.org/plugins/" title="插件清单">插件清单</a>。</p>\n<p>##　资源文件管理</p>\n<p>一个Java程序肯定会涉及到各种各样的配置文件，在maven的结构下通常我们会将资源文件放置到<code>${root}/src/main/resources</code>目录下。如下面结构的<code>application.properties</code>。\n</p>\n<pre><code class="sql">my-app\n|<span class="code-comment">-- pom.xml</span>\n`<span class="code-comment">-- src</span>\n    |<span class="code-comment">-- main</span>\n    |   |<span class="code-comment">-- java</span>\n    |   |   `<span class="code-comment">-- com</span>\n    |   |       `<span class="code-comment">-- mycompany</span>\n    |   |           `<span class="code-comment">-- app</span>\n    |   |               `<span class="code-comment">-- App.java</span>\n    |   `<span class="code-comment">-- resources</span>\n    |       `<span class="code-comment">-- META-INF</span>\n    |           `<span class="code-comment">-- application.properties</span>\n    `<span class="code-comment">-- test</span>\n        `<span class="code-comment">-- java</span>\n            `<span class="code-comment">-- com</span>\n                `<span class="code-comment">-- mycompany</span>\n                    `<span class="code-comment">-- app</span>\n                        `<span class="code-comment">-- AppTest.java</span>\n</code></pre>\n<p>例如上面这个文件格式，</p>\n<p>对于maven项目而言，classpath的根路径是从java开始的，与之对应的，<code>/resources</code>路径也是一个classpath的root，编译或者打包后，会将<code>resource</code>中的文件合并到一个classpath中。如下图的是根据上面的结构打包成JAR之后的文件格式。\n</p>\n<pre><code class="sql">|<span class="code-comment">-- META-INF</span>\n|   |<span class="code-comment">-- MANIFEST.MF</span>\n|   |<span class="code-comment">-- application.properties</span>\n|   `<span class="code-comment">-- maven</span>\n|       `<span class="code-comment">-- com.mycompany.app</span>\n|           `<span class="code-comment">-- my-app</span>\n|               |<span class="code-comment">-- pom.properties</span>\n|               `<span class="code-comment">-- pom.xml</span>\n`<span class="code-comment">-- com</span>\n    `<span class="code-comment">-- mycompany</span>\n        `<span class="code-comment">-- app</span>\n            `<span class="code-comment">-- App.class</span>\n</code></pre>\n<p>META-INF用于存放程序入口的相关信息，可以将他理解为classpath的一个root，所以在其中的各种配置文件也可以直接在classpath中获取，除此之外还存在<code>MANIFEST.MF</code>、<code>pom.properties</code>、<code>pom.xml</code>等几个文件。这些问价那都是maven在<code>package</code>时生成的标准文件，<code>MANIFEST.MF</code>告知了程序的入口，另外两个文件标记了maven的依赖关系。\n</p>\n<p>对应的，也可以在test目录下建立一个<code>resources</code>目录，在执行单元测试的时候，它会被加入到单元测试时的classpath中。</p>\n<h2 id="h2-7">资源文件参数化</h2>\n<p>通常情况下，发布生产和发布测试某些参数肯定是不一样的（比如数据库链接参数），所以某些时候需要资源文件中的参数根据打包命令进行变更。这个使用会用到<code>&lt;resources&gt;</code>标签（插件）。</p>\n<p>替换参数的过程并不复杂，首先是如下图引入<code>&lt;resources&gt;</code>标签。</p>\n<pre><code class="xml">  <span class="code-tag">&lt;<span class="code-name">build</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">resources</span>&gt;</span>\n      <span class="code-tag">&lt;<span class="code-name">resource</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">directory</span>&gt;</span>src/main/resources<span\n            class="code-tag">&lt;/<span class="code-name">directory</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">filtering</span>&gt;</span>true<span\n            class="code-tag">&lt;/<span class="code-name">filtering</span>&gt;</span>\n      <span class="code-tag">&lt;/<span class="code-name">resource</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">resources</span>&gt;</span>\n  <span class="code-tag">&lt;/<span class="code-name">build</span>&gt;</span>\n</code></pre>\n<p>然后用<code>&lt;directory&gt;</code>表示要进行参数替换的路径位置，这里将会把<code>resource</code>目录中的内容全部替换。</p>\n<p>对应的，在配置文件中使用占位符表示要替换的内容：</p>\n<p>properties：</p>\n<pre><code class="apache"><span class="code-attribute">application</span>.name=<span class="code-variable">${project.name}</span>\n<span class="code-attribute">application</span>.version=<span class="code-variable">${project.version}</span>\n</code></pre>\n<p>yaml：</p>\n<pre><code class="yaml coffeescript">application:\n\tname: @project.name@\n\tversion: @project.version@\n</code></pre>\n<p>配置好之后可以通过<code>mvn process-resources</code>命令来检查文件替换的效果。执行后可以到/target/classses看到替换效果。除了使用<em>project.version</em>之类的固定参数，还可以使用<code>&lt;properties&gt;</code>在<strong>pom.xml</strong>文件中定义全局参数：\n</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">properties</span>&gt;</span>\n\t<span class="code-tag">&lt;<span class="code-name">my.value</span>&gt;</span>hello<span class="code-tag">&lt;/<span\n            class="code-name">my.value</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">properties</span>&gt;</span>\n</code></pre>\n<p>最后，maven还支持系统参数和Java运行时参数，比如：</p>\n<pre><code class="apache"><span class="code-attribute">java</span>.version=<span\n        class="code-variable">${java.version}</span>\n<span class="code-attribute">command</span>.line.prop=<span class="code-variable">${command.line.prop}</span>\n</code></pre>\n<p><code>${java.version}</code>可以获取到操作系统中Java的版本参数。maven本身是一个Java程序，所以<code>mvn process-resources\n    "-Dcommand.line.prop=hello again"</code>命令在启动jvm同时，还传入了<code>command.line.prop</code>的数据。</p>\n<h2 id="h2-8">依赖管理</h2>\n<p><code>&lt;dependencies&gt;</code>和<code>&lt;dependency&gt;</code>组合表示引入依赖。一项依赖通过<code>&lt;groupId&gt;</code>、<code>&lt;artifactId&gt;</code>、<code>&lt;version&gt;</code>引入。<code>&lt;scope&gt;</code>用于确定依赖包的使用范围，与maven的运行生命周期相对应。更多的标签说明参见\n    <a href="http://maven.apache.org/ref/3.6.1/maven-model/maven.html" title="官网Project Descriptor Reference">官网Project\n        Descriptor Reference</a>。</p>\n<h3 id="h3-1">依赖范围</h3>\n<ol>\n    <li>compile：这是默认的范围，引入的包会在mvn的整个生命周期内被用到。</li>\n    <li>provided：在编译和测试的时候都会引入该包，但是到了打包（<code>install</code>）之后的阶段将不会依赖这个包。主要应用场景是使用tomcat之类的容器，在开发和单元测试的时候并不会引入容器，但是需要引用某些包（比如Servlet）完成编译。但是打包放入容器后某些包容器已经提供了，不需要我们带入到classpath中。\n    </li>\n    <li>runtime：除了编译（<code>compile</code>）阶段，其他阶段都会被引入。</li>\n    <li>test：仅用于测试。</li>\n    <li>system：本地操作系统依赖，不会去仓库下载jar包，根据配置的路径（包括网络路径）查找包。</li>\n    <li>import：导入其他pom文件，该标签仅仅能适用于<code>&lt;dependencyManagement&gt;</code>依赖管理标签中。<a\n            href="http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html。"\n            title="参考这篇文章的说明">参考说明</a>。\n    </li>\n</ol>\n<p>关于maven的依赖机制见<a href="http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html"\n                   title="官网关于依赖的说明">官网关于依赖的说明</a>。</p>\n<h3 id="h3-2">包引入过程</h3>\n<p>对于maven而言，一个包最终被引入到项目中有很多层级。首先每个人的操作系统上都有一个本地仓库。在本地执行<code>mvn install</code>命令时都会将对应的包安装到这个仓库中。当其他工程需要这个包时候，maven也是直接到本地仓库获取。\n</p>\n<p>除了自己<code>install</code>的包，更多的时候都是使用第三发提供的包。需要用到某个包时都是先去本地仓路获取，如果不存在maven会到远程仓库去获取。</p>\n<h3 id="h3-3">仓库说明</h3>\n<p>前面已经提及maven的包加载过程涉及到2个仓路：本地仓库（默认位置：<code>${user.home}/.m2/repository</code>）和远程仓库（默认位置：repo.maven.apache.org/maven2/）。\n</p>\n<p>本地仓路可以通过修改<code>${Maven_HOme}/conf/setting.xml</code>的<code>&lt;localRepository&gt;</code>设定，远程仓库通过<code>&lt;mirrors&gt;</code>标签指定。详情见：<a\n        href="http://maven.apache.org/guides/introduction/introduction-to-repositories.html" title="远程仓库介绍">仓库介绍</a>、<a\n        href="http://maven.apache.org/guides/mini/guide-mirror-settings.html"\n        title="远程仓库Mirrors配置说明">远程仓库Mirrors配置说明</a>、<a href="http://maven.apache.org/repository/index.html"\n                                                       title="中央仓库结构">中央仓库结构</a>。</p>\n<h2 id="h2-9">发布到远程仓库</h2>\n<p>发布到远程仓库需要对本地pom.xml以及本机的setting.xml进行配置。\n    pom.xml文件增加：</p>\n<pre><code class="xml">  <span class="code-tag">&lt;<span class="code-name">distributionManagement</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">repository</span>&gt;</span>\n      <span class="code-tag">&lt;<span class="code-name">id</span>&gt;</span>mycompany-repository<span class="code-tag">&lt;/<span\n            class="code-name">id</span>&gt;</span>\n      <span class="code-tag">&lt;<span class="code-name">name</span>&gt;</span>MyCompany Repository<span\n            class="code-tag">&lt;/<span class="code-name">name</span>&gt;</span>\n      <span class="code-tag">&lt;<span class="code-name">url</span>&gt;</span>scp://repository.mycompany.com/repository/maven2<span\n            class="code-tag">&lt;/<span class="code-name">url</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">repository</span>&gt;</span>\n  <span class="code-tag">&lt;/<span class="code-name">distributionManagement</span>&gt;</span>\n</code></pre>\n<p>setting.xml配置：</p>\n<pre><code class="xml"> <span class="code-tag">&lt;<span class="code-name">servers</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">server</span>&gt;</span>\n      <span class="code-comment">&lt;!-- 使用账号密码登录 --&gt;</span>\n      <span class="code-tag">&lt;<span class="code-name">id</span>&gt;</span>mycompany-repository<span class="code-tag">&lt;/<span\n            class="code-name">id</span>&gt;</span>\n      <span class="code-tag">&lt;<span class="code-name">username</span>&gt;</span>jvanzyl<span\n            class="code-tag">&lt;/<span class="code-name">username</span>&gt;</span>\n      <span class="code-comment">&lt;!-- 使用ssh登录 --&gt;</span>\n      <span class="code-tag">&lt;<span class="code-name">privateKey</span>&gt;</span>/path/to/identity<span\n            class="code-tag">&lt;/<span class="code-name">privateKey</span>&gt;</span>\n      <span class="code-tag">&lt;<span class="code-name">passphrase</span>&gt;</span>my_key_passphrase<span\n            class="code-tag">&lt;/<span class="code-name">passphrase</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">server</span>&gt;</span>\n  <span class="code-tag">&lt;/<span class="code-name">servers</span>&gt;</span>\n</code></pre>\n<p>远程服务器的权限有各种各样的规则——<a href="http://maven.apache.org/guides/mini/guide-encryption.html" title="参考文件">参考文件</a>。</p>\n<p>参考资料：<a href="http://maven.apache.org/guides/getting-started/index.html" title="官网介绍">官网介绍</a>。</p>'},359:function(n,s,e){"use strict";Object.defineProperty(s,"__esModule",{value:!0});s.content='<h2 id="h2-1">什么叫前后端同构？</h2>\n<p>为了解决某些问题（比如SEO、提升渲染速度等）<strong><em>react</em></strong>\n    提供了2个方法在服务端生成一个HTML文本格式的字符串。在得到了这个HTML格式的字符串之后，通常会将其组装成一个页面直接返回给用户的浏览器。</p>\n<p>到这里，服务端的活已经干完了，然后就是浏览器这边干活。</p>\n<p>浏览器拿到HTML文本后，立刻进行渲染将内容呈现给用户。然后加载页面所需的 .js 文件，然后执行\n    <em><strong>JavaScript&nbsp;</strong></em>脚本，然后开始初始化&nbsp;<em><strong>react</strong></em> 组件…………</p>\n<p>到这里问题就来了。<strong><em>react</em></strong> 初始化组件后会执行组件内所有\n    <em>render&nbsp;() </em>方法，然后生成虚拟DOM的树形结构，然后在适当的时候将虚拟dom<em>写</em>到浏览器的真实dom中。因为 <strong><em>react</em></strong>\n    总是根据虚拟dom来生成真实dom，所以最后会把服务器端渲染好的HTML全部替换掉。</p>\n<p>\n    上面这个事情说不是问题确实也不是问题，无非就是用户看到页面然后“闪现”一下。说是问题还真是个问题，产品会拿着这毛病从用户体验的角度在各种场合和你死磕半个月。磕累了你索性把服务端渲染关了，然后运营又拿着SEO的问题准备和你开始撕逼了。</p>\n<p>聪明如 Facebook 的工程师当然想到了这些问题，所以他们在<em>ReactDOMServer.renderToString(element) 方法</em>中提供了一个\n    <strong><em>checksum</em></strong> 机制。</p>\n<p>关于&nbsp;<strong><em>checksum </em></strong> <a href="https://facebook.github.io/react/docs/react-dom-server.html"\n                                                  rel="nofollow">官网</a> 并没有太多介绍，但是国内外的各路博客介绍了不少。我一直想找&nbsp;<em><strong>react</strong></em>\n    开发者关于这个机制的介绍一直没找到……。</p>\n<p><strong>前后端同构</strong>就是保证前端和后端的dom结构一致，不会发生重复渲染。<em><strong>react</strong></em>\n    使用&nbsp;<strong><em>checksum </em></strong>机制进行保障。</p>\n\n<h2 id="h2-2">什么叫React首屏渲染？</h2>\n<p>简单的说就是 <em><strong>react</strong></em> 在浏览器内存中第一次生成的虚拟 dom 树。<strong>切记是虚拟 dom ，而不是浏览器的dom</strong>。</p>\n<p>了解 <strong><em>react</em></strong> 的应该知道，所有 <em><strong>react</strong></em> 组件都有一个 <em>render()</em>\n    方法（如果使用function方式编写的组件会把function里的所有代码都塞到 <em>render()</em> 方法中去）。当<em>ReactDOM.render( element, container,\n        [callback] )</em>方法执行时，会执行以下步骤：</p>\n<ol>\n    <li>所有组件的会先进行初始化（es6执行构造函数）。</li>\n    <li>所有组件的&nbsp;<em>render</em>&nbsp;<em>()</em> 方法会被调用一次，完成这个过程后会得到一颗虚拟的 dom 树。</li>\n    <li>&nbsp;<em><strong>react</strong></em> 会将虚拟dom转换成浏览器dom，完成后调用组件的&nbsp;<em>componentDidMount()</em>&nbsp;方法告诉你已经装载到浏览器上了。\n    </li>\n</ol>\n<p>在上面这个过程成中，步骤2完成后即为完成 <em><strong>react</strong></em> 的首屏渲染。结合 <strong><em>checksum</em></strong>&nbsp;机制步骤3有可能不会执行。\n</p>\n<p>当组件状态发生变更时（ <em>setState() </em>生命周期函数被调用）或者 父组件渲染时（父组件的 <em>render()</em> 方法被调用），当前组件的 <em>render()</em>\n    方法都会被执行，都有可能会导致虚拟dom变更，但是这些变更和首屏渲染没任何关系了。</p>\n\n<h2 id="h2-3">React前后端同构首屏渲染</h2>\n<p>了解了同构和首屏渲染，就好理解如何解决首屏不重复渲染的问题了。</p>\n<p>首先服务端渲染完之后会有一个 <em><strong>checksum</strong></em> 值写在根元素的属性上：</p>\n<p><img alt="React 前后端同构防止重复渲染" height="70"\n        src="https://file.mahoooo.com/res/file/react_server_render_with_checksum_1.png" width="601"></p>\n<p>这个 <em><strong>checksum</strong></em>&nbsp;是根据服务端生成的HTML内容哈希计算得到的。</p>\n<p>然后在浏览器加载完所有的js文件之后，开始执行前面介绍的&nbsp;<em>ReactDOM.render( element, container, [callback] )</em> &nbsp;初始化渲染的三个步骤。当执行完第二步生成虚拟dom后，<strong><em>react</em></strong>\n    会根虚拟dom用相同的算法计算一个哈希值，如果和 <em><strong>checksum</strong></em> 一致则认为服务器已经完成渲染，不会再执行第三步。</p>\n<p>如果 <strong><em>checksum</em></strong> 比对不一致，在 <strong>开发环境</strong>&nbsp;和 <strong>测试环境</strong>\n    会在浏览器console中输出以下警告内容：</p>\n<p><img alt="React 前后端同构防止重复渲染" height="85"\n        src="https://file.mahoooo.com/res/file/react_server_render_with_checksum_2.png" width="790"></p>\n<p><strong>生产环境不会输出任何警告。</strong></p>\n<p>同构渲染的内容就这么多，原理其实蛮简单的，无非就是保证DOM一致。但是结合代码分片、异步加载、服务端调接口异步组装数据等等功能后，如何保证服务端和浏览器端第一次渲染的dom一致还得花不少功夫。不过原理清楚了，事情总能办成。</p>'},365:function(n,s,e){"use strict";Object.defineProperty(s,"__esModule",{value:!0});s.content='<p><a href="https://www.chkui.com/" title="@随风溜达的向日葵">@随风溜达的向日葵</a></p>\n<h2 id="h2-1">Nextjs</h2>\n<p><a href="https://nextjs.org/"><em>Nextjs</em></a>是<a href="https://reactjs.org/"><em>React</em></a>生态中非常受欢迎的SSR（server\n    side render——服务端渲染）框架，只需要几个步骤就可以搭建一个支持SSR的工程（_Nextjs_的快速搭建见<a\n            href="https://www.chkui.com/article/react/nextjs_getting_starting"><em>Next.js入门</em></a>）。 本文的案例代码来自于<a\n            href="https://github.com/palmg/website-standard-with-next">前端标准模板项目</a>。</p>\n<h2 id="h2-2">服务端组织数据</h2>\n<p><em>Nextjs</em>提供了便捷强大的服务端渲染功能——<strong>getInitialProps()</strong>，通过这个方法可以简单为服务端和前端同时处理异步请求数据：</p>\n<pre><code class="javascript"><span class="code-keyword">const</span> load = <span class="code-keyword">async</span> () =&gt;{\n    <span class="code-keyword">return</span> <span class="code-keyword">new</span> <span\n            class="code-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res, rej</span>)=&gt;</span>{\n        res(<span class="code-string">\'Success\'</span>)\n    })\n}\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">Simple</span> <span\n        class="code-keyword">extends</span> <span class="code-title">React</span>.<span\n        class="code-title">Component</span></span>{\n    <span class="code-keyword">static</span> <span class="code-keyword">async</span> getInitialProps({req, query}) {\n        <span class="code-keyword">const</span> data = <span class="code-keyword">await</span> load();\n        <span class="code-keyword">return</span> {data}\n    }\n    render() {\n        <span class="code-keyword">return</span>(<span class="xml"><span class="code-tag">&lt;<span\n            class="code-name">p</span>&gt;</span>{this.props.data}<span class="code-tag">&lt;/<span\n            class="code-name">p</span>&gt;</span></span>)\n    }\n}\n</code></pre>\n<p>Next的强大之一体现在就这么几行代码就解决了SSR中最麻烦的前后端异步数据组装功能。再复杂的异步数据组装过程都可以放置到代码中的Promise对象中。</p>\n<h2 id="h2-3">页面与内页</h2>\n<p>在继续述说本文内容之前还需要强化两个概念——<strong>内页</strong>与<strong>页面</strong>。</p>\n<p>通过浏览器输入一个地址获取到的内容称之为<strong>页面</strong>。</p>\n<p>而在单页面应用中也会有通过导航栏或菜单控制的内容切换效果，我们将这些切换的内容称之为<strong>内页</strong>。单页面应用中一般会先打开一个页面，然后通过Dom的增删改模拟页面切换的效果。</p>\n<h2 id="h2-4">Nextjs中SSR渲染的局限性</h2>\n<p>\n    <code>getInitialProps()</code>方法虽然强大好用，但是现在还存在一个问题——<strong>只能在“内页”中使用</strong>。<em>Nextjs_规定了所有放置到<code>./pages</code>中的文件（通常是*.js_文件，也可以引入</em>.ts*文件）都视为一个内页，这些文件中被导出的React组件可以直接输入地址上访问。例如现在有<a\n        href="https://github.com/palmg/website-standard-with-next/blob/master/pages/about.js"><em>./pages/about.js</em></a>文件，运行\n    <em>Nextjs</em> 后在浏览输入<code>http://localhost:3000/about</code>就可以看到这个组件，而<a\n        href="https://github.com/palmg/website-standard-with-next/blob/master/pages/async/simple.js"><em>./pages/async/simple.js</em></a>对用的路径是<code>http://localhost:3000/async/simple</code>。\n</p>\n<p>但是在其他路径（比如<code>./component</code>）的组件是无法使用<code>getInitialProps()</code>方法的。乍一看这样似乎没多大问题，但是某些应用又需要这些组件不能放置到<code>./pages</code>中暴露到_url_中，又需要异步加载数据。看下面的例子。\n</p>\n<h3 id="h3-1">按需加载菜单的例子</h3>\n<p><img src="https://oscimg.oschina.net/oscnet/fd51a66e0f097658f7db8e37fb621c76857.jpg" alt="Nextjs+React非页面组件SSR渲染"\n        title="应用菜单" class="zoom-in-cursor"></p>\n<p>如上图。在企业级应用中（例如OA系统）通常不太需要实现SSR，这个时候可以根据角色权限在组件的<code>componentDidMount()</code>方法中异步加载菜单，但是在某些时候（例如一个可配置菜单的内容网站，或者对企业级应用进行服务端缓存）也会有菜单异步加载并且实现SSR的需要，这个时候需要在_Nextjs_框架的基础上扩展。\n</p>\n<p>看到这里可能你会想可以把菜单的组装像下面放到每个内页的<code>getInitialProps()</code>方法中去：</p>\n<pre><code class="javascript"><span class="code-keyword">const</span> Comp = <span class="hljs-function"><span\n        class="hljs-params">props</span> =&gt;</span>(<span class="xml"><span class="code-tag">&lt;<span\n        class="code-name">div</span>&gt;</span><span class="code-tag">&lt;<span class="code-name">Menus</span> <span\n        class="hljs-attr">menus</span>=<span class="code-string">{props.menus}/</span>&gt;</span><span class="code-tag">&lt;<span\n        class="code-name">div</span>&gt;</span>{props.pageData}<span class="code-tag">&lt;/<span\n        class="code-name">div</span>&gt;</span><span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span>);\nComp.getInitialProps = async ({req})=&gt;{\n    //load Menu Promise\n    const menus = await getMenus();\n    //load Page Data Promise\n    const pageData = await getPageData();\n    return {menus, pageData}\n}\n</span></code></pre>\n<p>这样做在实现上没问题，但是在架构设计上是颇为糟糕的。以下三个原因：</p>\n<ol>\n    <li>\n        对于React有各种各样的描述，比如单向数据流、组件化等等。但是他的核心思想其实是<strong>分而治之</strong>。在Jquery“统治”的年代可以使用_selector_(比如<code>$(\'#id\')</code>)轻易获取到页面上的任何元素。一个项目如果没有很好的规范化管理（长久的人工规范化管理是需要投入不少成本的），久而久之会发现各个板块之间耦合性越来越强、坑越来越多(代码腐烂)。而React的单向数据流让组件与组件之间没有直接的沟通方式，规范化从技术层面就被强化，进而才会产生了_Redux_、_Flux_这一类按照“分-总-分”的模式（实际上就是一个消息总线模式）去控制模块间沟通的。所以将业务逻辑相关性并不强的页面和菜单放置在一个地方处理并不合理。\n    </li>\n    <li>绝大多数项目都不是一个人开发的，一个架构设计者要考虑到未来参与项目的开发者水平参差不齐。如果让框架级的结构直接暴露到业务开发者的面前，保不准某个负责业务开发的小伙伴忽略或修改了什么代码导致框架级的坑出现。</li>\n    <li>按照上面的代码，实际上要求每个内页都保留<code>const menus = await getMenus();</code>、<code>&lt;Menus menus={props.menus}/&gt;</code>这一类的代码（每个内页都复制粘贴）。在架构上这叫“样板式代码”，架构设计者应当尽量将这些代码通过“分层”的方式放到一个地方去处理。\n    </li>\n</ol>\n<p>所以有理由为_Nextjs_的<code>./pages</code>之外的组件实现ssr数据异步加载。</p>\n<h2 id="h2-5">组件ssr异步数据实现</h2>\n<p>为了实现本文的需求——让所有组件实现类似于<code>getInitialProps()</code>的方法，我们先要理清_Nextjs_前后端渲染的过程。</p>\n<h3 id="h3-2">渲染过程</h3>\n<p>_Nextjs_为使用者提供了<a href="https://github.com/palmg/website-standard-with-next/blob/master/pages/_app.js"><code>./pages/_app.js</code></a>和<a\n        href="https://github.com/palmg/website-standard-with-next/blob/master/pages/_document.js"><code>./pages/_document.js</code></a>在内页处理之前执行某些任务,后者用于构建整个HTML的结构。并且<a\n        href="https://github.com/palmg/website-standard-with-next/blob/master/pages/_document.js"><code>./pages/_document.js</code></a>只会在服务端执行。本文将开发者自行实现的内页称为_page,现在对于_Nextjs_就有三个类型的构建——_<em>document</em>、_<em>app_和_component</em>,每个构建都可以包含<code>static\n    getInitialProps()</code>、<code>constructor()</code>和<code>render()</code>方法，他们的执行过程如下。</p>\n<h4 id="h4-1">服务端执行过程</h4>\n<ol>\n    <li>_document getInitialProps()</li>\n    <li>_app getInitialProps()</li>\n    <li>_page getInitialProps()</li>\n    <li>_app constructor()</li>\n    <li>_app render()</li>\n    <li>_page constructor()</li>\n    <li>_page render()</li>\n    <li>_document constructor()</li>\n    <li>_document render()</li>\n</ol>\n<p>以上的过程分解如下：</p>\n<ol>\n    <li>\n        <p><strong>组装异步数据（1~3）</strong>：服务端会先开始执行<code>_document.getInitialProps()</code>这个静态方法，方法中会执行<code>_app.getInitialProps()</code>再遍历所有的<code>_page.getInitialProps()</code>执行到这里所有的异步数据完成组装。\n        </p>\n    </li>\n    <li>\n        <p><strong>渲染React组件（4~7）</strong>：有了数据之后开始渲染页面，会使用<a\n                href="https://reactjs.org/docs/react-dom-server.html"><code>ReactDOMServer</code></a>执行产生一个HTML格式的字符串。\n        </p>\n    </li>\n    <li>\n        <p><strong>构建静态HTML（8~9）</strong>：有了<a href="https://reactjs.org/docs/react-dom-server.html"><code>ReactDOMServer</code></a>产生的字符串剩下的工作就是将其组装为一个标准的HTML文档返回给客户端。\n        </p>\n    </li>\n</ol>\n<h4 id="h4-2">客户端执行过程</h4>\n<p><strong>初始化页面时（首次打开页面）：</strong></p>\n<ol>\n    <li>_app constructor()</li>\n    <li>_app render()</li>\n    <li>_page constructor()</li>\n    <li>_page render()</li>\n</ol>\n<p>\n    客户端在首次打开页面时（或刷新页面）服务端已经提供了完整的HTML文档可以立即显示。此时React的组件依然执行一次虚拟Dom渲染，所以所有的组件都会执行。然后_Nextjs_利用类似于_React_服务端渲染的_checksum_的机制防止虚拟Dom对真实Dom进行渲染，关于_React_服务端渲染的_checksum_机制可以到<a\n        href="https://www.chkui.com/article/react/react_server_render_with_checksum">React 前后端同构防止重复渲染</a>一文了解。</p>\n<p><strong>内页跳转时（通过<code>next/link</code>跳转）：</strong></p>\n<ol>\n    <li>_app getInitialProps()</li>\n    <li>_page getInitialProps()</li>\n    <li>_app render()</li>\n    <li>_page constructor()</li>\n    <li>_page render()</li>\n</ol>\n<p>客户端跳转到一个新的内页和服务端渲染就没有什么关系了。__app和_page_的<code>getInitialProps()</code>先组装数据，然后通过<code>props</code>将组装好的数据传递给组件去渲染。需要注意的是_app的构造方法在内页跳转的时候并不会执行，因为它只在整个页面渲染的时候实例化一次。\n</p>\n<h3 id="h3-3">实现</h3>\n<p>在了解_Nextjs_解执行过程之后实现需求就很简单了——先通过_document或_app的<code>getInitialProps()</code>方法完成数据组装，然后将数据传递给对应的组件即可。当然按照分而治之的思想不能直接在框架去完成业务的事，需要为组件提供一个注册接口然后由_document或_app使用注册的方法去构建业务数据。\n</p>\n<p><strong>数据加载方法注册</strong></p>\n<p>首先需要为我们组件提供一个注册异步加载数据的接口，组件可以利用这个接口注册异步加载数据的方法让框架统一去<code>getInitialProps()</code>执行。 <a\n        href="https://github.com/palmg/website-standard-with-next/blob/master/util/serverInitProps.js"><code>./util/serverInitProps.js</code></a>提供了这个功能:\n</p>\n<pre><code class="javascript"><span class="code-keyword">const</span> FooDict = {};\n<span class="code-comment">//注册方法</span>\n<span class="code-keyword">export</span> <span class="code-keyword">const</span> registerAsyncFoo = <span\n            class="hljs-function">(<span class="hljs-params">key, foo, params = {}</span>) =&gt;</span> {\n    FooDict[key] = {foo, params};\n};\n\n<span class="code-comment">//获取方法</span>\n<span class="code-keyword">export</span> <span class="code-keyword">const</span> executeAsyncFoo = <span\n            class="code-keyword">async</span> () =&gt; {\n    <span class="code-keyword">const</span> valueDict = {};\n    <span class="code-keyword">const</span> keys = <span class="code-built_in">Object</span>.keys(FooDict);\n    <span class="code-keyword">for</span> (<span class="code-keyword">let</span> key <span\n            class="code-keyword">of</span> keys) {\n        <span class="code-keyword">const</span> dict = FooDict[key];\n        valueDict[key] = <span class="code-keyword">await</span> dict.foo(dict.params);\n    }\n    <span class="code-keyword">return</span> valueDict;\n};\n\n\n</code></pre>\n<p>然后我们在<a\n        href="https://github.com/palmg/website-standard-with-next/blob/master/components/app/application/menu.js"><code>menu</code></a>组件中注册异步获取数据的方法：\n</p>\n<pre><code class="javascript">registerAsyncFoo(<span class="code-string">\'menus\'</span>, getMenus);\n</code></pre>\n<p><code>getMenus</code>模拟异步获取数据的过程:</p>\n<pre><code class="javascript"><span class="code-keyword">import</span> {Menus} <span\n        class="code-keyword">from</span> <span class="code-string">"../../../../data/menuData"</span>;\n<span class="code-keyword">export</span> <span class="code-keyword">const</span> getMenus = <span class="hljs-function"><span\n            class="hljs-params">()</span> =&gt;</span> {\n    <span class="code-comment">//可以将这个promise修改为一个net方法实现异步动态装菜菜单</span>\n    <span class="code-keyword">return</span> <span class="code-keyword">new</span> <span\n            class="code-built_in">Promise</span>(<span class="hljs-function">(<span\n            class="hljs-params">resolve, reject</span>) =&gt;</span> {\n        resolve(Menus)\n    })\n};\n</code></pre>\n<p>注册完成后再<code>_app</code>中执行异步加载：</p>\n<pre><code class="javascript"><span class="code-keyword">import</span> {executeAsyncFoo} <span\n        class="code-keyword">from</span> <span class="code-string">"../util/serverInitProps"</span>;\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">ExpressApp</span> <span\n        class="code-keyword">extends</span> <span class="code-title">App</span> </span>{\n    <span class="code-keyword">static</span> <span class="code-keyword">async</span> getInitialProps({Component, router, ctx}) {\n        info(<span class="code-string">\'Execute _App getInitialProps()!\'</span>, <span class="code-string">\'executeReport\'</span>);\n        <span class="code-comment">/**\n         * app的getInitialProps会在服务端被调用一次，在前端每次切换页面时被调用。\n         */</span>\n        <span class="code-keyword">let</span> pageProps = {}, appProps = {};\n        <span class="code-keyword">if</span> (Component.getInitialProps) {\n            pageProps = <span class="code-keyword">await</span> Component.getInitialProps(ctx);\n        }\n        <span class="code-keyword">if</span> (ctx &amp;&amp; !ctx.req) {<span class="code-comment">//客户端执行</span>\n            appProps = <span class="code-built_in">window</span>.__NEXT_DATA__.props.appProps;\n        } <span class="code-keyword">else</span> {<span class="code-comment">//服务端执行</span>\n            appProps = <span class="code-keyword">await</span> executeAsyncFoo();\n        }\n        <span class="code-keyword">return</span> {pageProps, appProps}\n    }\n    <span class="code-comment">//other function</span>\n}\n</code></pre>\n<p>在服务端获取到数据之后会返回给<code>_ducoment</code>，_Nextjs_会将这些数据写到HTML的<code>window.__NEXT_DATA__</code>对象上而后在客户端可以从这个对象获取到已经在服务端加载的数据。\n    最后用React的Context特性传递数据，有需要用到这些数据的组件可以从<a\n            href="https://github.com/palmg/website-standard-with-next/blob/master/components/app/applicationContext.js"><code>ApplicationContext</code></a>中获取这些数据:\n</p>\n<pre><code class="javascript"><span class="code-comment">//_app</span>\n<span class="code-keyword">import</span> ApplicationContext <span class="code-keyword">from</span> <span\n            class="code-string">\'../components/app/applicationContext\'</span>\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">ExpressApp</span> <span\n        class="code-keyword">extends</span> <span class="code-title">App</span> </span>{\n     <span class="code-comment">//other function</span>\n     render() {\n        info(<span class="code-string">\'Execute _App render()!\'</span>, <span class="code-string">\'executeReport\'</span>);\n        <span class="code-keyword">const</span> {Component, pageProps, appProps} = <span\n            class="code-keyword">this</span>.props;\n        <span class="code-keyword">return</span> (\n            &lt;ApplicationContext.Provider value={appProps}&gt;\n                &lt;Application&gt;\n                    &lt;Component {...pageProps} /&gt;\n                &lt;/Application&gt;\n            &lt;/ApplicationContext.Provider&gt;\n        )\n    }\n    //other function\n}\n</code></pre>\n<pre><code class="javascript"><span class="code-comment">//menu</span>\n<span class="code-keyword">import</span> ApplicationContext <span class="code-keyword">from</span> <span\n            class="code-string">\'../applicationContext\'</span>\n<span class="code-keyword">const</span> Menu = <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> {\n    <span class="code-keyword">return</span> (\n        <span class="xml"><span class="code-tag">&lt;<span\n                class="code-name">ApplicationContext.Consumer</span>&gt;</span>\n            {appProps =&gt; {\n                const {menus} = appProps;\n                return menus.map(menu =&gt; (\n                    <span class="code-tag">&lt;<span class="code-name">Link</span> <span\n                            class="hljs-attr">href</span>=<span class="code-string">{menu.href}</span>&gt;</span>\n                        <span class="code-tag">&lt;<span class="code-name">a</span>&gt;</span>{menu.name}<span\n                    class="code-tag">&lt;/<span class="code-name">a</span>&gt;</span>\n                    <span class="code-tag">&lt;/<span class="code-name">Link</span>&gt;</span>\n                ))\n            }}\n        <span class="code-tag">&lt;/<span class="code-name">ApplicationContext.Consumer</span>&gt;</span>\n    );\n};\n</span></code></pre>\n<p><a href="https://github.com/palmg/website-standard-with-next/blob/master/util/serverInitProps.js"><code>./util/serverInitProps.js</code></a>可以在任何组件中使用，<code>_app</code>会逐一执行方法获取数据按照kev-value的方式设置到<code>ApplicationContext</code>中，而任意组件要做的仅仅是从<code>ApplicationContext</code>拿到目标数据。\n</p>\n<p>当然传递数据的方式不仅仅局限于React的Context特性，换成Redux或全局管理数据的方法都是可行的。</p>\n<p><a href="https://www.chkui.com/" title="@随风溜达的向日葵">@随风溜达的向日葵</a></p>'},392:function(n,s,e){"use strict";Object.defineProperty(s,"__esModule",{value:!0});s.content='<h2 id="h2-1">一切从配置开始</h2>\n<p>在<a href="https://www.chkui.com/article/vertx/micro_service_index">微服务架构概念索引</a>一文中介绍了整个云源生应用的搭建体系，后续的内容将会从Spring\n    Cloud从技术架构，到基础设置再到团队协作方式一点一滴的记录搭建整个云服务的过程。现在从最基本的中心化配置开始介绍。</p>\n<p>Spring基金会项目繁多、种类各异，但是他们都脱离不了一个基本的要求——基于<a\n        href="https://www.chkui.com/article/spring/spring_annotation_of_xml_configuration">Spring Ioc的配置</a>。Spring的基础在于IoC容器，各种各样的项目都在IoC容器的基础之上扩展而来。在<a\n        href="https://www.chkui.com/article/spring/spring_core_design_pattern_and_ioc">设计模式与IoC</a>中已经介绍了IoCs的目的就是解决数据与Bean的关系、以及Bean与Bean之间的关系。\n</p>\n<h2 id="h2-2">Spring Cloud 中心化配置</h2>\n<p>在单Jvm的Spring应用中各种配置文件都是通过<a\n        href="https://www.chkui.com/article/spring/spring_core_environment_management_of_profile">Profile</a>结合<a\n        href="https://www.chkui.com/article/spring/spring_core_properties_management">PropertySource</a>进行管理，而到了<a\n        href="https://www.chkui.com/article/spring/spring_features_configuration">Spring Boot</a>则提供了大量的默认配置简化了这个过程。而在Spring\n    Cloud中需要管理大量的节点，中心化配置的需求随之而产生。</p>\n<p>Spring\n    Cloud的中心化配置并没有什么特别神奇的地方，实际上就是把本该放到本地的配置文件（例如application.yml）统一放置到一个仓库中。然后用一个Web服务来管理仓库，其他微服务节点从这个Web服务获取配置文件。所以就算没有Spring\n    Cloud Config提供这个功能，我们也可以自己编码在ApplicationContext的启动装载IoC之前先处理好配置。</p>\n<p>在假设有别的Spring Cloud知识之前，本文介绍不使用Netflix和Eureka注册服务的来管理中心化配置的方法。</p>\n<p><img src="http://file.mahoooo.com/res/file/2019-04-10-spring-cloud-config-struts.png" alt="Spring云源生应用-中心化配置"\n        title="配置服务结构" class="zoom-in-cursor"></p>\n<p>上图是Spring Cloud Config的基本结构。左侧是一系列的微服务节点，右侧是他们对应的配置文件。例如Node-1服务对应的是<em>node-1-config.yml</em>文件，在单一的应用中本来<em>node-1-config.yml</em>文件应该是放置在Node-1工程的classpath下的，现在的区别是将他们分开，将配置文件统一放置到一个仓库中，然后用Config-Service来管理。\n</p>\n<p>中心化配置就是这么简单，除了把配置文件拆走其他的使用方式完全一样，可以通过<a\n        href="https://www.chkui.com/article/spring/spring_core_properties_management">PropertySources或@Value注解</a>来获取配置的参数。\n</p>\n<p>至于中心化配置有什么好处就不用一一细说了，除了在负载均衡中减少配置之外，也便于环境管理等等。</p>\n<h2 id="h2-3">启用中心化配置</h2>\n<p>清楚原理之后做事就简单了，案例代码一共包含三个工程（<a\n        href="https://github.com/chkui/spring-cloud-samples/tree/master/configuration">github源码</a>），分别是<em>configuration-server</em>、<em>configuration-node-1</em>和<em>configuration-node-2</em>。configuration-server就是图中的Config-Service，他为所有的微服务节点提供中心化配置服务，所有的配置都在独立的<a\n        href="https://github.com/chkui/spring-cloud-repo">git仓库中</a>，在某个微服务节点请求配置数据的时候，<em>configuration-server</em>会去仓库中获取对应的配置并传输给微服务节点。\n</p>\n<h3 id="h3-1">Config Service</h3>\n<p>Spring Cloud的中心化配置服务通过Http请求提供配置管理服务，所以他自身也是一个Web。要启用的配置服务就2步：1.写一个配置文件指定服务端口和配置文件仓库，2.启动Spring Web服务。</p>\n<p>下面<code>application.yml</code>指定了中心化服务的端口（8888），然后指定了配置文件的Git仓库。配置文件的仓库可以是本地文件夹、可以是git仓库或者其他任何形式，这里以Git作为例子。</p>\n<pre><code class="yaml makefile"><span class="code-comment"># application.yml</span>\n<span class="code-section">server:</span>\n  port: 8888\n\n<span class="code-section">spring:</span>\n  cloud:\n    config:\n      server:\n        git:\n          uri:  https://github.com/chkui/spring-cloud-repo\n</code></pre>\n<p>配置好之后启动Web服务：</p>\n<pre><code class="java"><span class="code-comment">// chkui.spring.cloud.config.ConfigServiceApplication</span>\n\n<span class="code-meta">@EnableConfigServer</span> <span class="code-comment">//表示这是一个Configuration 服务</span>\n<span class="code-meta">@SpringBootApplication</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">ConfigServiceApplication</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tSpringApplication.run(ConfigServiceApplication.class, args);\n\t}\n}\n</code></pre>\n<p>启动web并没有任何特别之处，像个普通的Spring Boot工程启动即可。</p>\n<h3 id="h3-2">Client Node</h3>\n<p>有了中心化服务之后自然是要使用它。也仅仅需要2步：1.配置微服务，2.启动微服务。配置内容如下：</p>\n<pre><code class="yaml shell"><span class="code-meta">#</span><span class="bash"> bootstrap.yml</span>\nspring:\n  application:\n    name: node-config-1\n  cloud:\n    config:\n      uri: http://localhost:8888\n</code></pre>\n<p>访问中心化配置的参数主要就2个：1.指定配置文件名称、2.指定中心化服务器的地址与端口。</p>\n<p>\n    <strong>切记使用中心化配置时，像上面这个与服务器相关的配置要写到<code>bootstrap.yml</code>中，这样才能在访问远程配置之前先获取远程服务器的参数。写到<code>application.yml</code>里会导致永远都使用默认参数</strong>。\n</p>\n<p>配置文件的名称要与<a href="https://github.com/chkui/spring-cloud-repo">配置仓库</a>中的文件名对应。下面是<em>configuration-node-1</em>对应的配置文件的内容：\n</p>\n<pre><code class="yaml makefile"><span class="code-comment"># https://github.com/chkui/spring-cloud-repo/blob/master/node-config-1.yml</span>\n<span class="code-section">server:</span>\n  port: 9081 <span class="code-comment">#配置node-1端口</span>\n<span class="code-section">message: Response Node Client1 With WebFlux(Netty)! #配置message参数。</span>\n</code></pre>\n<p>下面是<em>configuration-node-1</em>中的主要代码：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.spring.cloud.config;\n<span class="code-comment">//import 省略</span>\n\n<span class="code-meta">@SpringBootApplication</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">ConfigClientApplication1</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n        SpringApplication.run(ConfigClientApplication1.class, args);\n    }\n}\n\n<span class="code-meta">@RestController</span>\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MessageRestController</span> </span>{\n\n    <span class="code-comment">//通过@Value注解获取中心化配置的参数</span>\n    <span class="code-meta">@Value</span>(<span\n            class="code-string">"${message:Configuration Server Error(Node-1)}"</span>)\n    <span class="code-keyword">private</span> String message;\n\n    <span class="code-meta">@RequestMapping</span>(<span class="code-string">"/message"</span>)\n    <span class="hljs-function">Mono&lt;String&gt; <span class="code-title">getMessage</span><span class="hljs-params">()</span> </span>{\n        <span class="code-keyword">return</span> Mono.just(<span class="code-keyword">this</span>.message);\n    }\n}\n</code></pre>\n<p><em>configuration-node-1</em>用spring-boot启动了一个WebFlux，这个时候访问 <a href="http://localhost:9081/message">http://localhost:9081/message</a>\n    会返回配置文件中的信息：<em>Response Node Client1 With WebFlux(Netty)!</em>。</p>\n<h2 id="h2-4">动态刷新</h2>\n<p>可以在不重启微服务节点的情况下更新配置参数，这在某些场景下非常意义。刷新配置参数主要是使用了<code>ConfigurableApplicationContext</code>的<code>refresh</code>接口，不过Spring\n    Cloud整合了Actuator功能直接外部调用接口即可。</p>\n<p><em>configuration-node-2</em>中的代码演示了这个过程：</p>\n<p>首先需要引入<code>spring-boot-starter-actuator</code>:</p>\n<pre><code class="groovy javascript">dependencies {\n\tcompile(<span class="code-string">\'org.springframework.cloud:spring-cloud-starter-config\'</span>)\n\tcompile(<span class="code-string">\'org.springframework.boot:spring-boot-starter-actuator\'</span>) <span\n            class="code-comment">//引入actuator</span>\n\tcompile(<span class="code-string">\'org.springframework.boot:spring-boot-starter-web\'</span>)\n}\n</code></pre>\n<p>然后在Controller层增加*@RefreshScope*注解：</p>\n<pre><code class="java"><span class="code-meta">@SpringBootApplication</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">ConfigClientApplication2</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tSpringApplication.run(ConfigClientApplication2.class, args);\n    }\n}\n\n<span class="code-meta">@RefreshScope</span>\n<span class="code-meta">@RestController</span>\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MessageRestController</span> </span>{\n    <span class="code-meta">@Value</span>(<span\n            class="code-string">"${message:Configuration Server Error(Node-2)}"</span>)\n    <span class="code-keyword">private</span> String message;\n\n    <span class="code-meta">@RequestMapping</span>(<span class="code-string">"/message"</span>)\n    <span class="hljs-function">String <span class="code-title">getMessage</span><span\n            class="hljs-params">()</span> </span>{\n        <span class="code-keyword">return</span> <span class="code-keyword">this</span>.message;\n    }\n}\n</code></pre>\n<p>最后在本地配置参数中暴露Actuator的接口：</p>\n<pre><code class="yaml php"><span class="code-comment">#</span>\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        <span class="code-keyword">include</span>: <span class="code-string">\'*\'</span>\n</code></pre>\n<p>现在就可以通过Actuator暴露的接口来更新配置参数——Post访问 <code>localhost:9082/actuator/refresh</code>：</p>\n<pre><code class="bash">curl localhost:9082/actuator/refresh -d {} -H <span class="code-string">"Content-Type: application/json"</span>\n</code></pre>\n<p>到了Spring Boot 2.×之后Actuator默认关闭所有Web服务接口。这里仅仅是说明有这个功能，通常不会使用Web暴露接口的方式来操作。如下图，Spring Boot和Spring\n    Cloud已经暴露了大量的MBean，通常会使用JMX来管理和监控服务状态。\n    <img src="http://file.mahoooo.com/res/file/2019-04-11-spring-cloud-config-mbeans.png" alt="Spring云源生应用-中心化配置"\n         title="Spring Cloud MBeans" class="zoom-in-cursor"></p>\n<p>所以如果要使用 配置刷新 等功能建议使用<code>Spirng Boot Admin</code>或者其他基于JMX的管理工具来操作。</p>\n<h2 id="h2-5">配置说明</h2>\n<h3 id="h3-3">服务端</h3>\n<p>启用必要配置：</p>\n<ol>\n    <li>引入<code>spring-cloud-config-server</code>。</li>\n    <li>设置服务端口：<code>server.port</code></li>\n    <li>设置仓库地址：<code>spring.cloud.config.server.git.uri</code>，仓库类型可以有很多种。</li>\n</ol>\n<p>更多配置：</p>\n<ol>\n    <li><code>spring.cloud.config.server.git.timeout</code><a\n            href="https://cloud.spring.io/spring-cloud-config/spring-cloud-config.html#_setting_http_connection_timeout"\n            title="可以设置访问仓库的超时时间（秒）">可以设置访问仓库的超时时间（秒）</a>。\n    </li>\n    <li><code>spring.cloud.config.server.git.uri</code><a\n            href="https://cloud.spring.io/spring-cloud-config/spring-cloud-config.html#_placeholders_in_git_uri"\n            title="可以使用`{application}`、`{profile}`等占位符">可以使用<code>{application}</code>、<code>{profile}</code>等占位符</a>。用于复杂的仓库管理。\n    </li>\n    <li>占位符可以配合使用通配符和正则表达式来解决更复杂的配置问题：<a\n            href="https://cloud.spring.io/spring-cloud-config/spring-cloud-config.html#_pattern_matching_and_multiple_repositories"\n            title="参考资料">详细</a>。\n    </li>\n    <li>通常git仓库都涉及到权限认证，可以用<a\n            href="https://cloud.spring.io/spring-cloud-config/spring-cloud-config.html#_authentication" title="HTTPS">HTTPS</a>或者<a\n            href="https://cloud.spring.io/spring-cloud-config/spring-cloud-config.html#_git_ssh_configuration_using_properties"\n            title="ssh-key">SSH-KEY</a>的方式解决。\n    </li>\n    <li><a href="https://cloud.spring.io/spring-cloud-config/spring-cloud-config.html#_force_pull_in_git_repositories"\n           title="`force-pull`参数可以强制更新本地仓库中的配置文件"><code>force-pull</code>参数可以强制更新本地仓库中的配置文件</a>。\n    </li>\n    <li><code>spring.cloud.config.server.git.repos</code>参数可以用于多项配置，用子目录来区分配置。</li>\n    <li><code>spring.cloud.config.server.git.refreshRate</code>可以控制服务器到仓库的更新频率。默认为0，表示只要有微服务请求了数据就会去远程仓库获取文件。</li>\n    <li><code>spring.cloud.config.server.git.basedir</code>用于配置远程文件下载本地的临时文件夹，默认使用操作系统的<code>/tmp</code>。</li>\n    <li>除了使用本文介绍的使用git作为配置文件仓库，还支持<a\n            href="https://cloud.spring.io/spring-cloud-config/spring-cloud-config.html#_file_system_backend"\n            title="本地文件系统">本地文件系统</a>、<a\n            href="https://cloud.spring.io/spring-cloud-config/spring-cloud-config.html#vault-backend" title="Vault">Vault</a>、<a\n            href="https://cloud.spring.io/spring-cloud-config/spring-cloud-config.html#_jdbc_backend"\n            title="数据库">数据库</a>、<a\n            href="https://cloud.spring.io/spring-cloud-config/spring-cloud-config.html#_redis_backend" title="Redis">Redis</a>、<a\n            href="https://cloud.spring.io/spring-cloud-config/spring-cloud-config.html#_credhub_backend"\n            title="CredHub">CredHub</a>等方式管理配置仓库。\n    </li>\n    <li>[可以同时使用git、svn等仓库](Composite Environment Repositories "可以同时使用git、svn等仓库")。</li>\n    <li><a href="https://cloud.spring.io/spring-cloud-config/spring-cloud-config.html#_property_overrides"\n           title="`spring.cloud.config.server.overrides`"><code>spring.cloud.config.server.overrides</code></a>用于配置通用属性，通过这个配置可以让所有的节点都获取这个属性。\n    </li>\n    <li><a href="https://cloud.spring.io/spring-cloud-config/spring-cloud-config.html#_security" title="安全管理">安全管理</a>用于在一些非独立的环境做中心化配置，比如配置服务器直接放置在外网。\n    </li>\n    <li>通常情况下会将Config Server作为一个独立的Web服务，但是也可以使用<code>spring.cloud.config.server.bootstrap</code>和``<a\n            href="https://cloud.spring.io/spring-cloud-config/spring-cloud-config.html#_embedding_the_config_server"\n            title="但是也可以把他嵌入别的系统中去">嵌入别的系统中去</a>。\n    </li>\n</ol>\n<h3 id="h3-4">客户端</h3>\n<ol>\n    <li>引入<code>spring-cloud-starter-config</code>。</li>\n    <li>在<code>bootstrap.yml</code>设置中心化配置服务地址：<code>spring.cloud.config.uri</code>。</li>\n    <li>在<code>bootstrap.yml</code>设置文件名：<code>spring.application.name</code>。</li>\n    <li>可以在<code>bootstrap.yml</code>设置profiles：<code>spring.profiles.active</code>。非必要</li>\n</ol>\n<h3 id="h3-5">配置仓库</h3>\n<ol>\n    <li>中心化配置文件同样支持<code>profile</code>特性，所以在仓库中具备以下命名规则：</li>\n</ol>\n<pre><code class="coffeescript"><span class="hljs-regexp">/{application}/</span>{profile}[/{label}]\n/{application}-{profile}.yml\n<span class="hljs-regexp">/{label}/</span>{application}-{profile}.yml\n/{application}-{profile}.properties\n<span class="hljs-regexp">/{label}/</span>{application}-{profile}.properties\n</code></pre>'},411:function(n,s,e){"use strict";Object.defineProperty(s,"__esModule",{value:!0});s.content='<h2 id="h2-1">表命名规范</h2>\n<p>表命名的规则分为3个层级，层级之间通过<code>_</code>分割，例如<code>b_r_identity</code>、<code>d_l_identity</code>。规约为:</p>\n<pre><code class="css"><span class="hljs-selector-attr">[leavel]</span>_<span\n        class="hljs-selector-attr">[type]</span>_<span class="hljs-selector-attr">[name]</span>\n</code></pre>\n<p><strong>[leavel]</strong> 表示数据库表的层级和功能，分为：</p>\n<ol>\n    <li><strong>s</strong>：业务无关的系统数据表。</li>\n    <li><strong>d</strong>：业务字典表。</li>\n    <li><strong>b</strong>：基础业务表。</li>\n    <li><strong>v</strong>：视图。</li>\n    <li><strong>i</strong>：聚合中间表。</li>\n</ol>\n<p><strong>[type]</strong> 表示数据库表的类型，分为：</p>\n<ol>\n    <li><strong>r</strong>：行数据表。</li>\n    <li><strong>l</strong>：列数据表。</li>\n    <li><strong>g</strong>：分组数据表。</li>\n</ol>\n<p><strong>[name]</strong> 用来表示表的作用名称，由于mysql默认对大小写不敏感，采用下划线命名法。比如：\n    <code>identity_enterprise</code>。</p>\n<p>因此，综合上面的规范，<strong>账号-账户管理模块</strong>命名为<strong>identity</strong>，相关的表命名为：</p>\n<ul>\n    <li>模块中的数据字典以列数据的方式存储，名称为：<code>d_l_identity_dc</code>。</li>\n    <li>模块中的账号主表以行数据的方式存储，命名为：<code>b_r_identity</code>。</li>\n    <li>模块中的账户表以行数据的方式存储，名为：<code>b_r_account</code>。</li>\n    <li>模块中的账号企账扩展表以行数据的方式存储，名为：<code>b_r_identity_enterprise</code>。</li>\n</ul>\n<p>采用以上命名法的目的：</p>\n<ol>\n    <li>便于代码开发阶段区分表的功能和数据组织形式；</li>\n    <li>通过前缀为以后可能会引入的开源框架生成的表扩展命名空间。</li>\n</ol>\n<blockquote>\n    <p>比如引入了流程框架activity，会向数据库添加几十个表，其中有名为account的表，如果不适用前缀，会增加引入的成本。</p>\n</blockquote>\n<h2 id="h2-2">字段命名规范</h2>\n<ol>\n    <li>逻辑主键：id。所有的表必须创建逻辑主键。采用统一的主键便于分库分表以及数据抽取。</li>\n    <li>业务主键：code, 必须创建唯一索引。业务主键除了反应真实数据关联，也便于程序进行类型判断。</li>\n    <li>外键：columnName_fk，字段名+fk后缀，比如state_fk。</li>\n    <li>父主键关联：pid</li>\n</ol>\n<h2 id="h2-3">行数据规范</h2>\n<p>所有的表必须包含modify_date、modify_type、modify_user、modify_access_id、activity字段。</p>\n<ol>\n    <li><code>modify_date</code>：标记数据修改时间，用于数据增量ETL或缺陷回溯。类型：<code>TIMESTAMP(13)</code>。</li>\n    <li>\n        <code>modify_type</code>：数据修改类型，通常数据由运营后台修改<code>OPR(0)</code>，或账号拥有这修改<code>USR(1)</code>。用于记录数据修改的行事人。类型：<code>TINYINT(1)</code>。\n    </li>\n    <li><code>modify_user</code>：结合modify_type，标记是修改人。类型：<code>BIGINT</code>。</li>\n    <li><code>modify_access_id</code>：在数据库中用于标记当前数据修改是由哪个访问id导致的。类型：<code>BIGINT</code>。</li>\n    <li><code>activity</code>：行数据标识符。用于标识行数据的作用范围，ACT(1)/DIS(2)/DEL(0)，启用、停用、逻辑删除。类型：<code>TINYINT(1)</code>。</li>\n    <li>所有的时间字段均以时间戳（Java十三位标准）的方式存储，Mysql对应<code>TIMESTAMP(13)</code>类型。</li>\n</ol>\n<h2 id="h2-4">主键规范</h2>\n<p>\n    逻辑（物理）主键使用64bit的<code>BigInt</code>类型，通过<strong>Snowflake算法获取</strong>。它可以完全充当<em>Mysql</em>主键，也能平滑兼容<em>MyCat</em>、<em>Sharding-jdbc</em>（3.0后更名为<em>Sharding-Sphere</em>）等开源分库分表数据源管理工具。\n</p>\n<p>业务组件原则上不做任何关联查询，只用于标记单表业务内容。</p>\n<p>采用该规范的原因请见后文<strong>主键规范设计背景及原因</strong>。</p>\n<hr>\n<h2 id="h2-5">主键规范设计背景及原因。</h2>\n<p>在分布式微服务系统中采用Mysql的自增主键在分表分库、灾备合库、分布式执行、缓存Write-Behind写时会有很大制约，因此需要制定不依赖数据库的行主键规范。</p>\n<h3 id="h3-1">主键类型</h3>\n<p>在解释数据设计规范之前先理解<strong>物理主键</strong>、<strong>逻辑主键</strong>和<strong>业务主键</strong>的区别:</p>\n<p><strong>物理主键</strong>即认为是数据库的自身的物理标识主键，例如oracle的ROW_ID，mysql的自增Sequence，物理主键除了具备独立的物理特性，也是数据库连接数据的核心。mysql中要求单表唯一。\n</p>\n<p><strong>逻辑主键</strong>是与数据库无关的非业务意义的主键，用于对行数据的唯一性进行标识。在单数据库系统中，通常不需要逻辑主键，而在分布式系统中，逻辑主键的意义重大。无论是什么数据库，逻辑主键要求全库（所有的数据库）唯一。某些时候可以将物理主键和逻辑主键合二为一。\n</p>\n<p><strong>业务主键</strong>是指与含有业务特性的的主键，例如订单编号会以 时间+流水号+业务编号实行存在。业务主键通常的要求是单向业务唯一，由于从技术角度来说业务是随时可变的，因此业务主键并不能提到逻辑主键或物理主键。\n</p>\n<h3 id="h3-2">MySql（InnoDB）索引特性</h3>\n<p>由于InnoDB的行数据排列是以主键数据（Oracle是ROW_ID）作为b+树索引，<strong>而扩展的索引都以主键索引作为数据对象——这种方式称为聚集索引</strong>。所以最大效率的保证b+树主键和索引数据进入的递增性对于数据库的性能有决定性作用（b+树越扁平，效率越高）。\n</p>\n<p>使用mysql的自增Sequence可以很自然的解决这个问题，主键就向一个队列一样，只要insert数据向队列尾push数据即可，几乎不会发生索引重建和数据碎片。但是自增队在分布式系统中使用有巨大的局限性。</p>\n<p>如果直接使用UUID既充当物理主键又充当业务主键，由于 <em>UUID并无法保障数据的递增性(？)</em>,会导数据碎片已经主键索引更新效率。此外UUID的长度是32位字符串，即使用ascii的编码方案，也会占据不少的空间。\n</p>\n<h3 id="h3-3">传统中间解决方案</h3>\n<p>\n    基于Mysql目前也可以自动生成UUID，所以有一种中间解决方案是在分布式系统的数据库中物理主键使用Mysql的自增Sequence，逻辑主键使用UUID，所有的ER关联都使用UUID建立，这样可以很好的保障<strong>聚集索引</strong>添加数据的效率，且能极大减少碎片。由于InnoDB聚集索引除了主键索引都会引起二次查询，所以这种方式外关联效率较差（即使是单表查询效率也一般）。\n</p>\n<h3 id="h3-4">主键需求</h3>\n<p>整合以上内容，现在我们需要一个具备以下特征的主键：</p>\n<ol>\n    <li>递增。</li>\n    <li>全系统唯一（至少保证单业务唯一）。</li>\n    <li>高效产生。</li>\n    <li>尽量短。（减少扩展索引的存储空间）</li>\n</ol>\n<h3 id="h3-5">连续递增与趋势递增</h3>\n<p>对于B+树递增要求的并不需要连续递增（0,1,2,3,4......）,只要趋势递增即可（0,3,5,7,18,100.....）。</p>\n<h3 id="h3-6">Snowflake算法</h3>\n<p>为了满足主键需求，现在比较推崇的是<em>Snowflake算法</em>。</p>\n<p>\n    <img src="http://upload-images.jianshu.io/upload_images/2308314-36052935d31a654e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp"\n         alt="数据结构（ER数据库）设计规范" title="Snowflake算法" class="zoom-in-cursor"></p>\n<p>Snowflake算法会产生一个<code>64bit</code>的数据，正好在Java中是一个long类型，对应Mysql是一个BigInt类型。</p>\n<ol>\n    <li>第一位是符号位（正负号）。在使用过程中基本不用理睬。</li>\n    <li>其后的41位表示时间戳的差值。</li>\n    <li>10位工作机id称为workid，需要人工指定。10bit=2^10=1024个Id</li>\n    <li>后续的12位用于在微秒级别生成序列号。</li>\n</ol>\n<p><strong>效率：</strong></p>\n<ul>\n    <li>\n        <p>因为其本质上还是一个数字，所以在关联查询能力上不会比源生的自增Sequence的差多少（微秒/纳秒级别）。</p>\n    </li>\n    <li>\n        <p>官方文档Snowflake Id算法理论上单机每秒可以生成409.6万个ID——1000个微秒单位，12位序列编码=1000*(2^12)。</p>\n    </li>\n</ul>\n<p><strong>递增性质：</strong></p>\n<p>算法是以微秒+递增序列作为区分的，并且时间单位处于64bit中的高位，在所有的微服务节点没有达到生成极限时（每秒409.6万个）一定是趋势递增的，计时达到了极限，也仅仅在时间单位出现相同。</p>\n<p><strong>传输：</strong></p>\n<p>64bit的long类型转换为十进制只有20个数字，由于64bit的第一个位置表示符号，所以实际只有19个数字。在http报文中仅仅是19个字符。如果将其转换为16进制或[0~9a~z]满表的36进制。长度还能极大的压缩。</p>\n<p><strong>局限性：</strong></p>\n<ol>\n    <li>\n        <p>\n            由于其本质是基于微秒级的机器时间戳进行ID生成，所以当整个集群有时间一致性服务时候，可能会发生时间回拨（也有可能是人为修改，不过几乎不可能发生）。当时间发生回拨时就会有极大的概率在回拨时间区内出现主键冲突。百度有个Snowflake算法变种解决方案是使用中心化的按块生成ID尽可能的回避这个问题。此外如果并发并没有达到极高的程度时，可以让入口服务器来统一生成access_id作为后续业务新增数据时的主键，当然这也没法完全解决这个问题。</p>\n    </li>\n    <li>\n        <p>\n            64bit的算法如果要求全系统主键唯一，那么基于算法的workid特性最大支持1024台服务器同时生成主键，再多就会出现冲突。解决办法就是不要求全系统唯一，而收敛为单个业务唯一，这样可以视为单个业务可以具有1024个分布式服务。</p>\n    </li>\n    <li>\n        <p>其数据位数决定了其从使用开始最多服务61年，61年后出现类似于千年虫的问题超出现有数据位。</p>\n    </li>\n</ol>\n<h3 id="h3-7">参考</h3>\n<ol>\n    <li>Snowflake算法最早由推特twitter的工程师创立并开源，现在整合到RPC框架<a href="https://twitter.github.io/finagle/"\n                                                      title="Finagle">Finagle</a>中，当然没必要引入整个Finagle，可以到这里<a\n            href="https://github.com/twitter-archive/snowflake/releases/tag/snowflake-2010" title="基本算法下载地址">下载核心算法</a>。\n    </li>\n    <li>Snowflake有个非常方便的使用途径是引入<a href="https://mvnrepository.com/artifact/io.shardingsphere/sharding-core"\n                                  title="sharding-core">sharding-core</a>。然后使用其中的<a\n            href="https://github.com/apache/incubator-shardingsphere/blob/b281f3e52410c2fdbc3e12e69a09e5109a96fa20/sharding-core/sharding-core-common/src/main/java/org/apache/shardingsphere/core/strategy/keygen/SnowflakeShardingKeyGenerator.java"\n            title="SnowflakeShardingKeyGenerator">SnowflakeShardingKeyGenerator</a>。当然Snowflake算法本身并不复杂，使用源码就能解决问题，而且具有极佳的扩展性。\n    </li>\n    <li>算法中workid最大支持1024，通常可以通过主动命名、ip地址、服务器命名等方式决定。</li>\n    <li>网上关于Snowflake算法的极少很多，自行查询解决问题。</li>\n</ol>'}});