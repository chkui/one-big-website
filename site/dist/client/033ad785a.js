webpackJsonp([0],{333:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<p>在hazelcast的官方文档中，提到了其支持read-through，write-through与write-behind三种模式。查阅资料，最后在oracle的官文中找到了比较靠谱的解释。</p>\n<p>read-throug、write-through、write-behind三个概念都是关于数据缓存管理的。其实这些概念在实际使用的过程中经常接触。</p>\n<h2 id="h2-1"><strong>Read-throug</strong></h2>\n<p>当应用系统向缓存系统请求数据时（例如使用key=x向缓存请求数据）；如果缓存中并没有对应的数据存在（key=x的value不存在），缓存系统将向底层数据源的读取数据。如果数据在缓存中存在（命中key=x），则直接返回缓存中存在的数据。这就是所谓的<strong>Read-throug。</strong></p>\n<p>hazelcast原文：</p>\n<blockquote>\n    <p>If an entry does not exist in the memory when an application asks for it, Hazelcast asks your loader implementation to load that entry from the data store。 &nbsp;If the entry exists there, the loader implementation gets it, hands it to Hazelcast, and Hazelcast puts it into the memory. This is read-through persistence mode。</p>\n</blockquote>\n<p>下图是Oracle官网的<strong>Read-throug</strong>图例。\n    <img alt="Hazelcast read-through、write-through与write-behind模式" src="https://file.mahoooo.com/res/file/read_through_write_through_and_write_behind_1.jpg">\n</p>\n<h2 id="h2-2">Write-Through</h2>\n<p>当应用系统对缓存中的数据进行更新时（例如调用put方法更新或添加条目），缓存系统会同步更新缓存数据和底层数据源。</p>\n<p>下图展示了执行过程：</p>\n<p><img alt="Hazelcast read-through、write-through与write-behind模式" src="https://file.mahoooo.com/res/file/read_through_write_through_and_write_behind_2.jpg"></p>\n<h2 id="h2-3">Write-Behind</h2>\n<p>当应用系统对缓存中的数据进行更新时（例如调用put方法更新或添加条目），缓存系统会在指定的时间后向底层数据源更新数据。</p>\n<p><img alt="Hazelcast read-through、write-through与write-behind模式" src="https://file.mahoooo.com/res/file/read_through_write_through_and_write_behind_3.jpg"></p>'},347:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h2 id="h2-1">jolokia架构</h2>\n<p>虽然jolokia是为了满足JSR-160的要求，但是他和JSR-160连接器有巨大的差异。其中最引人注目的区别是jolokia传递数据是无类型的数据（<span style="color:#FF8C00"><em>说白了就是使用了Json数据传递，替代了RMI传递Java序列化数据的方式</em></span>）。\n</p>\n<p>2003年提交的JSR-160规定客户端可以透明的调用MBean服务，无论被调用的MBean是驻留在本地还是在远程的MBean服务中。这样做的好处是提供了一个简洁通用的Java\n    API接口。但是JSR-160的实现存在许多问题：</p>\n<ol>\n    <li>它非常危险，因为它隐性暴露了JMX的远程接口。</li>\n    <li>它还存在性能问题。无论是远程还是本地调用，调用者至少要知道调用过程是怎么样的、会收到什么结果。在实际使用时，需要有明确的远程消息传递模式，让调用者知道现在是在使用响应较慢的远程调用。</li>\n    <li>使用RMI（<em><span style="color:#FF8C00">JSR-160连接器的默认协议栈</span></em>）时需要使用Java对象的序列化与反序列化机制来构建传递管道。这样做就阻碍了Java技术栈之外的环境来使用它。\n    </li>\n</ol>\n<p>以上3个原因大概就是RMI（<span style="color:#FF8C00"><em>JSR-160连接器的默认协议栈</em></span>）在远程传输协议上逐渐失去市场份额的原因。</p>\n<p>Jolokia是无类型的数据，使用了Json这种轻量化的序列化方案来替代RMI方案。使用这样的方法当然存在一些缺点（<em>比如需要额外增加一层代理</em>），但是带来了一些优势，至少这样的实现方案在JMX世界是独一无二的。</p>\n\n<h2 id="h2-2">Jolokia植入模式（Agent mode）</h2>\n<p><img alt="Jolokia——架构与使用介绍" height="489"\n        src="https://file.mahoooo.com/res/file/jolokia_how_to_use_2.png" width="666"></p>\n<p>上如展示了Jolokia 植入模式的体系结构，说明了与之有关的运行环境。</p>\n<p>Jolokia植入模式是在本地基于http协议提供了一个使用Json作为数据格式的外部接口，此时Jolokia会桥接到本地的JMX\n    MBeans接口。Jolokia使用http服务扩展了JSR-160，因此需要针对Jolokia的运行进行一些额外的处理。多种技术可以工作于http协议，最常规的方法是将jolokia放置到servlet容器中，比如Tomcat或Jetty，这样Jolokia完全可以看做是一个常规的Java\n    web应用，让所有的开发人员都能够很好理解并快速的从中读取数据。</p>\n<p>当然还有更多的方式使用Jolokia植入，比如使用OSGi HttpService或嵌入到有Jetty-Server的应用中。Jvm代理者需要使用Java1.6以上版本，在他运行时，可以连接到任何本地运行的Java进程。</p>\n<p><span style="color:#FF8C00"><em>附注——关于“植入模式”的称呼的说明：官方名为“Agent mode”，按照字面意思应该译为“代理者模式”。但是后面又一个模式叫代理模式（Proxy Mode），为了更便于理解和表达中文意思，这里命名其为“植入模式”。</em></span>\n</p>\n\n<h2 id="h2-3">Jolokia代理模式</h2>\n<p>代理模式用于无法将Jolokia部署到目标平台上（说白了就是无法部署到同一台服务器）。在这个模式下，唯一可用的方式就是目标服务开启了JSR-160连接。这样做大部分是规范原因（原文是“political\n    reasons”——政治原因-_-）——有时候根本不允许在目标服务器部署一个额外的软件系统，或者是这样做需要等待一个漫长的审批流程。还有一个原因是目标服务器已经通过RMI开启了JSR-160连接，并且我们不想额外再去在本地部署Jolokia。</p>\n<p>可以将jolokia.war部署到servlet容器中（这个war包也可用于植入模式）。下图是一个典型的代理模式架构。</p>\n<p><img alt="Jolokia——架构与使用介绍" height="439"\n        src="https://file.mahoooo.com/res/file/jolokia_how_to_use_1.png" width="617"></p>\n<p>一个jolokia客户端发送常规的请求到jolokia代理服务，这个请求包含了额外的数据用于标记要查询的目标。所有的路由信息包含在请求信息中，使得代理服务无需特别的配置即可工作。</p>\n\n<h2 id="h2-4">结尾</h2>\n<p>如果没有什么特别的限制，优先使用植入模式。植入模式比代理模式有更多的优势，因为他没有附加层、减少了维度成本和技术复杂性、而且性能也优于代理模式。此外，一些jolokia特性也无法在代理模式中使用，例如“merging of\n    MBeanServers”。</p>'},351:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<p>使用react到现在，让人头疼的一个问题是安装node-sass。其实导致问题的根源在于安装过程需要下载一个binding.node文件，而因“你懂的”原因，访问不了这个地址。根据这个原因，总结了以下几个解决方案：</p>\n<h2 id="h2-1">翻墙</h2>\n<p>这没什么好说的了，这是最轻松最彪悍的解决方案。只要能翻墙直接一个&nbsp;<span style="background-color:#D3D3D3">&nbsp;npm i&nbsp;</span>命令就完事了，什么都不必去操心。至于怎么翻墙…………\n</p>\n\n<h2 id="h2-2">使用cnpm</h2>\n<p>cnpm是一个强悍的工具，几乎能解决所有npm安装第三方包时遇到的问题。执行如下命令即可：</p>\n<pre class="sql"><code class="language-bash">npm <span class="code-keyword">install</span>\nnpm rm node-sass\ncnpm <span class="code-keyword">install</span> node-sass\nnpm <span class="code-keyword">install</span></code></pre>\n<p>\n    但是我们在使用cnpm时也遇到了一个坑，在ubuntu14.04打出来的包运行报错，不用cnpm下载居然就不会有这问题，由于没有时间，没有详细去了解原因是什么。如果你是Windows开发而使用Linux环境打包或运行，可能会碰到这个问题。</p>\n\n<h2 id="h2-3">下载后编译</h2>\n<p>\n    实际上为了得到binding.node，是可以直接从github上把源码下载下来之后再编译出来的，node-sass自己也会这样做，但是编译要依赖其他工具。在各种发行版的linux下还好，几乎所有需要的环境（python等）都是预安装的，如果是root权限直接<span\n        style="background-color:#A9A9A9"> upm install </span>就搞定了，所以有时候根本感觉不到这个问题。在windows下就得花时间根据install时的错误日志了解还要安装什么。\n</p>\n<p>linux下遇到权限问题请执行：</p>\n<pre class="lua"><code class="language-bash">npm i <span class="code-comment">--unsafe -perm</span></code></pre>\n\n<h2 id="h2-4">附送一个最奇葩的坑</h2>\n<p>这是我用所有的开源工具遇到过最奇葩的坑。我将一个文件命名为“./dropDown.scss”，然后在linux(是ubuntu\n    14.04其他发行版没时间去测试，windows没这毛病)上用webpack打包，打包过程没有任何异常，但是放到服务器上运行打开某个页面就抛出无法找到"./dropDown.scss"的异常，然后node直接停机了········。我前后跟进了2天寻找问题的原因。最后突发奇想将文件名由dropDown.scss修改为pullDown.scss后一切都好了。我强烈的怀疑是某个临时工在node-sass里写了什么“硬编码”对字符串进行判断，发现“/drop[*]”这样的前缀进行一些特殊处理。在此记录下来。</p>'},353:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<p>\n    React提供了一系列声明性的API接口，因此在使用时不必担心每次库的更新会修改API接口。这样可以降低编写应用的复杂度，但是带来的问题是无法很好的理解React是如何实现这些功能的。这篇文章会介绍React的差异比对算法——“融合算法”是如何执行的。</p>\n\n<h2 id="h2-1">差异匹配算法实现的前提</h2>\n<p>我们先来看看第一个值得关注的我问题：&nbsp;<code>render()</code>&nbsp;方法的作用是创建React元素的树形结构，当state或props发生更新后，&nbsp;<code>render()</code>&nbsp;会返回一个与之前有差异的结构树。在这个机制下，React需要弄清楚如何匹配最近的树并有效的更新UI。\n</p>\n<p>针对以上问题，有一些通用的算法可供参考，比如比对2颗树的差异，在前一个颗树的基础上生成最小操作树，但是这个算法的时间复杂度为n的三次方=O(n*n*n)，当树的节点较多时，这个算法的时间代价会导致算法几乎无法工作。</p>\n<p>\n    假设在我们使用React时，一共使用了1000个Dom标签元素，那么使用上面的算法，我们要比对数亿次才能得到比对的结果，根本不可能在一个浏览器中短时间完成。React实现了一个计算复杂度是O(n)的算法来解决这个问题，这个算法基于2个假设：</p>\n<ol>\n    <li>不同类型的2个标签元素产生不同的树。</li>\n    <li>开发人员可以为不同的子节点在渲染之前设定一个“key”属性值。</li>\n</ol>\n\n<h2 id="h2-2">差异算法</h2>\n<p>对于2颗有差异的树，React首先比对2颗树的根节点。根据跟节点的类型是否相同，算法接下来会执行不同的操作。</p>\n\n<h2 id="h2-3">Types不一样</h2>\n<p>\n    一旦2棵树之间的根元素类型不一样，React会直接移除旧的树并构建出新的树。例如从&nbsp;<code>&lt;a&gt;</code>&nbsp;变更为&nbsp;<code>&lt;img&gt;</code>、&nbsp;<code>&lt;Article&gt;</code>&nbsp;变更为&nbsp;<code>&lt;Comment&gt;</code>、&nbsp;<code>&lt;Button&gt;</code>&nbsp;变更为&nbsp;<code>&lt;div&gt;</code>&nbsp;，所有的这些变化都会导致整颗树重构。\n</p>\n<p>重构一棵新的树时，所有的旧节点都会移除。组件的<code>componentWillUnmount()</code>方法会被调用。&nbsp;然后到构建完成之后新的Dom会替换原来的Dom。此时组件的<code>componentWillMount()</code>和<code>componentDidMount()</code>会依次被调用。旧树Dom上的所有状态都会丢失。\n</p>\n<p>根据这个特性，根节点之后的所有组件都会卸载并重建，状态也会随之改变。例如下面2个组件对比：</p>\n<pre class="xml"><code class="language-html xml"><span class="code-tag"><span class="code-tag">&lt;</span><span\n        class="code-name"><span class="code-tag"><span class="code-name">div</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">Counter</span></span></span><span class="code-tag"> /&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n        class="code-name">div</span></span></span><span class="code-tag">&gt;</span></span>\n\n<span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n        class="code-name">span</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">Counter</span></span></span><span class="code-tag"> /&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n        class="code-name">span</span></span></span><span class="code-tag">&gt;</span></span></code></pre>\n<p><code>Counter</code>&nbsp;组件会被销毁并重新安装一个新的组件。</p>\n\n<h2 id="h2-4">Dom元素拥有相同的类型</h2>\n<p>当比较React元素为相同类型时，React会查看元素上的属性来比对。比对之后，React会保持的Dom节点不改变然后仅仅更新不同的属性值，例如：</p>\n<pre class="xml"><code class="language-html xml"><span class="code-tag"><span class="code-tag">&lt;</span><span\n        class="code-name"><span class="code-tag"><span class="code-name">div</span></span></span><span\n        class="code-tag"> </span><span class="hljs-attr"><span class="code-tag"><span class="hljs-attr">className</span></span></span><span\n        class="code-tag">=</span><span class="code-string"><span class="code-tag"><span\n        class="code-string">"before"</span></span></span><span class="code-tag"> </span><span class="hljs-attr"><span\n        class="code-tag"><span class="hljs-attr">title</span></span></span><span class="code-tag">=</span><span\n        class="code-string"><span class="code-tag"><span class="code-string">"stuff"</span></span></span><span\n        class="code-tag"> /&gt;</span></span>\n\n<span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n        class="code-name">div</span></span></span><span class="code-tag"> </span><span class="hljs-attr"><span\n        class="code-tag"><span class="hljs-attr">className</span></span></span><span class="code-tag">=</span><span\n        class="code-string"><span class="code-tag"><span class="code-string">"after"</span></span></span><span\n        class="code-tag"> </span><span class="hljs-attr"><span class="code-tag"><span\n        class="hljs-attr">title</span></span></span><span class="code-tag">=</span><span class="code-string"><span\n        class="code-tag"><span class="code-string">"stuff"</span></span></span><span\n        class="code-tag"> /&gt;</span></span></code></pre>\n<p>在比对这2个元素之后，React知道仅仅需要修改当前Dom的<code>className</code>。在更新<code>style</code>时，React同样知道仅仅需要更新修改部分即可。例如：</p>\n<pre class="groovy"><code class="language-html xml"><span class="code-tag">&lt;<span class="code-name">div</span> <span\n        class="hljs-attr">style</span>=<span class="code-string">{{<span class="code-string">color:</span></span> <span\n        class="code-string">\'</span><span class="hljs-attr"><span class="code-string">red</span></span><span\n        class="code-string">\'</span>, <span class="hljs-attr"><span class="code-string">fontWeight:</span></span> <span\n        class="code-string">\'</span><span class="hljs-attr"><span class="code-string">bold</span></span><span\n        class="code-string">\'</span>}} /&gt;</span>\n\n<span class="code-tag">&lt;<span class="code-name">div</span> <span class="hljs-attr">style</span>=<span\n        class="code-string">{{<span class="code-string">color:</span></span> <span class="code-string">\'</span><span\n        class="hljs-attr"><span class="code-string">green</span></span><span class="code-string">\'</span>, <span\n        class="hljs-attr"><span class="code-string">fontWeight:</span></span> <span class="code-string">\'</span><span\n        class="hljs-attr"><span class="code-string">bold</span></span><span class="code-string">\'</span>}} /&gt;</span></code></pre>\n<p>在转换这2个组件时，React知道仅仅需要修改color的样式，而fontWeight不必发生变动。</p>\n<p>在处理完当前Dom节点后，React依次对子节点进行递归。</p>\n\n<h2 id="h2-5">组件元素拥有相同的类型</h2>\n<p>当一个组件发生更新后，实例依然是原来的实例，所以状态还是以前的状态。React通过属性值（props）的更新来影响需要更新组件，此时组件实例的&nbsp;<code>componentWillReceiveProps()</code>&nbsp;和&nbsp;<code>componentWillUpdate()</code>&nbsp;方法会被调用。\n</p>\n<p>然后，&nbsp;<code>render()</code>&nbsp;方法会被调用并返回一个Dom，差异算法会递归比对之前返回Dom的差异。</p>\n\n<h2 id="h2-6">递归子元素</h2>\n<p>默认情况下，在递归子元素的Dom节点时，React同时对2个子元素列表进行迭代比对，如果发现差异都会产生一个突变（<a title="React性能优化"\n                                                               href="https://www.chkui.com/article/react/react_optimizing_performance"\n                                                               rel="nofollow">关于突变的概念请见React学习第六篇性能优化介绍不可变数据结构部分</a>）。\n</p>\n<p>例如，当增加一个元素在子元素的队尾，这2颗树的转换效率很高：</p>\n<pre class="xml"><code class="language-html xml"><span class="code-tag"><span class="code-tag">&lt;</span><span\n        class="code-name"><span class="code-tag"><span class="code-name">ul</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>first<span class="code-tag"><span\n            class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>second<span\n            class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n        class="code-name">ul</span></span></span><span class="code-tag">&gt;</span></span>\n\n<span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n        class="code-name">ul</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>first<span class="code-tag"><span\n            class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>second<span\n            class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>third<span class="code-tag"><span\n            class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n        class="code-name">ul</span></span></span><span class="code-tag">&gt;</span></span></code></pre>\n<p>React先匹配&nbsp;<code>&lt;li&gt;first&lt;/li&gt;</code>&nbsp;2棵树，然后再匹配&nbsp;<code>&lt;li&gt;second&lt;/li&gt;</code>&nbsp;。最后直接就添加&nbsp;<code>&lt;li&gt;third&lt;/li&gt;</code>&nbsp;节点。\n</p>\n<p>如果代码按下面的方式修改2颗树，执行的效率相对较差：</p>\n<pre class="xml"><code class="language-html xml"><span class="code-tag"><span class="code-tag">&lt;</span><span\n        class="code-name"><span class="code-tag"><span class="code-name">ul</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>Duke<span\n            class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>Villanova<span\n            class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n        class="code-name">ul</span></span></span><span class="code-tag">&gt;</span></span>\n\n<span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n        class="code-name">ul</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>Connecticut<span\n            class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>Duke<span\n            class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>Villanova<span\n            class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n            class="code-name">li</span></span></span><span class="code-tag">&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n        class="code-name">ul</span></span></span><span class="code-tag">&gt;</span></span></code></pre>\n<p>\n    React会突变修改所有的子节点，最终&nbsp;<code>&lt;li&gt;Duke&lt;/li&gt;</code>&nbsp;and&nbsp;<code>&lt;li&gt;Villanova&lt;/li&gt;</code>&nbsp;会被重新渲染。所以这种方式会带来很大的效率问题。\n</p>\n\n<h2 id="h2-7">Keys</h2>\n<p>为了解决上面的问题，React提供了一个“key”属性。当所有的子元素都有一个key值，React直接使用key值来比对树形结构中的所有子节点列表。例如为上面的的例子增加一个key会大大的提升转换效率：</p>\n<pre class="xml"><code class="language-html xml"><span class="code-tag"><span class="code-tag">&lt;</span><span\n        class="code-name"><span class="code-tag"><span class="code-name">ul</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">li</span></span></span><span class="code-tag"> </span><span class="hljs-attr"><span\n          class="code-tag"><span class="hljs-attr">key</span></span></span><span class="code-tag">=</span><span\n          class="code-string"><span class="code-tag"><span class="code-string">"2015"</span></span></span><span\n          class="code-tag">&gt;</span></span>Duke<span class="code-tag"><span class="code-tag">&lt;/</span><span\n            class="code-name"><span class="code-tag"><span class="code-name">li</span></span></span><span\n            class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">li</span></span></span><span class="code-tag"> </span><span class="hljs-attr"><span\n          class="code-tag"><span class="hljs-attr">key</span></span></span><span class="code-tag">=</span><span\n          class="code-string"><span class="code-tag"><span class="code-string">"2016"</span></span></span><span\n          class="code-tag">&gt;</span></span>Villanova<span class="code-tag"><span class="code-tag">&lt;/</span><span\n            class="code-name"><span class="code-tag"><span class="code-name">li</span></span></span><span\n            class="code-tag">&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n        class="code-name">ul</span></span></span><span class="code-tag">&gt;</span></span>\n\n<span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n        class="code-name">ul</span></span></span><span class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">li</span></span></span><span class="code-tag"> </span><span class="hljs-attr"><span\n          class="code-tag"><span class="hljs-attr">key</span></span></span><span class="code-tag">=</span><span\n          class="code-string"><span class="code-tag"><span class="code-string">"2014"</span></span></span><span\n          class="code-tag">&gt;</span></span>Connecticut<span class="code-tag"><span class="code-tag">&lt;/</span><span\n            class="code-name"><span class="code-tag"><span class="code-name">li</span></span></span><span\n            class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">li</span></span></span><span class="code-tag"> </span><span class="hljs-attr"><span\n          class="code-tag"><span class="hljs-attr">key</span></span></span><span class="code-tag">=</span><span\n          class="code-string"><span class="code-tag"><span class="code-string">"2015"</span></span></span><span\n          class="code-tag">&gt;</span></span>Duke<span class="code-tag"><span class="code-tag">&lt;/</span><span\n            class="code-name"><span class="code-tag"><span class="code-name">li</span></span></span><span\n            class="code-tag">&gt;</span></span>\n  <span class="code-tag"><span class="code-tag">&lt;</span><span class="code-name"><span class="code-tag"><span\n          class="code-name">li</span></span></span><span class="code-tag"> </span><span class="hljs-attr"><span\n          class="code-tag"><span class="hljs-attr">key</span></span></span><span class="code-tag">=</span><span\n          class="code-string"><span class="code-tag"><span class="code-string">"2016"</span></span></span><span\n          class="code-tag">&gt;</span></span>Villanova<span class="code-tag"><span class="code-tag">&lt;/</span><span\n            class="code-name"><span class="code-tag"><span class="code-name">li</span></span></span><span\n            class="code-tag">&gt;</span></span>\n<span class="code-tag"><span class="code-tag">&lt;/</span><span class="code-name"><span class="code-tag"><span\n        class="code-name">ul</span></span></span><span class="code-tag">&gt;</span></span></code></pre>\n<p>现在React可以知道key=\'2014\'的节点是一个新值另外2个节点仅仅需要移动一下位置。</p>\n<p>在实际使用中，key值并不难找。在常规业务中，很多列表都自然包含业务相关的ID了：</p>\n<pre class="dust"><code class="language-html xml"><span class="code-tag"><span class="xml"><span\n        class="code-tag">&lt;</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span\n        class="code-name">li</span></span></span></span><span class="xml"><span class="code-tag"> </span></span><span\n        class="hljs-attr"><span class="xml"><span class="code-tag"><span\n        class="hljs-attr">key</span></span></span></span><span class="xml"><span class="code-tag">=</span></span><span\n        class="code-string"><span class="code-template-variable">{item.id}</span></span><span class="xml"><span\n        class="code-tag">&gt;</span></span></span><span class="code-template-variable">{item.name}</span><span\n        class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span\n        class="xml"><span class="code-tag"><span class="code-name">li</span></span></span></span><span class="xml"><span\n        class="code-tag">&gt;</span></span></span></code></pre>\n<p>当无法使用业务ID时，也可以额外增加一个ID值来标记列表差异，比如根据要使用的数据生成一个hash值，React不需要key值全局唯一，只需要在兄弟节点之间保持唯一即可。</p>\n<p>最差情况下，你可以使用索引数据（0、1、2、....n）。使用索引需要注意的是，如果列表发生重新排序效率会很糟糕。</p>\n\n<h2 id="h2-8">一些常见的问题</h2>\n<p>在使用React时需要谨记每次调用 <strong><em>render()</em></strong>\n    方法，它总会尝试比对调用前后2棵树是否一致。在某些极端情况下，虽然最终呈现效果并没有发生多大的变化，但是有可能每一个简单的操作都导致React全局重新渲染(例如列表没有Key)。</p>\n<p>\n    React在当前版本的实现中还存在一个问题，可以快捷的告知React子树中某个节点的位置已经发生改变，但是无法告知React他移动到了什么位置。因此在遇到这种情况时，算法会重构整个子树。这个问题告诉我们，如果遇到弹窗之类需要偶尔出现的组件，最好是通过隐藏属性控制他，而非直接移除Dom。</p>\n<p>React依赖启发式算法，如果本文开篇提到的2个基本假设不成立，那么会导致算法效率极差。</p>\n<ol>\n    <li>算法不会尝试匹配不同2个组件之间的子树。如果编码中发现2个组件之间有非常相似的输出，应该尝试将2个组件合并为一个类型的组件。在实际应用中，我们还没发现这样导致问题。</li>\n    <li>用作列表的key值最好是稳定、可预见、唯一的。易变的key值（比如由<code>Math.random()</code>方法生成的值）将会导致许多组件实例和Dom节点被非必要的重新创建，这会导致性能低下且子组件丢失已有的状态。&nbsp;\n    </li>\n</ol>'},357:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<p>在16.x版本之后React提供了Protals功能来解决模式对话框不在Dom根节点导致的一些BUG。除了Protal还有更多的方法去解决这些问题，本文来自David\n    Gilbertson的博客，详细解释了React中模式对话框的一些问题，以及他给出的解决方案，在了解Protals之前阅读这篇内容，能让你更加明白Protal的重要性。</p>\n<p>对于React的模式对话框，有很多方法可以实现但是并没有一个绝对正确的方法。这句话怎么理解呢？让我们先看看一个模式对话框的特性：</p>\n<ol>\n    <li>能够浮现在最上层，阻止用户的其他操作。</li>\n    <li>能够处理鼠标和键盘事件，例如关闭窗口事件。</li>\n    <li>接受外部传入一个回调函数，当用户进行某些操作的时候调用他，例如点击“确定”或“取消”按钮。</li>\n    <li>接受外部参数，可以设定大小、文字、处理器等等。</li>\n</ol>\n\n<h2 id="h2-1">模式对话框的实现思路</h2>\n<p>下面的这些图片是常见模式对话框的例子：</p>\n<p><img alt="React中的模式对话框" src="https://file.mahoooo.com/res/file/modals_in_react_2018_5_15_2.png"></p>\n<p><img alt="React中的模式对话框" src="https://file.mahoooo.com/res/file/modals_in_react_2018_5_15_3.png"></p>\n<p><img alt="React中的模式对话框" src="https://file.mahoooo.com/res/file/modals_in_react_2018_5_15_4.png"></p>\n<p>这些模式对话框都有一个全局的背景遮罩层、有头部或描述内容、有一些功能按钮、可以随意设定的宽度和高度、位置居中。</p>\n<p>在React中有三种方式实现模式对话框：</p>\n<ol>\n    <li>使用一个常规的组件作为一个模式对话框的包装组件，然后将我们自定义的内容作为子组件传递给模式对话框。例如这个项目：<a href="https://github.com/reactjs/react-modal"\n                                                                   rel="nofollow">https://github.com/reactjs/react-modal</a>。\n    </li>\n    <li>将模式对话框放置到HTML结构的顶层，将其设置为 <em>document.body </em>的子元素。例如：<a href="https://github.com/tajo/react-portal"\n                                                                   rel="nofollow">https://github.com/tajo/react-portal</a>\n    </li>\n    <li>将模式对话框作为整个组件结构中的顶层组件（根元素的子组件），通过全局的数据来控制他显示或隐藏。</li>\n</ol>\n<p>那这三种实现方式有什么问题呢：</p>\n<p>第一种方式有定位问题。如果你用这种方式实现模式对话框，你的HTML上下文会影响当前模式对话框的展示效果，所以这种方式很有可能会出现一些意向不到的问题。你真的认为&nbsp;<strong>position:\n    fixed</strong>&nbsp;可以让某个元素相对与浏览器窗口绝对定位吗？请看这个例子：&nbsp;<a href="https://output.jsbin.com/fepime/" rel="nofollow">https://output.jsbin.com/fepime/</a>，使用开发人员工具看看\n    <em>.top-div</em> 和 <em>.fixed-div</em> 的样式你就懂了。</p>\n<p>\n    第二种方式首先对于单元测试不友好，因为我们不得不把对话框作为body的子元素（或者其他某个真实DOM的子元素）来显示，那么得有浏览器的真实DOM才能看到效果。而且这种方式看起来挺“骇客”的，我们按照单向数据流的思路开发了整套个标准合理的React组件，最后不得不用&nbsp;<strong>ReactDOM.unstable_renderSubtreeIntoContainer() </strong>方法装载一个组件到body元素中，最终可能会导致虚拟DOM与真实DOM不一致或者服务端渲染遇到问题。‘unstable’前缀的含义是React官方明确告诉你：这玩意有坑，踩上了别怪我。详情请看React官方对<strong>unstable_renderSubtreeIntoContainer</strong>的说明。\n</p>\n<p>第三种方式在笔者看来是最合理最优秀的，下面就谈谈这种实现方式的思路。</p>\n\n<h2 id="h2-2">全局数据流控制模式对话框</h2>\n<p>实际上就是用flux或redux的方式去控制对话框显示或关闭。如果之前用过flux之类思路的工具，后面的内容分分钟就理解了。</p>\n<p>先看下模式对话框的组件结构：</p>\n<p><img alt="React中的模式对话框" src="https://file.mahoooo.com/res/file/modals_in_react_2018_5_15_1.png"></p>\n<p></p>\n<ul>\n    <li><strong>App.jsx</strong>——整个工程的根组件，通常不会在这里有什么特殊的处理。它首先会渲染其他所有的顶层组件，然后再最后渲染模式对话框组件。</li>\n    <li><strong>ModalConductor.jsx</strong>——模式框的管理组件，由他来控制当前应该渲染哪个模式框。</li>\n    <li><strong>SignIn.jsx、EditScreen.jsx等组件</strong>——具体样式的模式对话框。</li>\n</ul>\n<p>在这些组件之外，还有store来存储全局模式对话框的相关数据。<strong>store.currentModal </strong>用于指示显示哪个模式框的字符串，如果为 null\n    则表示没有任何模式框要显示，所以整个工程一次只显示一个模式框。</p>\n<p>下面我们看看组件实现过程。</p>\n<p>首先我们在任何位置都可以修改 <strong>store</strong> 。当我们通过某种方式将&nbsp;<strong>store.currentModal </strong>的值修改为<strong>&nbsp;signIn\n    后，ModalConductor </strong>会触发重新渲染并在内部判断要渲染<strong>&nbsp;SignIn </strong>组件。</p>\n<p>这是 <strong>ModalConductor</strong>&nbsp;的示意代码，通过switch语句判断要显示的组件：</p>\n<pre class="typescript"><code class="language-javascript"><span class="code-keyword"><span\n        class="code-keyword">import</span></span> React <span class="code-keyword">from</span> <span\n        class="code-string"><span class="code-string">\'react\'</span></span>;\n\n<span class="code-keyword"><span class="code-keyword">import</span></span> ExportDataModal <span class="code-keyword">from</span> <span\n            class="code-string"><span class="code-string">\'./ExportDataModal.jsx\'</span></span>;\n<span class="code-keyword"><span class="code-keyword">import</span></span> SignInModal <span\n            class="code-keyword">from</span> <span class="code-string"><span\n            class="code-string">\'./SignInModal.jsx\'</span></span>;\n<span class="code-keyword"><span class="code-keyword">import</span></span> FeedbackModal <span\n            class="code-keyword">from</span> <span class="code-string"><span\n            class="code-string">\'./FeedbackModal.jsx\'</span></span>;\n<span class="code-keyword"><span class="code-keyword">import</span></span> BoxDetailsModal <span class="code-keyword">from</span> <span\n            class="code-string"><span class="code-string">\'./BoxDetailsModal.jsx\'</span></span>;\n\n<span class="code-keyword"><span class="code-keyword">const</span></span> ModalConductor = props =&gt; {\n  <span class="code-keyword"><span class="code-keyword">switch</span></span> (props.currentModal) {\n    <span class="code-keyword"><span class="code-keyword">case</span></span> <span class="code-string"><span\n            class="code-string">\'EXPORT_DATA\'</span></span>:\n      <span class="code-keyword"><span class="code-keyword">return</span></span> &lt;ExportDataModal {...props}/&gt;;\n\n    <span class="code-keyword">case</span> <span class="code-string">\'SOCIAL_SIGN_IN\'</span>:\n      <span class="code-keyword">return</span> &lt;SignInModal {...props}/&gt;;\n\n    <span class="code-keyword">case</span> <span class="code-string">\'FEEDBACK\'</span>:\n      <span class="code-keyword">return</span> &lt;FeedbackModal {...props}/&gt;;\n\n    <span class="code-keyword">case</span> <span class="code-string">\'EDIT_BOX\'</span>:\n      <span class="code-keyword">return</span> &lt;BoxDetailsModal {...props}/&gt;;\n\n    <span class="code-keyword">default</span>:\n      <span class="code-keyword">return</span> <span class="hljs-literal">null</span>;\n  }\n};\n\n<span class="code-keyword">export</span> <span class="code-keyword">default</span> ModalConductor;</code></pre>\n<p>下面模式对话框组件的代码结构：</p>\n<pre class="javascript"><code class="language-javascript"><span class="code-keyword"><span\n        class="code-keyword">import</span></span> React <span class="code-keyword"><span\n        class="code-keyword">from</span></span> <span class="code-string"><span\n        class="code-string">\'react\'</span></span>;\n\n<span class="code-keyword"><span class="code-keyword">import</span></span> ModalWrapper <span class="code-keyword"><span\n            class="code-keyword">from</span></span> <span class="code-string"><span class="code-string">\'../ModalWrapper.jsx\'</span></span>;\n\n<span class="code-keyword"><span class="code-keyword">const</span></span> SignIn = props =&gt; {\n  <span class="code-keyword"><span class="code-keyword">const</span></span> signIn = provider =&gt; {\n    props.hideModal();\n    props.signIn(provider);\n  };\n\n  <span class="code-keyword"><span class="code-keyword">return</span></span> (\n    <span class="xml"><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span\n            class="code-name">ModalWrapper</span></span></span></span><span class="xml"><span class="code-tag">\n      {</span></span><span class="hljs-attr"><span class="xml"><span class="code-tag"><span\n            class="hljs-attr">...props</span></span></span></span><span class="xml"><span class="code-tag">}\n      </span></span><span class="hljs-attr"><span class="xml"><span class="code-tag"><span\n            class="hljs-attr">title</span></span></span></span><span class="xml"><span\n            class="code-tag">=</span></span><span class="code-string"><span class="xml"><span class="code-tag"><span\n            class="code-string">"Sign in"</span></span></span></span><span class="xml"><span class="code-tag">\n      </span></span><span class="hljs-attr"><span class="xml"><span class="code-tag"><span\n            class="hljs-attr">width</span></span></span></span><span class="xml"><span\n            class="code-tag">=</span></span><span class="code-string"><span class="xml"><span class="code-tag"><span\n            class="code-string">{400}</span></span></span></span><span class="xml"><span class="code-tag">\n      </span></span><span class="hljs-attr"><span class="xml"><span class="code-tag"><span\n            class="hljs-attr">showOk</span></span></span></span><span class="xml"><span class="code-tag">=</span></span><span\n            class="code-string"><span class="xml"><span class="code-tag"><span class="code-string">{false}</span></span></span></span><span\n            class="xml"><span class="code-tag">\n    &gt;</span></span></span><span class="xml">\n      </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span\n            class="code-name">p</span></span></span></span><span class="xml"><span\n            class="code-tag">&gt;</span></span></span><span class="xml">Choose your flavor</span><span class="code-tag"><span\n            class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span class="xml"><span\n            class="code-tag"><span class="code-name">p</span></span></span></span><span class="xml"><span\n            class="code-tag">&gt;</span></span></span><span class="xml">\n      </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span\n            class="code-name">button</span></span></span></span><span class="xml"><span class="code-tag"> </span></span><span\n            class="hljs-attr"><span class="xml"><span class="code-tag"><span\n            class="hljs-attr">onClick</span></span></span></span><span class="xml"><span\n            class="code-tag">=</span></span><span class="code-string"><span class="xml"><span class="code-tag"><span\n            class="code-string">{()</span></span></span></span><span class="xml"><span\n            class="code-tag"> =&gt;</span></span></span><span class="xml"> signIn(\'facebook\')}&gt;Facebook</span><span\n            class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span\n            class="xml"><span class="code-tag"><span class="code-name">button</span></span></span></span><span\n            class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n      </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span\n            class="code-name">button</span></span></span></span><span class="xml"><span class="code-tag"> </span></span><span\n            class="hljs-attr"><span class="xml"><span class="code-tag"><span\n            class="hljs-attr">onClick</span></span></span></span><span class="xml"><span\n            class="code-tag">=</span></span><span class="code-string"><span class="xml"><span class="code-tag"><span\n            class="code-string">{()</span></span></span></span><span class="xml"><span\n            class="code-tag"> =&gt;</span></span></span><span class="xml"> signIn(\'google\')}&gt;Google</span><span\n            class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span\n            class="xml"><span class="code-tag"><span class="code-name">button</span></span></span></span><span\n            class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n      </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span\n            class="code-name">button</span></span></span></span><span class="xml"><span class="code-tag"> </span></span><span\n            class="hljs-attr"><span class="xml"><span class="code-tag"><span\n            class="hljs-attr">onClick</span></span></span></span><span class="xml"><span\n            class="code-tag">=</span></span><span class="code-string"><span class="xml"><span class="code-tag"><span\n            class="code-string">{()</span></span></span></span><span class="xml"><span\n            class="code-tag"> =&gt;</span></span></span><span class="xml"> signIn(\'twitter\')}&gt;Twitter</span><span\n            class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span\n            class="xml"><span class="code-tag"><span class="code-name">button</span></span></span></span><span\n            class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n    </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span\n            class="code-name">ModalWrapper</span></span></span></span><span class="xml"><span\n            class="code-tag">&gt;</span></span></span></span>\n  );\n};\n\n<span class="code-keyword"><span class="code-keyword">export</span></span> <span class="code-keyword"><span\n            class="code-keyword">default</span></span> SignIn;</code></pre>\n<p>他内部使用了一个名为&nbsp;<strong>ModalWrapper </strong>的包装组件，用来显示模式对话框的效果，可以直接使用<a\n        href="https://github.com/reactjs/react-modal" rel="nofollow">https://github.com/reactjs/react-modal</a>或者自己实现，如下是一个模式框的包装组件：\n</p>\n<pre class="javascript"><code class="language-javascript"><span class="code-keyword"><span\n        class="code-keyword">import</span></span> React <span class="code-keyword"><span\n        class="code-keyword">from</span></span> <span class="code-string"><span\n        class="code-string">\'react\'</span></span>;\n<span class="code-keyword"><span class="code-keyword">const</span></span> {PropTypes} = React;\n\n<span class="code-keyword"><span class="code-keyword">const</span></span> ModalWrapper = props =&gt; {\n  <span class="code-keyword"><span class="code-keyword">const</span></span> handleBackgroundClick = e =&gt; {\n    <span class="code-keyword"><span class="code-keyword">if</span></span> (e.target === e.currentTarget) props.hideModal();\n  };\n\n  <span class="code-keyword"><span class="code-keyword">const</span></span> onOk = () =&gt; {\n    props.onOk();\n    props.hideModal();\n  };\n\n  <span class="code-keyword"><span class="code-keyword">const</span></span> okButton = props.showOk\n    ? (\n      <span class="xml"><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n              class="code-name"><span class="xml"><span class="code-tag"><span\n              class="code-name">button</span></span></span></span><span class="xml"><span class="code-tag">\n        </span></span><span class="hljs-attr"><span class="xml"><span class="code-tag"><span\n              class="hljs-attr">onClick</span></span></span></span><span class="xml"><span\n              class="code-tag">=</span></span><span class="code-string"><span class="xml"><span class="code-tag"><span\n              class="code-string">{onOk}</span></span></span></span><span class="xml"><span class="code-tag">\n        </span></span><span class="hljs-attr"><span class="xml"><span class="code-tag"><span\n              class="hljs-attr">disabled</span></span></span></span><span class="xml"><span\n              class="code-tag">=</span></span><span class="code-string"><span class="xml"><span class="code-tag"><span\n              class="code-string">{props.okDisabled}</span></span></span></span><span class="xml"><span\n              class="code-tag">\n      &gt;</span></span></span><span class="xml">\n        {props.okText}\n      </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span\n              class="xml"><span class="code-tag"><span class="code-name">button</span></span></span></span><span\n              class="xml"><span class="code-tag">&gt;</span></span></span></span>\n    ) : <span class="hljs-literal"><span class="hljs-literal">null</span></span>;\n\n  <span class="code-keyword"><span class="code-keyword">return</span></span> (\n    <span class="xml"><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">div</span></span></span></span><span\n            class="xml"><span class="code-tag"> </span></span><span class="hljs-attr"><span class="xml"><span\n            class="code-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span\n            class="code-tag">=</span></span><span class="code-string"><span class="xml"><span class="code-tag"><span\n            class="code-string">{handleBackgroundClick}</span></span></span></span><span class="xml"><span\n            class="code-tag">&gt;</span></span></span><span class="xml">\n      </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span\n            class="code-name">header</span></span></span></span><span class="xml"><span\n            class="code-tag">&gt;</span></span></span><span class="xml">\n        </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span\n            class="code-name">h1</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span\n            class="xml">{props.title}</span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span\n            class="code-name">h1</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span\n            class="xml">\n\n        </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span\n            class="code-name">button</span></span></span></span><span class="xml"><span class="code-tag"> </span></span><span\n            class="hljs-attr"><span class="xml"><span class="code-tag"><span\n            class="hljs-attr">onClick</span></span></span></span><span class="xml"><span\n            class="code-tag">=</span></span><span class="code-string"><span class="xml"><span class="code-tag"><span\n            class="code-string">{props.hideModal}</span></span></span></span><span class="xml"><span class="code-tag">&gt;</span></span></span><span\n            class="xml">Close</span><span class="code-tag"><span class="xml"><span\n            class="code-tag">&lt;/</span></span><span class="code-name"><span class="xml"><span class="code-tag"><span\n            class="code-name">button</span></span></span></span><span class="xml"><span\n            class="code-tag">&gt;</span></span></span><span class="xml">\n      </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span class="code-name"><span\n            class="xml"><span class="code-tag"><span class="code-name">header</span></span></span></span><span\n            class="xml"><span class="code-tag">&gt;</span></span></span><span class="xml">\n\n      {props.children}\n\n      {okButton}\n    </span><span class="code-tag"><span class="xml"><span class="code-tag">&lt;/</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span class="code-name">div</span></span></span></span><span\n            class="xml"><span class="code-tag">&gt;</span></span></span></span>\n  );\n};\n\nModalWrapper.defaultProps = {\n  title: <span class="code-string"><span class="code-string">\'\'</span></span>,\n  showOk: <span class="hljs-literal"><span class="hljs-literal">true</span></span>,\n  okText: <span class="code-string"><span class="code-string">\'OK\'</span></span>,\n  okDisabled: <span class="hljs-literal"><span class="hljs-literal">false</span></span>,\n  width: <span class="hljs-number"><span class="hljs-number">400</span></span>,\n  onOk: () =&gt; {}\n};\n\n<span class="code-keyword"><span class="code-keyword">export</span></span> <span class="code-keyword"><span\n            class="code-keyword">default</span></span> ModalWrapper;</code></pre>'},370:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h3 id="h3-1">使用PropTypes进行类型检查</h3>\n<p>当应用不断增长时，可以用过类型检查发现很多bug。对于某些应用，可以使用JavaScript扩展工具来完成，比如使用&nbsp;\n    <a title="flow类型检查工具" href="https://chkui.com/article/react/react_static_type_check_with_flow">Flow </a>或\n    <a title="Typescript官网" href="https://www.typescriptlang.org/" rel="nofollow">TypeScript </a>来检查整个工程。除了引入外部工具之外，React也提供了参数类型检查的功能，只需要为每一个属性指定一个&nbsp;<code>propTypes</code>&nbsp;即可：\n</p>\n<pre class="scala"><code class="language-javascript"><span class="code-comment"><span class="code-comment">// 15.5之后，需要单独引入依赖才能使用类型检查</span></span>\n<span class="code-keyword"><span class="code-keyword">import</span></span> <span\n            class="code-type">PropTypes</span> <span class="code-keyword">from</span> <span class="code-string"><span\n            class="hljs-symbol">\'prop</span>-types\'</span>;\n<span class="code-comment"><span class="code-comment">//定义组件</span></span>\n<span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span\n        class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Greeting</span></span></span><span class="hljs-class"> </span><span\n        class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> (\n      <span class="xml"><span class="code-tag">&lt;<span class="code-name">h1</span>&gt;</span><span class="code-type">Hello</span>, {<span\n              class="code-keyword">this</span>.props.name}<span class="code-tag">&lt;/<span class="code-name">h1</span>&gt;</span></span>\n    );\n  }\n}\n\n<span class="code-comment"><span class="code-comment">//指定类型检查</span></span>\n<span class="code-type">Greeting</span>.propTypes = {\n  name: <span class="code-type">React</span>.<span class="code-type">PropTypes</span>.string\n};</code></pre>\n<p> PropTypes将会设定一系列验证器，这些验证器用于确保组件接受到的参数（props）是指定的类型。比如上面的例子，当一个错误的类型被组件接收到，会有一段警告内容使通过console输出。<span\n        style="color:#FF0000">propsTypes仅仅在开发模式下使用</span>。</p>\n\n<h3 id="h3-2">PropTypes</h3>\n<p>以下是各种验证器的示例：</p>\n<pre class="javascript"><code class="language-javascript">MyComponent.propTypes = {\n  <span class="code-comment"><span class="code-comment">// 指明每个传入参数的具体类型，传递的参数仅限于这些JavaScript的内置类型</span></span>\n  optionalArray: PropTypes.array,\n  optionalBool: PropTypes.bool,\n  optionalFunc: PropTypes.func,\n  optionalNumber: PropTypes.number,\n  optionalObject: PropTypes.object,\n  optionalString: PropTypes.string,\n  optionalSymbol: PropTypes.symbol,\n\n  <span class="code-comment"><span class="code-comment">// number、string、element或者一个列表都是允许的</span></span>\n  optionalNode: PropTypes.node,\n\n  <span class="code-comment"><span class="code-comment">// 接收一个React组件</span></span>\n  optionalElement: PropTypes.element,\n\n  <span class="code-comment"><span class="code-comment">// 声明这个参数只接收某个对象(class)的实例，适用于传递一个对象作为配置参数的</span></span>\n  optionalMessage: PropTypes.instanceOf(Message),\n\n  <span class="code-comment"><span class="code-comment">// 指定参数限定在多个对象之内</span></span>\n  optionalEnum: PropTypes.oneOf([<span class="code-string"><span class="code-string">\'News\'</span></span>, <span\n            class="code-string"><span class="code-string">\'Photos\'</span></span>]),\n\n  <span class="code-comment"><span class="code-comment">// 指定参数允许多个类型</span></span>\n  optionalUnion: PropTypes.oneOfType([\n    PropTypes.string,\n    PropTypes.number,\n    PropTypes.instanceOf(Message)\n  ]),\n\n  <span class="code-comment"><span class="code-comment">// 指定类型的列表</span></span>\n  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),\n\n  <span class="code-comment"><span class="code-comment">// 指定传递某个类型，是一个对象不是数据本身</span></span>\n  optionalObjectOf: PropTypes.objectOf(PropTypes.number),\n\n  <span class="code-comment"><span class="code-comment">// 指定传递参数的结构，适用于传递一个对象时限定对象的结构</span></span>\n  optionalObjectWithShape: PropTypes.shape({\n    color: PropTypes.string,\n    fontSize: PropTypes.number\n  }),\n\n  <span class="code-comment"><span class="code-comment">// 表明这个参数是必须要传递的参数，在使用这个组件时，这个参数必须传入数据</span></span>\n  requiredFunc: PropTypes.func.isRequired,\n\n  <span class="code-comment"><span class="code-comment">// 允许任何类型的数据。</span></span>\n  requiredAny: PropTypes.any.isRequired,\n\n  <span class="code-comment"><span class="code-comment">// 指定一个自定义的检查器，当检查失败时需要返回一个Error对象来指明错误。</span></span>\n  <span class="code-comment"><span class="code-comment">// 错误只需要返回，切记不能使用throw或console.warn输出</span></span>\n  <span class="code-comment"><span class="code-comment">// 不适用于 oneOfType 类型。</span></span>\n  customProp: <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">function</span></span></span><span class="hljs-function">(</span><span\n            class="hljs-params"><span class="hljs-function"><span\n            class="hljs-params">props, propName, componentName</span></span></span><span class="hljs-function">) </span></span>{\n    <span class="code-keyword"><span class="code-keyword">if</span></span> (!<span class="hljs-regexp"><span\n            class="hljs-regexp">/matchme/</span></span>.test(props[propName])) {\n      <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="code-keyword"><span\n            class="code-keyword">new</span></span> <span class="code-built_in"><span class="code-built_in">Error</span></span>(\n        <span class="code-string"><span class="code-string">\'Invalid prop `\'</span></span> + propName + <span\n            class="code-string"><span class="code-string">\'` supplied to\'</span></span> +\n        <span class="code-string"><span class="code-string">\' `\'</span></span> + componentName + <span\n            class="code-string"><span class="code-string">\'`. Validation failed.\'</span></span>\n      );\n    }\n  },\n\n  <span class="code-comment"><span class="code-comment">// 用于检测一个数组传递的自定义检查器，适用于arrayOf和objectOf类型。</span></span>\n  <span class="code-comment"><span class="code-comment">// 当出现检查错误时需要返回Error</span></span>\n  customArrayProp: PropTypes.arrayOf(<span class="hljs-function"><span class="code-keyword"><span\n            class="hljs-function"><span class="code-keyword">function</span></span></span><span\n            class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span\n            class="hljs-params">propValue, key, componentName, location, propFullName</span></span></span><span\n            class="hljs-function">) </span></span>{\n    <span class="code-keyword"><span class="code-keyword">if</span></span> (!<span class="hljs-regexp"><span\n            class="hljs-regexp">/matchme/</span></span>.test(propValue[key])) {\n      <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="code-keyword"><span\n            class="code-keyword">new</span></span> <span class="code-built_in"><span class="code-built_in">Error</span></span>(\n        <span class="code-string"><span class="code-string">\'Invalid prop `\'</span></span> + propFullName + <span\n            class="code-string"><span class="code-string">\'` supplied to\'</span></span> +\n        <span class="code-string"><span class="code-string">\' `\'</span></span> + componentName + <span\n            class="code-string"><span class="code-string">\'`. Validation failed.\'</span></span>\n      );\n    }\n  })\n};</code></pre>\n\n<h4 id="h4-1">限定至少接收一个子元素</h4>\n<p>可以使用&nbsp;<code>PropTypes.element</code>&nbsp;来指明组件必须接收一个子元素：</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span\n        class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span\n        class="code-title"><span class="hljs-class"><span class="code-title">MyComponent</span></span></span><span\n        class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  render() {\n    <span class="code-comment"><span\n            class="code-comment">// This must be exactly one element or it will warn.</span></span>\n    <span class="code-keyword">const</span> children = <span class="code-keyword"><span class="code-keyword">this</span></span>.props.children;\n    <span class="code-keyword"><span class="code-keyword">return</span></span> (\n      <span class="xml"><span class="code-tag">&lt;<span class="code-name">div</span>&gt;</span>\n        {children}\n      <span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span></span>\n    );\n  }\n}\n\n<span class="code-type">MyComponent</span>.propTypes = {\n  children: <span class="code-type">React</span>.<span class="code-type">PropTypes</span>.element.isRequired\n};</code></pre>\n\n<h4 id="h4-2">设定props默认值</h4>\n<p>还可以使用&nbsp;<code>defaultProps</code>来指定默认值：</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span\n        class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span\n        class="code-title"><span class="hljs-class"><span class="code-title">Greeting</span></span></span><span\n        class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> (\n      <span class="xml"><span class="code-tag">&lt;<span class="code-name">h1</span>&gt;</span><span class="code-type">Hello</span>, {<span\n              class="code-keyword">this</span>.props.name}<span class="code-tag">&lt;/<span class="code-name">h1</span>&gt;</span></span>\n    );\n  }\n}\n\n<span class="code-comment"><span class="code-comment">// 指定props.name的默认值:</span></span>\n<span class="code-type">Greeting</span>.defaultProps = {\n  name: <span class="code-string"><span class="hljs-symbol">\'Strange</span>r\'</span>\n};\n\n<span class="code-type">ReactDOM</span>.render(\n  <span class="xml"><span class="code-tag">&lt;<span class="code-name"><span class="code-type">Greeting</span></span> /&gt;</span>,\n  document.getElementById(<span class="hljs-symbol">\'exampl</span>e\')\n);</span></code></pre>\n\n<h3 id="h3-3">Refs和真实Dom</h3>\n<p>\n    在典型的React数据流中，props参数传递的唯一接口。当需要修改参数时，必须修改props值并重新渲染（render）。然而，有很多场景需要在单向数据流之外修改子组件，React提供“Refs”特性来直接修改真实Dom元素。</p>\n\n<h4 id="h4-3">什么时候需要使用Refs</h4>\n<p>当遇到以下情况时，建议使用Refs特性：</p>\n<ul>\n    <li>需要管理聚（focus）、文档选择或媒体回放等真实Dom事件时。</li>\n    <li>触发需要马上执行的动画。</li>\n    <li>引入第三方库时。</li>\n</ul>\n<p>避免将Refs用于任何声明性的工作，如使用一个props.isOpen参数来代替Dialog的open()和close()接口。</p>\n\n<h4 id="h4-4">将Ref添加到Dom元素中</h4>\n<p>React支持在任何组件上使用ref。ref属性提供一个回调方法，当组件被渲染或被移除后，这个回调方法会被调用。</p>\n<p>当ref属性用于一个HTML元素时，ref的回调方法会获取Dom的实例。例如，下面的例子获取到input标签的Dom实例并保存到this.textInput变量中，这个变量一直指向Dom节点。</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span\n        class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span\n        class="code-title"><span class="hljs-class"><span class="code-title">CustomTextInput</span></span></span><span\n        class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  <span class="code-keyword">constructor</span>(props) {\n    <span class="code-keyword"><span class="code-keyword">super</span></span>(props);\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.focus = <span class="code-keyword"><span\n            class="code-keyword">this</span></span>.focus.bind(<span class="code-keyword"><span class="code-keyword">this</span></span>);\n  }\n\n  <span class="code-comment"><span class="code-comment">// 定义一个focus方法</span></span>\n  focus() {\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.textInput.focus();\n  }\n\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> (\n      &lt;div&gt;\n        &lt;input\n          <span class="hljs-class"><span class="code-keyword">type</span></span>=<span class="code-string">"text"</span>\n          ref={(input) =&gt; { <span class="code-keyword">this</span>.textInput = input; }} /&gt;\n        &lt;input\n          <span class="hljs-class"><span class="code-keyword">type</span></span>=<span\n            class="code-string">"button"</span>\n          value=<span class="code-string">"Focus the text input"</span>\n          onClick={<span class="code-keyword">this</span>.focus}\n        /&gt;\n      &lt;/div&gt;\n    );\n  }\n}</code></pre>\n<p>当Dom元素被渲染后，React会回调ref指定的方法，并传递当前Dom的实例作为参数，当Dom被移除时，ref指向的方法也会被调用，传入的参数为null。</p>\n<p>使用ref回调方法来设置class的属性是获取真实Dom对象的常用方法，上面的例子给出了一个编写方式，只要语法正确你可以用各种方式来编写，如更简短的：&nbsp;<code>ref={input =&gt;\n    this.textInput = input}</code>。</p>\n\n<h4 id="h4-5">给class组件增加一个Ref属性</h4>\n<p>当ref用于一个由class关键字声明的自定义组件时，ref指向的回调方法会在组件完成渲染后被回调，传递的参数是组件的实例。例如下面的例子，在&nbsp;<code>CustomTextInput</code>&nbsp;组件完成渲染后立即模拟一次focus事件：\n</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span\n        class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span\n        class="code-title"><span class="hljs-class"><span\n        class="code-title">AutoFocusTextInput</span></span></span><span class="hljs-class"> </span><span\n        class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  componentDidMount() {<span class="code-comment"><span class="code-comment">//完成渲染后被回调</span></span>\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.textInput.focus();<span\n            class="code-comment"><span class="code-comment">//聚焦到当前组件</span></span>\n  }\n\n  render() {\n    <span class="code-comment"><span class="code-comment">// CustomTextInput 已经在上一段代码中声明</span></span>\n    <span class="code-keyword"><span class="code-keyword">return</span></span> (\n      <span class="xml"><span class="code-tag">&lt;<span class="code-name"><span\n              class="code-type">CustomTextInput</span></span>\n        <span class="hljs-attr">ref</span>=<span class="code-string">{(input)</span> =&gt;</span> { <span\n              class="code-keyword">this</span>.textInput = input; }} /&gt;\n    );\n  }\n}</span></code></pre>\n<p>必须用class来定义&nbsp;<code>CustomTextInput</code>&nbsp;组件才会生效。</p>\n\n<h4 id="h4-6">给Function声明的组件设定Refs</h4>\n<p>不能再function定义的组件直接使用ref，因为在声明时他并没有实例化：</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-function"><span\n        class="code-keyword">function</span> <span class="code-title"><span\n        class="code-type">MyFunctionalComponent</span></span>(<span class="hljs-params"></span>) </span>{\n  <span class="code-keyword"><span class="code-keyword">return</span></span> &lt;input /&gt;;\n}\n\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">Parent</span> <span\n        class="code-keyword">extends</span> <span class="code-title">React</span>.<span\n        class="code-title">Component</span> </span>{\n  render() {\n    <span class="code-comment">// 错误，这里的ref不会有任何效果。</span>\n    <span class="code-keyword">return</span> (\n      &lt;<span class="code-type">MyFunctionalComponent</span>\n        ref={(input) =&gt; { <span class="code-keyword">this</span>.textInput = input; }} /&gt;\n    );\n  }\n}</code></pre>\n<p>最合理的方式是将function定义的组件转换为class，这和我们需要使用state来控制状态是一个道理。不过在function组件中，如果内部引用的是另一个class组件也是可以使用Refs特性的：</p>\n<pre class="php"><code class="language-javascript"><span class="hljs-function"><span class="code-keyword"><span\n        class="hljs-function"><span class="code-keyword">function</span></span></span><span\n        class="hljs-function"> </span><span class="code-title"><span class="hljs-function"><span class="code-title">CustomTextInput</span></span></span><span\n        class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-params"><span\n        class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function"><span\n        class="hljs-params">)</span> </span></span>{\n  <span class="code-comment"><span class="code-comment">// 在这里声明textInput，每次重新渲染时，都会新生成一个本地变量</span></span>\n  <span class="code-keyword">let</span> textInput = <span class="hljs-literal"><span\n            class="code-keyword">null</span></span>;\n\n  <span class="code-comment"><span class="code-comment">// 每次重新渲染时，都会新生成一个回调方法</span></span>\n  <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span\n          class="code-keyword">function</span></span></span><span class="hljs-function"> </span><span\n          class="code-title"><span class="hljs-function"><span class="code-title">handleClick</span></span></span><span\n          class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-params"></span><span\n          class="hljs-function"><span class="hljs-params">)</span> </span></span>{\n    textInput.focus();\n  }\n\n  <span class="code-keyword"><span class="code-keyword">return</span></span> (\n    &lt;div&gt;\n      &lt;input\n        type=<span class="code-string">"text"</span>\n        ref={(input) =&gt; { textInput = input; }} /&gt;\n      &lt;input\n        type=<span class="code-string">"button"</span>\n        value=<span class="code-string">"Focus the text input"</span>\n        onClick={handleClick}\n      /&gt;\n    &lt;/div&gt;\n  );  \n}</code></pre>\n\n<h4 id="h4-7">切勿过度使用Refs特性</h4>\n<p>\n    可能在了解Refs的机制后，某些开发人员更倾向于在代码中使用Refs这种“操作即发生”特性来实现功能。但是在使用之前最好多花点时间来思考为什么状态需要由不同的组件层次来控制，通常情况下组件之间的状态最好由他们共同的祖先来控制：\n    <a title="React 状态、事件与动态渲染" href="/article/react/react_state_event_and_render" rel="nofollow">React 状态、事件与动态渲染</a>\n</p>\n<h4 id="h4-8">*使用警告</h4>\n<p>\n    如果ref的回调方法被定义为一个内联方法，它在更新之前会发生2次调用，第一调用时会传递一个null值，第二次会赋予真正的Dom对象。这是因为在每次渲染时都会有一个新的方法实例被创建所以React必须清除已有的ref并创建一个的ref。可以通过将ref回调方法定义为类的绑定方法来避免这种情况，但请注意，在大多数情况下，这并不会导致什么问题。</p>'},372:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h3 id="h3-1">非受控组件（Uncontrolled Components）</h3>\n<h4 id="h4-1">使用非受控组件</h4>\n<p>在大部分情况下，推荐使用 <a title="受控组件" href="https://www.chkui.com/article/react/react_list_key_and_form#h1-2">受控组件</a> 来实现表单、输入框等状态控制。在受控组件中，表单等数据都有React组件自己处理。这里将介绍另外一种非受控组件，表单的数据有Dom自己控制。</p>\n<p>非受控组件实现的重点是用Refs特性获取真实Dom来代替每次数据变更去更新组件的状态值。</p>\n<p>例如下面的代码，在非受控组件中记录被用户输入的名字：</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">NameForm</span></span></span><span class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span class="hljs-class"><span class="code-title">Component</span></span></span><span class="hljs-class"> </span></span>{\n  <span class="code-keyword">constructor</span>(props) {\n    <span class="code-keyword"><span class="code-keyword">super</span></span>(props);\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.handleSubmit = <span class="code-keyword"><span class="code-keyword">this</span></span>.handleSubmit.bind(<span class="code-keyword"><span class="code-keyword">this</span></span>);\n  }\n\n  handleSubmit(event) {\n    <span class="code-comment"><span class="code-comment">//在提交时，直接使用ref获取的真实Dom获取值</span></span>\n    alert(<span class="code-string"><span class="hljs-symbol">\'A</span> name was submitted: \'</span> + <span class="code-keyword"><span class="code-keyword">this</span></span>.input.value);\n    event.preventDefault();\n  }\n\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> (\n      &lt;form onSubmit={<span class="code-keyword">this</span>.handleSubmit}&gt;\n        &lt;label&gt;\n          <span class="code-type">Name</span>:\n          &lt;input <span class="hljs-class"><span class="code-keyword">type</span></span>=<span class="code-string">"text"</span> ref={(input) =&gt; <span class="code-keyword">this</span>.input = input} /&gt;\n        &lt;/label&gt;\n        &lt;input <span class="hljs-class"><span class="code-keyword">type</span></span>=<span class="code-string">"submit"</span> value=<span class="code-string">"Submit"</span> /&gt;\n      &lt;/form&gt;\n    );\n  }\n}</code></pre>\n<p><a title="代码测试" href="https://codepen.io/gaearon/pen/WooRWa?editors=0010" rel="nofollow">尝试代码</a>。</p>\n<p>由于在非受控组件中使用Refs特性获取了真实Dom的实例，所以在使用非受控组建时，更容易集成React和非React代码，在某些时候也可以省略一些代码。但是建议除了特殊情况，都使用受控组件。</p>\n<p>如果想要深入理解什么情况下使用哪种组件，建议阅读 <a title="受控组件与非受控组件的差异" href="https://goshakkk.name/controlled-vs-uncontrolled-inputs-react/" rel="nofollow">受控和不受控表单输入</a> 一文。</p>\n<h4 id="h4-2">组件默认值</h4>\n<p>在React渲染的生命周期，表单中的value属性会被覆盖Dom中的value值。在使用非受控组件时，通常需要React设定一个默认初始值但是不再控制后续更新。基于这个案例，你可以指定一个<code>defaultValue</code>&nbsp;属性来代替&nbsp;<code>value</code>。</p>\n<pre class="xml"><code class="language-javascript">render() {\n  <span class="code-keyword">return</span> (\n    <span class="code-tag">&lt;<span class="code-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="code-string">{this.handleSubmit}</span>&gt;</span>\n      <span class="code-tag">&lt;<span class="code-name">label</span>&gt;</span>\n        Name:\n        <span class="code-tag">&lt;<span class="code-name">input</span>\n          <span class="hljs-attr">defaultValue</span>=<span class="code-string">"Bob"</span>\n          <span class="hljs-attr">type</span>=<span class="code-string">"text"</span>\n          <span class="hljs-attr">ref</span>=<span class="code-string">{(input)</span> =&gt;</span> this.input = input} /&gt;\n      <span class="code-tag">&lt;/<span class="code-name">label</span>&gt;</span>\n      <span class="code-tag">&lt;<span class="code-name">input</span> <span class="hljs-attr">type</span>=<span class="code-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="code-string">"Submit"</span> /&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">form</span>&gt;</span>\n  );\n}</code></pre>\n<p>例如中“defaultValue = "Bob"”就是指定了一个默认值。同样地，&nbsp;<code>&lt;input type="checkbox"&gt;</code>&nbsp;和&nbsp;<code>&lt;input type="radio"&gt;</code>&nbsp;支持&nbsp;<code>defaultChecked</code>属性，&nbsp;<code>&lt;select&gt;</code>&nbsp;标签支持&nbsp;<code>defaultValue</code>属性。</p>'},391:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h2 id="h2-1">WebFLux与WebMvc的差异</h2>\n<p><em>WebFlux</em>读写<em>Cookie</em>不像<em>WebMvc</em>那么直接，最主要的原因是<em>WebMvc</em>是基于<em>Servlet</em>规范的，而<em>WebFlux</em>仅仅遵守的是<em>HTTP</em>协议。所以在使用的时候会发现<code>HttpServletRequest</code>、<code>HttpServletResponse</code>这些<em>Servlet</em>层级的接口根本就无法使用。\n</p>\n<p><em>Cookie</em>与<em>Servlet</em>并没有太直接的关系，前者是属于<em>HTTP</em>规范的而后者是一个<em>J2EE</em>的规范，在应用层面仅有的联系就是<em>Servlet</em>会读写<em>Cookie</em>中的<em>JSESSIONID</em>来标记与前端浏览器和服务端的关系。而<code>HttpServletRequest</code>、<code>HttpServletResponse</code>仅是<em>Servlet</em>为请求和响应提供<em>header</em>、<em>body</em>管理的接口。\n</p>\n<h2 id="h2-2">WebFlux的Cookie管理</h2>\n<p><em>WebFlux</em>目前并没有为写<em>Cookie</em>提供任何工具。这就需要开发者按照<em>HTTP</em>的规范来写<em>Cookie</em>。\n    在HTTP协议交互的过程中，服务端可以通过在<em>response</em>中添加<strong>Set-Cookie</strong>头来让浏览器记录<em>Cookie</em>，而浏览器则在<em>request</em>中使用<strong>Cookie</strong>头来传递cookie。\n</p>\n<h2 id="h2-3">写Cookie</h2>\n<p>写<em>cookie</em>使用<code>ResponseEntity</code>向response头中添加<strong>Set-Cookie</strong>即可。<code>CookieBuilder</code>的代码比较长，它是用于构建一个<em>cookie</em>字符串，<strong>Set-Cookie</strong>头除了设置<em>key=value</em>，还可以设置过期日期<em>expires</em>，域名<em>domain</em>，路径<em>path</em>等。\n</p>\n<pre><code class="java"><span class="code-meta">@RestController</span>\n<span class="code-meta">@RequestMapping</span>(<span class="code-string">"/cookie"</span>)\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">CookieReadAWriteController</span> </span>{\n\t<span class="code-meta">@GetMapping</span>(<span class="code-string">"/write"</span>)\n\t<span class="hljs-function"><span class="code-keyword">public</span> ResponseEntity&lt;String&gt; <span\n            class="code-title">cookieWrite</span><span class="hljs-params">()</span> </span>{\n\t\tHttpHeaders headers = <span class="code-keyword">new</span> HttpHeaders();\n\t\tString cookie = <span class="code-keyword">new</span> CookieBuilder().setKey(<span class="code-string">"cookie-text"</span>)\n\t\t\t.setValue(cookieText)\n\t\t\t.setMaxAge(<span class="hljs-number">840000</span>)\n\t\t\t.setPath(<span class="code-string">"/"</span>)\n\t\t\t.build();\n\t\theaders.add(<span class="code-string">"Set-Cookie"</span>, cookie);\n\t\t<span class="code-keyword">return</span> <span\n            class="code-keyword">new</span> ResponseEntity&lt;String&gt;(<span class="code-string">"hi,"</span> + userName, headers, HttpStatus.OK);\n\t}\n}\n\n\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">CookieBuilder</span> </span>{\n\t<span class="code-keyword">private</span> String key;\n\t<span class="code-keyword">private</span> String value;\n\t<span class="code-keyword">private</span> String expires;\n\t<span class="code-keyword">private</span> String domain;\n\t<span class="code-keyword">private</span> String path;\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> CookieBuilder <span\n            class="code-title">setKey</span><span class="hljs-params">(String key)</span> </span>{\n\t\t<span class="code-keyword">this</span>.key = key;\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>;\n\t}\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> CookieBuilder <span\n            class="code-title">setValue</span><span class="hljs-params">(String value)</span> </span>{\n\t\t<span class="code-keyword">this</span>.value = value;\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>;\n\t}\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> CookieBuilder <span class="code-title">setMaxAge</span><span\n            class="hljs-params">(<span class="code-keyword">long</span> ms)</span> </span>{\n\t\t<span class="code-comment">//cookie的过期日期为GMT格式的时间。</span>\n\t\tDate date = <span class="code-keyword">new</span> Date(<span class="code-keyword">new</span> Date().getTime() + ms);\n\t\tSimpleDateFormat sdf = <span class="code-keyword">new</span> SimpleDateFormat(<span class="code-string">"EEE d MMM yyyy HH:mm:ss \'GMT\'"</span>, Locale.US);\n\t\tsdf.setTimeZone(TimeZone.getTimeZone(<span class="code-string">"GMT"</span>));\n\t\t<span class="code-keyword">this</span>.expires = sdf.format(date);\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>;\n\t}\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> CookieBuilder <span class="code-title">setDomain</span><span\n            class="hljs-params">(String domain)</span> </span>{\n\t\t<span class="code-keyword">this</span>.domain = domain;\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>;\n\t}\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> CookieBuilder <span\n            class="code-title">setPath</span><span class="hljs-params">(String path)</span> </span>{\n\t\t<span class="code-keyword">this</span>.path = path;\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>;\n\t}\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span\n            class="code-title">build</span><span class="hljs-params">()</span> </span>{\n\t\tStringBuilder sb = <span class="code-keyword">new</span> StringBuilder();\n\t\tsb.append(<span class="code-keyword">this</span>.key);\n\t\tsb.append(<span class="code-string">"="</span>);\n\t\tsb.append(<span class="code-keyword">this</span>.value);\n\t\tsb.append(<span class="code-string">";"</span>);\n\t\t<span class="code-keyword">if</span> (<span class="code-keyword">null</span> != <span\n            class="code-keyword">this</span>.expires) {\n\t\t\tsb.append(<span class="code-string">"expires="</span>);\n\t\t\tsb.append(<span class="code-keyword">this</span>.expires);\n\t\t\tsb.append(<span class="code-string">";"</span>);\n\t\t}\n\t\t<span class="code-keyword">if</span> (<span class="code-keyword">null</span> != <span\n            class="code-keyword">this</span>.domain) {\n\t\t\tsb.append(<span class="code-string">"domain="</span>);\n\t\t\tsb.append(<span class="code-keyword">this</span>.domain);\n\t\t\tsb.append(<span class="code-string">";"</span>);\n\t\t}\n\t\t<span class="code-keyword">if</span> (<span class="code-keyword">null</span> != <span\n            class="code-keyword">this</span>.path) {\n\t\t\tsb.append(<span class="code-string">"path="</span>);\n\t\t\tsb.append(<span class="code-keyword">this</span>.path);\n\t\t\tsb.append(<span class="code-string">";"</span>);\n\t\t}\n\t\t<span class="code-keyword">return</span> sb.toString();\n\t}\n}\n</code></pre>\n<h2 id="h2-4">读cookie</h2>\n<p>获取<em>cookie</em>就比较直观，可以直接使用<code>@CookieValue</code>这个<em>Annotation</em>来获取：</p>\n<pre><code class="java"><span class="code-meta">@RestController</span>\n<span class="code-meta">@RequestMapping</span>(<span class="code-string">"/cookie"</span>)\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">CookieReadAWriteController</span> </span>{\n\t<span class="code-meta">@GetMapping</span>(<span class="code-string">"/read/annotation"</span>)\n\t<span class="code-comment">/**\n\t * <span class="hljs-doctag">@param</span> value\n\t * <span class="hljs-doctag">@return</span>\n\t */</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">cookieReadAnnotation</span><span\n            class="hljs-params">(@CookieValue(<span\n            class="code-string">"cookie-text"</span>)</span> String value) </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"当前Cookie中的内容"</span> + value;\n\t}\n}\n</code></pre>\n<p>也可以直接从<em>Request的Header</em>中获取：</p>\n<pre><code class="java"><span class="code-meta">@RestController</span>\n<span class="code-meta">@RequestMapping</span>(<span class="code-string">"/cookie"</span>)\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">CookieReadAWriteController</span> </span>{\n\t<span class="code-meta">@GetMapping</span>(<span class="code-string">"/read/annotation"</span>)\n\t<span class="code-comment">/**\n\t * <span class="hljs-doctag">@param</span> value\n\t * <span class="hljs-doctag">@return</span>\n\t */</span>\n\t<span class="code-meta">@GetMapping</span>(<span class="code-string">"/read/entity"</span>)\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">cookieReadEntity</span><span\n            class="hljs-params">(RequestEntity&lt;String&gt; entity)</span> </span>{\n\t\tHttpHeaders headers = entity.getHeaders();\n\t\tList&lt;String&gt; cookie = headers.get(<span class="code-string">"Cookie"</span>);\n\t\t<span class="code-keyword">return</span> <span class="code-string">"当前Cookie中的内容"</span> + cookie;\n\t}\n}\n</code></pre>\n<p>\n    使用<em>Annotatin</em>是直接标记<em>Cookie</em>的<em>key</em>来获取<em>value</em>。而使用<em>RequestEntity</em>需要从头中先获取<em>Cookie</em>的内容，然后再解析<em>key</em>和<em>value</em>，存在一个<em>key</em>对应多个<em>value</em>的情况需要使用<em>RequestEntity</em>。\n</p>                                    '}});