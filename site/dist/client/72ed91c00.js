webpackJsonp([7],{369:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<p>在<a href="https://www.chkui.com/article/spring/spring_core_environment_management_of_profile" title="Profile管理环境">Profile管理环境</a>一文中介绍了环境的概念以及Spring\n    Profile特性控制Bean的添加。本文将进一步介绍Spring管理和控制操作系统变量、JVM变量和Java标准资源（properties文件）的相关功能。</p>\n<p>文章的代码仅仅用于说明问题，<a href="https://gitee.com/chkui-com/spring-core-sample" rel="nofollow">可执行代码请到我的gitee库clone</a>，本文的代码在<em>chkui.springcore.example.hybrid.propertsource</em>包中。\n</p>\n\n<h2 id="h2-1">PropertySource与优先级</h2>\n<p>在整个Jvm运行期间，我们可以随时随地获取到2个与环境相关的参数：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.propertsource;\n\n<span class="code-comment">//env是与操作系统相关的参数</span>\nMap&lt;String, String&gt; env = System.getenv();\n<span class="code-comment">//properties中是Jvm相关的参数</span>\nProperties p = System.getProperties();\nSystem.out.println(<span class="code-string">"env :"</span> + env);\nSystem.out.println(<span class="code-string">"properties :"</span> +  p);</code></pre>\n<p>如果没有人为的添加额外信息，<em>System::getEnv</em>获取的数据都与当前的操作系统相关（以下称为“操作系统参数”），而<em>System::getProperties</em>获取的内容都与Jvm相关（以下称为“JVM参数”）。\n</p>\n<p>Spring会将操作系统参数和Jvm参数都整合到自己的环境管理接口Environment中，例如下面的代码：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.propertsource;\n\n<span class="code-comment">//向系统级的properties设置一个参数</span>\nSystem.setProperty(<span class="code-string">"wow"</span>, <span class="code-string">"World of Warcraft"</span>);\nApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(PropertySourcesApp.class);\n<span class="code-comment">//通过spring的Environment获取参数</span>\nEnvironment springEnv = ctx.getEnvironment();\nSystem.out.println(springEnv.getProperty(<span class="code-string">"wow"</span>));\nSystem.out.println(springEnv.getProperty(<span class="code-string">"PATH"</span>));\n</code></pre>\n<p>除了我们自定义的"wow"，操作系统参数"PATH"也可以在Spring的<em>Environment</em>中获取。</p>\n<p>通常情况下，在<em>Environment</em>内部维护了2个<a\n        href="https://docs.spring.io/spring-framework/docs/5.0.8.RELEASE/javadoc-api/org/springframework/core/env/PropertySource.html"\n        rel="nofollow">PropertySources</a>的实例：一个是操作系统参数，另外一个是JVM参数。如果2者有同样的参数，那么我们在调用<em>Environment::getProperty</em>方法时，得到的是JVM参数（<em>System::getProperties</em>）,也就是说&nbsp;Jvm参数具有更高的优先级。\n</p>\n<p>除了通过外部设置，我们也可以直接使用Spring提供的接口来设置：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.propertsource;\n\n<span class="code-comment">//我们要对环境进行配置，需要使用ConfigurableApplicationContext接口</span>\nConfigurableApplicationContext configAbleCtx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(PropertySourcesApp.class);\n\n<span class="code-comment">//ConfigurableApplicationContext接口提供对应的可编辑Environment和PropertySources</span>\nMutablePropertySources ps = configAbleCtx.getEnvironment().getPropertySources();\nMap&lt;String, Object&gt; map = <span class="code-keyword">new</span> HashMap&lt;String, Object&gt;();\nmap.put(<span class="code-string">"wow"</span>, <span class="code-string">"Origin = World of Warcraft!But Edit it already!"</span>);\n<span class="code-comment">//添加到Spring的环境参数中</span>\nps.addFirst(<span class="code-keyword">new</span> MapPropertySource(<span class="code-string">"myPropertySource"</span>, map));\nSystem.out.println(springEnv.getProperty(<span class="code-string">"wow"</span>));</code></pre>\n<p>代码添加到<em>PropertySource</em>中，Environment会额外维护一个<a\n        href="https://docs.spring.io/spring-framework/docs/5.0.8.RELEASE/javadoc-api/org/springframework/core/env/PropertySource.html"\n        rel="nofollow">PropertySources</a>，而自己添加的<a\n        href="https://docs.spring.io/spring-framework/docs/5.0.8.RELEASE/javadoc-api/org/springframework/core/env/PropertySource.html"\n        rel="nofollow">PropertySources</a>优先级是最高的，所以最后Environment::getProperty获取到的值是最后设置的值。</p>\n<p>如果需要添加多个<a\n        href="https://docs.spring.io/spring-framework/docs/5.0.8.RELEASE/javadoc-api/org/springframework/core/env/PropertySource.html"\n        rel="nofollow">PropertySources</a>，可以通过<em>MutablePropertySources::addFirst</em>或<em>MutablePropertySources::addLast</em>方法来控制他们之间的优先级。\n</p>\n\n<h2 id="h2-2">引入资源文件</h2>\n<p><em>*.properties</em>是Java的标准资源文件，在Java的各种项目中常用来记录各种配置参数。Spring提供了注解和XML配置将<em>*.properties</em>文件中的数据整合到Spring的环境参数（Environment）中。\n</p>\n\n<h3 id="h3-1">@PropertySource</h3>\n<p>在<em>@Configuration</em>标记的类上使用<em>@PropertySource</em>注解可以引入0~n个<em>*.properties</em>配置文件。如下面的例子：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.propertsource;\n\n<span class="code-meta">@Configuration</span>\n<span class="code-meta">@PropertySource</span>(<span class="code-string">"classpath:/hybrid/propertysource/config.properties"</span>)\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">PropertySourcesApp</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(PropertySourcesApp.class); \n\t\tSystem.out.println(<span class="code-string">"Properties file params: "</span> + springEnv.getProperty(<span\n            class="code-string">"Gdi"</span>));\n\t}\n}</code></pre>\n<p>对应的<em>config.properties</em>文件：</p>\n<pre><code class="bash"><span class="code-comment">#hybrid.propertysource.config.properties</span>\n\nGdi=StarCraft</code></pre>\n<p>\n    同一个工程中支持使用多个@PropertySource注解来引入配置文件，也支持Ant风格（Ant-style，例如"classpath:a/b/**/config.properties"）以及Spring扩展的（比如"classpath*:"）的路径规则，资源路径控制会在后续的文章中介绍。</p>\n\n<h3 id="h3-2">XML配置</h3>\n<p>XML配置在之前介绍容器后置处理器——<a href="https://www.chkui.com/article/spring/spring_core_factory_post_processor_of_official"\n                         title="BeanFactoryPostProcessor">BeanFactoryPostProcessor</a>的文章中已经介绍了，他就是&nbsp;<em>PropertyPlaceholderConfigurer</em>&nbsp;，我们在XML配置文件中进行一下设置即可。\n</p>\n<p>引入Bean：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span\n        class="hljs-attr">class</span>=<span class="code-string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span>\n    <span class="code-comment">&lt;!-- 指定*.properties文件的路径 --&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"locations"</span> <span class="hljs-attr">value</span>=<span class="code-string">"classpath:/hybrid/propertysource/config.properties"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span></code></pre>\n<p>直接使用context进行全局设置：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">context:property-placeholder</span> <span\n        class="hljs-attr">location</span>=<span\n        class="code-string">"classpath:/hybrid/propertysource/config.properties"</span>/&gt;</span></code></pre>\n\n<h2 id="h2-3">占位符替换</h2>\n<p><em>PropertyPlaceholderConfigurer</em>继承了抽象类<em>PropertyPlaceholderConfigurer，</em>而<em>*.properties</em>文件的读写就是在<em>PropertyResourceConfigurer</em>类中实现的。<em>PropertyPlaceholderConfigurer</em>进一步实现了配置文件中占位符<em>（${...}）</em>替换功能<em>。</em>\n</p>\n<p>在Spring IoC容器执行Bean的扫描、加载之前添加一个环境变量（也可以动态添加然后再执行<em>ConfigurableApplicationContext::refresh</em>方法），就可以在很多资源路径的位置使用这个占位符，对上面的例子进行一些修改：\n</p>\n<pre><code class="java"><span class="code-meta">@Configuration</span>\n<span class="code-comment">//通过占位符来设置路径</span>\n<span class="code-meta">@PropertySource</span>(<span class="code-string">"classpath:${resource.propertiesPath}/config.properties"</span>)\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">PropertySourcesApp</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n        <span class="code-comment">//容器启动之前设置环境变量</span>\n\t\tSystem.setProperty(<span class="code-string">"resource.propertiesPath"</span>, <span class="code-string">"/hybrid/propertysource"</span>);\n\t\tApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(PropertySourcesApp.class);\n\t\t<span class="code-comment">//获取环境对象实例</span>\n\t\tEnvironment springEnv = ctx.getEnvironment();\n\t\tSystem.out.println(<span class="code-string">"Properties : "</span> + springEnv.getProperty(<span\n            class="code-string">"Gdi"</span>));\n\t}\n}</code></pre>\n<p>同样的，只要环境变量存在，也可以使用占位符替换配置文件中的数据，例如：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">context:property-placeholder</span> <span\n        class="hljs-attr">location</span>=<span class="code-string">"classpath:${resource.propertiesPath:/config}/config.properties"</span>/&gt;</span></code></pre>\n<p>XML中的占位符使用的格式是<em>${resource.propertiesPath:/config}</em>，它表示使用环境变量<em>resource.propertiesPath</em>进行替换，如果<em>resource.propertiesPath</em>不存在则使用值"/config"。\n</p>\n\n<h2 id="h2-4">@Value</h2>\n<p>我们可以在任何Bean中使用@Value注解来获取环境变量。如下面的例子：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.propertsource;\n\n<span class="code-meta">@Configuration</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">PropertySourcesApp</span> </span>{\n\t<span class="code-meta">@Value</span>(<span class="code-string">"${resource.propertiesPath}"</span>)\n\t<span class="code-keyword">private</span> String value;\n\t<span class="code-meta">@Value</span>(<span\n            class="code-string">"#{systemProperties[\'resource.propertiesPath\']}"</span>)\n\t<span class="code-keyword">private</span> String elValue;\n\t<span class="code-meta">@Value</span>(<span class="code-string">"Resource PropertiesPath"</span>)\n\t<span class="code-keyword">private</span> String staticValue;\n\t\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tSystem.setProperty(<span class="code-string">"resource.propertiesPath"</span>, <span class="code-string">"/hybrid/propertysource"</span>);\n\n\t\tApplicationContext ctx = <span class="code-keyword">new</span> AnnotationConfigApplicationContext(PropertySourcesApp.class);\n\t\t\n\t\tPropertySourcesApp app = ctx.getBean(PropertySourcesApp.class);\n\t\tSystem.out.println(<span class="code-string">"Value: "</span> + app.value);\n\t\tSystem.out.println(<span class="code-string">"EL Value: "</span> + app.elValue);\n\t\tSystem.out.println(<span class="code-string">"Static Value: "</span> + app.staticValue);\n\t}\n}</code></pre>\n<p>\n    @Value可以注入一个纯字面量，如上面示例代码中的staticValue，也可以使用占位符使用环境变量中的任何值。除了使用占位符${}，@Value还支持"#{systemProperties[\'resource.propertiesPath\']}"这样具备代码执行功能的复杂表达式来获取数据，这部分功能会在后续介绍EL表达式的文章中进行分享。</p>'},374:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h3 id="h3-1">依赖注入</h3>\n<p>在<a href="https://www.chkui.com/article/spring/spring_core_design_pattern_and_ioc" rel="nofollow">设计模式与IoC</a>这篇文章中，介绍了Spring基础的三大支柱的两项内容——IoC、Bean。本篇将继续围绕着Bean的创建时的注入方式来介绍Spring的核心思想与设计模式。\n</p>\n<p>天底下所有面向对象的语言都不可能只用一个类来解决问题，即使是最简单的应用程序都存在类与类之间的依存关系。如下面这个人人都理解的组合例子：</p>\n<pre><code class="java"><span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">Foo</span></span>{\n   <span class="code-keyword">private</span> Other other;\n   <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-title">Foo</span><span\n           class="hljs-params">()</span></span>{\n      other = <span class="code-keyword">new</span> Other();\n   }\n}\n\n<span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">Other</span></span>{}</code></pre>\n<p>在设计模式上关于类的组合与继承的适用性不属于本篇的讨论范围，但是从Spring框架非侵入式的设计思路来看，组合才是使用Spring的正确姿势。</p>\n<p>官方将这种组合的关系叫做“依赖注入（DI——<em>Dependency injection</em>）”。从名字上来看这也是一种依托Ioc容器很自然的实现方式——所有的Bean都放置在容器中，然后通过一些配置来告诉容器bean与bean之间的依存关系。一个类除了在内部块中通过new关键字实现一个组合关系，也可以通过构造方法传参或接口方法设置。\n</p>\n<p>由于IoC容器不可能去修改一个类内部的代码，所以类与类的组合方式通过构造方法（Constructor）和set方法（Setter）来实现。此外，Ioc可以根据接口（interface）来注入对应的实现类（class extands\n    interface）,所以从设计模式的角度来说，依赖注入的方式很好的规避了<strong>标准组合模式</strong>中new关键字违反<strong>依赖倒置原则</strong>的问题。</p>\n\n<h3 id="h3-2">构造方法注入</h3>\n<p>直接通过构造方法注入组合数据。</p>\n<p>class：</p>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">A</span> </span>{\n    <span class="code-keyword">private</span> B b;\n    <span class="code-keyword">private</span> C c;\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-title">Foo</span><span\n            class="hljs-params">(B b, C c)</span> </span>{\n       <span class="code-keyword">this</span>.b = b;\n       <span class="code-keyword">this</span>.c = c;\n    }\n}\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">B</span> </span>{}\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">C</span> </span>{}\n</code></pre>\n<p>xml：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n            class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.A"</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">constructor-arg</span> <span\n                class="hljs-attr">ref</span>=<span class="code-string">"b"</span>/&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">constructor-arg</span> <span\n                class="hljs-attr">ref</span>=<span class="code-string">"c"</span>/&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n            class="code-string">"b"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.B"</span>/&gt;</span>\n\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n            class="code-string">"c"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.C"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>如果是源生类型的参数，可以通过指定类型来注入数据：</p>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">A</span> </span>{\n    <span class="code-keyword">private</span> <span class="code-keyword">int</span> b;\n    <span class="code-keyword">private</span> String c;\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-title">Foo</span><span\n            class="hljs-params">(<span class="code-keyword">int</span> b, String c)</span> </span>{\n       <span class="code-keyword">this</span>.b = b;\n       <span class="code-keyword">this</span>.c = c;\n    }\n}\n</code></pre>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.A"</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span\n            class="code-string">"int"</span> <span class="hljs-attr">value</span>=<span class="code-string">"1"</span>/&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span\n            class="code-string">"java.lang.String"</span> <span class="hljs-attr">value</span>=<span\n            class="code-string">"42"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span></code></pre>\n<p>也可以通过索引的方式：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.A"</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span\n            class="code-string">"0"</span> <span class="hljs-attr">value</span>=<span class="code-string">"1"</span>/&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span\n            class="code-string">"1"</span> <span class="hljs-attr">value</span>=<span class="code-string">"42"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span></code></pre>\n<p>配合<a href="http://download.oracle.com/javase/6/docs/api/java/beans/ConstructorProperties.html" rel="nofollow">@ConstructorProperties</a>注解，还可以直接使用名称来注入：\n</p>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">A</span> </span>{\n    <span class="code-keyword">private</span> <span class="code-keyword">int</span> b;\n    <span class="code-keyword">private</span> String c;\n    <span class="code-meta">@ConstructorProperties</span>({<span class="code-string">"b"</span>, <span\n            class="code-string">"c"</span>})\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-title">Foo</span><span\n            class="hljs-params">(<span class="code-keyword">int</span> b, String c)</span> </span>{\n       <span class="code-keyword">this</span>.b = b;\n       <span class="code-keyword">this</span>.c = c;\n    }\n}\n</code></pre>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"exampleBean"</span> <span class="hljs-attr">class</span>=<span class="code-string">"examples.ExampleBean"</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"b"</span> <span class="hljs-attr">value</span>=<span class="code-string">"1"</span>/&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"c"</span> <span class="hljs-attr">value</span>=<span class="code-string">"42"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span></code></pre>\n<p>在Debug模式下不用这个注解也可以实现按名字注入，但是千万别这样做。</p>\n\n<h3 id="h3-3">Set方法注入</h3>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">A</span> </span>{\n    <span class="code-keyword">private</span> B b;\n    <span class="code-keyword">private</span> C c;\n    <span class="code-keyword">private</span> String value;\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setA</span><span class="hljs-params">(A a)</span></span>{<span\n            class="code-keyword">this</span>.a = a;}\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setB</span><span class="hljs-params">(B b)</span></span>{<span\n            class="code-keyword">this</span>.b = b;}\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setB</span><span class="hljs-params">(String value)</span></span>{<span\n            class="code-keyword">this</span>.value = value;}\n}\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">B</span> </span>{}\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">C</span> </span>{}\n</code></pre>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.A"</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"b"</span> <span class="hljs-attr">ref</span>=<span class="code-string">"b"</span>/&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"c"</span> <span class="hljs-attr">ref</span>=<span class="code-string">"c"</span>/&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"value"</span> <span class="hljs-attr">value</span>=<span class="code-string">"1"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"b"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.B"</span>/&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"c"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.C"</span>/&gt;</span></code></pre>\n\n<h3 id="h3-4">使用&nbsp;Constructor还是Setter？</h3>\n<p>\n    2种注入方法在使用的过程中我们应该如何选取呢？Spring官方给出的答案是如果注入的数据或bean是一个“必要依赖”那么使用构造方法注入，如果属于配置性的非必须数据，使用Set方法注入。但是在实际应用时，会发现绝大部分注入方式都是通过Setter实现的，包括一些很流行的开源工具，例如下面的druid：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"ds"</span> <span class="hljs-attr">class</span>=<span class="code-string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span>\n     <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n             class="code-string">"driverClass"</span> <span class="hljs-attr">value</span>=<span class="code-string">"com.mysql.jdbc.Driver"</span>/&gt;</span>\n     <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n             class="code-string">"jdbcUrl"</span> <span class="hljs-attr">value</span>=<span class="code-string">"jdbc:mysql://localhost:3306/c3p0jdbctemplate"</span>/&gt;</span>\n     <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n             class="code-string">"user"</span> <span class="hljs-attr">value</span>=<span\n             class="code-string">"admin"</span>/&gt;</span>\n     <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n             class="code-string">"password"</span> <span class="hljs-attr">value</span>=<span class="code-string">"123456"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span></code></pre>\n<p>话说你不提供账户和密码能链接到数据库吗？这算必要依赖还是配置性依赖？所以也不用死守这些规则。下面是一些关键性的建议：</p>\n<ol>\n    <li>数据配置类使用constructor注入的方法来实现，因为这样可以将bean设置为一个不可变对象（<em>immutable objects</em>）。这样结合单例模式能够很好实现享元模式共享数据，结合原型模式可以创建“浅对比”对象（变更则替换）。\n    </li>\n    <li>如果构造函数要传入的参数太多，证明你的类要完成的责任太多，这个时候用Setter当然比较合理，但是建议回头去看看类当中是不是有可以拆分的功能。</li>\n    <li>Setter注入主要用于可选的依赖关系，如果没有设置值，类应该提供默认值。所以Setter方法应该检查传入值的有效性（not null、not blank等）。</li>\n    <li>如果出现了循环依赖，其实可以通过一个bean使用setter注入另外一个bean使用constructor注入来解决，不过最好检查一下代码为什么会循环，这是设计模式上的大忌。</li>\n    <li>最有一个建议最重要。如果用第三方类，别人给什么你只能用什么，没得选。</li>\n</ol>\n\n<h3 id="h3-5">注入参数</h3>\n<p>在XML配置中，用来设定注入方式和注入数据的XML标签很多，详细内容就不一一复述了，常规用法可以到官网&nbsp;<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-properties-detailed"\n        rel="nofollow">Dependencies and configuration in detail</a>&nbsp; 一节了解。这里仅仅说明一些要点：</p>\n<ol>\n    <li>父子Bean。Ioc容器提供Bean的父子关系配置。父子关系Bean可以进行数据合并，但是很少看见什么地方有实际应用。</li>\n    <li>&lt;idref&gt;标签和&lt;ref&gt;标签的差异：1)前者只能通过id引入，后者可以通过id或name引入；2)前者可以直接用value属性替换，但是value属性的效率会差很多；3)前者只能适用与当前配置文件或当前容器，后者可以引入任何位置的内容。</li>\n    <li>当需要设置一个null值时，用&lt;null&gt;标签代替value=""。在执行代码时直接传入一个null。</li>\n</ol>\n\n<h3 id="h3-6">自动装配</h3>\n<p>这里所说的自动装配是通过&lt;bean&gt;上的autowire属性实现的功能，与@Autowired注解并不是一回事，但是他的一些参数会影像@Autowired注解的行为。</p>\n<p>\n    在有@Autowired注解的情况下，autowire属性现在用得很少。基本上他实现的结果和@Autowired差不多，就是让Ioc容器根据bean的类型或者bean名称等自动将容器中其他能对应得上的bean注入到对于的构造方法或者set方法中。详情了解&nbsp;<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire"\n        rel="nofollow">Autowiring collaborators</a>。</p>\n\n<h3 id="h3-7">方法注入</h3>\n<p>如果每一个Bean都是单例模式，那么我们通过常规的XML配置引用的手段就可以实现所有的依赖组合关系。但是每个bean都有不同的生命周期，常规配置方法很难实现某些应用不同生命周期bean的依赖关系。</p>\n<p>第一种方式是通过继承&nbsp;ApplicationContextAware 类，继承后可以直接使用&nbsp;applicationContext 的 getBean 接口来获取任何一个 bean。</p>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n<span class="code-keyword">import</span> org.springframework.beans.BeansException;\n<span class="code-keyword">import</span> org.springframework.context.ApplicationContext;\n<span class="code-keyword">import</span> org.springframework.context.ApplicationContextAware;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">BeanManagerFoo</span> <span class="code-keyword">implements</span> <span\n            class="code-title">ApplicationContextAware</span> </span>{\n\n    <span class="code-keyword">private</span> ApplicationContext applicationContext;\n\n    <span class="code-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span\n            class="code-title">getBean</span><span class="hljs-params">(Class&lt;T&gt; type)</span></span>{\n\t\t<span class="code-keyword">return</span> applicationContext.getBean(type);\n\t}\n\n    <span class="hljs-function"><span class="code-keyword">public</span> Object <span\n            class="code-title">getBean</span><span class="hljs-params">(String id)</span></span>{\n\t\t<span class="code-keyword">return</span> springContext.getBean(id);\n\t}\n\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setApplicationContext</span><span class="hljs-params">(\n            ApplicationContext applicationContext)</span> <span\n            class="code-keyword">throws</span> BeansException </span>{\n        <span class="code-keyword">this</span>.applicationContext = applicationContext;\n    }\n}</code></pre>\n<p>第二种方法是使用Lookup Method。</p>\n<p>Lookup Method的实现思路是使用CGLIB生成了动态代理类并放置到Ioc中代替源生的类。看下面的例子。</p>\n<p>首先实现我们的抽象类，抽象的要求至少有一个抽象方法：</p>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n\n<span class="code-keyword">public</span> <span class="code-keyword">abstract</span> <span class="hljs-class"><span\n            class="code-keyword">class</span> <span class="code-title">A</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> String <span\n            class="code-title">getName</span><span class="hljs-params">()</span> </span>{\n        B b = <span class="code-keyword">this</span>.createB();\n        <span class="code-keyword">return</span> b.getName();\n    }\n\n    <span class="hljs-function"><span class="code-keyword">protected</span> <span class="code-keyword">abstract</span> B <span\n            class="code-title">createB</span><span class="hljs-params">()</span></span>;\n}\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">B</span> </span>{\n    <span class="code-keyword">private</span> String name = <span class="code-string">"B class"</span>;\n    <span class="hljs-function"><span class="code-keyword">public</span> String <span\n            class="code-title">getName</span><span class="hljs-params">()</span></span>{\n        <span class="code-keyword">return</span> <span class="code-keyword">this</span>.name;\n    }\n}</code></pre>\n<p>然后通过&lt;lookup-method&gt;标签来指定获取bean的方式：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"b"</span> <span class="hljs-attr">class</span>=<span\n        class="code-string">"x.y.B"</span> <span class="hljs-attr">scope</span>=<span\n        class="code-string">"prototype"</span> /&gt;</span>\n\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.A"</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">lookup-method</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"createB"</span> <span class="hljs-attr">bean</span>=<span\n            class="code-string">"b"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span></code></pre>\n<p>现在，在调用A.getName方法时都会创建一个新的B类实例。需要注意scope属性，如果修改为<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-singleton"\n        rel="nofollow">singleton</a>则每次都获取同一个B实例。</p>\n<p>使用动态代理由于是字节码级别的变换，所有有很多限制需要注意：方法和类都不能用fina关键字；测试用例需要自己实现代理模式，否则抽象类没有实现；</p>\n<p>第三种方法是使用委派模式，即我们执行A.compute方法时，实际执行的是被委派的B.reimplement方法。</p>\n<p>先定义2个基础类——Origin、Replace：</p>\n<pre><code class="java"><span class="code-keyword">package</span> x.y\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Origin</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">int</span> <span\n            class="code-title">compute</span><span class="hljs-params">(<span class="code-keyword">int</span> in1, <span\n            class="code-keyword">int</span> in2)</span> </span>{\n        <span class="code-keyword">return</span> in1+in2;\n    }\n}\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Replace</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">int</span> <span\n            class="code-title">reimplement</span><span\n            class="hljs-params">(Object o, Method m, Object[] args)</span> </span>{\n        <span class="code-keyword">int</span> in1 = (<span class="code-keyword">int</span>)args[<span\n            class="hljs-number">0</span>];\n        <span class="code-keyword">int</span> in2 = (<span class="code-keyword">int</span>)args[<span\n            class="hljs-number">1</span>];\n        <span class="code-keyword">return</span> in1+in2;\n    }\n}</code></pre>\n<p>然后定义Spring配置：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"origin"</span> <span class="hljs-attr">class</span>=<span\n        class="code-string">"x.y.Origin"</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">replaced-method</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"compute"</span> <span class="hljs-attr">replacer</span>=<span class="code-string">"replace"</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">arg-type</span>&gt;</span>int<span\n            class="code-tag">&lt;/<span class="code-name">arg-type</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">arg-type</span>&gt;</span>int<span\n            class="code-tag">&lt;/<span class="code-name">arg-type</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">replaced-method</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"replace"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.Replace"</span>/&gt;</span></code></pre>\n<p>这个时候，在任何时候执行“origin”这个bean的compute方法，实际上都是执行的Replace::reimplement方法。</p>\n<p>上面&lt;arg-type/&gt;的参数用全称或简写都可以，例如java.lang.String，使用String，Str都是指向这个类型。</p>\n<p>\n    使用委派模式的好处是限制少、灵活，并且不会用到CGLIB这种重量级工具。但是委派之后委派方法的真实参数和被委派方法的参数完全不一样，开发时需要时时刻刻紧跟委派类的结构来修改代码。一旦委派类发生任何修改而没有相应的调整被委派类，可能会出现意想不到的问题。</p>'},375:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<p>在前面两篇介绍Sring核心与设计模式的文章中，分别介绍了<a title="Ioc容器"\n                                   href="https://www.chkui.com/article/spring/spring_core_design_pattern_and_ioc">Ioc容器</a>和\n    <a title="Bean的依赖关系" href="https://www.chkui.com/article/spring/spring_core_design_pattern_and_ioc">Bean的依赖关系</a>。如果阅读过前2文就会知道，Spring的整个运转机制就是围绕着IoC容器以及Bean展开的。IoC就是一个篮子，所有的Bean都向里面扔。除了提供篮子功能创建并存放Bean之外，IoC还要负责管理Bean与Bean之间的关系——依赖注入。之前也提到Bean是Spring核心容器的最小工作单元，Spring一些更高级的功能（例如切面、代理）都是在Bean的基础上实现。\n</p>\n<p>除了管理Bean与Bean之间的关系，IoC还提供了对Bean自身进行控制的各项功能，本文将介绍Bean的<strong>生命周期功能</strong>以及<strong>状态定义功能。</strong></p>\n\n<h2 id="h2-1">前置依赖</h2>\n<p>\n    Bean与Bean之间存在依赖关系，可以是强依赖（通过XML和注解直接声明依赖）、也可以是弱依赖（ApplicationContextAware等方式获取）。当一个Bean需要另外一个Bean完成初始化后自身才能工作时，例如一个Bean依赖DataSoruce，但是DataSource的初始化需要较长时间。这个时候用<em>depends-on</em>声明前置依赖即可：\n</p>\n<pre><code class="xml"><span class="code-comment">&lt;!-- 依赖多个Bean使用,号分割 --&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"beanOne"</span> <span class="hljs-attr">class</span>=<span class="code-string">"ExampleBean"</span> <span\n        class="hljs-attr">depends-on</span>=<span class="code-string">"manager,accountDao"</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n            class="code-string">"manager"</span> <span class="hljs-attr">ref</span>=<span\n            class="code-string">"manager"</span> /&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"manager"</span> <span class="hljs-attr">class</span>=<span class="code-string">"ManagerBean"</span> /&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"accountDao"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.jdbc.JdbcAccountDao"</span> /&gt;</span></code></pre>\n\n<h2 id="h2-2">延迟加载</h2>\n<p>通常情况下，所有的&nbsp;<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-singleton"\n        rel="nofollow">singleton</a>&nbsp;类型的Bean都会在容器创建后进行初始化，简单的说就是启动Jvm就开始创建（实际上是创建ApplicationContext的某个实现类实例之后）。</p>\n<p>IoC支持所有的&nbsp;<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-singleton"\n        rel="nofollow">singleton</a>&nbsp;Bean在使用时再加载，这样做的好处是可以大大节省初始化的时间。<span style="color:#e74c3c">但是如果你的应用对启动时间的长短并不敏感，建议让所有的&nbsp;</span><a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes-singleton"\n        rel="nofollow"><span style="color:#e74c3c">singleton</span></a><span style="color:#e74c3c">&nbsp;都启动时加载。这样可以在启动时就发现一些问题，而不是在运行很久直到使用时才由用户去触发这个问题</span>。或者可以根据场景来使用决定是否延迟，例如开发时使用延迟加载，而在集成测试或上生产时关闭。\n</p>\n<p>可以设置全局延迟加载，也可以设置某个Bean延迟加载：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span> <span class="hljs-attr">default-lazy-init</span>=<span\n        class="code-string">"true"</span>&gt;</span>\n    <span class="code-comment">&lt;!-- 所有的Bean知道使用的时候才会进行加载... --&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<pre><code class="xml"><span class="code-comment">&lt;!-- 只有lazy类延迟加载 --&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"lazy"</span> <span class="hljs-attr">class</span>=<span class="code-string">"com.foo.ExpensiveToCreateBean"</span> <span\n        class="hljs-attr">lazy-init</span>=<span class="code-string">"true"</span>/&gt;</span>\n<span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">name</span>=<span\n        class="code-string">"not.lazy"</span> <span class="hljs-attr">class</span>=<span class="code-string">"com.foo.AnotherBean"</span>/&gt;</span></code></pre>\n<p>需要注意的是，在设置某个单独的Bean延迟加载时，如果有某个没有延迟加载的Bean要依赖他，那实际上也会在初始化的时候就加载。</p>\n<p>还要强调一下，这里的“加载”仅仅是为了表示一个类被Ioc创造并放置容器中，和classLoad方法将class文件中的字节码加载到方法区的加载是两个概念。</p>\n<p>延迟加载在设计模式上是单例模式一种延伸，通常也被称为懒汉模式。单例通常有双重锁+volatile、静态类和枚举三种方式实现。在<a\n        href="http://www.baidu.com/link?url=kGkdnL7l_ll3LfLYL8dxNgxmZdGW-wKRbUh6i8wRu2CERbWLWDBkpLtu38Jg9qTx0-KOIOBr6FXsjRwJigZmxa"\n        target="_blank" rel="nofollow">Effective&nbsp;<em>Java</em></a>一书中对三种模式都有深入的解析。而对于Spring容器而言，枚举的方式肯定不好用了，静态类由于属于自身代码级别应该也不会用，所以双重锁的实现方式较为可信。不过我没去看过源码，仅属于猜测。\n</p>\n\n<h2 id="h2-3">生命周期方法</h2>\n<p>一个Bean的创建、使用再到最后销毁称为"Bean的生命周期"。Spring框架为Bean的生命周期各个阶段提供了多种回掉方法来处理各种状态或者数据。</p>\n\n<h3 id="h3-1">初始化方法</h3>\n<p>\n    当一个Bean完成初始化并注入各项参数之后，初始化回掉方法会被调用，简单的说就是完成创建之后会被调用。实现初始化回调方法有2个路径：1.继承org.springframework.beans.factory.InitializingBean接口，然后实现\n    afterPropertiesSet方法。2.在Bean的XML配置上使用init-method属性来制定要调用的初始化：</p>\n<p>继承实现：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.A"</span> /&gt;</span></code></pre>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">A</span> <span class="code-keyword">implements</span> <span class="code-title">InitializingBean</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">afterPropertiesSet</span><span class="hljs-params">()</span></span>{\n        <span class="code-comment">// init</span>\n    }\n}</code></pre>\n<p>配置实现：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span\n        class="code-string">"x.y.A"</span> <span class="hljs-attr">init-method</span>=<span\n        class="code-string">"init"</span> /&gt;</span></code></pre>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">A</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">init</span><span class="hljs-params">()</span></span>{}\n}</code></pre>\n<p>2种方法都等效，实际使用是我们应该使用哪一种方法呢？</p>\n<p>InitializingBean是Spring早期实现的一个生命周期回调方法。但是在JCP推出JSR-250和<a title="JSR-330"\n                                                             href="https://www.chkui.com/article/java/java_jsr330"\n>JSR-330</a>规范之后，Spring的大神们开始意识到基于元编程思想和配置手段来实现非侵入式框架（Not\n    Coupled）才是正道。所以现在都是推荐使用配置文件和JSR-250的@PostConstruct（关于各种Annotation的使用请关注后续的文章）。现在依然保留InitializingBean应该是考虑到兼容问题。</p>\n\n<h3 id="h3-2">销毁方法</h3>\n<p>与创建方法相对应的是销毁方法。当一个类将要被销毁之前，对应的销毁回调方法会被调用。销毁方法也有一个继承实现和配置+注解实现：</p>\n<p>继承实现：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.A"</span> /&gt;</span></code></pre>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">A</span> <span class="code-keyword">implements</span> <span class="code-title">DisposableBean</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">destroy</span><span class="hljs-params">()</span></span>{\n        <span class="code-comment">// 销毁资源</span>\n    }\n}</code></pre>\n<p>配置实现：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span\n        class="code-string">"x.y.A"</span> <span class="hljs-attr">destroy-method</span>=<span class="code-string">"cleanUp"</span> /&gt;</span></code></pre>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">A</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">cleanUp</span><span class="hljs-params">()</span></span>{\n        <span class="code-comment">// 销毁资源</span>\n    }\n}</code></pre>\n<p>依然建议销毁手段也使用配置或@PreDestroy来设定销毁方法。</p>\n\n<h3 id="h3-3">全局配置初始化与销毁方法</h3>\n<p>IoC容器还提供了全局配置初始化与销毁方法的配置：</p>\n<pre><code class="java"><span class="code-keyword">package</span> x.y;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">A</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">init</span><span class="hljs-params">()</span></span>{\n        <span class="code-comment">// 初始化资源</span>\n    }\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">destroy</span><span class="hljs-params">()</span></span>{\n        <span class="code-comment">// 销毁资源</span>\n    }\n}</code></pre>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span> <span class="hljs-attr">default-init-method</span>=<span\n        class="code-string">"init"</span> <span class="hljs-attr">default-destroy-method</span>=<span\n        class="code-string">"destroy"</span>&gt;</span>\n     <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n             class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span\n             class="code-string">"x.y.A"</span>/&gt;</span>\n     <span class="code-comment">&lt;!-- bean configuration --&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>通过在&lt;beans&gt;标签上使用<em>default-init-method</em>和<em>default-destroy-method</em>&nbsp;属性参数，可以为容器中所有的Bean统一指定初始化和销毁的生命周期方法。\n</p>\n<p>如果在&lt;beans&gt;上设定2个默认的生命周期方法，同时在&lt;bean&gt;上也指定了<em>init-method</em>或<em>destroy-method，</em>回调方法会以&lt;bean&gt;上的配置为准。这样就保证全局配置与单独配置可以共存。\n</p>\n<p>使用初始化或销毁2个生命周期方法注意的要点：</p>\n<ol>\n    <li>\n        初始化和销毁都提供了3种手段：XML配置、注解、以及实现接口。系统的各个部分会交由不同的团队开发，不遵循统一的规范，建议使用满足JSR规范的注解——@PostConstruct、@PreDestroy。如果是统一的团队，准训一致的规范，建议使用&lt;beans&gt;的属性统一名称使用全局配置。\n    </li>\n    <li>如果Bean设计到代理模式时（例如使用了AOP），那么生命周期方法被调用时，有可能代理类还没有被创建出来。因为生命周期方法是实体类完成对应工作之后就会被调用，而与代理类无关。</li>\n</ol>'}});