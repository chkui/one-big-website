webpackJsonp([9],{351:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<h2 id="h2-1">高阶组件</h2>\n<p>高阶组件（higher-order components：以下简称HOC或HOC组件）是一个React组件复用的高级技巧。HOCs本身并不是React的API接口，他是React组件之间组织方式的一种模式。</p>\n<p>具体来说，一个HOC组件是一个返回另外一个新组件的方法，如下面的代码：</p>\n<pre class="lisp"><code class="language-javascript"><span class="code-keyword">const</span> EnhancedComponent = higherOrderComponent(<span\n        class="code-name">WrappedComponent</span>)<span class="code-comment">;</span></code></pre>\n<p>常规的React组件都是将传入的props值转换成一个UI返回，而高阶组件是将一个组件转换成另外一个组件。HOCs通常以第三方React组件库的方式呈现，比如Redux的 <a\n        href="https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options"\n        rel="nofollow">connect </a>和&nbsp;Relay的&nbsp;<a\n        href="https://facebook.github.io/relay/docs/api-reference-relay.html#createcontainer-static-method"\n        rel="nofollow">createContainer</a>。</p>\n<p>本文会讨论为什么HOCs非常有用，并且介绍如何开发自定义的HOCs。</p>\n\n<h4 id="h4-1">HOCs用于组件代码共用</h4>\n<blockquote>\n    <p>在前面的文章中已经介绍了“混合器”，他也是组件代码共用的一种方式，但是到目前为止“混合器”在使用中遇到很多问题，并且官方已经不再推荐使用它。可以阅读这篇文章（<a\n            href="https://facebook.github.io/react/blog/2016/07/13/mixins-considered-harmful.html" rel="nofollow">Mixins\n        Considered Harmful</a>）了解为什么官方已经不再推荐使用“混合器”以及将代码转换成其他模式的方式。</p>\n</blockquote>\n<p>组件是React中代码重用的主要单元。但是随着应用的深入，开发者会发现一些模式对于一些传统的组件并不总是行之有效。下面这个例子，假设有一个名为&nbsp;<code>CommentList</code>&nbsp;的组件,它利用外部数据源来更新组件内的列表：\n</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span\n        class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span\n        class="code-title"><span class="hljs-class"><span class="code-title">CommentList</span></span></span><span\n        class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n        class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n        class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  <span class="code-keyword">constructor</span>() {\n    <span class="code-keyword"><span class="code-keyword">super</span></span>();\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.handleChange = <span\n            class="code-keyword"><span class="code-keyword">this</span></span>.handleChange.bind(<span\n            class="code-keyword"><span class="code-keyword">this</span></span>);\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.state = {\n      <span class="code-comment"><span class="code-comment">// "DataSource"是一个全局的数据源</span></span>\n      comments: <span class="code-type">DataSource</span>.getComments()\n    };\n  }\n\n  componentDidMount() {\n    <span class="code-comment"><span class="code-comment">// 监听数据变更</span></span>\n    <span class="code-type">DataSource</span>.addChangeListener(<span class="code-keyword"><span class="code-keyword">this</span></span>.handleChange);\n  }\n\n  componentWillUnmount() {\n    <span class="code-comment"><span class="code-comment">// 清除注册事件</span></span>\n    <span class="code-type">DataSource</span>.removeChangeListener(<span class="code-keyword"><span\n            class="code-keyword">this</span></span>.handleChange);\n  }\n\n  handleChange() {\n    <span class="code-comment"><span class="code-comment">// 当数据变更时更新组件的列表数据</span></span>\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.setState({\n      comments: <span class="code-type">DataSource</span>.getComments()\n    });\n  }\n\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> (\n      <span class="xml"><span class="code-tag">&lt;<span class="code-name">div</span>&gt;</span>\n        {<span class="code-keyword">this</span>.state.comments.map((comment) =&gt; (\n          <span class="code-tag">&lt;<span class="code-name"><span class="code-type">Comment</span></span> <span\n                  class="hljs-attr">comment</span>=<span class="code-string">{comment}</span> <span class="hljs-attr">key</span>=<span\n                  class="code-string">{comment.id}</span> /&gt;</span>\n        ))}\n      <span class="code-tag">&lt;/<span class="code-name">div</span>&gt;</span>\n    );\n  }\n}</span></code></pre>\n<p>随后，再创建一个组件来订阅监听数据的更新，也使用类似的模式：</p>\n<pre class="kotlin"><code class="language-javascript"><span class="hljs-class"><span class="code-keyword"><span\n        class="hljs-class"><span class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span\n        class="code-title"><span class="hljs-class"><span class="code-title">BlogPost</span></span></span><span\n        class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span\n        class="code-title">extends</span></span></span><span class="hljs-class"> </span><span class="code-title"><span\n        class="hljs-class"><span class="code-title">React</span></span></span><span class="hljs-class">.</span><span\n        class="code-title"><span class="hljs-class"><span class="code-title">Component</span></span></span><span\n        class="hljs-class"> </span></span>{\n  <span class="code-keyword"><span class="code-keyword">constructor</span></span>(props) {\n    <span class="code-keyword"><span class="code-keyword">super</span></span>(props);\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.handleChange = <span\n            class="code-keyword"><span class="code-keyword">this</span></span>.handleChange.bind(<span\n            class="code-keyword"><span class="code-keyword">this</span></span>);\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.state = {\n      blogPost: DataSource.getBlogPost(props.id)\n    };\n  }\n\n  componentDidMount() {\n    DataSource.addChangeListener(<span class="code-keyword"><span class="code-keyword">this</span></span>.handleChange);\n  }\n\n  componentWillUnmount() {\n    DataSource.removeChangeListener(<span class="code-keyword"><span class="code-keyword">this</span></span>.handleChange);\n  }\n\n  handleChange() {\n    <span class="code-keyword"><span class="code-keyword">this</span></span>.setState({\n      blogPost: DataSource.getBlogPost(<span class="code-keyword"><span class="code-keyword">this</span></span>.props.id)\n    });\n  }\n\n  render() {\n    <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="xml"><span class="code-tag">&lt;<span\n            class="code-name">TextBlock</span> <span class="hljs-attr">text</span>=<span class="code-string">{<span\n            class="code-keyword">this</span>.state.blogPost}</span> /&gt;</span>;\n  }\n}</span></code></pre>\n<p><code>CommentList</code>&nbsp;和<code>BlogPost</code>&nbsp;没有任何关系，他们只是都调用了<code>DataSource</code>中不同的方法以获取特定的数据。但是实现的模式是一致的，相似点有：\n</p>\n<ol>\n    <li>在生命周期方法完成组件装载后，都增加了对&nbsp;<code>DataSource</code>&nbsp;的监听。</li>\n    <li>在监听方法中，只要数据发生变更都会调用&nbsp;<code>setState</code>&nbsp;。</li>\n    <li>在组件被卸载时，都会移除监听功能。</li>\n</ol>\n<p>可以想象在一个非常庞大的应用中，上面这种订阅&nbsp;<code>DataSource</code>&nbsp;变更并调用&nbsp;<code>setState</code>&nbsp;的模式可以在许多组件中重复使用。所以，我们可以将这一层功能抽象出来在一个地方编码实现这个处理逻辑，将它分享到许多组件中去使用，这就是HOCs。\n</p>\n<p>可以编写一个通用方法来创建类似&nbsp;<code>CommentList</code>&nbsp;和&nbsp;<code>BlogPost</code>&nbsp;组件中一致的功能——统一订阅&nbsp;<code>DataSource</code>。这个方法应该可以接受一个参数，这个参数将外部组件作为一个子组件传入到方法中，并在方法中完成子组件数据订阅的功能，例如下面的例子中的&nbsp;<code>withSubscription</code>：\n</p>\n<pre class="lisp"><code class="language-javascript"><span class="code-keyword">const</span> CommentListWithSubscription = withSubscription(\n  <span class="code-name">CommentList</span>,\n  (<span class="code-name">DataSource</span>) =&gt; DataSource.getComments()\n)<span class="code-comment">;</span>\n\n<span class="code-keyword">const</span> BlogPostWithSubscription = withSubscription(\n  <span class="code-name">BlogPost</span>,\n  (<span class="code-name">DataSource</span>, props) =&gt; DataSource.getBlogPost(<span class="code-name">props</span>.id)\n})<span class="code-comment">;</span></code></pre>\n<p><code>withSubscription</code>的第一个参数就是要被方法包装的子组件。第二个方法设定我们要获取的数据，直接指定&nbsp;<code>DataSource</code>&nbsp;并利用组件传入的\n    props。</p>\n<p>当&nbsp;<code>CommentListWithSubscription</code>&nbsp;和&nbsp;<code>BlogPostWithSubscription</code>&nbsp;被渲染时，<code>CommentList</code>&nbsp;和<code>BlogPost</code>&nbsp;将会被传入一个&nbsp;<code>data</code>&nbsp;属性值，这个值是从&nbsp;<code>DataSource</code>中检索的数据：\n</p>\n<pre class="kotlin"><code class="language-javascript"><span class="code-comment"><span class="code-comment">// 方法第一个参数传入另外一个组件</span></span>\n<span class="hljs-function"><span class="code-keyword">function</span> <span class="code-title">withSubscription</span>(<span\n        class="hljs-params">WrappedComponent, selectData</span>) </span>{\n  <span class="code-comment"><span class="code-comment">// 然后在方法体中构建另外一个组件并返回</span></span>\n  <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="hljs-class"><span\n            class="code-keyword"><span class="hljs-class"><span class="code-keyword">class</span></span></span><span\n            class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-title">extends</span></span></span><span\n            class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n            class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n            class="hljs-class"><span class="code-title">Component</span></span></span><span class="hljs-class"> </span></span>{\n    <span class="code-keyword"><span class="code-keyword">constructor</span></span>(props) {\n      <span class="code-keyword"><span class="code-keyword">super</span></span>(props);\n      <span class="code-keyword"><span class="code-keyword">this</span></span>.handleChange = <span\n            class="code-keyword"><span class="code-keyword">this</span></span>.handleChange.bind(<span\n            class="code-keyword"><span class="code-keyword">this</span></span>);\n      <span class="code-keyword"><span class="code-keyword">this</span></span>.state = {\n        <span class="code-keyword">data</span>: selectData(DataSource, props)\n      };\n    }\n\n    componentDidMount() {\n      <span class="code-comment"><span class="code-comment">// 订阅DataSource的数据</span></span>\n      DataSource.addChangeListener(<span class="code-keyword"><span class="code-keyword">this</span></span>.handleChange);\n    }\n\n    componentWillUnmount() {\n      DataSource.removeChangeListener(<span class="code-keyword"><span class="code-keyword">this</span></span>.handleChange);\n    }\n\n    handleChange() {\n      <span class="code-keyword"><span class="code-keyword">this</span></span>.setState({\n        <span class="code-keyword">data</span>: selectData(DataSource, <span class="code-keyword"><span\n            class="code-keyword">this</span></span>.props)\n      });\n    }\n\n    render() {\n      <span class="code-comment"><span class="code-comment">// 在render返回的部分对传入的组件进行包装，</span></span>\n      <span class="code-comment"><span class="code-comment">// 将变更后的数据以data属性传入包装组件，并返回根据参数渲染之后的组件</span></span>\n      <span class="code-comment"><span class="code-comment">// 如果这里利用ES6的"..."扩展属性 + assgin方法，可以组合更多的参数</span></span>\n      <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="xml"><span\n            class="code-tag">&lt;<span class="code-name">WrappedComponent</span> <span class="hljs-attr"><span\n            class="code-keyword">data</span></span>=<span class="code-string">{<span class="code-keyword">this</span>.state.<span\n            class="code-keyword">data</span>}</span> {<span class="hljs-attr">...<span class="code-keyword">this</span>.props</span>} /&gt;</span>;\n    }\n  };\n}</span></code></pre>\n<p>需要注意的，一个HOC模式的组件不会修改传入的组件，更不会使用继承的方式去复制组件原有的功能。相反地，一个HOC模式的组件是通过组合的方式将原来的组件通过“容器组件”包装起来。概括的来说，HOC是一个零副作用的纯函数。</p>\n<p>就像我们在例子中看到的，被包装的组件从容器获取所有的props属性，根据容器传入给他新属性值——&nbsp;<code>data</code>&nbsp;来渲染并输出。HOC并不关心数据是如何被子组件使用的，而与之对应的是，子组件不会去关心这些数据从何而来。\n</p>\n<p><code>withSubscription</code>&nbsp;并不是一个普通的方法，可以根据需要额外增加许多参数。例如在现在的需求是让传入到子组件的&nbsp;<code>data</code>&nbsp;属性可配置，以进一步实现子组件和包装组件相互分离，或者能够接受一个参数能够配置&nbsp;<code>shouldComponentUpdate</code>方法，或者可以配置数据源。以上这些需求都是可以实现的，因为HOC可以完全控制组件的定义。\n</p>\n\n<h4 id="h4-2">不要让源组件数据突变</h4>\n<p>在HOC编码过程中，一定不能让组件产生数据突变：</p>\n<pre class="javascript"><code class="language-javascript"><span class="hljs-function"><span class="code-keyword"><span\n        class="hljs-function"><span class="code-keyword">function</span></span></span><span\n        class="hljs-function"> </span><span class="code-title"><span class="hljs-function"><span class="code-title">logProps</span></span></span><span\n        class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">InputComponent</span></span></span><span\n        class="hljs-function">) </span></span>{\n  InputComponent.prototype.componentWillReceiveProps(nextProps) {\n    <span class="code-built_in"><span class="code-built_in">console</span></span>.log(<span class="code-string"><span\n            class="code-string">\'Current props: \'</span></span>, <span class="code-keyword"><span class="code-keyword">this</span></span>.props);\n    <span class="code-built_in"><span class="code-built_in">console</span></span>.log(<span class="code-string"><span\n            class="code-string">\'Next props: \'</span></span>, nextProps);\n  }\n  <span class="code-comment"><span class="code-comment">// 实时上，这里返回的原始input只是一个映射值，因为它已经发生了突变</span></span>\n  <span class="code-keyword"><span class="code-keyword">return</span></span> InputComponent;\n}\n\n<span class="code-comment"><span class="code-comment">// EnhancedComponent 将在收到props时记录。</span></span>\n<span class="code-keyword"><span class="code-keyword">const</span></span> EnhancedComponent = logProps(InputComponent);</code></pre>\n<p>上面的代码看似没毛病，但是存在一些隐藏的问题。</p>\n<p>首先是输入的组件不能与HOC分开使用，比如例子中的&nbsp;<code>componentWillReceiveProps</code>&nbsp;生命周期方法被增强组件覆盖，那么必须保证原始组件中&nbsp;<code>componentWillReceiveProps</code>&nbsp;不包含任何实现代码。\n</p>\n<p>其次还存在更重要的问题是，如果还有另外一个HOC组件包装了&nbsp;<code>EnhancedComponent</code>&nbsp;并且也以突变的方式覆盖&nbsp;<code>componentWillReceiveProps</code>&nbsp;方法，此时第一个HOC的功能将会被覆盖，组件之间并没有完全意义上实现隔离。\n</p>\n<p>用数据突变的方式去实现HOCs是一种不完备的抽象，开发人员在使用这些HOCs时候必须知道某些实现细节，以避免与其他HOC组件或在自身的编码中与之产生冲突。</p>\n<p>HOCs应该使用组合的方式来代替数据突变，下面的代码展示了使用容器如何包装输入组件以实现相同的功能：</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-function"><span\n        class="code-keyword">function</span> <span class="code-title">logProps</span>(<span class="hljs-params"><span\n        class="code-type">WrappedComponent</span></span>) </span>{\n  <span class="code-comment"><span class="code-comment">// 新创建一个组件</span></span>\n  <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="hljs-class"><span\n            class="code-keyword"><span class="hljs-class"><span class="code-keyword">class</span></span></span><span\n            class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n            class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n            class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n            class="hljs-class"><span class="code-title">Component</span></span></span><span class="hljs-class"> </span></span>{\n    <span class="code-comment"><span class="code-comment">//重载生命周期方法</span></span>\n    componentWillReceiveProps(nextProps) {\n      <span class="code-built_in">console</span>.log(<span class="code-string"><span class="hljs-symbol">\'Current</span> props: \'</span>, <span\n            class="code-keyword"><span class="code-keyword">this</span></span>.props);\n      <span class="code-built_in">console</span>.log(<span class="code-string"><span class="hljs-symbol">\'Next</span> props: \'</span>, nextProps);\n    }\n    render() {\n      <span class="code-comment"><span class="code-comment">// 对输入组件进行包装，利用ES6"..."扩展将参数原封不动的传入输入组件</span></span>\n      <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="xml"><span\n            class="code-tag">&lt;<span class="code-name"><span class="code-type">WrappedComponent</span></span> {<span\n            class="hljs-attr">...<span class="code-keyword">this</span>.props</span>} /&gt;</span>;\n    }\n  }\n}</span></code></pre>\n<p>这一段代码和之前的数据突变例子具备相同的功能，同时能避免上面提到的问题，而且无论是class还是function定义的组件它都适用。由于是一个纯函数，所以即使对其继续使用HOC包装也不会有任何问题。</p>\n<p>\n    在前面的介绍中，HOCs和容器组件的实现模式有相似之处。容器组件是将高级组件和底层组件整合在一起形成连接的一部分。容器会管理各种各样的内容，例如：订阅、状态，以及将属性数据传递到子组件中以实现底层组件的渲染功能。容器组件是HOCs模式实现的一部分，可以将HOCs模式看作一个参数化的容器组件。</p>\n\n<h4 id="h4-3">惯例：将无关的属性值传递到包装组件中</h4>\n<p>HOCs为一个组件额外增加了一些特性，但是它不应该影响组件原有的功能。对于一个HOC组件来说，他应该和被包装的子组件有相似的输入接口、有相同的返回。</p>\n<p>HOC组件应该将那些外部传入但是与HOC组件功能无关的参数按照被包装子组件接口定义的方式传递到子组件中。所以大部分HOC组件都会像下面这个编写render方法：</p>\n<pre class="javascript"><code class="language-javascript">render() {\n  <span class="code-comment"><span class="code-comment">// 过滤掉在当前HOC组件中不需要传递的额外参数</span></span>\n  <span class="code-keyword"><span class="code-keyword">const</span></span> { extraProp, ...passThroughProps } = <span\n            class="code-keyword"><span class="code-keyword">this</span></span>.props;\n\n  <span class="code-comment"><span class="code-comment">// 需要注入到包装组件中的参数</span></span>\n  <span class="code-keyword"><span class="code-keyword">const</span></span> injectedProp = someStateOrInstanceMethod;\n\n  <span class="code-comment"><span class="code-comment">// Pass props to wrapped component</span></span>\n  <span class="code-keyword"><span class="code-keyword">return</span></span> (\n    <span class="xml"><span class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span\n            class="code-name"><span class="xml"><span class="code-tag"><span\n            class="code-name">WrappedComponent</span></span></span></span><span class="xml"><span class="code-tag">\n      </span></span><span class="hljs-attr"><span class="xml"><span class="code-tag"><span class="hljs-attr">injectedProp</span></span></span></span><span\n            class="xml"><span class="code-tag">=</span></span><span class="code-string"><span class="xml"><span\n            class="code-tag"><span class="code-string">{injectedProp}</span></span></span></span><span class="xml"><span\n            class="code-tag">\n      {</span></span><span class="hljs-attr"><span class="xml"><span class="code-tag"><span class="hljs-attr">...passThroughProps</span></span></span></span><span\n            class="xml"><span class="code-tag">}\n    /&gt;</span></span></span><span class="xml">\n  );\n}</span></span></code></pre>\n<p>这个惯例能确保HOC具备不错的复用能力。</p>\n\n<h4 id="h4-4">惯例：最大化组合性</h4>\n<p>并不是所有HOC组件都是一样的。某些时候，它们仅仅需求接受一个参数，例如：</p>\n<pre class="lisp"><code class="language-javascript"><span class="code-keyword">const</span> NavbarWithRouter = withRouter(<span\n        class="code-name">Navbar</span>)<span class="code-comment">;</span></code></pre>\n<p>通常情况下，HOC组件会接受额外的参数，下面的例子中一个配置对象 config 用于指定组件的数据依赖：</p>\n<pre class="actionscript"><code class="language-javascript"><span class="code-keyword"><span\n        class="code-keyword">const</span></span> CommentWithRelay = Relay.createContainer(Comment, config);</code></pre>\n<p>最通用的的HOC组件声明方式是这样的：</p>\n<pre class="actionscript"><code class="language-javascript"><span class="code-comment"><span class="code-comment">// React Redux\'s `connect`</span></span>\n<span class="code-keyword"><span class="code-keyword">const</span></span> ConnectedComment = connect(commentSelector, commentActions)(Comment);</code></pre>\n<p>看到这里可能还有点懵逼，但是把它拆开来看就明白了：</p>\n<pre class="actionscript"><code class="language-javascript"><span class="code-comment"><span class="code-comment">// connect是一个返回另外一个方法的方法</span></span>\n<span class="code-keyword"><span class="code-keyword">const</span></span> enhance = connect(commentListSelector, commentListActions);\n<span class="code-comment"><span\n        class="code-comment">// connect返回的方法是一个HOC组件，这个HOC组件会返回一个与Redux store相互关联的组件</span></span>\n<span class="code-keyword"><span\n        class="code-keyword">const</span></span> ConnectedComment = enhance(CommentList);</code></pre>\n<p>换一种说法,&nbsp;<code>connect</code>&nbsp;是一个高阶方法，它返回一个高阶组件！</p>\n<p>这个结构看起来令人困惑或者没有必要，但是他有一个非常有用的特性。由&nbsp;<code>connect</code>&nbsp;返回的只有一个参数的HOC组件拥有一个特殊的结构&nbsp;<code>Component =&gt;\n    Component</code>——输入一个组件输出一个组件，这种结构非常有利于组件之间重复组成组合关系，看下面这个例子：</p>\n<pre class="actionscript"><code class="language-javascript"><span class="code-comment"><span class="code-comment">// 例子用于实现这个过程</span></span>\n<span class="code-comment"><span class="code-comment">// const EnhancedComponent = connect(commentSelector)(withRouter(WrappedComponent))</span></span>\n\n<span class="code-comment"><span class="code-comment">// 有一个已定义的compose(f, g, h)方法，这个方法的执行效果就是不断的包装组件</span></span>\n<span class="code-comment"><span class="code-comment">// 效果等同于 (...args) =&gt; f(g(h(...args)))</span></span>\n<span class="code-keyword"><span class="code-keyword">const</span></span> enhance = compose(\n  <span class="code-comment"><span class="code-comment">// 2个参数都是一个HOC组件</span></span>\n  connect(commentSelector),\n  withRouter\n)\n<span class="code-keyword"><span class="code-keyword">const</span></span> EnhancedComponent = enhance(WrappedComponent)</code></pre>\n<p>有很多第三方库都提供了类似于compose的方法。只要我们编写的HOC组件都使用这个模式，可以很好的延伸使用下去，而不必考虑参数模式。</p>\n\n<h4 id="h4-5">惯例：包装组件名称以便于调试</h4>\n<p>由HOCs模式创建的包装组件很难在&nbsp;<a href="https://github.com/facebook/react-devtools" rel="nofollow">React Developer Tools</a>&nbsp;等调试工具中与原组件关联起来。为了便于调试，需要选择一个用于显示的名称表明它是一个HOC组件。\n</p>\n<p>通用的实现技巧是包装被包装组件的名称。所以如果定义的高阶组件命名为&nbsp;<code>withSubscription</code>， 而被包装的组件名为&nbsp;<code>CommentList</code>，那么HOC组件的名称应该是&nbsp;<code>WithSubscription(CommentList)</code>：\n</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-function"><span\n        class="code-keyword">function</span> <span class="code-title">withSubscription</span>(<span class="hljs-params"><span\n        class="code-type">WrappedComponent</span></span>) </span>{\n  <span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span\n          class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span\n          class="hljs-class"><span class="code-title">WithSubscription</span></span></span><span\n          class="hljs-class"> </span><span class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n          class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n          class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n          class="hljs-class"><span class="code-title">Component</span></span></span><span\n          class="hljs-class"> </span></span>{<span class="code-comment"><span\n            class="code-comment">/* ... */</span></span>}\n  <span class="code-type">WithSubscription</span>.displayName = <span class="code-string">`<span class="code-type">WithSubscription</span>(<span\n            class="hljs-subst">${getDisplayName(<span class="code-type">WrappedComponent</span>)}</span>)`</span>;\n  <span class="code-keyword"><span class="code-keyword">return</span></span> <span\n            class="code-type">WithSubscription</span>;\n}\n\n<span class="hljs-function"><span class="code-keyword">function</span> <span\n        class="code-title">getDisplayName</span>(<span class="hljs-params"><span\n        class="code-type">WrappedComponent</span></span>) </span>{\n  <span class="code-keyword"><span class="code-keyword">return</span></span> <span\n            class="code-type">WrappedComponent</span>.displayName || <span class="code-type">WrappedComponent</span>.name || <span\n            class="code-string"><span class="hljs-symbol">\'Componen</span>t\'</span>;\n}</code></pre>\n\n<h3 id="h3-1">HOCs的坑</h3>\n<p>对于刚使用React的开发人员来说，HOCs存在的一些隐性问题需要注意。</p>\n\n<h4 id="h4-6">不要在render方法中去编码HOCs模式的实现代码</h4>\n<p>React的对比算法（融合算法）使用组件的标记来确定子树是需要更新还是移除重建。如果组件返回的数据和之前返回的数据相同（===），React会递归的比较子树并更新有差异的部分，如果不相同，则会移除重建整个子树。</p>\n<p>通常在使用组件时，并不需要去了解这个情况。但是如果是编写HOC组件就非常重要，这就意味着开发人员不能在render方法中去编写实现HOC的代码：</p>\n<pre class="javascript"><code class="language-javascript">render() {\n  <span class="code-comment"><span class="code-comment">// 在每次渲染时，一个新的EnhancedComponent 组件都会被创建。</span></span>\n  <span class="code-comment"><span class="code-comment">// 并且每次创建的EnhancedComponent实例都不一样</span></span>\n  <span class="code-keyword"><span class="code-keyword">const</span></span> EnhancedComponent = enhance(MyComponent);\n  <span class="code-comment"><span class="code-comment">// 这样会导致这个组件的子树每次都会重建!</span></span>\n  <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="xml"><span\n            class="code-tag"><span class="xml"><span class="code-tag">&lt;</span></span><span class="code-name"><span\n            class="xml"><span class="code-tag"><span\n            class="code-name">EnhancedComponent</span></span></span></span><span class="xml"><span class="code-tag"> /&gt;</span></span></span><span\n            class="xml">;\n}</span></span></code></pre>\n<p>这个问题并不仅仅是和性能有关，每次重建一个组件会导致组件以及子组件已有的状态都会丢失。我们应该将HOCs模式应用于组件之外，以保证组件的实例只被创建一次，确保每次渲染时，他的标记都是一致的。</p>\n<p>在某些罕见的应用下需要动态的使用HOC组件，可以在组件的生命周期方法或其构造函数中构造HOC模式相关的代码。</p>\n\n<h4 id="h4-7">静态方法必须复制</h4>\n<p>某些时候，在React组件中顶一个静态方法非常有用。当在某个组件上使用HOC组件时，源组件会被容器组件包装起来，这就意味着新的组件并没有源组件的静态方法。</p>\n<pre class="actionscript"><code class="language-javascript"><span class="code-comment"><span class="code-comment">// 定义一个静态方法</span></span>\nWrappedComponent.staticMethod = <span class="hljs-function"><span class="code-keyword"><span class="hljs-function"><span\n            class="code-keyword">function</span></span></span><span class="hljs-function"><span\n            class="hljs-params">(</span></span><span class="hljs-params"></span><span class="hljs-function"><span\n            class="hljs-params">)</span> </span></span>{<span class="code-comment"><span\n            class="code-comment">/*...*/</span></span>}\n<span class="code-comment"><span class="code-comment">// 现在提供一个HOC模式</span></span>\n<span class="code-keyword"><span class="code-keyword">const</span></span> EnhancedComponent = enhance(WrappedComponent);\n\n<span class="code-comment"><span class="code-comment">// 增强组件并没有静态方法</span></span>\n<span class="code-keyword"><span class="code-keyword">typeof</span></span> EnhancedComponent.staticMethod === <span\n            class="code-string"><span class="code-string">\'undefined\'</span></span> <span class="code-comment"><span\n            class="code-comment">// true</span></span></code></pre>\n<p>为了解决这个问题，你必须将源组件上的静态方法拷贝到容器组件上：</p>\n<pre class="scala"><code class="language-javascript"><span class="hljs-function"><span\n        class="code-keyword">function</span> <span class="code-title">enhance</span>(<span class="hljs-params"><span\n        class="code-type">WrappedComponent</span></span>) </span>{\n  <span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span\n          class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span\n          class="hljs-class"><span class="code-title">Enhance</span></span></span><span class="hljs-class"> </span><span\n          class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n          class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n          class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n          class="hljs-class"><span class="code-title">Component</span></span></span><span\n          class="hljs-class"> </span></span>{<span class="code-comment"><span class="code-comment">/*...*/</span></span>}\n  <span class="code-comment"><span class="code-comment">// 必须知道哪些静态方法需要拷贝 :(</span></span>\n  <span class="code-type">Enhance</span>.staticMethod = <span class="code-type">WrappedComponent</span>.staticMethod;\n  <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="code-type">Enhance</span>;\n}</code></pre>\n<p>上面的例子开发人员必须提前知道哪些静态方法需要被拷贝，我们可以利用<a href="https://github.com/mridgway/hoist-non-react-statics" rel="nofollow">hoist-non-react-statics</a>这个扩展工具来自动拷贝所有非React定义的静态方法：\n</p>\n<pre class="scala"><code class="language-javascript"><span class="code-keyword"><span class="code-keyword">import</span></span> hoistNonReactStatic <span\n        class="code-keyword">from</span> <span class="code-string"><span class="hljs-symbol">\'hoist</span>-non-react-statics\'</span>;\n<span class="hljs-function"><span class="code-keyword">function</span> <span class="code-title">enhance</span>(<span\n        class="hljs-params"><span class="code-type">WrappedComponent</span></span>) </span>{\n  <span class="hljs-class"><span class="code-keyword"><span class="hljs-class"><span\n          class="code-keyword">class</span></span></span><span class="hljs-class"> </span><span class="code-title"><span\n          class="hljs-class"><span class="code-title">Enhance</span></span></span><span class="hljs-class"> </span><span\n          class="code-keyword"><span class="hljs-class"><span class="code-keyword">extends</span></span></span><span\n          class="hljs-class"> </span><span class="code-title"><span class="hljs-class"><span\n          class="code-title">React</span></span></span><span class="hljs-class">.</span><span class="code-title"><span\n          class="hljs-class"><span class="code-title">Component</span></span></span><span\n          class="hljs-class"> </span></span>{<span class="code-comment"><span class="code-comment">/*...*/</span></span>}\n  hoistNonReactStatic(<span class="code-type">Enhance</span>, <span class="code-type">WrappedComponent</span>);\n  <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="code-type">Enhance</span>;\n}</code></pre>\n<p>另外一个解决方法是由底层组件的开发者去导出静态方法：</p>\n<pre class="javascript"><code class="language-javascript"><span class="code-comment"><span class="code-comment">// Instead of...</span></span>\nMyComponent.someFunction = someFunction;\n<span class="code-keyword"><span class="code-keyword">export</span></span> <span class="code-keyword"><span\n            class="code-keyword">default</span></span> MyComponent;\n\n<span class="code-comment"><span class="code-comment">// ...export the method separately...</span></span>\n<span class="code-keyword"><span class="code-keyword">export</span></span> { someFunction };\n\n<span class="code-comment"><span class="code-comment">// ...and in the consuming module, import both</span></span>\n<span class="code-keyword"><span class="code-keyword">import</span></span> MyComponent, { someFunction } <span\n            class="code-keyword"><span class="code-keyword">from</span></span> <span class="code-string"><span\n            class="code-string">\'./MyComponent.js\'</span></span>;</code></pre>\n\n<h4 id="h4-8">Refs并不会被传递</h4>\n<p>\n    在前面的惯例中介绍了将所有的props属性传递给被包装子组件的实现方法，但是需要明确的是Refs并不会被传递。这是因为Refs并不是一个真正的属性，对于React来说他是一个处理器。如果你给一个HOC组件添加一个ref，这个ref指向的是外层容器组件而非被包装的组件。</p>\n<p>\n    如果已经在编码中出现了这个问题，明智的解决方案是找到避免使用Refs特性的方法。有时候刚开始使用React开发的编程人员更喜欢使用ref胜过props。在不得不使用Refs的情况下，我们可以考虑将ref作为一个props参数的回调方法来使用：</p>\n<pre class="actionscript"><code class="language-javascript"><span class="hljs-function"><span class="code-keyword"><span\n        class="hljs-function"><span class="code-keyword">function</span></span></span><span\n        class="hljs-function"> </span><span class="code-title"><span class="hljs-function"><span class="code-title">Field</span></span></span><span\n        class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-params"><span\n        class="hljs-function"><span class="hljs-params">{ inputRef, <span class="hljs-rest_arg">...rest</span> }</span></span></span><span\n        class="hljs-function"><span class="hljs-params">)</span> </span></span>{\n  <span class="code-keyword"><span class="code-keyword">return</span></span> &lt;input ref={inputRef} {...rest} /&gt;;\n}\n\n<span class="code-comment">// HOC包装Field</span>\n<span class="code-keyword">const</span> EnhancedField = enhance(Field);\n\n<span class="code-comment">// render()</span>\n&lt;EnhancedField\n  inputRef={(inputEl) =&gt; {\n    <span class="code-comment">// 指定一个回调函数，通过这个回调将ref通过props传递到外部</span>\n    <span class="code-keyword">this</span>.inputEl = inputEl\n  }}\n/&gt;\n\n<span class="code-comment">// 然后直接使用回调</span>\n<span class="code-keyword">this</span>.inputEl.focus();</code></pre>'},372:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<p>在<a href="https://www.chkui.com/article/spring/spring_core_auto_inject_of_annotation" title="注解自动装载">注解自动装载</a>中介绍了通过注解（Annotation）自动向Bean中注入其他Bean的方法，本篇将介绍通过注解（Annotation）向容器添加Bean的方法。\n</p>\n<p>\n    Spring的核心容器提供了@Component和@Bean注解来标记如何向IoC容器添加Bean。在核心包中@Component又派生了@Service、@Controller和@Repository这三个注解（在其他的Spring工程或包中还有更多的派生），本文主要介绍@Component及其派生注解的使用。</p>\n\n<h2 id="h2-1">一个简单的使用例子</h2>\n<p>\n    要想使用@Component等注解来向容器添加Bean，需要向IoC容器指明什么类有这个注解，所以Spring提供了一个扫描机制让使用者指定要检查的路径。配置非常简单，只要使用上下文的component-scan标签即可。我们通过下面的例子来简单说明如何配置。</p>\n<p>例子中的代码仅用于说明问题，并不能运行。源码请到<a href="https://gitee.com/chkui-com/spring-core-sample" rel="nofollow">https://gitee.com/chkui-com/spring-core-sample</a>自行clone，例子在<em>chkui.springcore.example.hybrid.component</em>包中。\n</p>\n<p>有一个接口和一个实现类作为要添加到IoC容器的Bean：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.component.bean;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n            class="code-title">NameService</span> </span>{\n\t<span class="hljs-function">String <span class="code-title">getName</span><span class="hljs-params">()</span></span>;\n}</code></pre>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.component.bean;\n\n<span class="code-meta">@Component</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">NameServiceImpl</span> <span class="code-keyword">implements</span> <span\n            class="code-title">NameService</span></span>{\n\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span\n            class="code-title">getName</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"This is My Component"</span>;\n\t}\n}</code></pre>\n<p>在实现类NameServiceImpl上使用了@Component注解。</p>\n<p>然后XML（/spring-core-sample/src/main/resources/hybrid/component）配置为：</p>\n<pre><code class="xml"><span class="php"><span class="code-meta">&lt;?</span>xml version=<span\n        class="code-string">"1.0"</span> encoding=<span class="code-string">"UTF-8"</span><span\n        class="code-meta">?&gt;</span></span>\n<span class="code-tag">&lt;<span class="code-name">beans</span> <span class="hljs-attr">xmlns</span>=<span\n        class="code-string">"http://www.springframework.org/schema/beans"</span>\n    <span class="hljs-attr">xmlns:xsi</span>=<span\n            class="code-string">"http://www.w3.org/2001/XMLSchema-instance"</span>\n    <span class="hljs-attr">xmlns:context</span>=<span class="code-string">"http://www.springframework.org/schema/context"</span>\n    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="code-string">"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span>\n    \n    <span class="code-tag">&lt;<span class="code-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span\n            class="code-string">"chkui.springcore.example.hybrid.component.bean"</span>/&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>XML配置文件中没有任何&lt;bean&gt;的声明，仅仅是通过component-scan启用了路径扫描功能，base-package指定了扫描的包路径。</p>\n<p>然后我们加载这个XML运行Spring IoC容器：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.component;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">SimpleScanApp</span> </span>{\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n\t\tprint(<span class="code-keyword">new</span> ClassPathXmlApplicationContext(<span class="code-string">"hybrid/component/scanConfig.xml"</span>));\n\t}\n\t\n\t<span class="hljs-function"><span class="code-keyword">private</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">print</span><span class="hljs-params">(ApplicationContext context)</span> </span>{\n    \tNameService service = context.getBean(NameService.class);\n    \tSystem.out.println(service.getName());\n\t}\n}</code></pre>\n<p>运行之后NameServiceImpl就会作为一个Bean添加到IoC容器中。</p>\n<p>在<a href="https://www.chkui.com/article/spring/spring_core_ioc_extension_points" title="IOC功能扩展点">IOC功能扩展点</a>&nbsp;一文中已经介绍通过XML、@Component、@Bean任何一种方式去声明一个Bean都会转化为一个&nbsp;<a\n        href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/config/BeanDefinition.html"\n        rel="nofollow">BeanDefinition</a>的实现类交给BeanFactory来创建实例，所以实际上通过@Component注解和在XML文件中编写一个&lt;bean&gt;标签在结果上并没有什么区别——都是向容器添加了一个Bean实例。但是Spring偏偏提供了@Bean和@Component（以及他的派生注解）2个注解来声名Bean，这当中肯定是有一些差异的。\n</p>\n<p>@Bean在后续的文章会介绍，它就等价与在XML编写一个&lt;bean&gt;标签。而@Component以及他的派生注解除了是一个IoC容器中的Bean还有许多附加的含义。</p>\n\n<h2 id="h2-2">Stereotype与功能分层</h2>\n<p>观察@Bean和@Component两个注解的包，前者是在 <em>org.springframework.context.annotation</em> ，而后者是在&nbsp;<em>org.springframework.stereotype</em>\n    。不仅仅是@Component，他的派生注解@Service、@Controller和@Repository都在这个包中，实际上它就是在告诉使用者这些注解提供<em>stereotype</em>的特性（或者称为功能、作用）。\n</p>\n<p>那什么是<em>stereotype</em>特性呢？这很难通过Stereotype这个词的字面意思（这个词能翻译的意思很多，这里最接近的翻译应该是“旧规矩”或者“使固定”）来理解。</p>\n<p>\n    Stereotype特性最早出现在J2EE6中（忘记是哪个JSR提出的了），可以理解为围绕着“元数据”功能而发展出来的一种设计模式，虽然我很难说清楚他属于23个设计模式中的哪一个，但是这确实已经是一种约定俗成的做法，只要看到Stereotype就应该像看到“Factory——工厂模式”、“Adapter——适配器模式”、“Facade——外观模式”一样，一眼就知道他的作用。</p>\n<p>\n    Stereotype特性的目标就是为“组合模式的分层系统”按层标记一个类的功能。所谓的“组合模式的分层系统”实际上就是我们常用的Controller-Service-Dao这种分层模式，只不过有些系统可能会多几层（比如Controller和Service之间加个RPC框架什么的）。根据<a\n        href="https://docs.oracle.com/javaee/6/api/javax/enterprise/inject/Stereotype.html" rel="nofollow">Stereotype特性的Java官网原文</a>介绍，它是一个用来标记注解的注解（annotating\n    annotation）。一个注解如果被@Stereotype标记证明他提供Stereotype模式的功能，例如下面这样：</p>\n<pre><code class="java"><span class="code-meta">@Stereotype</span> \n<span class="code-meta">@Target</span>(TYPE) \n<span class="code-meta">@Retention</span>(RUNTIME) \n<span class="code-meta">@interface</span> controller {}\n\n<span class="code-meta">@Stereotype</span> \n<span class="code-meta">@Target</span>(TYPE) \n<span class="code-meta">@Retention</span>(RUNTIME) \n<span class="code-meta">@interface</span> service {}</code></pre>\n<p>然后我们在使用时可以为不同层的类打上这些标记，表示他们属于不同的分层：</p>\n<pre><code class="java"><span class="hljs-class"><span class="code-keyword">interface</span> <span class="code-title">UserService</span></span>{}\n\n<span class="code-meta">@Service</span>\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">UserServiceImpl</span> <span\n        class="code-keyword">implements</span> <span class="code-title">UserService</span></span>{\n\t\n}\n\n<span class="code-meta">@Controller</span>\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">UseController</span></span>{\n\t<span class="code-meta">@Autowired</span>\n\tUserService userService;\n\t\n}</code></pre>\n<p>\n    一个类的实例可能会被用于0到多个分层中（比如Spring的一个Bean既可以是Controller也可以是Service，只要标记对应的注解即可），但是通常情况下一个类最多只会用在一个分层中使用。简单的说Stereotype特性就是用注解来告诉框架某个类是属于系统功能中的哪一层。</p>\n<p>\n    Java的文档上要求提供Stereotype特性的注解需要用@Stereotype来标记。但是Spring的开发大神并没有理会这个事，@Component并没有使用@Stereotype来标记，但是他确实提供了Stereotype的模式。</p>\n<p>\n    在Stereotype模式下，Spring核心工程为Controller-Service-Dao的分层模型分别提供了@Controller、@Service、@Repository注解。我们按照Stereotype的模式为对应的类标记3个注解，然后在引入MVC、ORM、JPA相关的框架之后这些注解会告诉框架对应的类扮演着什么样的功能角色，框架就能很清晰的根据注解提供相关的功能服务。</p>\n<p>\n    例如引入Spring-webmvc之后，一个类如果用@Controller注解标记了之后框架就知道他们都是处理前端请求的，MVC框架就会为他提供RequestMapping之类的功能。随后我们需要将框架调整为WebFlux，基本上直接更换依赖的Jar包就可以了，因为大家都是按照一个模式来开发的。</p>\n<p><span style="color:#e74c3c">所以，如果我们的某个类是用于指定的分层功能，那么最好使用<em>org.springframework.stereotype</em>包中的注解来标记他所属的分层。如果类没有明确的功能（例如用于存储配置数据的类，或者Helper类），使用@Bean等其他方式添加到容器中更合适（@Bean会在后续的文章中介绍）。</span>\n</p>\n<p>使用Stereotype特性来标记分层，还有一个好处是即使工程的结构再复杂多样，都可以很轻松的使用注解（Annotation）来实现拦截器或者AOP功能。因为我们能够很清晰的知道每个分层的作用，开发AOP的功能就非常便利。</p>\n\n<h2 id="h2-3">扫描配置</h2>\n<p>本文开篇使用了一个简单的例子说明使用&lt;context:component-scan&gt;扫描功能来自动添加被注解标记的Bean。除了使用base-package属性还有其他的标签来控制扫描的路径。</p>\n<p>&lt;context:include-filter&gt;和&lt;context:exclude-filter&gt;标签用来指定包含和排除的过滤规则。他们提供2个参数——type和expression，用来指定过滤类型和过滤参数，例如:</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span\n            class="code-string">"org.example"</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">context:include-filter</span> <span\n                class="hljs-attr">type</span>=<span class="code-string">"regex"</span>\n                <span class="hljs-attr">expression</span>=<span\n                    class="code-string">".*Stub.*Repository"</span>/&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">context:exclude-filter</span> <span\n                class="hljs-attr">type</span>=<span class="code-string">"annotation"</span>\n                <span class="hljs-attr">expression</span>=<span class="code-string">"org.springframework.stereotype.Repository"</span>/&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">context:component-scan</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>此外还可以使用use-default-filters属性来指定是否扫描默认注解（<code>@Component</code>、<code>@Repository</code>、<code>@Service</code>、<code>@Controller、</code><code>@Configuration</code>），默认值为ture。如果设定成false，需要我们在include-filter中增加对应的annotation。\n</p>\n<p>除了使用XML配置，还可以使用@ComponentScan注解来指定扫描的路径，他提供和XML配置一样的功能。在后续的文章会介绍纯Java配置的功能。</p>\n<p>关于扫描的详细说明见<a\n        href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-scanning-filters"\n        rel="nofollow">官网的过滤规则说明</a>。</p>\n\n<h2 id="h2-4">组件命名</h2>\n<p>和普通的Bean一样，我们也可以在@Component上添加注解来指定Bean在IoC容器的名称：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.component.bean;\n\n<span class="code-meta">@Service</span>(<span class="code-string">"implementNameService"</span>)\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">NameServiceImpl</span> <span class="code-keyword">implements</span> <span\n            class="code-title">NameService</span></span>{\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span\n            class="code-title">getName</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-string">"This is My Component"</span>;\n\t}\n}</code></pre>\n<p>这样在容器中这个Bean的名称被命名为"implementNameService"。除了直接在注解上添加内容，我们还可以实现&nbsp;BeanNameGenerator 接口来实现全局的命名方法。看下面这个例子。（源码请到<a\n        href="https://gitee.com/chkui-com/spring-core-sample" rel="nofollow">https://gitee.com/chkui-com/spring-core-sample</a>自行clone，例子在<em>chkui.springcore.example.hybrid.component</em>包中。）\n</p>\n<p>首先在XML中使用 "name-generator"&nbsp;指定名称的生成器：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span> <span\n        class="hljs-attr">xmlns</span>=<span class="code-string">"http://www.springframework.org/schema/beans"</span>\n\t<span class="hljs-attr">xmlns:xsi</span>=<span\n            class="code-string">"http://www.w3.org/2001/XMLSchema-instance"</span>\n\t<span class="hljs-attr">xmlns:context</span>=<span class="code-string">"http://www.springframework.org/schema/context"</span>\n\t<span class="hljs-attr">xsi:schemaLocation</span>=<span class="code-string">"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span>\n\n\t<span class="code-tag">&lt;<span class="code-name">context:component-scan</span>\n\t\t<span class="hljs-attr">base-package</span>=<span class="code-string">"chkui.springcore.example.hybrid.component.bean"</span>\n\t\t<span class="hljs-attr">name-generator</span>=<span class="code-string">"chkui.springcore.example.hybrid.component.bean.NameGenerator"</span> /&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>然后编写我们的命名生成规则：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.hybrid.component.bean;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">NameGenerator</span> <span class="code-keyword">implements</span> <span\n            class="code-title">BeanNameGenerator</span> </span>{\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">generateBeanName</span><span\n            class="hljs-params">(BeanDefinition definition, BeanDefinitionRegistry registry)</span> </span>{\n\t\tAnnotatedBeanDefinition annotdef = AnnotatedBeanDefinition.class.cast(definition);\n\t\tAnnotationMetadata meta = annotdef.getMetadata();\n\t\t<span class="code-comment">//生成规则:如果已经命名不做任何调整，如果未命名则在类名车后面增加”_NoDefinedName“字符串</span>\n\t\t<span class="code-keyword">return</span> Optional.of(meta).map(met -&gt; met.getAnnotationTypes()).map(set -&gt; set.toArray(<span\n            class="code-keyword">new</span> String[] {}))\n\t\t\t\t.map(array -&gt; array[<span class="hljs-number">0</span>]).map(name -&gt; meta.getAnnotationAttributes(name)).map(entry -&gt; entry.get(<span\n            class="code-string">"value"</span>))\n\t\t\t\t.map(obj -&gt; <span class="code-string">""</span>.equals(obj) ? <span class="code-keyword">null</span> : obj).orElse(definition.getBeanClassName() + <span\n            class="code-string">"_NoDefinedName"</span>)\n\t\t\t\t.toString();\n\t}\n}</code></pre>\n\n<h2 id="h2-5">使用索引提升启动速度</h2>\n<p>\n    通常情况下，即使是对整个classpath进行扫描并不会占用太多的时间，但是某些应用对启动时间有极高的要求，对此Spring提供了索引功能。索引功能并不复杂，就是第一次扫描之后生成一个静态文件记录所有的组件，然后下一次扫描就直接读取文件中的内容，而不去执行扫描过程。</p>\n<p>首先引入spring-context-indexer包：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">dependencies</span>&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">dependency</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">groupId</span>&gt;</span>org.springframework<span\n            class="code-tag">&lt;/<span class="code-name">groupId</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">artifactId</span>&gt;</span>spring-context-indexer<span\n            class="code-tag">&lt;/<span class="code-name">artifactId</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">version</span>&gt;</span>5.0.7.RELEASE<span class="code-tag">&lt;/<span\n            class="code-name">version</span>&gt;</span>\n        <span class="code-tag">&lt;<span class="code-name">optional</span>&gt;</span>true<span\n            class="code-tag">&lt;/<span class="code-name">optional</span>&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">dependency</span>&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">dependencies</span>&gt;</span></code></pre>\n<pre><code class="json">dependencies {\n    compileOnly(<span class="hljs-attr">"org.springframework:spring-context-indexer:5.0.7.RELEASE"</span>)\n}</code></pre>\n<p>然后在运行后会生成一个&nbsp;META-INF/spring.components\n    的文件，之后只要运行工程发现这个文件都会直接使用他。可以通过环境变量或工程根目录的spring.properties中设置spring.index.ignore=ture来禁用这个功能。</p>\n<p>这个功能如果没有什么明确的需求，慎重使用，会提高工程的管理成本。</p>'},394:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<p>Vert.x可以使用Zookeeper和Ignite等框架来创建集群，但是首选框架还是Hazelcast。此外，码友们也可以通过<em>ClusterManager</em>接口实现或引入需要的集群管理工具。本文将说明Vert.x是如何利用Hazelcast来创建和管理集群的，同时你也会了解到Vertx如何创建单机实例。</p>\n<h2 id="h2-1"><strong>集群创建</strong></h2>\n<p>在创建Vert.x集调用群时，调用方法和创建单机实例是有差异的。集群需要调<em>Vertx.clusteredVertx</em>异步方法创建。集群可以完全新建和引入已有的Hazelcast实例二种方式来创建。如下：</p>\n<p>1.新建实例</p>\n<blockquote>\n    <p>ClusterManager mgr = new HazelcastClusterManager();</p>\n</blockquote>\n<p>2.引入Hazelcast实例</p>\n<blockquote>\n    <p>ClusterManager mgr = new HazelcastClusterManager(hazelcastInstance);</p>\n</blockquote>\n<p>详情可以参考官方手册<a title="Hazelcast" href="http://vertx.io/docs/vertx-hazelcast/java/" rel="nofollow">http://vertx.io/docs/vertx-hazelcast/java/</a>。</p>\n\n<h2 id="h2-2">新建集群过程</h2>\n<p>调用<em>Vertx.clusteredVertx</em>静态方法后，Vert.x会利用Vertx工厂方法创建Vertx实例。如下</p>\n<p>其中简单直白的使用 <em>new&nbsp;VertxImpl();</em>来创建Vertx实例。</p>\n<pre class="gradle"><code class="gradle">VertxFactoryImpl.clusteredVertx(VertxOptions <span class="code-keyword"><span class="code-keyword">options</span></span>, <span class="code-keyword"><span class="code-keyword">final</span></span> Handler&lt;AsyncResult&lt;Vertx&gt;&gt; resultHandler) {\n    <span class="code-keyword"><span class="code-keyword">options</span></span>.setClustered(<span class="code-keyword"><span class="code-keyword">true</span></span>);<span class="code-comment"><span class="code-comment">//设置参数，启用集群</span></span>\n    <span class="code-keyword"><span class="code-keyword">new</span></span> VertxImpl(<span class="code-keyword"><span class="code-keyword">options</span></span>, resultHandler);<span class="code-comment"><span class="code-comment">//创建Vertx实例</span></span>\n}</code></pre>\n<p style="text-align:center">图1启动集群</p>\n<p>在<em>VertxImpl</em>的构造方法中，若需要创建集群，则执行：</p>\n<pre class="gradle"><code class="gradle">VertxImpl(VertxOptions <span class="code-keyword"><span class="code-keyword">options</span></span>, Handler&lt;AsyncResult&lt;Vertx&gt;&gt; resultHandler) {\n    <span class="code-comment"><span class="code-comment">// some code</span></span>\n    <span class="code-keyword"><span class="code-keyword">if</span></span> (<span class="code-keyword"><span class="code-keyword">options</span></span>.isClustered()) {\n      <span class="code-keyword"><span class="code-keyword">this</span></span>.clusterManager = getClusterManager(<span class="code-keyword"><span class="code-keyword">options</span></span>);<span class="code-comment"><span class="code-comment">//1.获取集群管理对象</span></span>\n      <span class="code-keyword"><span class="code-keyword">this</span></span>.clusterManager.setVertx(<span class="code-keyword"><span class="code-keyword">this</span></span>);<span class="code-comment"><span class="code-comment">//2. 设置实例</span></span>\n      <span class="code-keyword"><span class="code-keyword">this</span></span>.clusterManager.<span class="code-keyword"><span class="code-keyword">join</span></span>(ar -&gt; {<span class="code-comment"><span class="code-comment">//3. 加入集群</span></span>\n        <span class="code-keyword"><span class="code-keyword">if</span></span> (ar.failed()) {\n          log.error(<span class="code-string"><span class="code-string">"Failed to join cluster"</span></span>, ar.cause());\n        } <span class="code-keyword"><span class="code-keyword">else</span></span> {\n          <span class="code-comment"><span class="code-comment">// Provide a memory barrier as we are setting from a different thread</span></span>\n          <span class="code-keyword"><span class="code-keyword">synchronized</span></span> (VertxImpl.<span class="code-keyword"><span class="code-keyword">this</span></span>) {\n            haManager = <span class="code-keyword"><span class="code-keyword">new</span></span> HAManager(<span class="code-keyword"><span class="code-keyword">this</span></span>, deploymentManager, clusterManager, <span class="code-keyword"><span class="code-keyword">options</span></span>.getQuorumSize(),\n                                      <span class="code-keyword"><span class="code-keyword">options</span></span>.getHAGroup(), haEnabled);\n            createAndStartEventBus(<span class="code-keyword"><span class="code-keyword">options</span></span>, resultHandler);\n          }\n        }\n      });\n    } <span class="code-keyword"><span class="code-keyword">else</span></span> {\n      <span class="code-keyword"><span class="code-keyword">this</span></span>.clusterManager = <span class="code-keyword"><span class="code-keyword">null</span></span>;\n      createAndStartEventBus(<span class="code-keyword"><span class="code-keyword">options</span></span>, resultHandler);\n    }\n    <span class="code-comment"><span class="code-comment">// some code</span></span>\n  }</code></pre>\n<p style="text-align:center">图2</p>\n<p>这里会分3部来创建集群，首先调用<em>getClusterManager</em>来获取集群的配置管理实例。如下：</p>\n<pre class="gradle"><code class="language-java">getClusterManager(VertxOptions <span class="code-keyword">options</span>) {\n    <span class="code-keyword"><span class="code-keyword">if</span></span> (<span class="code-keyword">options</span>.isClustered()) {\n      <span class="code-keyword"><span class="code-keyword">if</span></span> (<span class="code-keyword">options</span>.getClusterManager() != <span class="code-keyword"><span class="code-keyword">null</span></span>) {<span class="code-comment"><span class="code-comment">//判断是否已经创建集群管理对方</span></span>\n        <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="code-keyword">options</span>.getClusterManager();<span class="code-comment"><span class="code-comment">//若已创建，直接使用这个对象。</span></span>\n      } <span class="code-keyword"><span class="code-keyword">else</span></span> {<span class="code-comment"><span class="code-comment">//若无创建，执行新建过程。</span></span>\n        ClusterManager mgr;\n        String clusterManagerClassName = System.getProperty(<span class="code-string"><span class="code-string">"vertx.cluster.managerClass"</span></span>);<span class="code-comment"><span class="code-comment">/*通过系统参数设置集群管理对象*/</span></span>\n        <span class="code-keyword"><span class="code-keyword">if</span></span> (clusterManagerClassName != <span class="code-keyword"><span class="code-keyword">null</span></span>) {<span class="code-comment"><span class="code-comment">//clusterManagerClassName变量指定的类名存在，开始加载</span></span>\n          <span class="code-comment"><span class="code-comment">// We allow specify a sys prop for the cluster manager factory which overrides ServiceLoader</span></span>\n          <span class="code-keyword"><span class="code-keyword">try</span></span> {\n            <span class="code-keyword">Class</span>&lt;?&gt; clazz = <span class="code-keyword">Class</span>.forName(clusterManagerClassName);\n            mgr = (ClusterManager)clazz.newInstance();\n          } <span class="code-keyword"><span class="code-keyword">catch</span></span> (Exception e) {\n            <span class="code-keyword"><span class="code-keyword">throw</span></span> <span class="code-keyword"><span class="code-keyword">new</span></span> IllegalStateException(<span class="code-string"><span class="code-string">"Failed to instantiate "</span></span> + clusterManagerClassName, e);\n          }\n        } <span class="code-keyword"><span class="code-keyword">else</span></span> {<span class="code-comment"><span class="code-comment">//clusterManagerClassName指定的变量null,使用默认加载器。</span></span>\n          ServiceLoader&lt;ClusterManager&gt; mgrs = ServiceLoader.load(ClusterManager.<span class="code-keyword">class</span>);\n          <span class="code-keyword"><span class="code-keyword">if</span></span> (!mgrs.iterator().hasNext()) {\n            <span class="code-keyword"><span class="code-keyword">throw</span></span> <span class="code-keyword"><span class="code-keyword">new</span></span> IllegalStateException(<span class="code-string"><span class="code-string">"No ClusterManagerFactory instances found on classpath"</span></span>);\n          }\n          mgr = mgrs.iterator().<span class="code-keyword">next</span>();\n        }\n        <span class="code-keyword"><span class="code-keyword">return</span></span> mgr;\n      }\n    } <span class="code-keyword"><span class="code-keyword">else</span></span> {\n      <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="code-keyword"><span class="code-keyword">null</span></span>;\n    }\n  }</code></pre>\n<p style="text-align:center">图3，获取集群管理类<br> 从源码看，<em><code>getClusterManager</code></em>并没有什么特殊的地方。首先检查用户在创建Vertx实例之前，是否创建了集群的管理对象<code><em>ClusterManager</em>。创建了，则使用这个管理对象，没有创建则自行新建一个。</code></p>\n<p>注意</p>\n<blockquote>\n    <p>String clusterManagerClassName = System.getProperty("vertx.cluster.managerClass");</p>\n</blockquote>\n<p>这行代码 ，这说明可以通过JVM环境参数（<em>-Dvertx.cluster.managerClass=[className]</em>）来指定Vertx加载集群管理对象类。这在官方手册中并没有任何一个地方说明。</p>\n<p>如果指定了managerClass，则会使用默认加载方式加载指定的类，并转换成<em>ClusterManager</em>接口。</p>\n<p>如果没有指定managerClass，则使用默认集群加载类启动集群。</p>\n<blockquote>\n    <p>ServiceLoader&lt;ClusterManager&gt; mgrs = ServiceLoader.load(ClusterManager.class);&nbsp;</p>\n</blockquote>\n<p>ServiceLoader是Java在1.6定义的聚群接口类，有点类似于spring的Ioc容器。其过程也是加载类。详细说明请查阅&nbsp;<a href="http://my.oschina.net/hanzhankang/blog/109794" rel="nofollow">通过ServiceLoader实现链式处理</a>&nbsp;一文，解释得很清楚。</p>\n<p>可以看到在<em>vertx-hazelcast-[vertsion].jar</em>包中，<em>META-INF/services/io.vertx.core.spi.cluster.ClusterManager</em>指定了<em>ClusterManager</em>要<em>ServiceLoader</em>加载<em>HazelcastClusterManager。</em></p>\n<blockquote>\n    <p>io.vertx.spi.cluster.hazelcast.HazelcastClusterManager</p>\n</blockquote>\n<p>回到图2，Vert.x接下来使用</p>\n<blockquote>\n    <p>clusterManager.setVertx(this)</p>\n</blockquote>\n<p>将vertx实例设置到集群管理类中。 随后调用</p>\n<blockquote>\n    <p>clusterManager.join</p>\n</blockquote>\n<p>来加入集群。 下面是<em>clusterManager.join</em>的源码</p>\n<pre class="less"><code class="less"><span class="code-selector-tag"><span class="code-selector-tag">synchronized</span></span> <span class="code-selector-tag"><span class="code-selector-tag">void</span></span> <span class="code-selector-tag"><span class="code-selector-tag">join</span></span>(Handler&lt;AsyncResult&lt;Void&gt;&gt; resultHandler) {\n    <span class="code-selector-tag"><span class="code-selector-tag">vertx</span></span><span class="code-selector-class"><span class="code-selector-class">.executeBlocking</span></span>(fut -&gt; {\n      <span class="code-selector-tag"><span class="code-selector-tag">if</span></span> (!active) {<span class="code-comment"><span class="code-comment">//确保只初始化一次</span></span>\n        active = true;\n        <span class="code-selector-tag"><span class="code-selector-tag">if</span></span> (customHazelcastCluster) {<span class="code-comment"><span class="code-comment">//当使用的是用户自己创建的Hazelcast实例时</span></span>\n          nodeID = hazelcast<span class="code-selector-class"><span class="code-selector-class">.getLocalEndpoint</span></span>()<span class="code-selector-class"><span class="code-selector-class">.getUuid</span></span>();<span class="code-comment"><span class="code-comment">//获取节点编号</span></span>\n          membershipListenerId = hazelcast<span class="code-selector-class"><span class="code-selector-class">.getCluster</span></span>()<span class="code-selector-class"><span class="code-selector-class">.addMembershipListener</span></span>(this);<span class="code-comment"><span class="code-comment">//获取当前节点监听成员变换的事件的ID</span></span>\n          fut<span class="code-selector-class"><span class="code-selector-class">.complete</span></span>();\n          return;\n        }\n        if (conf == null) {<span class="code-comment"><span class="code-comment">//获取Hazelcast的Config</span></span>\n          conf = loadConfigFromClasspath();\n          <span class="code-selector-tag"><span class="code-selector-tag">if</span></span> (conf == null) {\n            log<span class="code-selector-class"><span class="code-selector-class">.warn</span></span>(<span class="code-string"><span class="code-string">"Cannot find cluster configuration on classpath and none specified programmatically. Using default hazelcast configuration"</span></span>);\n          }\n        }\n        <span class="code-comment"><span class="code-comment">//新建hazelcast实例</span></span>\n        hazelcast = Hazelcast.newHazelcastInstance(conf);\n        nodeID = hazelcast.getLocalEndpoint().getUuid();\n        membershipListenerId = hazelcast.getCluster().addMembershipListener(this);\n        fut.complete();\n      }\n    }, resultHandler);\n  }</code></pre>\n<p style="text-align:center">图4，新建hazelcast实例</p>\n<p>如果用户自己创建并传入Hazelcast实例，<em>ClusterManager</em>只是简单的从中获取需要的参数。如果未创建实例，则<em>ClusterManager</em>会自行创建。</p>\n<p>首先，loadConfigFromClasspath会用来加载本地的配置文件。</p>\n<pre class="cs"><code class="language-java"><span class="hljs-function"><span class="hljs-function">Config </span><span class="code-title"><span class="hljs-function"><span class="code-title">loadConfigFromClasspath</span></span></span><span class="hljs-params"><span class="hljs-function">(<span class="hljs-params"></span>)</span></span><span class="hljs-function"> </span></span>{\n    Config cfg = <span class="code-keyword"><span class="hljs-literal">null</span></span>;\n    <span class="code-keyword"><span class="code-keyword">try</span></span> (InputStream <span class="code-keyword">is</span> = getConfigStream();\n         InputStream bis = <span class="code-keyword"><span class="code-keyword">new</span></span> BufferedInputStream(<span class="code-keyword">is</span>)) {\n      <span class="code-keyword"><span class="code-keyword">if</span></span> (<span class="code-keyword">is</span> != <span class="code-keyword"><span class="hljs-literal">null</span></span>) {\n        cfg = <span class="code-keyword"><span class="code-keyword">new</span></span> XmlConfigBuilder(bis).build();<span class="code-comment"><span class="code-comment">//创建HazelcastConfig</span></span>\n      }\n    } <span class="code-keyword"><span class="code-keyword">catch</span></span> (IOException ex) {\n      log.error(<span class="code-string"><span class="code-string">"Failed to read config"</span></span>, ex);\n    }\n    <span class="code-keyword"><span class="code-keyword">return</span></span> cfg;\n  }</code></pre>\n<p style="text-align:center">图5，加载HazelcastConfig</p>\n<p>getConfigStream用来读取配置文件。</p>\n<pre class="kotlin"><code class="language-java"><span class="hljs-function">InputStream <span class="code-title">getConfigStream</span><span class="hljs-params">()</span> </span>{\n    ClassLoader ctxClsLoader = Thread.currentThread().getContextClassLoader();\n    InputStream <span class="code-keyword">is</span> = <span class="code-keyword"><span class="hljs-literal">null</span></span>;\n    <span class="code-keyword"><span class="code-keyword">if</span></span> (ctxClsLoader != <span class="code-keyword"><span class="hljs-literal">null</span></span>) {\n      <span class="code-keyword">is</span> = ctxClsLoader.getResourceAsStream(CONFIG_FILE);\n    }\n    <span class="code-keyword"><span class="code-keyword">if</span></span> (<span class="code-keyword">is</span> == <span class="code-keyword"><span class="hljs-literal">null</span></span>) {\n      <span class="code-keyword">is</span> = getClass().getClassLoader().getResourceAsStream(CONFIG_FILE);\n      <span class="code-keyword"><span class="code-keyword">if</span></span> (<span class="code-keyword">is</span> == <span class="code-keyword"><span class="hljs-literal">null</span></span>) {\n        <span class="code-keyword">is</span> = getClass().getClassLoader().getResourceAsStream(DEFAULT_CONFIG_FILE);\n      }\n    }\n    <span class="code-keyword"><span class="code-keyword">return</span></span> <span class="code-keyword">is</span>;\n  }</code></pre>\n<p style="text-align:center">图6，读取配置文件</p>\n<p>如图5、图6的源码。<em>getConfigStream</em>会先加载classpath下的<em>cluster.xml（CONFIG_FILE）</em>文件。如果不存在，则加载jar包内的<em>default-cluster.xml（DEFAULT_CONFIG_FILE）</em>文件。读取完毕后，<em>loadConfigFromClasspath</em>使用Hazelcast的<em>XmlConfigBuilder</em>来构建<em>HazelcastConfig</em>。而后会用这个Config初始化Hazelcast。</p>\n<p>集群创建成功后， 会初始化一个<em>HAManager</em>实例，用于做verticle迁移。后面在详细说明HA模式。</p>\n<p>最后，在VertxImpl中，会调用<em>createAndStartEventBus</em>方法在集群环境运行的EventBus。</p>'}});