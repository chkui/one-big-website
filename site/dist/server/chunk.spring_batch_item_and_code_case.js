exports.ids=[27],exports.modules={370:function(s,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<p>在 <a href="https://www.chkui.com/article/spring/spring_batch_introduction" title="批处理概念">批处理概念</a> 中介绍一个标准的批处理分为 <a\n        href="https://www.chkui.com/article/spring/spring_batch_job" title="Job">Job</a> 和 <a\n        href="https://www.chkui.com/article/spring/spring_batch_step">Step</a>。本文将结合代码介绍在<code>Step</code>中<code>Reader</code>、<code>Processor</code>、<code>Writer</code>的实际使用。\n</p>\n<h2 id="h2-1">Reader</h2>\n<p><code>Reader</code>是指从各种各样的外部输入中获取数据，框架为获取各种类型的文件已经预定义了常规的<code>Reader</code>实现类。<code>Reader</code>通过<code>ItemReader</code>接口实现：\n</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">ItemReader</span>&lt;<span class="code-title">T</span>&gt; </span>{\n    <span class="hljs-function">T <span class="code-title">read</span><span class="hljs-params">()</span> <span\n            class="code-keyword">throws</span> Exception, UnexpectedInputException, ParseException, NonTransientResourceException</span>;\n}\n</code></pre>\n<p><code>read</code>方法的作用就是读取一条数据，数据以泛型T的实体结构返回，<strong>当read返回null时表示所有数据读取完毕</strong>。返回的数据可以是任何结构，比如文件中的一行字符串，数据库的一行数据，或者xml文件中的一系列元素，只要是一个Java对象即可。\n</p>\n<h2 id="h2-2">Writer</h2>\n<p><code>Writer</code>通过<code>ItemWriter</code>接口实现：</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">ItemWriter</span>&lt;<span class="code-title">T</span>&gt; </span>{\n    <span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">write</span><span\n            class="hljs-params">(List&lt;? extends T&gt; items)</span> <span class="code-keyword">throws</span> Exception</span>;\n}\n</code></pre>\n<p><code>Writer</code>是<code>Reader</code>的反向操作，是将数据写入到特定的数据源中。在<a\n        href="https://www.chkui.com/article/spring/spring_batch_step" title="Step控制">Step控制</a>一文已经介绍<code>Writer</code>是根据<code>chunk</code>属性设定的值按列表进行操作的，所以传入的是一个<code>List</code>结构。<code>chunk</code>用于表示批处理的事物分片，因此需要注意的是，在<code>writer</code>方法中进行完整数据写入事物操作。例如向数据库写入<code>List</code>中的数据，在写入完成之后再提交事物。\n</p>\n<h2 id="h2-3">读写的组合模式</h2>\n<p>无论是读还是写，有时会需要从多个不同的来源获取文件，或者写入到不同的数据源，或者是需要在读和写之间处理一些业务。可以使用组合模式来实现这个目的：</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">CompositeItemWriter</span>&lt;<span class="code-title">T</span>&gt; <span\n        class="code-keyword">implements</span> <span class="code-title">ItemWriter</span>&lt;<span\n        class="code-title">T</span>&gt; </span>{\n    ItemWriter&lt;T&gt; itemWriter;\n    <span class="hljs-function"><span class="code-keyword">public</span> <span\n            class="code-title">CompositeItemWriter</span><span\n            class="hljs-params">(ItemWriter&lt;T&gt; itemWriter)</span> </span>{\n        <span class="code-keyword">this</span>.itemWriter = itemWriter;\n    }\n\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">write</span><span class="hljs-params">(List&lt;? extends T&gt; items)</span> <span\n            class="code-keyword">throws</span> Exception </span>{\n        <span class="code-comment">//Add business logic here</span>\n       itemWriter.write(items);\n    }\n\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setDelegate</span><span\n            class="hljs-params">(ItemWriter&lt;T&gt; itemWriter)</span></span>{\n        <span class="code-keyword">this</span>.itemWriter = itemWriter;\n    }\n}\n</code></pre>\n<h2 id="h2-4">Processor</h2>\n<p>除了使用组合模式，直接使用<code>Processor</code>是一种更优雅的方法。<code>Processor</code>是<code>Step</code>中的可选项，但是批处理大部分时候都需要对数据进行处理，因此框架提供了<code>ItemProcessor</code>接口来满足<code>Processor</code>过程：\n</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">ItemProcessor</span>&lt;<span class="code-title">I</span>, <span class="code-title">O</span>&gt; </span>{\n    <span class="hljs-function">O <span class="code-title">process</span><span class="hljs-params">(I item)</span> <span\n            class="code-keyword">throws</span> Exception</span>;\n}\n</code></pre>\n<p><code>Processor</code>的结构非常简单也是否易于理解。传入一个类型I，然后由<code>Processor</code>处理成为O。</p>\n<h3 id="h3-1">Processor链</h3>\n<p>在一个<a href="https://www.chkui.com/article/spring/spring_batch_step">Step</a>中可以使用多个<code>Processor</code>来按照顺序处理业务，此时同样可以使用<code>CompositeItem</code>模式来实现：\n</p>\n<pre><code class="Java">\n<span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> CompositeItemProcessor <span class="code-title">compositeProcessor</span><span\n        class="hljs-params">()</span> </span>{\n    <span class="code-comment">//创建 CompositeItemProcessor</span>\n    CompositeItemProcessor&lt;Foo,Foobar&gt; compositeProcessor = <span class="code-keyword">new</span> CompositeItemProcessor&lt;Foo,Foobar&gt;();\n    List itemProcessors = <span class="code-keyword">new</span> ArrayList();\n    <span class="code-comment">//添加第一个 Processor</span>\n    itemProcessors.add(<span class="code-keyword">new</span> FooTransformer());\n    <span class="code-comment">//添加第二个 Processor</span>\n    itemProcessors.add(<span class="code-keyword">new</span> BarTransformer());\n    <span class="code-comment">//添加链表</span>\n    compositeProcessor.setDelegates(itemProcessors);\n    <span class="code-keyword">return</span> processor;\n}\n</code></pre>\n<h3 id="h3-2">过滤记录</h3>\n<p>\n    在<code>Reader</code>读取数据的过程中，并不是所有的数据都可以使用，此时<code>Processor</code>还可以用于过滤非必要的数据，同时不会影响<code>Step</code>的处理过程。只要<code>ItemProcesspr</code>的实现类在<code>procss</code>方法中返回<code>null</code>即表示改行数据被过滤掉了。\n</p>\n<h2 id="h2-5">ItemStream</h2>\n<p>在<a href="https://www.chkui.com/article/spring/spring_batch_step">Step控制</a>一文中已经提到了<code>ItemStream</code>。在<a\n        href="https://www.chkui.com/article/spring/spring_batch_introduction">数据批处理概念</a>中提到过，Spring\n    Batch的每一步都是无状态的，进而<code>Reader</code>和<code>Writer</code>也是无状态的，这种方式能够很好的隔离每行数据的处理，也能将容错的范围收窄到可以空子的范围。但是这并不意味着整个批处理的过程中并不需要控制状态。例如从数据库持续读入或写入数据，每次<code>Reader</code>和<code>Writer</code>都单独去申请数据源的链接、维护数据源的状态（打开、关闭等）。因此框架提供了<code>ItemStream</code>接口来完善这些操作：\n</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">ItemStream</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">open</span><span\n            class="hljs-params">(ExecutionContext executionContext)</span> <span class="code-keyword">throws</span> ItemStreamException</span>;\n    <span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">update</span><span\n            class="hljs-params">(ExecutionContext executionContext)</span> <span class="code-keyword">throws</span> ItemStreamException</span>;\n    <span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">close</span><span\n            class="hljs-params">()</span> <span class="code-keyword">throws</span> ItemStreamException</span>;\n}\n</code></pre>\n<h2 id="h2-6">持久化数据</h2>\n<p>在使用Spring Batch之前需要初始化他的元数据存储（Meta-Data Schema）,也就是要将需要用到的表导入到对应的数据库中。当然，Spring\n    Batch支持不使用任何持久化数据库，仅仅将数据放到内存中，不设置<code>DataSource</code>即可。</p>\n<h3 id="h3-3">初始化序列</h3>\n<p>Spring Batch相关的工作需要使用序列<code>SEQUENCE</code>：</p>\n<pre><code class="SQL"><span class="code-keyword">CREATE</span> <span class="code-keyword">SEQUENCE</span> BATCH_STEP_EXECUTION_SEQ;\n<span class="code-keyword">CREATE</span> <span class="code-keyword">SEQUENCE</span> BATCH_JOB_EXECUTION_SEQ;\n<span class="code-keyword">CREATE</span> <span class="code-keyword">SEQUENCE</span> BATCH_JOB_SEQ;\n</code></pre>\n<p>有些数据库不支持<code>SEQUENCE</code>，可以通过表代理，比如在MySql（InnoDB数据库）中：</p>\n<pre><code class="SQL"><span class="code-keyword">CREATE</span> <span class="code-keyword">TABLE</span> BATCH_STEP_EXECUTION_SEQ (<span\n        class="code-keyword">ID</span> <span class="code-built_in">BIGINT</span> <span\n        class="code-keyword">NOT</span> <span class="hljs-literal">NULL</span>);\n<span class="code-keyword">INSERT</span> <span class="code-keyword">INTO</span> BATCH_STEP_EXECUTION_SEQ <span\n            class="code-keyword">values</span>(<span class="hljs-number">0</span>);\n<span class="code-keyword">CREATE</span> <span class="code-keyword">TABLE</span> BATCH_JOB_EXECUTION_SEQ (<span\n            class="code-keyword">ID</span> <span class="code-built_in">BIGINT</span> <span\n            class="code-keyword">NOT</span> <span class="hljs-literal">NULL</span>);\n<span class="code-keyword">INSERT</span> <span class="code-keyword">INTO</span> BATCH_JOB_EXECUTION_SEQ <span\n            class="code-keyword">values</span>(<span class="hljs-number">0</span>);\n<span class="code-keyword">CREATE</span> <span class="code-keyword">TABLE</span> BATCH_JOB_SEQ (<span\n            class="code-keyword">ID</span> <span class="code-built_in">BIGINT</span> <span\n            class="code-keyword">NOT</span> <span class="hljs-literal">NULL</span>);\n<span class="code-keyword">INSERT</span> <span class="code-keyword">INTO</span> BATCH_JOB_SEQ <span\n            class="code-keyword">values</span>(<span class="hljs-number">0</span>);\n</code></pre>\n<h3 id="h3-4">关于Version字段</h3>\n<p>某些表中都有<code>Version</code>字段。因为Spring的更新策略是乐观锁，因此在进行数据更新之后都会对表的<code>Version</code>字段进行+1处理。在内存与数据库交互的过程中，会使用采用<em>getVersion</em>、<em>increaseVersion（+1）</em>、<em>updateDataAndVersion</em>的过程，如果在<code>update</code>的时候发现Version不是预计的数值（+1），则会抛出<code>OptimisticLockingFailureException</code>的异常。当同一个<code>Job</code>在进群中不同服务上执行时，需要注意这个问题。\n</p>\n<h3 id="h3-5">BATCH_JOB_INSTANCE</h3>\n<p><code>BATCH_JOB_INSTANCE</code>用于记录JobInstance，在<a\n        href="https://www.chkui.com/article/spring/spring_batch_introduction">数据批处理概念</a>中介绍了他的工作方式，其结构为：</p>\n<pre><code class="SQL"><span class="code-keyword">CREATE</span> <span class="code-keyword">TABLE</span> BATCH_JOB_INSTANCE  (\n  JOB_INSTANCE_ID <span class="code-built_in">BIGINT</span>  PRIMARY <span class="code-keyword">KEY</span> ,\n  <span class="code-keyword">VERSION</span> <span class="code-built_in">BIGINT</span>,\n  JOB_NAME <span class="code-built_in">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="code-keyword">NOT</span> <span\n            class="hljs-literal">NULL</span> ,\n  JOB_KEY <span class="code-built_in">VARCHAR</span>(<span class="hljs-number">2500</span>)\n);\n</code></pre>\n<table>\n    <thead>\n    <tr>\n        <th>字段</th>\n        <th>说明</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n        <td>JOB_INSTANCE_ID</td>\n        <td>主键，主键与单个<code>JobInstance</code>相关。当获取到某个<code>JobInstance</code>实例后，通过<code>getId</code>方法可以获取到此数据</td>\n    </tr>\n    <tr>\n        <td>VERSION</td>\n        <td></td>\n    </tr>\n    <tr>\n        <td>JOB_NAME</td>\n        <td>Job的名称，用于标记运行的Job，在创建Job时候指定</td>\n    </tr>\n    <tr>\n        <td>JOB_KEY</td>\n        <td><em>JobParameters</em>的序列化数值。在<a href="https://www.chkui.com/article/spring/spring_batch_introduction">数据批处理概念</a>中介绍了一个<code>JobInstance</code>相当于<em>Job</em>+<em>JobParameters</em>。他用于标记同一个<code>Job</code>不同的实例\n        </td>\n    </tr>\n    </tbody>\n</table>\n<h3 id="h3-6">BATCH_JOB_EXECUTION_PARAMS</h3>\n<p><code>BATCH_JOB_EXECUTION_PARAMS</code>对应的是<code>JobParameters</code>对象。其核心功能是存储<em>Key-Value</em>结构的各种状态数值。字段中<code>IDENTIFYING=true</code>用于标记那些运行过程中必须的数据（可以理解是框架需要用到的数据），为了存储<em>key-value</em>结构该表一个列数据格式：\n</p>\n<pre><code class="SQL"><span class="code-keyword">CREATE</span> <span class="code-keyword">TABLE</span> BATCH_JOB_EXECUTION_PARAMS  (\n\tJOB_EXECUTION_ID <span class="code-built_in">BIGINT</span> <span class="code-keyword">NOT</span> <span\n            class="hljs-literal">NULL</span> ,\n\tTYPE_CD <span class="code-built_in">VARCHAR</span>(<span class="hljs-number">6</span>) <span class="code-keyword">NOT</span> <span\n            class="hljs-literal">NULL</span> ,\n\tKEY_NAME <span class="code-built_in">VARCHAR</span>(<span class="hljs-number">100</span>) <span\n            class="code-keyword">NOT</span> <span class="hljs-literal">NULL</span> ,\n\tSTRING_VAL <span class="code-built_in">VARCHAR</span>(<span class="hljs-number">250</span>) ,\n\tDATE_VAL DATETIME <span class="code-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> ,\n\tLONG_VAL <span class="code-built_in">BIGINT</span> ,\n\tDOUBLE_VAL <span class="code-keyword">DOUBLE</span> <span class="code-keyword">PRECISION</span> ,\n\tIDENTIFYING <span class="code-built_in">CHAR</span>(<span class="hljs-number">1</span>) <span class="code-keyword">NOT</span> <span\n            class="hljs-literal">NULL</span> ,\n\t<span class="code-keyword">constraint</span> JOB_EXEC_PARAMS_FK foreign <span class="code-keyword">key</span> (JOB_EXECUTION_ID)\n\t<span class="code-keyword">references</span> BATCH_JOB_EXECUTION(JOB_EXECUTION_ID)\n);\n</code></pre>\n<table>\n    <thead>\n    <tr>\n        <th>字段</th>\n        <th>说明</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n        <td>JOB_EXECUTION_ID</td>\n        <td>与<em>BATCH_JOB_EXECUTION</em>表关联的外键，详见<a\n                href="https://www.chkui.com/article/spring/spring_batch_introduction">数据批处理概念</a>中<em>Job</em>、<em>JobInstance</em>、<em>JobExecute</em>的关系\n        </td>\n    </tr>\n    <tr>\n        <td>TYPE_CD</td>\n        <td>用于标记数据的对象类型，例如 <em>string</em>、<em>date</em>、<em>long</em>、<em>double</em>，非空</td>\n    </tr>\n    <tr>\n        <td>KEY_NAME</td>\n        <td>key的值</td>\n    </tr>\n    <tr>\n        <td>STRING_VAL</td>\n        <td><em>string</em>类型的数值</td>\n    </tr>\n    <tr>\n        <td>DATE_VAL</td>\n        <td><em>date</em>类型的数值</td>\n    </tr>\n    <tr>\n        <td>LONG_VAL</td>\n        <td><em>long</em>类型的数值</td>\n    </tr>\n    <tr>\n        <td>DOUBLE_VAL</td>\n        <td><em>double</em>类型的数值</td>\n    </tr>\n    <tr>\n        <td>IDENTIFYING</td>\n        <td>标记这对<em>key-valuse</em>是否来自于<em>JobInstace</em>自身</td>\n    </tr>\n    </tbody>\n</table>\n<h3 id="h3-7">BATCH_JOB_EXECUTION</h3>\n<p>关联<code>JobExecution</code>，每当运行一个<code>Job</code>都会产生一个新的<code>JobExecution</code>，对应的在表中都会新增一行数据。</p>\n<pre><code class="SQL"><span class="code-keyword">CREATE</span> <span class="code-keyword">TABLE</span> BATCH_JOB_EXECUTION  (\n  JOB_EXECUTION_ID <span class="code-built_in">BIGINT</span>  PRIMARY <span class="code-keyword">KEY</span> ,\n  <span class="code-keyword">VERSION</span> <span class="code-built_in">BIGINT</span>,\n  JOB_INSTANCE_ID <span class="code-built_in">BIGINT</span> <span class="code-keyword">NOT</span> <span\n            class="hljs-literal">NULL</span>,\n  CREATE_TIME <span class="code-keyword">TIMESTAMP</span> <span class="code-keyword">NOT</span> <span\n            class="hljs-literal">NULL</span>,\n  START_TIME <span class="code-keyword">TIMESTAMP</span> <span class="code-keyword">DEFAULT</span> <span\n            class="hljs-literal">NULL</span>,\n  END_TIME <span class="code-keyword">TIMESTAMP</span> <span class="code-keyword">DEFAULT</span> <span\n            class="hljs-literal">NULL</span>,\n  <span class="code-keyword">STATUS</span> <span class="code-built_in">VARCHAR</span>(<span\n            class="hljs-number">10</span>),\n  EXIT_CODE <span class="code-built_in">VARCHAR</span>(<span class="hljs-number">20</span>),\n  EXIT_MESSAGE <span class="code-built_in">VARCHAR</span>(<span class="hljs-number">2500</span>),\n  LAST_UPDATED <span class="code-keyword">TIMESTAMP</span>,\n  JOB_CONFIGURATION_LOCATION <span class="code-built_in">VARCHAR</span>(<span class="hljs-number">2500</span>) <span\n            class="hljs-literal">NULL</span>,\n  <span class="code-keyword">constraint</span> JOB_INSTANCE_EXECUTION_FK foreign <span class="code-keyword">key</span> (JOB_INSTANCE_ID)\n  <span class="code-keyword">references</span> BATCH_JOB_INSTANCE(JOB_INSTANCE_ID)\n) ;\n</code></pre>\n<table>\n    <thead>\n    <tr>\n        <th>字段</th>\n        <th>说明</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n        <td>JOB_EXECUTION_ID</td>\n        <td><em>JobExecution</em>的主键，<em>JobExecution::getId</em>方法可以获取到该值</td>\n    </tr>\n    <tr>\n        <td>VERSION</td>\n        <td></td>\n    </tr>\n    <tr>\n        <td>JOB_INSTANCE_ID</td>\n        <td>关联到<em>JobInstace</em>的外键，详见<a\n                href="https://www.chkui.com/article/spring/spring_batch_introduction">数据批处理概念</a>中<em>Job</em>、<em>JobInstance</em>、<em>JobExecute</em>的关系\n        </td>\n    </tr>\n    <tr>\n        <td>CREATE_TIME</td>\n        <td>创建时间戳</td>\n    </tr>\n    <tr>\n        <td>START_TIME</td>\n        <td>开始时间戳</td>\n    </tr>\n    <tr>\n        <td>END_TIME</td>\n        <td>结束时间戳，无论成功或失败都会更新这一项数据。如果某行数据该值为空表示运行期间出现错误，并且框架无法更新该值</td>\n    </tr>\n    <tr>\n        <td>STATUS</td>\n        <td><em>JobExecute</em>的运行状态:<em>COMPLETED</em>、<em>STARTED</em>或者其他状态。此数值对应Java中<em>BatchStatus</em>枚举值</td>\n    </tr>\n    <tr>\n        <td>EXIT_CODE</td>\n        <td><em>JobExecute</em>执行完毕之后的退出返回值</td>\n    </tr>\n    <tr>\n        <td>EXIT_MESSAGE</td>\n        <td><em>JobExecute</em>退出的详细内容，如果是异常退出可能会包括异常堆栈的内容</td>\n    </tr>\n    <tr>\n        <td>LAST_UPDATED</td>\n        <td>最后一次更新的时间戳</td>\n    </tr>\n    </tbody>\n</table>\n<h3 id="h3-8">BATCH_STEP_EXECUTION</h3>\n<p>该表对应的是<code>StepExecution</code>，其结构和<code>BATCH_JOB_EXECUTION</code>基本相似，只是对应的对象是<code>Step</code>，增加了与之相对的一些字段数值：\n</p>\n<pre><code class="SQL"><span class="code-keyword">CREATE</span> <span class="code-keyword">TABLE</span> BATCH_STEP_EXECUTION  (\n  STEP_EXECUTION_ID <span class="code-built_in">BIGINT</span>  PRIMARY <span class="code-keyword">KEY</span> ,\n  <span class="code-keyword">VERSION</span> <span class="code-built_in">BIGINT</span> <span\n            class="code-keyword">NOT</span> <span class="hljs-literal">NULL</span>,\n  STEP_NAME <span class="code-built_in">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="code-keyword">NOT</span> <span\n            class="hljs-literal">NULL</span>,\n  JOB_EXECUTION_ID <span class="code-built_in">BIGINT</span> <span class="code-keyword">NOT</span> <span\n            class="hljs-literal">NULL</span>,\n  START_TIME <span class="code-keyword">TIMESTAMP</span> <span class="code-keyword">NOT</span> <span\n            class="hljs-literal">NULL</span> ,\n  END_TIME <span class="code-keyword">TIMESTAMP</span> <span class="code-keyword">DEFAULT</span> <span\n            class="hljs-literal">NULL</span>,\n  <span class="code-keyword">STATUS</span> <span class="code-built_in">VARCHAR</span>(<span\n            class="hljs-number">10</span>),\n  COMMIT_COUNT <span class="code-built_in">BIGINT</span> ,\n  READ_COUNT <span class="code-built_in">BIGINT</span> ,\n  FILTER_COUNT <span class="code-built_in">BIGINT</span> ,\n  WRITE_COUNT <span class="code-built_in">BIGINT</span> ,\n  READ_SKIP_COUNT <span class="code-built_in">BIGINT</span> ,\n  WRITE_SKIP_COUNT <span class="code-built_in">BIGINT</span> ,\n  PROCESS_SKIP_COUNT <span class="code-built_in">BIGINT</span> ,\n  ROLLBACK_COUNT <span class="code-built_in">BIGINT</span> ,\n  EXIT_CODE <span class="code-built_in">VARCHAR</span>(<span class="hljs-number">20</span>) ,\n  EXIT_MESSAGE <span class="code-built_in">VARCHAR</span>(<span class="hljs-number">2500</span>) ,\n  LAST_UPDATED <span class="code-keyword">TIMESTAMP</span>,\n  <span class="code-keyword">constraint</span> JOB_EXECUTION_STEP_FK foreign <span class="code-keyword">key</span> (JOB_EXECUTION_ID)\n  <span class="code-keyword">references</span> BATCH_JOB_EXECUTION(JOB_EXECUTION_ID)\n) ;\n</code></pre>\n<p>未填入内容部分见<code>BATCH_JOB_EXECUTION</code>说明。</p>\n<table>\n    <thead>\n    <tr>\n        <th>字段</th>\n        <th>说明</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n        <td>STEP_EXECUTION_ID</td>\n        <td><em>StepExecute</em>对应的主键</td>\n    </tr>\n    <tr>\n        <td>VERSION</td>\n        <td></td>\n    </tr>\n    <tr>\n        <td>STEP_NAME</td>\n        <td><em>Step</em>名称</td>\n    </tr>\n    <tr>\n        <td>JOB_EXECUTION_ID</td>\n        <td>关联到<em>BATCH_JOB_EXECUTION</em>表的外键，标记该<em>StepExecute</em>所属的<em>JobExecute</em></td>\n    </tr>\n    <tr>\n        <td>START_TIME</td>\n        <td></td>\n    </tr>\n    <tr>\n        <td>END_TIME</td>\n        <td></td>\n    </tr>\n    <tr>\n        <td>STATUS</td>\n        <td></td>\n    </tr>\n    <tr>\n        <td>COMMIT_COUNT</td>\n        <td>执行过程中，事物提交的次数，该值与数据的规模以及<em>chunk</em>的设置有关</td>\n    </tr>\n    <tr>\n        <td>READ_COUNT</td>\n        <td>读取数据的次数</td>\n    </tr>\n    <tr>\n        <td>FILTER_COUNT</td>\n        <td><em>Processor</em>中过滤记录的次数</td>\n    </tr>\n    <tr>\n        <td>WRITE_COUNT</td>\n        <td>吸入数据的次数</td>\n    </tr>\n    <tr>\n        <td>READ_SKIP_COUNT</td>\n        <td>读数据的跳过次数</td>\n    </tr>\n    <tr>\n        <td>WRITE_SKIP_COUNT</td>\n        <td>写数据的跳过次数</td>\n    </tr>\n    <tr>\n        <td>PROCESS_SKIP_COUNT</td>\n        <td><em>Processor</em>跳过的次数</td>\n    </tr>\n    <tr>\n        <td>ROLLBACK_COUNT</td>\n        <td>回滚的次数</td>\n    </tr>\n    <tr>\n        <td>EXIT_CODE</td>\n        <td></td>\n    </tr>\n    <tr>\n        <td>EXIT_MESSAGE</td>\n        <td></td>\n    </tr>\n    <tr>\n        <td>LAST_UPDATED</td>\n        <td></td>\n    </tr>\n    </tbody>\n</table>\n<h3 id="h3-9">BATCH_JOB_EXECUTION_CONTEXT</h3>\n<p>\n    该表会记录所有与<code>Job</code>相关的<code>ExecutionContext</code>信息。每个<code>ExecutionContext</code>都对应一个<code>JobExecution</code>，在运行的过程中它包含了所有<code>Job</code>范畴的状态数据，这些数据在执行失败后对于后续处理有中重大意义。\n</p>\n<pre><code class="SQL"><span class="code-keyword">CREATE</span> <span class="code-keyword">TABLE</span> BATCH_JOB_EXECUTION_CONTEXT  (\n  JOB_EXECUTION_ID <span class="code-built_in">BIGINT</span> PRIMARY <span class="code-keyword">KEY</span>,\n  SHORT_CONTEXT <span class="code-built_in">VARCHAR</span>(<span class="hljs-number">2500</span>) <span\n            class="code-keyword">NOT</span> <span class="hljs-literal">NULL</span>,\n  SERIALIZED_CONTEXT <span class="code-keyword">CLOB</span>,\n  <span class="code-keyword">constraint</span> JOB_EXEC_CTX_FK foreign <span class="code-keyword">key</span> (JOB_EXECUTION_ID)\n  <span class="code-keyword">references</span> BATCH_JOB_EXECUTION(JOB_EXECUTION_ID)\n) ;\n</code></pre>\n<table>\n    <thead>\n    <tr>\n        <th>字段</th>\n        <th>说明</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n        <td>JOB_EXECUTION_ID</td>\n        <td>关联到<em>JobExecution</em>的外键，建立<em>JobExecution</em>和<em>ExecutionContext</em>的关系。</td>\n    </tr>\n    <tr>\n        <td>SHORT_CONTEXT</td>\n        <td>标记<em>SERIALIZED_CONTEXT</em>的版本号</td>\n    </tr>\n    <tr>\n        <td>SERIALIZED_CONTEXT</td>\n        <td>序列化的<em>ExecutionContext</em></td>\n    </tr>\n    </tbody>\n</table>\n<h3 id="h3-10">BATCH_STEP_EXECUTION_CONTEXT</h3>\n<p><code>Step</code>中<code>ExecutionContext</code>相关的数据表，结构与<code>BATCH_JOB_EXECUTION_CONTEXT</code>完全一样。</p>\n<h3 id="h3-11">表索引建议</h3>\n<p>上面的所有建表语句都没有提供索引，但是并不代表索引没有价值。当感觉到SQL语句的执行有效率问题时候，可以增加索引。</p>\n<p>索引带来的价值取决于SQL查询的频率以及关联关系，下面是Spring Batch框架在运行过程中会用到的一些查询条件语句，用于参考优化索引：</p>\n<table>\n    <thead>\n    <tr>\n        <th>表</th>\n        <th>Where条件</th>\n        <th>执行频率</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n        <td>BATCH_JOB_INSTANCE</td>\n        <td>JOB_NAME = ? and JOB_KEY = ?</td>\n        <td>每次Job启动执时</td>\n    </tr>\n    <tr>\n        <td>BATCH_JOB_EXECUTION</td>\n        <td>JOB_INSTANCE_ID = ?</td>\n        <td>每次Job重启时</td>\n    </tr>\n    <tr>\n        <td>BATCH_EXECUTION_CONTEXT</td>\n        <td>EXECUTION_ID = ? and KEY_NAME = ?</td>\n        <td>视<em>chunk</em>的大小而定</td>\n    </tr>\n    <tr>\n        <td>BATCH_STEP_EXECUTION</td>\n        <td>VERSION = ?</td>\n        <td>视<em>chunk</em>的大小而定</td>\n    </tr>\n    <tr>\n        <td>BATCH_STEP_EXECUTION</td>\n        <td>STEP_NAME = ? and JOB_EXECUTION_ID = ?</td>\n        <td>每一个<em>Step</em>执行之前</td>\n    </tr>\n    </tbody>\n</table>\n<h2 id="h2-7">使用案例</h2>\n<p>下面是Spring Batch一些简单的应用，源码在下列地址的<em>simple</em>工程：</p>\n<ul>\n    <li>Gitee：<a\n            href="https://gitee.com/chkui-com/spring-batch-sample">https://gitee.com/chkui-com/spring-batch-sample</a>\n    </li>\n    <li>Github：<a href="https://github.com/chkui/spring-batch-sample">https://github.com/chkui/spring-batch-sample</a>\n    </li>\n</ul>\n<p>Spring Batch提供了2种执行方式：命令行方式或Java内嵌方式。命令行方式是直到需要执行批处理任务的时候才启动程序，内嵌方式是结合Web工程或其他外部化框架来使用。2者最大的差别就是是否直接向IoCs注入一个<code>Job</code>实例。\n</p>\n<h3 id="h3-12">通用基本配置</h3>\n<p>\n    两种方式的基本配置都是一样的，通过<code>Reader</code>、<code>Processor</code>、<code>Writer</code>来组装一个<code>Step</code>。代码中<code>Item</code>并不涉及文件或数据库的操作，只是简单的模拟数据读取、处理、写入的过程。实体<code>Record</code>和<code>Msg</code>用于模拟数据转换，基本配置如下：\n</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">BatchDefaultConfig</span> </span>{\n\t<span class="code-meta">@Bean</span>\n\t<span class="code-comment">//配置Step</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> Step <span class="code-title">simpleStep</span><span\n            class="hljs-params">(StepBuilderFactory builder, ItemReader&lt;Record&gt; reader, ItemProcessor&lt;Record, Msg&gt; processor,\n\t\t\tItemWriter&lt;Msg&gt; writer)</span> </span>{\n\t\t<span class="code-keyword">return</span> builder.get(<span class="code-string">"SimpleStep"</span>).&lt;Record, Msg&gt;chunk(<span\n            class="hljs-number">10</span>).reader(reader).processor(processor).writer(writer)\n\t\t\t\t.build();\n\t}\n\n\t<span class="code-meta">@Bean</span>\n\t<span class="code-comment">//配置 Reader</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> ItemReader&lt;Record&gt; <span\n            class="code-title">reader</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> ItemReader&lt;Record&gt;() {\n\t\t\t<span class="code-keyword">private</span> <span class="code-keyword">int</span> count = <span\n            class="hljs-number">0</span>;\n\t\t\t<span class="hljs-function"><span class="code-keyword">public</span> Record <span\n                    class="code-title">read</span><span class="hljs-params">()</span>\n\t\t\t\t\t<span class="code-keyword">throws</span> Exception, UnexpectedInputException, ParseException, NonTransientResourceException </span>{\n\t\t\t\t<span class="code-keyword">return</span> ++<span class="code-keyword">this</span>.count &lt; <span\n            class="hljs-number">100</span> ? <span class="code-keyword">new</span> Record().setId(<span\n            class="code-keyword">this</span>.count).setMsg(<span class="code-string">"Read Number:"</span> + <span\n            class="code-keyword">this</span>.count) : <span class="code-keyword">null</span>;\n\t\t\t}\n\t\t};\n\t}\n\n\t<span class="code-meta">@Bean</span>\n\t<span class="code-comment">//配置 Processor</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> ItemProcessor&lt;Record, Msg&gt; <span\n            class="code-title">processor</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> ItemProcessor&lt;Record, Msg&gt;() {\n\t\t\t<span class="hljs-function"><span class="code-keyword">public</span> Msg <span\n                    class="code-title">process</span><span class="hljs-params">(Record item)</span> <span\n                    class="code-keyword">throws</span> Exception </span>{\n\t\t\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> Msg(<span\n            class="code-string">"MSG GET INFO = "</span> + item.getMsg());\n\t\t\t}\n\t\t};\n\t}\n\n\t<span class="code-meta">@Bean</span>\n\t<span class="code-comment">//配置 Writer</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> ItemWriter&lt;Msg&gt; <span class="code-title">writer</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> ItemWriter&lt;Msg&gt;() {\n\t\t\t<span class="code-keyword">private</span> <span class="code-keyword">int</span> batchCount = <span\n            class="hljs-number">0</span>;\n\t\t\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n                    class="code-title">write</span><span\n                    class="hljs-params">(List&lt;? extends Msg&gt; items)</span> <span\n                    class="code-keyword">throws</span> Exception </span>{\n\t\t\t\tSystem.out.println(<span class="code-string">"Batch Count : "</span> + ++batchCount + <span\n            class="code-string">". Data:"</span>);\n\t\t\t\t<span class="code-keyword">for</span> (Msg msg : items) {\n\t\t\t\t\tSystem.out.println(msg.getInfo());\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n}\n</code></pre>\n<h3 id="h3-13">命令行方式运行</h3>\n<p>有了基本配置之后，命令行运行的方式仅仅是向容器添加一个<code>Job</code>：</p>\n<pre><code class="Java"><span class="code-meta">@Configuration</span>\n<span class="code-comment">//导入依赖配置</span>\n<span class="code-meta">@Import</span>({ BatchDefaultConfig.class })\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">BatchCommondConfig</span> </span>{\n\t<span class="code-meta">@Bean</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> Job <span\n            class="code-title">simpleJob</span><span class="hljs-params">(Step step, JobBuilderFactory builder)</span> </span>{\n\t\t<span class="code-keyword">return</span> builder.get(<span class="code-string">"SimpleJob"</span>).start(step).build(); <span\n            class="code-comment">//向容器返回一个Job的Bean</span>\n\t}\n}\n</code></pre>\n<p>然后启动Spring Framework则会自动启用Command Runner运行方式运行——先调用<code>SpringApplication::callRunner</code>方法，然后使用<code>JobLauncherCommandLineRunner::execute</code>运行：\n</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">CommondSample</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> <span\n            class="code-keyword">throws</span> DuplicateJobException </span>{\n\t\t<span class="code-comment">//模拟测试参数, 这些参数值在执行Java时从外部传入的，比如-Dkey=value</span>\n\t\tString[] argsExt = <span class="code-keyword">new</span> String[<span class="hljs-number">2</span>];\n\t\targsExt[<span class="hljs-number">0</span>] = <span class="code-string">"BuilderParam1=Value1"</span>;\n\t\targsExt[<span class="hljs-number">1</span>] = <span class="code-string">"BuilderParam2=Value2"</span>;\n\t\t<span class="code-comment">//运行Spring Framework</span>\n\t\tSpringApplication.run(CommondSample.class, argsExt);\n\t}\n}\n</code></pre>\n<p>启用之后观察数据库已经发生了变更。使用命令行需要通过 Java运行参数（-Dkey=value）传递<code>JobParameters</code>的数据，上面的代码模拟实现了相关的过程。</p>\n<h3 id="h3-14">Java内嵌运行</h3>\n<p>Java内嵌的方式主要是用于搭配外部工程化使用，比如使用Web框架或则统一调度平台管之类的结构化框架来统一管理批处理任务。与命令行执行最大的区别就是不向容器注入<code>Job</code>：</p>\n<pre><code class="Java"><span class="code-meta">@Configuration</span>\n<span class="code-comment">//导入进出配置 </span>\n<span class="code-meta">@Import</span>({BatchDefaultConfig.class})\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">BatchOperatoConfig</span> </span>{\n\t<span class="code-meta">@Bean</span>\n\t<span class="code-comment">//返回JobFactory</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> JobFactory <span\n            class="code-title">simpleJob</span><span class="hljs-params">(Step step, JobBuilderFactory builder)</span> </span>{\n\t\tSimpleJobFactory sampleJobFactory = <span class="code-keyword">new</span> SimpleJobFactory();\n\t\tsampleJobFactory.setJob(builder.get(<span class="code-string">"SimpleJob"</span>).start(step).build());\n\t\t<span class="code-keyword">return</span> sampleJobFactory;\n\t}\n}\n</code></pre>\n<p>\n    配置代码向容器添加了一个<code>JobFactory</code>的实现类，<code>JobFactory</code>的两个接口一个是获取<code>Job</code>一个是获取<code>Job</code>的名称，<code>SimpleJobFactory</code>实现了<code>JobFactory</code>：\n</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">SimpleJobFactory</span> <span class="code-keyword">implements</span> <span\n        class="code-title">JobFactory</span> </span>{\n\t<span class="code-keyword">private</span> Job job;\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setJob</span><span class="hljs-params">(Job job)</span> </span>{\n\t\t<span class="code-keyword">this</span>.job = job;\n\t}\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> Job <span\n            class="code-title">createJob</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> job;\n\t}\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span\n            class="code-title">getJobName</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> job.getName();\n\t}\n}\n</code></pre>\n<p>最后通过<code>SimpleJobFactory</code>来启动一个<code>Job</code>：</p>\n<pre><code class="Java"><span class="code-meta">@SpringBootApplication</span>\n<span class="code-meta">@EnableBatchProcessing</span>\n<span class="code-meta">@EnableScheduling</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">OperatorSample</span> </span>{\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> <span\n            class="code-keyword">throws</span> DuplicateJobException </span>{\n\t\t<span class="code-keyword">new</span> SuspendThread().run(); <span class="code-comment">//挂起系统一直运行</span>\n\t\tConfigurableApplicationContext ctx = SpringApplication.run(OperatorSample.class);\n\t\tCron cron = ctx.getBean(Cron.class);\n\t\tcron.register(); <span class="code-comment">//注册JobFactory</span>\n\t\tcron.runJobLaunch();\n\t}\n}\n\n<span class="code-meta">@Service</span>\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">Cron</span> </span>{\n\t<span class="code-meta">@Autowired</span>\n\tJobLauncher jobLauncher;\n\n\t<span class="code-meta">@Autowired</span>\n\t<span class="code-keyword">private</span> JobOperator jobOperator;\n\n\t<span class="code-meta">@Autowired</span>\n\t<span class="code-keyword">private</span> JobRegistry jobRegistry;\n\n\t<span class="code-meta">@Autowired</span>\n\t<span class="code-keyword">private</span> JobFactory jobFactory;\n\n\t<span class="code-comment">//注册JobFactory</span>\n\t<span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">register</span><span\n            class="hljs-params">()</span> <span class="code-keyword">throws</span> DuplicateJobException </span>{\n\t\tjobRegistry.register(jobFactory);\n\t}\n\n\t<span class="code-comment">//使用JobLaunch执行</span>\n\t<span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">runJobLaunch</span><span\n            class="hljs-params">()</span> </span>{\n\t\tMap&lt;String, JobParameter&gt; map = <span class="code-keyword">new</span> HashMap&lt;&gt;();\n\t\tmap.put(<span class="code-string">"Builder"</span>, <span class="code-keyword">new</span> JobParameter(<span\n            class="code-string">"1"</span>));\n\t\tmap.put(<span class="code-string">"Timer"</span>, <span class="code-keyword">new</span> JobParameter(<span\n            class="code-string">"2"</span>));\n\t\tjobLauncher.run(jobFactory.createJob(), <span class="code-keyword">new</span> JobParameters(map));\n\t}\n\n\t<span class="code-meta">@Scheduled</span>(cron = <span class="code-string">"30 * * * * ? "</span>)\n\t<span class="hljs-function"><span class="code-keyword">void</span> <span class="code-title">task1</span><span\n            class="hljs-params">()</span> </span>{\n\t\tSystem.out.println(<span class="code-string">"1"</span>);\n\t\trunOperator();\n\t}\n\n\t<span class="code-comment">//定时任务使用 JobOperator执行</span>\n\t<span class="hljs-function"><span class="code-keyword">private</span> <span class="code-keyword">void</span> <span\n            class="code-title">runOperator</span><span class="hljs-params">()</span> </span>{\n\t\tjobOperator.start(<span class="code-string">"SimpleJob"</span>, <span\n            class="code-string">"Builder=1,Timer=2"</span>);\n\t}\n}\n</code></pre>\n<p>这里使用了2种执行方式：<code>JobLauncher</code>和<code>JobOperator</code>。<code>JobLauncher</code>简单明了的启动一个批处理任务。而<code>JobOperator</code>扩展了一些用于<code>Job</code>管理的接口方法，观察<code>JobOperator</code>的源码可以发现它提供了获取<code>ExecuteContext</code>、检查<code>JobInstance</code>等功能，如果需要定制开发一个基于Web或者JMX管理批处理任务的系统，<code>JobOperator</code>更合适。<code>JobOperator</code>的第二个参数用于传递<code>JobParameters</code>，等号两端分别是<code>key</code>和<code>value</code>，逗号用于分割多行数据。\n</p>\n<p>在<a href="https://www.chkui.com/article/spring/spring_batch_job">Job配置与运行</a>提及过一个<code>JobInstance</code>相当于<code>Job</code>+<code>JobParameters</code>，因此虽然上面的代码使用了两种不同的运行方式，但是<code>Job</code>和<code>JobParameters</code>是一样的。在运行被定时任务包裹的<code>runOperator</code>方法时，会一直抛出<code>JobInstanceAlreadyExistsException</code>异常，因为同一个实例不能运行2次。如果运行失败可以使用对应的<code>restart</code>方法。\n</p>\n<p>后续会介绍各种<code>Reader</code>和<code>Writer</code>的使用。</p>'}};