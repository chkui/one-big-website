exports.ids=[26],exports.modules={371:function(e,n,s){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<p>在<a href="https://www.chkui.com/article/spring/spring_batch_introduction" title="Spring batch由上至下的结构">Spring\n    batch由上至下的结构</a>中<a href="https://www.chkui.com/article/spring/spring_batch_job">Job</a>、<a\n        href="https://www.chkui.com/article/spring/spring_batch_step">Step</a>都是属于框架级别的的功能，大部分时候都是提供一些配置选项给开发人员使用，而<a\n        href="https://www.chkui.com/article/spring/spring_batch_item_and_code_case"\n        title="Item">Item</a>中的<code>Reader</code>、<code>Processor</code>和<code>Writer</code>是属于业务级别的，它开放了一些业务切入的接口。\n    但是文件的读写过程中有很多通用一致的功能Spring Batch为这些相同的功能提供了一致性实现类。</p>\n<h2 id="h2-1">扁平结构文件</h2>\n<p><strong>扁平结构文件</strong>（也称为矩阵结构文件，后文简称为文件）是最常见的一种文件类型。他通常以一行表示一条记录，字段数据之间用某种方式分割。与标准的格式数据（xml、json等）主要差别在于他没有结构性描述方案（SXD、JSON-SCHEME），进而没有结构性分割规范。因此在读写此类文件之前需要先设定好字段的分割方法。\n</p>\n<p>文件的字段数据分割方式通常有两种：<strong>使用分隔符</strong>或<strong>固定字段长度</strong>。前者通常使用逗号（<code>，</code>）之类的符号对字段数据进行划分，后者的每一列字段数据长度是固定的。\n    框架为文件的读取提供了<code>FieldSet</code>用于将文件结构中的信息映射到一个对象。<code>FieldSet</code>的作用是将文件的数据与类的<code>field</code>进行绑定（field是Java中常见的概念，不清楚的可以了解Java反射）。\n</p>\n<h2 id="h2-2">数据读取</h2>\n<p>Spring Batch为文件读取提供了<code>FlatFileItemReader</code>类，它为文件中的数据的读取和转换提供了基本功能。在<code>FlatFileItemReader</code>中有2个主要的功能接口，一是<code>Resource</code>、二是<code>LineMapper</code>。\n    <code>Resource</code>用于外部文件获取，详情请查看<a href="https://www.chkui.com/article/spring/spring_core_resources_management"\n                                          title="Spring核心——资源管理">Spring核心——资源管理</a>部分的内容，下面是一个例子：</p>\n<pre><code class="Java">Resource resource = <span class="code-keyword">new</span> FileSystemResource(<span\n        class="code-string">"resources/trades.csv"</span>); \n</code></pre>\n<p>在复杂的生产环境中，文件通常由中心化、或者流程式的基础框架来管理（比如EAI）。因此文件往往需要使用FTP等方式从其他位置获取。如何迁移文件已经超出了Spring Batch框架的范围，在Spring的体系中可以参考<code>Spring\n    Integration</code>项目。</p>\n<p>下面是<code>FlatFileItemReader</code>的属性，每一个属性都提供了Setter方法。</p>\n<table>\n    <thead>\n    <tr>\n        <th>属性名</th>\n        <th>参数类型</th>\n        <th>说明</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n        <td>comments</td>\n        <td>String[]</td>\n        <td>指定文件中的注释前缀，用于过滤注释内容行</td>\n    </tr>\n    <tr>\n        <td>encoding</td>\n        <td>String</td>\n        <td>指定文件的编码方式，默认为<em>Charset.defaultCharset()</em></td>\n    </tr>\n    <tr>\n        <td>lineMapper</td>\n        <td>LineMapper</td>\n        <td>利用LineMapper接口将一行字符串转换为对象</td>\n    </tr>\n    <tr>\n        <td>linesToSkip</td>\n        <td>int</td>\n        <td>跳过文件开始位置的行数，用于跳过一些字段的描述行</td>\n    </tr>\n    <tr>\n        <td>recordSeparatorPolicy</td>\n        <td>RecordSeparatorPolicy</td>\n        <td>用于判断数据是否结束</td>\n    </tr>\n    <tr>\n        <td>resource</td>\n        <td>Resource</td>\n        <td>指定外部资源文件位置</td>\n    </tr>\n    <tr>\n        <td>skippedLinesCallback</td>\n        <td>LineCallbackHandler</td>\n        <td>当配置linesToSkip，每执行一次跳过都会被回调一次，会传入跳过的行数据内容</td>\n    </tr>\n    </tbody>\n</table>\n<p>每个属性都为文件的解析提供了某方面的功能，下面是结构的说明。</p>\n<h3 id="h3-1">LineMapper</h3>\n<p>这个接口的作用是将字符串转换为对象：</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">LineMapper</span> </span>{ <span class="hljs-function">T <span\n        class="code-title">mapLine</span><span class="hljs-params">(String line, <span class="code-keyword">int</span> lineNumber)</span> <span\n        class="code-keyword">throws</span> Exception</span>; }\n</code></pre>\n<p>接口的基本处理逻辑是聚合类（<code>FlatFileItemReader</code>）传递一行字符串以及行号给<code>LineMapper::mapLine</code>，方法处理后返回一个映射的对象。</p>\n<h3 id="h3-2">LineTokenizer</h3>\n<p>这个接口的作用是将一行数据转换为一个<code>FieldSet</code>结构。对于Spring Batch而言，扁平结构文件的到Java实体的映射都通过<code>FieldSet</code>来控制，因此读写文件的过程需要完成字符串到<code>FieldSet</code>的转换：\n</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">LineTokenizer</span> </span>{ <span class="hljs-function">FieldSet <span class="code-title">tokenize</span><span\n        class="hljs-params">(String line)</span></span>; }\n</code></pre>\n<p>这个接口的含义是：传递一行字符串数据，然后获取一个<code>FieldSet</code>。</p>\n<p>框架为<code>LineTokenizer</code>提供三个实现类：</p>\n<ul>\n    <li>\n        <p><code>DelimitedLineTokenizer</code>：利用分隔符将数据转换为<code>FieldSet</code>。最常见的分隔符是逗号<code>,</code>，类提供了分隔符的配置和解析方法。\n        </p>\n    </li>\n    <li>\n        <p><code>FixedLengthTokenizer</code>：根据字段的长度来解析出<code>FieldSet</code>结构。必须为记录定义字段宽度。</p>\n    </li>\n    <li>\n        <p><code>PatternMatchingCompositeLineTokenizer</code>：使用一个匹配机制来动态决定使用哪个<code>LineTokenizer</code>。</p>\n    </li>\n</ul>\n<h3 id="h3-3">FieldSetMapper</h3>\n<p>该接口是将<code>FieldSet</code>转换为对象：</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">FieldSetMapper</span> </span>{ <span class="hljs-function">T <span class="code-title">mapFieldSet</span><span\n        class="hljs-params">(FieldSet fieldSet)</span> <span class="code-keyword">throws</span> BindException</span>; }\n</code></pre>\n<p><code>FieldSetMapper</code>通常和<code>LineTokenizer</code>联合在一起使用：<em>String-&gt;FieldSet-&gt;Object</em>。</p>\n<h3 id="h3-4">DefaultLineMapper</h3>\n<p><code>DefaultLineMapper</code>是<code>LineMapper</code>的实现，他实现了从文件到Java实体的映射：</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">DefaultLineMapper</span> <span class="code-keyword">implements</span> <span\n        class="code-title">LineMapper</span>&lt;&gt;, <span class="code-title">InitializingBean</span> </span>{\n\t<span class="code-keyword">private</span> LineTokenizer tokenizer;\n\t<span class="code-keyword">private</span> FieldSetMapper fieldSetMapper;\n\t<span class="hljs-function"><span class="code-keyword">public</span> T <span class="code-title">mapLine</span><span\n            class="hljs-params">(String line, <span class="code-keyword">int</span> lineNumber)</span> <span\n            class="code-keyword">throws</span> Exception </span>{\n\t\t<span class="code-keyword">return</span> fieldSetMapper.mapFieldSet(tokenizer.tokenize(line));\n\t}\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setLineTokenizer</span><span class="hljs-params">(LineTokenizer tokenizer)</span> </span>{\n\t\t<span class="code-keyword">this</span>.tokenizer = tokenizer;\n\t}\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n            class="code-title">setFieldSetMapper</span><span class="hljs-params">(FieldSetMapper fieldSetMapper)</span> </span>{\n\t\t<span class="code-keyword">this</span>.fieldSetMapper = fieldSetMapper;\n\t}\n}\n</code></pre>\n<p>在解析文件时数据是按行解析的：</p>\n<ol>\n    <li>传入一行字符串。</li>\n    <li><code>LineTokenizer</code>将字符串解析为<code>FieldSet</code>结构。</li>\n    <li><code>FieldSetMapper</code>继续解析为一个Java实体对象返回给调用者。</li>\n</ol>\n<p><code>DefaultLineMapper</code>是框架提供的默认实现类，看似非常简单，但是利用组合模式可以扩展出很多功能。</p>\n<h3 id="h3-5">数据自动映射</h3>\n<p>在转换过程中如果将<code>FieldSet</code>的<code>names</code>属性与目标类的<code>field</code>绑定在一起，那么可以直接使用反射实现数据转换，为此框架提供了<code>BeanWrapperFieldSetMapper</code>来实现。\n</p>\n<pre><code class="Java">DefaultLineMapper&lt;WeatherEntity&gt; lineMapper = <span class="code-keyword">new</span> DefaultLineMapper&lt;&gt;(); <span\n        class="code-comment">//创建LineMapper</span>\n\nDelimitedLineTokenizer tokenizer = <span class="code-keyword">new</span> DelimitedLineTokenizer(); <span\n            class="code-comment">//创建LineTokenizer</span>\ntokenizer.setNames(<span class="code-keyword">new</span> String[] { <span class="code-string">"siteId"</span>, <span\n            class="code-string">"month"</span>, <span class="code-string">"type"</span>, <span class="code-string">"value"</span>, <span\n            class="code-string">"ext"</span> }); <span class="code-comment">//设置Field名称</span>\n\nBeanWrapperFieldSetMapper&lt;WeatherEntity&gt; wrapperMapper \n\t= <span class="code-keyword">new</span> BeanWrapperFieldSetMapper&lt;&gt;(); <span class="code-comment">//创建FieldSetMapper</span>\nwrapperMapper.setTargetType(WeatherEntity.class); <span\n            class="code-comment">//设置实体，实体的field名称必须和tokenizer.names一致。</span>\n\n<span class="code-comment">// 组合lineMapper</span>\nlineMapper.setLineTokenizer(tokenizer);\nlineMapper.setFieldSetMapper(wrapperMapper);\n</code></pre>\n<h3 id="h3-6">文件读取总结</h3>\n<p>上面提到了各种接口和实现，实际上都是围绕着<code>FlatFileItemReader</code>的属性在介绍，虽然内容很多但是实际上就以下几点：</p>\n<ul>\n    <li>\n        <p>首先要定位文件，Spring Batch提供了<code>Resource</code>相关的定位方法。</p>\n    </li>\n    <li>\n        <p>其次是将文件中的行字符串数据转换为对象，<code>LineMapper</code>的功能就是完成这个功能。</p>\n    </li>\n    <li>\n        <p>\n            框架为<code>LineMapper</code>提供了<code>DefaultLineMapper</code>作为默认实现方法，在<code>DefaultLineMapper</code>中需要组合使用<code>LineTokenizer</code>和<code>FieldSetMapper</code>。前者将字符串转为为一个<code>Field</code>，后者将<code>Field</code>转换为目标对象。\n        </p>\n    </li>\n    <li>\n        <p>\n            <code>LineTokenizer</code>有3个实现类可供使用、<code>FieldSetMapper</code>有一个默认实现类<code>BeanWrapperFieldSetMapper</code>。\n        </p>\n    </li>\n</ul>\n<h3 id="h3-7">文件读取可执行源码</h3>\n<p>可执行的源码在下列地址的<em>items</em>子工程中：</p>\n<ul>\n    <li>Gitee：<a\n            href="https://gitee.com/chkui-com/spring-batch-sample">https://gitee.com/chkui-com/spring-batch-sample</a>\n    </li>\n    <li>Github：<a href="https://github.com/chkui/spring-batch-sample">https://github.com/chkui/spring-batch-sample</a>\n    </li>\n</ul>\n<p>运行之前需要配置数据库链接，参看源码库中的README.md。</p>\n<p>文件读取的主要逻辑在<code>org.chenkui.spring.batch.sample.items.FlatFileReader</code>类：</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">FlatFileReader</span> </span>{\n    <span class="code-comment">// FeildSet的字段名，设置字段名之后可以直接使用名字作为索引获取数据。也可以使用索引位置来获取数据</span>\n    <span class="code-keyword">public</span> <span class="code-keyword">final</span> <span\n            class="code-keyword">static</span> String[] Tokenizer = <span\n            class="code-keyword">new</span> String[] { <span class="code-string">"siteId"</span>, <span\n            class="code-string">"month"</span>, <span class="code-string">"type"</span>, <span class="code-string">"value"</span>, <span\n            class="code-string">"ext"</span> };\n    <span class="code-keyword">private</span> <span class="code-keyword">boolean</span> userWrapper = <span\n            class="code-keyword">false</span>;\n\n    <span class="code-meta">@Bean</span>\n    <span class="code-comment">//定义FieldSetMapper用于FieldSet-&gt;WeatherEntity</span>\n    <span class="hljs-function"><span class="code-keyword">public</span> FieldSetMapper&lt;WeatherEntity&gt; <span\n            class="code-title">fieldSetMapper</span><span class="hljs-params">()</span> </span>{\n        <span class="code-keyword">return</span> <span class="code-keyword">new</span> FieldSetMapper&lt;WeatherEntity&gt;() {\n            <span class="code-meta">@Override</span>\n            <span class="hljs-function"><span class="code-keyword">public</span> WeatherEntity <span class="code-title">mapFieldSet</span><span\n                    class="hljs-params">(FieldSet fieldSet)</span> <span class="code-keyword">throws</span> BindException </span>{\n                <span class="code-keyword">if</span> (<span class="code-keyword">null</span> == fieldSet) {\n                    <span class="code-keyword">return</span> <span class="code-keyword">null</span>; <span\n            class="code-comment">// fieldSet不存在则跳过该行处理</span>\n                } <span class="code-keyword">else</span> {\n                    WeatherEntity observe = <span class="code-keyword">new</span> WeatherEntity();\n                    observe.setSiteId(fieldSet.readRawString(<span class="code-string">"siteId"</span>));\n                    <span class="code-comment">//Setter</span>\n                    <span class="code-keyword">return</span> observe;\n                }\n            }\n        };\n    }\n\n    <span class="code-meta">@Bean</span>\n    <span class="code-comment">// 配置 Reader</span>\n    <span class="hljs-function"><span class="code-keyword">public</span> ItemReader&lt;WeatherEntity&gt; <span\n            class="code-title">flatFileReader</span><span class="hljs-params">(\n                           @Qualifier(<span class="code-string">"fieldSetMapper"</span>)</span> FieldSetMapper&lt;WeatherEntity&gt; fieldSetMapper) </span>{\n        FlatFileItemReader&lt;WeatherEntity&gt; reader = <span class="code-keyword">new</span> FlatFileItemReader&lt;&gt;();\n        reader.setResource(<span class="code-keyword">new</span> FileSystemResource(<span class="code-string">"src/main/resources/data.csv"</span>)); <span\n            class="code-comment">// 读取资源文件</span>\n        DefaultLineMapper&lt;WeatherEntity&gt; lineMapper = <span class="code-keyword">new</span> DefaultLineMapper&lt;&gt;(); <span\n            class="code-comment">// 初始化 LineMapper实现类</span>\n        DelimitedLineTokenizer tokenizer = <span class="code-keyword">new</span> DelimitedLineTokenizer(); <span\n            class="code-comment">// 创建LineTokenizer接口实现</span>\n\n        tokenizer.setNames(Tokenizer); <span class="code-comment">// 设定每个字段的名称，如果不设置需要使用索引获取值</span>\n        lineMapper.setLineTokenizer(tokenizer); <span class="code-comment">// 设置tokenizer工具</span>\n\n        <span class="code-keyword">if</span> (userWrapper) { <span class="code-comment">//使用 BeanWrapperFieldSetMapper 使用反射直接转换</span>\n            BeanWrapperFieldSetMapper&lt;WeatherEntity&gt; wrapperMapper = <span class="code-keyword">new</span> BeanWrapperFieldSetMapper&lt;&gt;();\n            wrapperMapper.setTargetType(WeatherEntity.class);\n            fieldSetMapper = wrapperMapper;\n        }\n\n        lineMapper.setFieldSetMapper(fieldSetMapper);\n        reader.setLineMapper(lineMapper);\n        reader.setLinesToSkip(<span class="hljs-number">1</span>); <span class="code-comment">// 跳过的初始行，用于过滤字段行</span>\n        reader.open(<span class="code-keyword">new</span> ExecutionContext());\n        <span class="code-keyword">return</span> reader;\n    }\n}\n</code></pre>\n<h3 id="h3-8">按字段长度格读取文件</h3>\n<p>除了按照分隔符，有些文件可以字段数据的占位长度来提取数据。按照前面介绍的过程，实际上只要修改LineTokenizer接口即可，框架提供了<code>FixedLengthTokenizer</code>类：</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> FixedLengthTokenizer <span class="code-title">fixedLengthTokenizer</span><span\n        class="hljs-params">()</span> </span>{\n    FixedLengthTokenizer tokenizer = <span class="code-keyword">new</span> FixedLengthTokenizer();\n\n    tokenizer.setNames(<span class="code-string">"ISIN"</span>, <span class="code-string">"Quantity"</span>, <span\n            class="code-string">"Price"</span>, <span class="code-string">"Customer"</span>);\n    <span class="code-comment">//Range用于设定数据的长度。</span>\n    tokenizer.setColumns(<span class="code-keyword">new</span> Range(<span class="hljs-number">1</span>-<span\n            class="hljs-number">12</span>),\n                        <span class="code-keyword">new</span> Range(<span class="hljs-number">13</span>-<span\n            class="hljs-number">15</span>),\n                        <span class="code-keyword">new</span> Range(<span class="hljs-number">16</span>-<span\n            class="hljs-number">20</span>),\n                        <span class="code-keyword">new</span> Range(<span class="hljs-number">21</span>-<span\n            class="hljs-number">29</span>));\n\t<span class="code-keyword">return</span> tokenizer;\n}\n</code></pre>\n<h2 id="h2-3">写入扁平结构文件</h2>\n<p>将数据写入到文件与读取的过程正好相反：将对象转换为字符串。</p>\n<h3 id="h3-9">LineAggregator</h3>\n<p>与<code>LineMapper</code>相对应的是<code>LineAggregator</code>，他的功能是将实体转换为字符串：</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">LineAggregator</span>&lt;<span class="code-title">T</span>&gt; </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> String <span\n            class="code-title">aggregate</span><span class="hljs-params">(T item)</span></span>;\n}\n</code></pre>\n<h3 id="h3-10">PassThroughLineAggregator</h3>\n<p>\n    框架为<code>LineAggregator</code>接口提供了一个非常简单的实现类——<code>PassThroughLineAggregator</code>，其唯一实现就是使用对象的<code>toString</code>方法：\n</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">PassThroughLineAggregator</span>&lt;<span class="code-title">T</span>&gt; <span\n        class="code-keyword">implements</span> <span class="code-title">LineAggregator</span>&lt;<span\n        class="code-title">T</span>&gt; </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> String <span\n            class="code-title">aggregate</span><span class="hljs-params">(T item)</span> </span>{\n        <span class="code-keyword">return</span> item.toString();\n    }\n}\n</code></pre>\n<h3 id="h3-11">DelimitedLineAggregator</h3>\n<p><code>LineAggregator</code>的另外一个实现类是<code>DelimitedLineAggregator</code>。与<code>PassThroughLineAggregator</code>简单直接使用<code>toString</code>方法不同的是，<code>DelimitedLineAggregator</code>需要一个转换接口<code>FieldExtractor</code>：\n</p>\n<pre><code class="Java">DelimitedLineAggregator&lt;CustomerCredit&gt; lineAggregator = <span\n        class="code-keyword">new</span> DelimitedLineAggregator&lt;&gt;();\nlineAggregator.setDelimiter(<span class="code-string">","</span>);\nlineAggregator.setFieldExtractor(fieldExtractor);\n</code></pre>\n<h3 id="h3-12">FieldExtractor</h3>\n<p><code>FieldExtractor</code>用于实体类到<code>collection</code>结构的转换。它可以和<code>LineTokenizer</code>进行类比，前者是将实体类转换为扁平结构的数据，后者是将<code>String</code>转换为一个<code>FieldSet</code>结构。\n</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">FieldExtractor</span>&lt;<span class="code-title">T</span>&gt; </span>{\n    Object[] extract(T item);\n}\n</code></pre>\n<p>框架为<code>FieldExtractor</code>接口提供了一个基于反射的实现类<code>BeanWrapperFieldExtractor</code>，其过程就是将实体对象转换为列表：</p>\n<pre><code class="Java">BeanWrapperFieldExtractor&lt;CustomerCredit&gt; fieldExtractor = <span\n        class="code-keyword">new</span> BeanWrapperFieldExtractor&lt;&gt;();\nfieldExtractor.setNames(<span class="code-keyword">new</span> String[] {<span class="code-string">"field1"</span>, <span\n            class="code-string">"field2"</span>});\n</code></pre>\n<p><code>setName</code>方法用于指定要转换的<code>field</code>列表。</p>\n<h3 id="h3-13">输出文件处理</h3>\n<p>文件读取的逻辑非常简单：文件存在打开文件并写入数据，当文件不存在抛出异常。但是写入文件明显不能这么简单粗暴。新建一个<code>JobInstance</code>时最直观的操作是：存在同名文件就抛出异常，不存在则创建文件并写入数据。但是这样做显然有很大的问题，当批处理过程中出现问题需要<code>restart</code>，此时并不会从头开始处理所有的数据，而是要求文件存在并接着继续写入。为了确保这个过程<code>FlatFileItemWriter</code>默认会在新<code>JobInstance</code>运行时删除已有文件，而运行重启时继续在文件末尾写入。<code>FlatFileItemWriter</code>可以使用<code>shouldDeleteIfExists</code>、<code>appendAllowed</code>、<code>shouldDeleteIfEmpty</code>来有针对性的控制文件。\n</p>\n<h3 id="h3-14">文件写入可执源码</h3>\n<p>文件写入主要代码在<code>org.chenkui.spring.batch.sample.items.FlatFileWriter</code>：</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">FlatFileWriter</span> </span>{\n\n    <span class="code-keyword">private</span> <span class="code-keyword">boolean</span> useBuilder = <span\n            class="code-keyword">true</span>;\n\n    <span class="code-meta">@Bean</span>\n    <span class="hljs-function"><span class="code-keyword">public</span> ItemWriter&lt;MaxTemperatureEntiry&gt; <span\n            class="code-title">flatFileWriter</span><span class="hljs-params">()</span> </span>{\n        BeanWrapperFieldExtractor&lt;MaxTemperatureEntiry&gt; fieldExtractor = <span class="code-keyword">new</span> BeanWrapperFieldExtractor&lt;&gt;();\n        fieldExtractor.setNames(<span class="code-keyword">new</span> String[] { <span\n            class="code-string">"siteId"</span>, <span class="code-string">"date"</span>, <span class="code-string">"temperature"</span> }); <span\n            class="code-comment">//设置映射field</span>\n        fieldExtractor.afterPropertiesSet(); <span class="code-comment">//参数检查</span>\n\n        DelimitedLineAggregator&lt;MaxTemperatureEntiry&gt; lineAggregator = <span class="code-keyword">new</span> DelimitedLineAggregator&lt;&gt;();\n        lineAggregator.setDelimiter(<span class="code-string">","</span>); <span class="code-comment">//设置输出分隔符</span>\n        lineAggregator.setFieldExtractor(fieldExtractor); <span class="code-comment">//设置FieldExtractor处理器</span>\n\n        FlatFileItemWriter&lt;MaxTemperatureEntiry&gt; fileWriter = <span class="code-keyword">new</span> FlatFileItemWriter&lt;&gt;();\n        fileWriter.setLineAggregator(lineAggregator);\n        fileWriter.setResource(<span class="code-keyword">new</span> FileSystemResource(<span class="code-string">"src/main/resources/out-data.csv"</span>)); <span\n            class="code-comment">//设置输出文件位置</span>\n        fileWriter.setName(<span class="code-string">"outpufData"</span>);\n\n        <span class="code-keyword">if</span> (useBuilder) {<span class="code-comment">//使用builder方式创建</span>\n            fileWriter = <span class="code-keyword">new</span> FlatFileItemWriterBuilder&lt;MaxTemperatureEntiry&gt;().name(<span\n            class="code-string">"outpufData"</span>)\n                .resource(<span class="code-keyword">new</span> FileSystemResource(<span class="code-string">"src/main/resources/out-data.csv"</span>)).lineAggregator(lineAggregator)\n                .build();\n        }\n        <span class="code-keyword">return</span> fileWriter;\n    }\n}\n</code></pre>\n<p>文件的写入过程与读取过程完全对称相反：先用<code>FieldExtractor</code>将对象转换为一个<code>collection</code>结构（列表），然后用<code>lineAggregator</code>将<code>collection</code>转化为带分隔符的字符串。\n</p>\n<h2 id="h2-4">代码说明</h2>\n<ul>\n    <li>\n        <p>代码中的测试数据来自数据分析交流项目<a href="https://github.com/chkui/bi-process-example">bi-process-example</a>，是NOAA的2015年全球天气监控数据。为了便于源码存储进行了大量的删减，原始数据有百万条，如有需要使用下列方式下载：\n        </p>\n        <pre><code class="ruby">\tcurl -O <span class="hljs-symbol">ftp:</span>/<span class="hljs-regexp">/ftp.ncdc.noaa.gov/pub</span><span\n                class="hljs-regexp">/data/ghcn</span><span class="hljs-regexp">/daily/by</span>_year/<span\n                class="hljs-number">2015</span>.csv.gz <span class="code-comment">#数据文件</span>\n\tcurl -O <span class="hljs-symbol">ftp:</span>/<span class="hljs-regexp">/ftp.ncdc.noaa.gov/pub</span><span\n                    class="hljs-regexp">/data/ghcn</span><span\n                    class="hljs-regexp">/daily/ghcnd</span>-stations.txt <span class="code-comment"># 文件结构及类型说明</span>\n</code></pre>\n    </li>\n    <li>\n        <p>代码实现了读取文件、处理文件、写入文件的整个过程。处理文件的过程是只获取监控的最高温度信息（<code>Type=TMAX</code>），其他都过滤。</p>\n    </li>\n    <li>\n        <p>本案例的代码使用<code>org.chenkui.spring.batch.sample.flatfile.FlatFileItemApplication::main</code>方法运行，使用的是Command\n            Runner的方式执行（运行方式的说明见<a href="https://www.chkui.com/article/spring/spring_batch_item_and_code_case">Item概念及使用代码</a>的<em>命令行方式运行</em>、<em>Java内嵌运行</em>）。\n        </p>\n    </li>\n</ul>'}};