exports.ids=[49],exports.modules={348:function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});a.content='<p>本文继续之前的2篇文章（<a href="https://www.chkui.com/article/spring/spring_core_bean_post_processors" rel="nofollow">BeanPostProcessor</a>和<a\n        href="https://www.chkui.com/article/spring/spring_core_ioc_extension_points" rel="nofollow">BeanFactoryPostProcessor</a>）介绍Ioc容器的功能扩展。\n</p>\n<p>FactoryBean是用来构造Bean的接口。常规情况下向容器添加一个Bean只需要像下面这样通过XML的配置或注解直接引入这个类即可：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n        class="code-string">"a"</span> <span class="hljs-attr">class</span>=<span class="code-string">"x.y.z.A"</span>&gt;</span>\n     <span class="code-tag">&lt;<span class="code-name">property</span> <span class="hljs-attr">name</span>=<span\n             class="code-string">"setter"</span> <span class="hljs-attr">value</span>=<span\n             class="code-string">"1"</span> /&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span></code></pre>\n<pre><code class="java"><span class="code-meta">@Component</span>\n<span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">A</span></span>{}</code></pre>\n<p>但是某些情况下我们需要动态的装载一个复的Bean，此时可以使用FactoryBean来动态装载一个Bean。FactoryBean字面上看就知道它是一个Bean，但是有Factory的功能（工厂模式）。</p>\n<p>FactoryBean的使用和之前介绍的Processor 一样，实现一个接口，然后设置为一个Spring的Bean即可：</p>\n<pre><code class="java"><span class="hljs-class"><span class="code-keyword">class</span> <span class="code-title">MyFactory</span> <span\n        class="code-keyword">implements</span> <span class="code-title">FactoryBean</span></span>{\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> Object <span\n            class="code-title">getObject</span><span class="hljs-params">()</span> <span\n            class="code-keyword">throws</span> Exception </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">null</span>;\n\t}\n\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> Class <span\n            class="code-title">getObjectType</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">null</span>;\n\t}\n}</code></pre>\n<p>下面通过一个适配器的例子来说明FactoryBean的使用，文中的代码仅用于示例，可执行源码请移步&nbsp;https://gitee.com/chkui-com/spring-core-sample 中的&nbsp;chkui.springcore.example.xml.factorybean包。</p>\n<p>例子是使用适配器模式对对应的资源进行解码，执行一下3步：</p>\n<ol>\n    <li>&nbsp;容器启动之后会加载一个密文资源类，可能是Base64的编码，也可能是UrlBase64的编码，根据配置来确定。</li>\n    <li>&nbsp;FactoryBean会根据资源类型向容器添加一个解码的适配器。</li>\n    <li>&nbsp;最后用适配器解码输出。</li>\n</ol>\n<p>例子的代码结构如下：</p>\n<pre><code class="bash">factorybean\n--BeanFactoryApp.java main方法\n--AdapterFactory.java 一个FactoryBean，用于生成适配器Bean\n--entity\n----Text.java 编码资源类的接口\n----Base64Entity.java Base64编码\n----UrlBase64Entity.java urlBase64编码\n--adapter\n----DecodeAdapter.java 解码适配器接口\n----Base64Adapter.java Base64的解码适配器 \n----UrlBase64Adapter.java UrlBase64的解码适配器 \n</code></pre>\n<p>另外配置文件在 resources/xml/factorybean/config.xml：</p>\n<pre><code class="xml"><span class="code-tag">&lt;<span class="code-name">beans</span>&gt;</span>\n    <span class="code-comment">&lt;!-- Base64编码 --&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">class</span>=<span\n            class="code-string">"chkui.springcore.example.xml.factorybean.entity.Base64Entity"</span>&gt;</span>\n     \t<span class="code-tag">&lt;<span class="code-name">constructor-arg</span> <span\n                class="hljs-attr">value</span>=<span class="code-string">"一串加密的文字。URLBase64和Base64的区别是调整了可以用于URL的符号，例如+替换为-。"</span>/&gt;</span>\n    <span class="code-tag">&lt;/<span class="code-name">bean</span>&gt;</span>\n    <span class="code-comment">&lt;!-- UrlBase64编码 --&gt;</span>\n    <span class="code-comment">&lt;!-- &lt;bean class="chkui.springcore.example.xml.factorybean.entity.UrlBase64Entity"&gt;\n     \t&lt;constructor-arg value="一串加密的文字。URLBase64和Base64的区别是调整了可以用于URL的符号，例如+替换为-。"/&gt;\n    &lt;/bean&gt; --&gt;</span>\n    <span class="code-tag">&lt;<span class="code-name">bean</span> <span class="hljs-attr">id</span>=<span\n            class="code-string">"adapter"</span> <span class="hljs-attr">class</span>=<span class="code-string">"chkui.springcore.example.xml.factorybean.AdapterFactory"</span> /&gt;</span>\n<span class="code-tag">&lt;/<span class="code-name">beans</span>&gt;</span></code></pre>\n<p>Base64Entity和UrlBase64Entity是2个资源类，分别用Base64和UrlBase64对字符串进行编码，通过配置来管理。下面是Text和Base64Entity的代码：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.xml.factorybean.entity;\n\n<span class="code-comment">//文本资源接口</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n            class="code-title">Text</span> </span>{\n\t<span class="code-comment">//定义资源类型，目前支持Base64和UrlBase642种加密编码文件</span>\n\t<span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">enum</span> Type{\n\t\tBase64,\n\t\tUrlBase64\n\t}\n\t<span class="code-comment">//获取资源编码类型</span>\n\t<span class="hljs-function">Type <span class="code-title">getType</span><span class="hljs-params">()</span></span>;\n\t<span class="code-comment">//获取编码的密文</span>\n\t<span class="hljs-function">String <span class="code-title">getCipher</span><span\n            class="hljs-params">()</span></span>;\n}</code></pre>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.xml.factorybean.entity;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Base64Entity</span> <span class="code-keyword">implements</span> <span\n            class="code-title">Text</span> </span>{\n\t<span class="code-keyword">private</span> String cipher;\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span\n            class="code-title">Base64Entity</span><span class="hljs-params">(String text)</span> </span>{\n\t\t<span class="code-keyword">this</span>.cipher = Base64.getEncoder().encodeToString(text.getBytes());\n\t}\n\t\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> Type <span\n            class="code-title">getType</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> Text.Type.Base64;\n\t}\n\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span\n            class="code-title">getCipher</span><span class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> cipher;\n\t}\n}</code></pre>\n<p>然后我们根据不同的资源定义了不同的适配器来解码，下面是适配器接口和一个实现类——DecodeAdapter、Base64Adapter：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.xml.factorybean.adapter;\n\n<span class="code-comment">//加密编码文件解码适配器</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n            class="code-title">DecodeAdapter</span> </span>{\n\t<span class="code-comment">//获取解码之后的明文</span>\n\t<span class="hljs-function">String <span class="code-title">getPlain</span><span\n            class="hljs-params">()</span></span>;\n}</code></pre>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.xml.factorybean.adapter;\n\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">Base64Adapter</span> <span class="code-keyword">implements</span> <span\n            class="code-title">DecodeAdapter</span> </span>{\n\t<span class="code-keyword">private</span> String cipher;\n\n\t<span class="hljs-function"><span class="code-keyword">public</span> <span\n            class="code-title">Base64Adapter</span><span class="hljs-params">(String cipher)</span></span>{\n\t\t<span class="code-keyword">this</span>.cipher = cipher;\n\t}\n\t\n\t<span class="code-meta">@Override</span>\n\t<span class="hljs-function"><span class="code-keyword">public</span> String <span class="code-title">getPlain</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">new</span> String(Base64.getDecoder().decode(cipher));\n\t}\n}\n</code></pre>\n<p>\n    最后是核心的FactoryBean——AdapterFactory，他的作用是根据当前向IoC添加的资源类型来确定启用哪个适配器。AdapterFactory继承了BeanFactoryAware以便获得BeanFactory实例：</p>\n<pre><code class="cpp"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n        class="code-title">AdapterFactory</span> <span class="code-title">implements</span> <span class="code-title">FactoryBean</span>&lt;DecodeAdapter&gt;, <span\n        class="code-title">BeanFactoryAware</span> {</span>\n\t<span class="code-keyword">private</span> Text text;\n\t<span class="code-keyword">private</span> <span class="code-keyword">volatile</span> DecodeAdapter adapter;\n\n\t@<span class="hljs-function">Override\n\t<span class="code-keyword">public</span> DecodeAdapter <span class="code-title">getObject</span><span\n                class="hljs-params">()</span> throws Exception </span>{\n\t\t<span class="code-comment">//根据IoC中的资源类型选择适配器,懒加载模式</span>\n\t\t<span class="code-keyword">return</span> lazyLoadAdapter();\n\t}\n\n\t@Override\n\t<span class="code-keyword">public</span> Class&lt;DecodeAdapter&gt; getObjectType() {\n\t\t<span class="code-keyword">return</span> DecodeAdapter.class;\n\t}\n\n\t@<span class="hljs-function">Override\n\t<span class="code-keyword">public</span> <span class="code-keyword">void</span> <span class="code-title">setBeanFactory</span><span\n                class="hljs-params">(BeanFactory beanFactory)</span> throws BeansException </span>{\n\t\t<span class="code-keyword">this</span>.text = beanFactory.getBean(Text.class);\n\t}\n\n\t<span class="hljs-function"><span class="code-keyword">private</span> DecodeAdapter <span class="code-title">lazyLoadAdapter</span><span\n            class="hljs-params">()</span> </span>{\n\t\t<span class="code-keyword">if</span> (null == adapter) {\n\t\t\tsynchronized (AdapterFactory.class) {\n\t\t\t\t<span class="code-keyword">if</span> (null == adapter) {\n\t\t\t\t\t<span class="code-keyword">switch</span> (text.getType()) {\n\t\t\t\t\t<span class="code-keyword">case</span> UrlBase64: \n\t\t\t\t\t\tadapter = <span class="code-keyword">new</span> UrlBase64Adapter(text.getCipher());\n\t\t\t\t\t\t<span class="code-keyword">break</span>;\n\t\t\t\t\t<span class="code-keyword">case</span> Base64:\n\t\t\t\t\t<span class="code-keyword">default</span>:\n\t\t\t\t\t\tadapter = <span class="code-keyword">new</span> Base64Adapter(text.getCipher());\n\t\t\t\t\t\t<span class="code-keyword">break</span>;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t<span class="code-keyword">return</span> <span class="code-keyword">this</span>.adapter;\n\t}\n}</code></pre>\n<p>lazyLoadAdapter方法实现了适配的过程——根据不同的编码类型返回不同的适配器。最后运行容器：</p>\n<pre><code class="java"><span class="code-keyword">package</span> chkui.springcore.example.xml.factorybean;\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">BeanFactoryApp</span> </span>{\n    <span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n    \tApplicationContext context = <span class="code-keyword">new</span> ClassPathXmlApplicationContext(<span\n            class="code-string">"xml/factorybean/config.xml"</span>);\n    \tText text = context.getBean(Text.class);\n\t\tSystem.out.println(<span class="code-string">"密文:"</span> + text.getCipher());\n\t\tSystem.out.println(<span class="code-string">"编码类型:"</span> + text.getType());\n\t\tDecodeAdapter decode = context.getBean(DecodeAdapter.class);\n\t\tSystem.out.println(<span class="code-string">"明文:"</span> + decode.getPlain());\n    }\n    <span class="code-comment">//通过符号规则获取工厂Bean</span>\n    <span class="hljs-function"><span class="code-keyword">private</span> <span class="code-keyword">static</span> <span\n            class="code-keyword">void</span> <span class="code-title">nameSymbol</span><span class="hljs-params">(ApplicationContext context)</span> </span>{\n    \tObject adapter = context.getBean(<span class="code-string">"adapter"</span>);<span class="code-comment">//获取实际Bean</span>\n\t\tSystem.out.println(<span class="code-string">"adapterClass :"</span> + adapter.getClass().getName());\n\t\tadapter = context.getBean(<span class="code-string">"&amp;adapter"</span>);<span class="code-comment">//获取实际工厂Bean</span>\n\t\tSystem.out.println(<span class="code-string">"adapterClass :"</span> + adapter.getClass().getName());\n    }\n}</code></pre>\n<p>实际上，Spring的所有预设Bean都是通过FactoryBean实现的，现在大概有50多个Spring官方实现的FactoryBean。</p>\n<p>注意nameSymbol方法中的代码和BeanFactory的配置——&lt;bean id="adapter"\n    class="chkui.springcore.example.xml.factorybean.AdapterFactory" /&gt;。如果为BeanFactory指定了ID或别名，那么通过ID获取到的是工厂生成Bean而不是这个工厂本身。但是可以通过在之前增加"&amp;"符号来告诉IoC获取BeanFactory本身。</p>\n<p></p>'}};