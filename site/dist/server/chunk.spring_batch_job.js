exports.ids=[26],exports.modules={363:function(s,n,p){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.content='<p>在 <a href="https://www.chkui.com/article/spring/spring_batch_introduction" title="Spring Batch(1)——数据批处理概念">Spring\n    Batch(1)——数据批处理概念</a> 文中介绍了批处理的概念以及Spring Batch相关的使用场景，后续将会陆续说明在代码层面如何使用。</p>\n<h2 id="h2-1">引入</h2>\n<p>Spring batch的引入非常简单，只需要引入Spring Framework、Datasource以及Spring Batch。在Spring\n    Boot体系下只需引入<code>spring-boot-starter-batch</code> 即可。他已经涵盖了以上所有内容。</p>\n<h2 id="h2-2">Job配置</h2>\n<p><code>Job</code>接口有多种多样的实现类，通常我们使用configuration类来构建获取一个<code>Job</code>：</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Job <span\n        class="code-title">footballJob</span><span class="hljs-params">()</span> </span>{\n&nbsp; &nbsp; <span class="code-keyword">return</span> <span\n            class="code-keyword">this</span>.jobBuilderFactory.get(<span class="code-string">"footballJob"</span>) <span\n            class="code-comment">//Job名称</span>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.start(playerLoad()) <span\n            class="code-comment">//Job Step</span>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.next(gameLoad()) <span\n            class="code-comment">//Job Step</span>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.next(playerSummarization()) <span\n            class="code-comment">//Job Step</span>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.end()\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.build();\n}\n</code></pre>\n<p>上面的代码定义了一个<code>Job</code>实例，并且在这个实例中包含了三个Step实例</p>\n<h3 id="h3-1">重启（启动）配置</h3>\n<p>批处理的一个核心问题是需要定义重启（启动）时的一些行为。当指定的<code>JobInstance</code>被<code>JobExecution</code>执行时候即认为某个<code>Job</code>已经重启（启动）。理想状态下，所有的任务都应该可以从它们之前中断的位置启动，但是某些情况下这样做是无法实现的。开发人员可以关闭重启机制或认为每次启动都是新的<code>JobInstance</code>：\n</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Job <span\n        class="code-title">footballJob</span><span class="hljs-params">()</span> </span>{\n&nbsp; &nbsp; <span class="code-keyword">return</span> <span\n            class="code-keyword">this</span>.jobBuilderFactory.get(<span class="code-string">"footballJob"</span>)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.preventRestart() <span\n            class="code-comment">//防止重启</span>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;...\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.build();\n}\n</code></pre>\n<h3 id="h3-2">监听Job Execution</h3>\n<p>当任务执行完毕或开始执行时，需要执行一些处理工作。这个时候可以使用<code>JobExecutionListener</code>：</p>\n<pre><code class="Java"><span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">interface</span> <span\n        class="code-title">JobExecutionListener</span> </span>{\n&nbsp; &nbsp; <span class="hljs-function"><span class="code-keyword">void</span> <span\n            class="code-title">beforeJob</span><span class="hljs-params">(JobExecution jobExecution)</span></span>;\n&nbsp; &nbsp; <span class="hljs-function"><span class="code-keyword">void</span> <span\n            class="code-title">afterJob</span><span class="hljs-params">(JobExecution jobExecution)</span></span>;\n}\n</code></pre>\n<p>添加方式：</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> Job <span\n        class="code-title">footballJob</span><span class="hljs-params">()</span> </span>{\n&nbsp; &nbsp; <span class="code-keyword">return</span> <span\n            class="code-keyword">this</span>.jobBuilderFactory.get(<span class="code-string">"footballJob"</span>)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.listener(sampleListener()) <span\n            class="code-comment">//JobExecutionListener的实现类</span>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;...\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.build();\n}\n</code></pre>\n<p>需要注意的是<code>afterJob</code>方法无论批处理任务成功还是失败都会被执行，所以增加以下判断：</p>\n<pre><code class="Java"><span class="hljs-function"><span class="code-keyword">public</span> <span class="code-keyword">void</span> <span\n        class="code-title">afterJob</span><span class="hljs-params">(JobExecution jobExecution)</span></span>{\n&nbsp; &nbsp; <span class="code-keyword">if</span>( jobExecution.getStatus() == BatchStatus.COMPLETED ){\n&nbsp; &nbsp; &nbsp; &nbsp; <span class="code-comment">//job success</span>\n&nbsp; &nbsp; }\n&nbsp; &nbsp; <span class="code-keyword">else</span> <span class="code-keyword">if</span>(jobExecution.getStatus() == BatchStatus.FAILED){\n&nbsp; &nbsp; &nbsp; &nbsp; <span class="code-comment">//job failure</span>\n&nbsp; &nbsp; }\n}\n</code></pre>\n<p>除了直接实现接口还可以用 @BeforeJob 和 @AfterJob 注解。</p>\n<h3 id="h3-3">Java配置</h3>\n<p>在Spring Batch 2.2.0版本之后（Spring 3.0+）支持纯Java配置。其核心是<code>@EnableBatchProcessing</code>注解和两个构造器。<code>@EnableBatchProcessing</code>的作用类似于Spring中的其他@Enable*,使用<code>@EnableBatchProcessing</code>之后会提供一个基本的配置用于执行批处理任务。对应的会有一系列<code>StepScope</code>实例被注入到Ioc容器中：<code>JobRepository</code>、<code>JobLauncher</code>、<code>JobRegistry</code>、<code>PlatformTransactionManager</code>、<code>JobBuilderFactory</code>以及<code>StepBuilderFactory</code>。\n</p>\n<p>\n    配置的核心接口是<code>BatchConfigurer</code>，默认情况下需要在容器中指定<code>DataSource</code>，该数据源用于JobRepository相关的表。开发的过程中可以使用自定义的<code>BatchConfigurer</code>实现来提供以上所有的Bean。通常情况下可以扩展重载<code>DefaultBatchConfigurer</code>类中的Getter方法用于实现部分自定义功能：\n</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> BatchConfigurer <span class="code-title">batchConfigurer</span><span\n        class="hljs-params">()</span> </span>{\n&nbsp;&nbsp; &nbsp;<span class="code-keyword">return</span> <span class="code-keyword">new</span> DefaultBatchConfigurer() {\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<span class="code-meta">@Override</span>\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<span class="hljs-function"><span class="code-keyword">public</span> PlatformTransactionManager <span\n            class="code-title">getTransactionManager</span><span class="hljs-params">()</span> </span>{\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<span class="code-keyword">return</span> <span\n            class="code-keyword">new</span> MyTransactionManager();\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}\n&nbsp;&nbsp; &nbsp;};\n}\n</code></pre>\n<p>使用了<code>@EnableBatchProcessing</code>之后开发人员可以使用以下的方法来配置一个Job：</p>\n<pre><code class="Java"><span class="code-meta">@Configuration</span>\n<span class="code-meta">@EnableBatchProcessing</span>\n<span class="code-meta">@Import</span>(DataSourceConfiguration.class)\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">AppConfig</span> </span>{\n\n&nbsp; &nbsp; <span class="code-meta">@Autowired</span>\n&nbsp; &nbsp; <span class="code-keyword">private</span> JobBuilderFactory jobs;\n\n&nbsp; &nbsp; <span class="code-meta">@Autowired</span>\n&nbsp; &nbsp; <span class="code-keyword">private</span> StepBuilderFactory steps;\n\n&nbsp; &nbsp; <span class="code-meta">@Bean</span>\n&nbsp; &nbsp; <span class="hljs-function"><span class="code-keyword">public</span> Job <span\n            class="code-title">job</span><span class="hljs-params">(@Qualifier(<span class="code-string">"step1"</span>)</span> Step step1, @<span\n            class="code-title">Qualifier</span><span class="hljs-params">(<span\n            class="code-string">"step2"</span>)</span> Step step2) </span>{\n&nbsp; &nbsp; &nbsp; &nbsp; <span class="code-keyword">return</span> jobs.get(<span class="code-string">"myJob"</span>).start(step1).next(step2).build();\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; <span class="code-meta">@Bean</span>\n&nbsp; &nbsp; <span class="hljs-function"><span class="code-keyword">protected</span> Step <span class="code-title">step1</span><span\n            class="hljs-params">(ItemReader&lt;Person&gt; reader,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ItemProcessor&lt;Person, Person&gt; processor,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ItemWriter&lt;Person&gt; writer)</span> </span>{\n&nbsp; &nbsp; &nbsp; &nbsp; <span class="code-keyword">return</span> steps.get(<span class="code-string">"step1"</span>)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .&lt;Person, Person&gt; chunk(<span class="hljs-number">10</span>)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .reader(reader)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .processor(processor)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .writer(writer)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .build();\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; <span class="code-meta">@Bean</span>\n&nbsp; &nbsp; <span class="hljs-function"><span class="code-keyword">protected</span> Step <span class="code-title">step2</span><span\n            class="hljs-params">(Tasklet tasklet)</span> </span>{\n&nbsp; &nbsp; &nbsp; &nbsp; <span class="code-keyword">return</span> steps.get(<span class="code-string">"step2"</span>)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .tasklet(tasklet)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .build();\n&nbsp; &nbsp; }\n}\n</code></pre>\n<h2 id="h2-3">JobRepository配置</h2>\n<p>一旦使用了<code>@EnableBatchProcessing</code>\n    注解，<code>JobRepository</code>即会被注入到IoCs容器中并自动使用容器中的<code>DataSource</code>。<code>JobRepository</code>用于处理批处理表的CURD，整个Spring\n    Batch的运行都会使用到它。除了使用容器中默认的<code>DataSoruce</code>以及其他组件，还可以在<code>BatchConfigurer</code>中进行配置：</p>\n<pre><code class="Java"><span class="code-meta">@Override</span>\n<span class="hljs-function"><span class="code-keyword">protected</span> JobRepository <span class="code-title">createJobRepository</span><span\n        class="hljs-params">()</span> <span class="code-keyword">throws</span> Exception </span>{\n&nbsp; &nbsp; JobRepositoryFactoryBean factory = <span class="code-keyword">new</span> JobRepositoryFactoryBean();\n&nbsp; &nbsp; factory.setDataSource(dataSource);\n&nbsp; &nbsp; factory.setTransactionManager(transactionManager);\n&nbsp; &nbsp; factory.setIsolationLevelForCreate(<span class="code-string">"ISOLATION_SERIALIZABLE"</span>);\n&nbsp; &nbsp; factory.setTablePrefix(<span class="code-string">"BATCH_"</span>);\n&nbsp; &nbsp; factory.setMaxVarCharLength(<span class="hljs-number">1000</span>);\n&nbsp; &nbsp; <span class="code-keyword">return</span> factory.getObject();\n}\n</code></pre>\n<p>在代码中可以看到，设置<code>JobRepository</code>需要<code>DataSource</code>和<code>TransactionManager</code>，如果没有指定将会使用容器中的默认配置。\n</p>\n<h3 id="h3-4">JobRepository的事物配置</h3>\n<p>默认情况下框架为<code>JobRepository</code>提供了默认<code>PlatformTransactionManager</code>事物管理。它用于确保批处理执行过程中的元数据正确的写入到指定数据源中。如果缺乏事物，那么框架产生元数据就无法和整个处理过程完全契合。\n</p>\n<p>如下图，在BatchConfigurer中的<code>setIsolationLevelForCreate</code>方法中可以指定事物的隔离等级：</p>\n<pre><code class="Java"><span class="hljs-function"><span class="code-keyword">protected</span> JobRepository <span\n        class="code-title">createJobRepository</span><span class="hljs-params">()</span> <span class="code-keyword">throws</span> Exception </span>{\n&nbsp; &nbsp; JobRepositoryFactoryBean factory = <span class="code-keyword">new</span> JobRepositoryFactoryBean();\n&nbsp; &nbsp; factory.setDataSource(dataSource);\n&nbsp; &nbsp; factory.setTransactionManager(transactionManager);\n&nbsp; &nbsp; factory.setIsolationLevelForCreate(<span class="code-string">"ISOLATION_REPEATABLE_READ"</span>);\n&nbsp; &nbsp; <span class="code-keyword">return</span> factory.getObject();\n}\n</code></pre>\n<p><code>setIsolationLevelForCreate</code>方法支持2个值：<em>ISOLATION_SERIALIZABLE</em>、<em>ISOLATION_REPEATABLE_READ</em>，前者是默认配置，类似于<code>@Transactional(isolation\n    = Isolation.SERIALIZABLE)</code>，表示查询和写入都是一次事物，会对事物进行严格的锁定，当事物完成提交后才能进行其他的读写操作，容易死锁。后者是读事物开放，写事物锁定。任何时候都可以快速的读取数据，但是写入事物有严格的事物机制。当一个事物挂起某些记录时，其他写操作必须排队。\n</p>\n<h3 id="h3-5">修改表名称</h3>\n<p>默认情况下，<code>JobRepository</code>管理的表都以*BATCH_*开头。需要时可以修改前缀：</p>\n<pre><code class="java"><span class="code-comment">// This would reside in your BatchConfigurer implementation</span>\n<span class="code-meta">@Override</span>\n<span class="hljs-function"><span class="code-keyword">protected</span> JobRepository <span class="code-title">createJobRepository</span><span\n        class="hljs-params">()</span> <span class="code-keyword">throws</span> Exception </span>{\n&nbsp; &nbsp; JobRepositoryFactoryBean factory = <span class="code-keyword">new</span> JobRepositoryFactoryBean();\n&nbsp; &nbsp; factory.setDataSource(dataSource);\n&nbsp; &nbsp; factory.setTransactionManager(transactionManager);\n&nbsp; &nbsp; factory.setTablePrefix(<span class="code-string">"SYSTEM.TEST_"</span>); <span\n            class="code-comment">//修改前缀</span>\n&nbsp; &nbsp; <span class="code-keyword">return</span> factory.getObject();\n}\n</code></pre>\n<h3 id="h3-6">内存级存储</h3>\n<p>Spring Batch支持将运行时的状态数据（元数据）仅保存在内存中。重载<code>JobRepository</code>不设置<code>DataSource</code>即可：</p>\n<pre><code class="Java"><span class="code-meta">@Override</span>\n<span class="hljs-function"><span class="code-keyword">protected</span> JobRepository <span class="code-title">createJobRepository</span><span\n        class="hljs-params">()</span> <span class="code-keyword">throws</span> Exception </span>{\n&nbsp; &nbsp; MapJobRepositoryFactoryBean factory = <span class="code-keyword">new</span> MapJobRepositoryFactoryBean();\n&nbsp; &nbsp; factory.setTransactionManager(transactionManager);\n&nbsp; &nbsp; <span class="code-keyword">return</span> factory.getObject();\n}\n</code></pre>\n<p>需要注意的是，内存级存储无法满足分布式系统。</p>\n<h2 id="h2-4">JobLauncher配置</h2>\n<p>启用了<code>@EnableBatchProcessing</code>之后<code>JobLauncher</code>会自动注入到容器中以供使用。此外可以自行进行配置：</p>\n<pre><code class="Java"><span class="code-meta">@Override</span>\n<span class="hljs-function"><span class="code-keyword">protected</span> JobLauncher <span class="code-title">createJobLauncher</span><span\n        class="hljs-params">()</span> <span class="code-keyword">throws</span> Exception </span>{\n&nbsp;&nbsp; &nbsp;SimpleJobLauncher jobLauncher = <span class="code-keyword">new</span> SimpleJobLauncher();\n&nbsp;&nbsp; &nbsp;jobLauncher.setJobRepository(jobRepository);\n&nbsp;&nbsp; &nbsp;jobLauncher.afterPropertiesSet();\n&nbsp;&nbsp; &nbsp;<span class="code-keyword">return</span> jobLauncher;\n}\n</code></pre>\n<p><code>JobLauncher</code>唯一的必要依赖只有<code>JobRepository</code>。如下图，Job的执行通常是一个同步过程：\n    <img src="https://docs.spring.io/spring-batch/4.2.x/reference/html/images/job-launcher-sequence-sync.png"\n         alt="Spring Batch(2)——Job配置与运行" class="zoom-in-cursor"></p>\n<p>可以通过修改TaskExecutor来指定Job的执行过程：</p>\n<pre><code class="Java"><span class="code-meta">@Bean</span>\n<span class="hljs-function"><span class="code-keyword">public</span> JobLauncher <span\n        class="code-title">jobLauncher</span><span class="hljs-params">()</span> </span>{\n&nbsp;&nbsp; &nbsp;SimpleJobLauncher jobLauncher = <span class="code-keyword">new</span> SimpleJobLauncher();\n&nbsp;&nbsp; &nbsp;jobLauncher.setJobRepository(jobRepository());\n&nbsp;&nbsp; &nbsp;jobLauncher.setTaskExecutor(<span class="code-keyword">new</span> SimpleAsyncTaskExecutor()); <span\n            class="code-comment">//转换为异步任务</span>\n&nbsp;&nbsp; &nbsp;jobLauncher.afterPropertiesSet();\n&nbsp;&nbsp; &nbsp;<span class="code-keyword">return</span> jobLauncher;\n}\n</code></pre>\n<p>这样执行过程变为：</p>\n<p><img src="https://docs.spring.io/spring-batch/4.2.x/reference/html/images/job-launcher-sequence-async.png"\n        alt="Spring Batch(2)——Job配置与运行" class="zoom-in-cursor"></p>\n<h2 id="h2-5">运行一个Job</h2>\n<p>以一个Http为例：</p>\n<pre><code class="Java"><span class="code-meta">@Controller</span>\n<span class="code-keyword">public</span> <span class="hljs-class"><span class="code-keyword">class</span> <span\n            class="code-title">JobLauncherController</span> </span>{\n\n&nbsp; &nbsp; <span class="code-meta">@Autowired</span>\n&nbsp; &nbsp; JobLauncher jobLauncher;\n\n&nbsp; &nbsp; <span class="code-meta">@Autowired</span>\n&nbsp; &nbsp; Job job;\n\n&nbsp; &nbsp; <span class="code-meta">@RequestMapping</span>(<span class="code-string">"/jobLauncher.html"</span>)\n&nbsp; &nbsp; <span class="hljs-function"><span class="code-keyword">public</span> <span\n            class="code-keyword">void</span> <span class="code-title">handle</span><span\n            class="hljs-params">()</span> <span class="code-keyword">throws</span> Exception</span>{\n&nbsp; &nbsp; &nbsp; &nbsp; jobLauncher.run(job, <span class="code-keyword">new</span> JobParameters());\n&nbsp; &nbsp; }\n}\n</code></pre>\n<p>单单是配置好<code>Job</code>是肯定无法执行的，还需要对Step进行配置。后面会陆续介绍。</p>'}};